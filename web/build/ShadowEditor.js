(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.Shadow = {}));
}(this, (function (exports) { 'use strict';

	window.URL = window.URL || window.webkitURL;
	window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;

	Number.prototype.format = function () {
	  return this.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
	};

	String.prototype.format = function () {
	  var str = this;

	  for (var i = 0; i < arguments.length; i++) {
	    str = str.replace('{' + i + '}', arguments[i]);
	  }

	  return str;
	}; // 在一个渲染循环中，getDelta和getElapsedTime只能调用一次，否则会导致动画异常。
	// 这里改成可以调用多次，避免产生各种奇怪的bug。


	THREE.Clock.prototype._getDelta = function () {
	  var diff = 0;

	  if (this.autoStart && !this.running) {
	    this.start();
	    return 0;
	  }

	  if (this.running) {
	    var newTime = (typeof performance === 'undefined' ? Date : performance).now();
	    diff = (newTime - this.oldTime) / 1000;
	    this.oldTime = newTime;
	    this.elapsedTime += diff;
	  }

	  this.deltaTime = diff;
	  return diff;
	};

	THREE.Clock.prototype.getDelta = function () {
	  return this.deltaTime ? this.deltaTime : 0;
	};

	THREE.Clock.prototype.getElapsedTime = function () {
	  return this.elapsedTime;
	};

	var applyMatrix4 = "\r\nvec3 applyMatrix4(vec3 v, mat4 m) {\r\n    float x = v.x;\r\n    float y = v.y;\r\n    float z = v.z;\r\n    \r\n    float w = 1.0 / ( m[0][3] * x + m[1][3] * y + m[2][3] * z + m[3][3] );\r\n\r\n    return vec3(\r\n        (m[0][0] * x + m[1][0] * y + m[2][0] * z + m[3][0]) * w,\r\n        (m[0][1] * x + m[1][1] * y + m[2][1] * z + m[3][1]) * w,\r\n        (m[0][2] * x + m[1][2] * y + m[2][2] * z + m[3][2] ) * w\r\n    );\r\n}";

	var lengthSq = "\r\nfloat lengthSq(vec3 v) {\r\n    return v.x * v.x + v.y * v.y + v.z * v.z;\r\n}";

	var angleTo = "#include <lengthSq>\r\n\r\n\r\nfloat angleTo(vec3 v1, vec3 v2) {\r\n    float theta = dot(v1, v2) / sqrt(lengthSq(v1) * lengthSq(v2) );\r\n    \r\n    // clamp, to handle numerical problems\r\n    return acos(clamp(theta, -1.0, 1.0));\r\n}";

	var makeOrthographic = "\r\nmat4 makeOrthographic(float left, float right, float top, float bottom, float near, float far) {\r\n    float w = 1.0 / ( right - left );\r\n    float h = 1.0 / ( top - bottom );\r\n    float p = 1.0 / ( far - near );\r\n    \r\n    float x = ( right + left ) * w;\r\n    float y = ( top + bottom ) * h;\r\n    float z = ( far + near ) * p;\r\n\r\n    return mat4(\r\n        2 * w, 0.0,     0.0,      0.0,\r\n        0.0,   2.0 * h, 0.0,      0.0,\r\n        0.0,   0.0,     -2.0 * p, 0.0,\r\n        -x,    -y,      -z,       1.0\r\n    );\r\n}";

	var makePerspective = "\r\nmat4 makePerspective(float left, float right, float top, float bottom, float near, float far) {\r\n    float x = 2.0 * near / ( right - left );\r\n    float y = 2.0 * near / ( top - bottom );\r\n    \r\n    float a = ( right + left ) / ( right - left );\r\n    float b = ( top + bottom ) / ( top - bottom );\r\n    float c = - ( far + near ) / ( far - near );\r\n    float d = - 2.0 * far * near / ( far - near );\r\n\r\n    return mat4(\r\n        x,   0.0, 0.0, 0.0,\r\n        0.0, y,   0.0, 0.0,\r\n        a,   b,   c,   -1.0,\r\n        0.0, 0.0, d,   0.0\r\n    );\r\n}";

	var makePerspective2 = "#include <makePerspective>\r\n\r\n\r\nmat4 makePerspective2(float fov, float aspect, float near, float far) {\r\n    const float DEG2RAD = 0.017453292519943295; // PI / 180\r\n\r\n    float top = near * tan( DEG2RAD * 0.5 * fov );\r\n\tfloat height = 2.0 * top;\r\n\tfloat width = aspect * height;\r\n\tfloat left = - 0.5 * width;\r\n    \r\n    return makePerspective(left, left + width, top, top - height, near, far );\r\n}";

	var determinant = "\r\nfloat determinant(mat4 te) {\r\n    float n11 = te[0][0], n12 = te[1][0], n13 = te[2][0], n14 = te[3][0];\r\n\tfloat n21 = te[0][1], n22 = te[1][1], n23 = te[2][1], n24 = te[3][1];\r\n\tfloat n31 = te[0][2], n32 = te[1][2], n33 = te[2][2], n34 = te[3][2];\r\n\tfloat n41 = te[0][3], n42 = te[1][3], n43 = te[2][3], n44 = te[3][3];\r\n\r\n\t//TODO: make this more efficient\r\n\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\treturn (\r\n\t\tn41 * (\r\n\t\t\t+ n14 * n23 * n32\r\n\t\t\t - n13 * n24 * n32\r\n\t\t\t - n14 * n22 * n33\r\n\t\t\t + n12 * n24 * n33\r\n\t\t\t + n13 * n22 * n34\r\n\t\t\t - n12 * n23 * n34\r\n\t\t) +\r\n\t\tn42 * (\r\n\t\t\t+ n11 * n23 * n34\r\n\t\t\t - n11 * n24 * n33\r\n\t\t\t + n14 * n21 * n33\r\n\t\t\t - n13 * n21 * n34\r\n\t\t\t + n13 * n24 * n31\r\n\t\t\t - n14 * n23 * n31\r\n\t\t) +\r\n\t\tn43 * (\r\n\t\t\t+ n11 * n24 * n32\r\n\t\t\t - n11 * n22 * n34\r\n\t\t\t - n14 * n21 * n32\r\n\t\t\t + n12 * n21 * n34\r\n\t\t\t + n14 * n22 * n31\r\n\t\t\t - n12 * n24 * n31\r\n\t\t) +\r\n\t\tn44 * (\r\n\t\t\t- n13 * n22 * n31\r\n\t\t\t - n11 * n23 * n32\r\n\t\t\t + n11 * n22 * n33\r\n\t\t\t + n13 * n21 * n32\r\n\t\t\t - n12 * n21 * n33\r\n\t\t\t + n12 * n23 * n31\r\n\t\t)\r\n\t);\r\n}";

	var compose = "\r\nmat4 compose( vec3 position, vec4 quaternion, vec3 scale ) {\r\n\tfloat x = quaternion.x,\r\n          y = quaternion.y,\r\n          z = quaternion.z,\r\n          w = quaternion.w;\r\n\r\n\tfloat x2 = x + x,\r\n          y2 = y + y,\r\n          z2 = z + z;\r\n\r\n\tfloat xx = x * x2, xy = x * y2, xz = x * z2;\r\n\tfloat yy = y * y2, yz = y * z2, zz = z * z2;\r\n\tfloat wx = w * x2, wy = w * y2, wz = w * z2;\r\n\t\r\n    float sx = scale.x, sy = scale.y, sz = scale.z;\r\n\r\n    return mat4(\r\n        ( 1.0 - ( yy + zz ) ) * sx,\r\n        ( xy + wz ) * sx,\r\n        ( xz - wy ) * sx,\r\n        0.0,\r\n        ( xy - wz ) * sy,\r\n        ( 1.0 - ( xx + zz ) ) * sy,\r\n        ( yz + wx ) * sy,\r\n        0.0,\r\n        ( xz + wy ) * sz,\r\n        ( yz - wx ) * sz,\r\n        ( 1.0 - ( xx + yy ) ) * sz,\r\n        0.0,\r\n        position.x,\r\n        position.y,\r\n        position.z,\r\n        1.0\r\n    );\r\n}";

	var decomposeMatrix = "#include <determinant>\r\n\r\n\r\nvoid decomposeMatrix(in mat4 te, out mat4 position, out mat4 rotation, out mat4 scale) {\r\n    float sx = length(vec3(te[0][0], te[0][1], te[0][2]));\r\n    float sy = length(vec3(te[1][0], te[1][1], te[1][2]));\r\n    float sz = length(vec3(te[2][0], te[2][1], te[2][2]));\r\n    \r\n    // if determine is negative, we need to invert one scale\r\n\tfloat det = determinant(te);\r\n    \r\n    if (det < 0.0) sx = -sx;\r\n\r\n\tposition = mat4(\r\n\t\t1.0, 0.0, 0.0, 0.0,\r\n\t\t0.0, 1.0, 0.0, 0.0,\r\n\t\t0.0, 0.0, 1.0, 0.0,\r\n\t\tte[3][0], te[3][1], te[3][2], 1.0\r\n\t);\r\n    \r\n    // scale the rotation part\r\n    float invSX = 1.0 / sx;\r\n\tfloat invSY = 1.0 / sy;\r\n\tfloat invSZ = 1.0 / sz;\r\n\r\n\trotation = mat4(\r\n\t\tte[0][0] * invSX, te[0][1] * invSX, te[0][2] * invSX, 0.0,\r\n\t\tte[1][0] * invSY, te[1][1] * invSY, te[1][2] * invSY, 0.0,\r\n\t\tte[2][0] * invSZ, te[2][1] * invSZ, te[2][2] * invSZ, 0.0,\r\n\t\t0.0,              0.0,              0.0,              1.0\r\n\t);\r\n    \r\n\tscale = mat4(\r\n\t\tsx, 0.0, 0.0, 0.0,\r\n\t\t0.0, sy, 0.0, 0.0,\r\n\t\t0.0, 0.0, sz, 0.0,\r\n\t\t0.0, 0.0, 0.0, 1.0\r\n\t);\r\n}";

	var mercator = "\r\nvec2 mercator(vec2 lonlat) \r\n{\r\n    return vec2(\r\n        lonlat.x,\r\n        log(tan((PI / 2.0 + lonlat.y) / 2.0))\r\n    );\r\n}";

	var mercatorInvert = "\r\nvec2 mercatorInvert(vec2 mercatorXY) \r\n{\r\n    return vec2(\r\n        mercatorXY.x,\r\n        2.0 * atan(exp(mercatorXY.y)) - PI / 2.0\r\n    );\r\n}";

	Object.assign(THREE.ShaderChunk, {
	  // vec3
	  applyMatrix4: applyMatrix4,
	  lengthSq: lengthSq,
	  angleTo: angleTo,
	  // mat4
	  makeOrthographic: makeOrthographic,
	  makePerspective: makePerspective,
	  makePerspective2: makePerspective2,
	  determinant: determinant,
	  compose: compose,
	  decomposeMatrix: decomposeMatrix,
	  // geo
	  mercator: mercator,
	  mercatorInvert: mercatorInvert
	});

	/**
	 * 配置选项
	 * @author tengge / https://github.com/tengge1
	 * @param {*} options 配置选项
	 */
	function Options(options = {}) {
	  // 服务端配置
	  this.server = options.server === undefined ? location.origin : options.server; // 服务端地址

	  if (!this.server.startsWith('http') && this.server !== '.') {
	    this.server = `http://${this.server}`;
	  }

	  this.sceneType = options.sceneType === undefined ? 'Empty' : options.sceneType; // 场景类型：Empty, GIS
	  // 场景优化选项
	  // 是否保存模型内部子组件

	  this.saveChild = options.saveChild === undefined ? true : options.saveChild; // 是否保存模型内部子组件材质

	  this.saveMaterial = options.saveMaterial === undefined ? true : options.saveMaterial; // 阴影配置

	  this.shadowMapType = THREE.PCFSoftShadowMap; // gamma校正
	  // this.gammaInput = false;
	  // this.gammaOutput = false;

	  this.gammaFactor = 2.0; // 滤镜

	  this.hueRotate = 0;
	  this.saturate = 1;
	  this.brightness = 1;
	  this.blur = 0;
	  this.contrast = 1;
	  this.grayscale = 0;
	  this.invert = 0;
	  this.sepia = 0; // 天气

	  this.weather = ''; // ''-无，rain-下雨,snow-下雪
	  // 物理引擎

	  this.enablePhysics = false; // 是否启用物理引擎
	}

	THREE.EditorControls = function (object, domElement) {
	  domElement = domElement !== undefined ? domElement : document; // API

	  this.enabled = true;
	  this.center = new THREE.Vector3();
	  this.panSpeed = 0.002;
	  this.zoomSpeed = 0.1;
	  this.rotationSpeed = 0.005; // internals

	  var scope = this;
	  var vector = new THREE.Vector3();
	  var delta = new THREE.Vector3();
	  var box = new THREE.Box3();
	  var STATE = {
	    NONE: -1,
	    ROTATE: 0,
	    ZOOM: 1,
	    PAN: 2
	  };
	  var state = STATE.NONE;
	  var center = this.center;
	  var normalMatrix = new THREE.Matrix3();
	  var pointer = new THREE.Vector2();
	  var pointerOld = new THREE.Vector2();
	  var spherical = new THREE.Spherical();
	  var sphere = new THREE.Sphere(); // events

	  var changeEvent = {
	    type: 'change'
	  };

	  this.focus = function (target) {
	    var distance;
	    box.setFromObject(target);

	    if (box.isEmpty() === false) {
	      box.getCenter(center);
	      distance = box.getBoundingSphere(sphere).radius;
	    } else {
	      // Focusing on an Group, AmbientLight, etc
	      center.setFromMatrixPosition(target.matrixWorld);
	      distance = 0.1;
	    }

	    delta.set(0, 0, 1);
	    delta.applyQuaternion(object.quaternion);
	    delta.multiplyScalar(distance * 4);
	    object.position.copy(center).add(delta);
	    scope.dispatchEvent(changeEvent);
	  };

	  this.pan = function (delta) {
	    var distance = object.position.distanceTo(center);
	    delta.multiplyScalar(distance * scope.panSpeed);
	    delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));
	    object.position.add(delta);
	    center.add(delta);
	    scope.dispatchEvent(changeEvent);
	  };

	  this.zoom = function (delta) {
	    var distance = object.position.distanceTo(center);
	    delta.multiplyScalar(distance * scope.zoomSpeed);
	    if (delta.length() > distance) return;
	    delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));
	    object.position.add(delta);
	    scope.dispatchEvent(changeEvent);
	  };

	  this.rotate = function (delta) {
	    vector.copy(object.position).sub(center);
	    spherical.setFromVector3(vector);
	    spherical.theta += delta.x * scope.rotationSpeed;
	    spherical.phi += delta.y * scope.rotationSpeed;
	    spherical.makeSafe();
	    vector.setFromSpherical(spherical);
	    object.position.copy(center).add(vector);
	    object.lookAt(center);
	    scope.dispatchEvent(changeEvent);
	  }; // mouse


	  function onMouseDown(event) {
	    if (scope.enabled === false) return;

	    if (event.button === 0) {
	      state = STATE.ROTATE;
	    } else if (event.button === 1) {
	      state = STATE.ZOOM;
	    } else if (event.button === 2) {
	      state = STATE.PAN;
	    }

	    pointerOld.set(event.clientX, event.clientY);
	    domElement.addEventListener('mousemove', onMouseMove, false);
	    domElement.addEventListener('mouseup', onMouseUp, false);
	    domElement.addEventListener('mouseout', onMouseUp, false);
	    domElement.addEventListener('dblclick', onMouseUp, false);
	  }

	  function onMouseMove(event) {
	    if (scope.enabled === false) return;
	    pointer.set(event.clientX, event.clientY);
	    var movementX = pointer.x - pointerOld.x;
	    var movementY = pointer.y - pointerOld.y;

	    if (state === STATE.ROTATE) {
	      scope.rotate(delta.set(-movementX, -movementY, 0));
	    } else if (state === STATE.ZOOM) {
	      scope.zoom(delta.set(0, 0, movementY));
	    } else if (state === STATE.PAN) {
	      scope.pan(delta.set(-movementX, movementY, 0));
	    }

	    pointerOld.set(event.clientX, event.clientY);
	  }

	  function onMouseUp(event) {
	    domElement.removeEventListener('mousemove', onMouseMove, false);
	    domElement.removeEventListener('mouseup', onMouseUp, false);
	    domElement.removeEventListener('mouseout', onMouseUp, false);
	    domElement.removeEventListener('dblclick', onMouseUp, false);
	    state = STATE.NONE;
	  }

	  function onMouseWheel(event) {
	    event.preventDefault(); // Normalize deltaY due to https://bugzilla.mozilla.org/show_bug.cgi?id=1392460

	    scope.zoom(delta.set(0, 0, event.deltaY > 0 ? 1 : -1));
	  }

	  function contextmenu(event) {
	    event.preventDefault();
	  }

	  this.dispose = function () {
	    domElement.removeEventListener('contextmenu', contextmenu, false);
	    domElement.removeEventListener('mousedown', onMouseDown, false);
	    domElement.removeEventListener('wheel', onMouseWheel, false);
	    domElement.removeEventListener('mousemove', onMouseMove, false);
	    domElement.removeEventListener('mouseup', onMouseUp, false);
	    domElement.removeEventListener('mouseout', onMouseUp, false);
	    domElement.removeEventListener('dblclick', onMouseUp, false);
	    domElement.removeEventListener('touchstart', touchStart, false);
	    domElement.removeEventListener('touchmove', touchMove, false);
	  };

	  domElement.addEventListener('contextmenu', contextmenu, false);
	  domElement.addEventListener('mousedown', onMouseDown, false);
	  domElement.addEventListener('wheel', onMouseWheel, false); // touch

	  var touches = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
	  var prevTouches = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
	  var prevDistance = null;

	  function touchStart(event) {
	    if (scope.enabled === false) return;

	    switch (event.touches.length) {
	      case 1:
	        touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        break;

	      case 2:
	        touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0).divideScalar(window.devicePixelRatio);
	        prevDistance = touches[0].distanceTo(touches[1]);
	        break;
	    }

	    prevTouches[0].copy(touches[0]);
	    prevTouches[1].copy(touches[1]);
	  }

	  function touchMove(event) {
	    if (scope.enabled === false) return;
	    event.preventDefault();
	    event.stopPropagation();

	    function getClosest(touch, touches) {
	      var closest = touches[0];

	      for (var i in touches) {
	        if (closest.distanceTo(touch) > touches[i].distanceTo(touch)) closest = touches[i];
	      }

	      return closest;
	    }

	    switch (event.touches.length) {
	      case 1:
	        touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        scope.rotate(touches[0].sub(getClosest(touches[0], prevTouches)).multiplyScalar(-1));
	        break;

	      case 2:
	        touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0).divideScalar(window.devicePixelRatio);
	        var distance = touches[0].distanceTo(touches[1]);
	        scope.zoom(delta.set(0, 0, prevDistance - distance));
	        prevDistance = distance;
	        var offset0 = touches[0].clone().sub(getClosest(touches[0], prevTouches));
	        var offset1 = touches[1].clone().sub(getClosest(touches[1], prevTouches));
	        offset0.x = -offset0.x;
	        offset1.x = -offset1.x;
	        scope.pan(offset0.add(offset1));
	        break;
	    }

	    prevTouches[0].copy(touches[0]);
	    prevTouches[1].copy(touches[1]);
	  }

	  domElement.addEventListener('touchstart', touchStart, false);
	  domElement.addEventListener('touchmove', touchMove, false);
	};

	THREE.EditorControls.prototype = Object.create(THREE.EventDispatcher.prototype);
	THREE.EditorControls.prototype.constructor = THREE.EditorControls;

	// This set of controls performs orbiting, dollying (zooming), and panning.
	// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
	//
	//    Orbit - left mouse / touch: one-finger move
	//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
	//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
	THREE.OrbitControls = function (object, domElement) {
	  if (domElement === undefined) console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
	  if (domElement === document) console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
	  this.object = object;
	  this.domElement = domElement; // Set to false to disable this control

	  this.enabled = true; // "target" sets the location of focus, where the object orbits around

	  this.target = new THREE.Vector3(); // How far you can dolly in and out ( PerspectiveCamera only )

	  this.minDistance = 0;
	  this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )

	  this.minZoom = 0;
	  this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.
	  // Range is 0 to Math.PI radians.

	  this.minPolarAngle = 0; // radians

	  this.maxPolarAngle = Math.PI; // radians
	  // How far you can orbit horizontally, upper and lower limits.
	  // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].

	  this.minAzimuthAngle = -Infinity; // radians

	  this.maxAzimuthAngle = Infinity; // radians
	  // Set to true to enable damping (inertia)
	  // If damping is enabled, you must call controls.update() in your animation loop

	  this.enableDamping = false;
	  this.dampingFactor = 0.05; // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	  // Set to false to disable zooming

	  this.enableZoom = true;
	  this.zoomSpeed = 1.0; // Set to false to disable rotating

	  this.enableRotate = true;
	  this.rotateSpeed = 1.0; // Set to false to disable panning

	  this.enablePan = true;
	  this.panSpeed = 1.0;
	  this.screenSpacePanning = false; // if true, pan in screen-space

	  this.keyPanSpeed = 7.0; // pixels moved per arrow key push
	  // Set to true to automatically rotate around the target
	  // If auto-rotate is enabled, you must call controls.update() in your animation loop

	  this.autoRotate = false;
	  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
	  // Set to false to disable use of the keys

	  this.enableKeys = true; // The four arrow keys

	  this.keys = {
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    BOTTOM: 40
	  }; // Mouse buttons

	  this.mouseButtons = {
	    LEFT: THREE.MOUSE.ROTATE,
	    MIDDLE: THREE.MOUSE.DOLLY,
	    RIGHT: THREE.MOUSE.PAN
	  }; // Touch fingers

	  this.touches = {
	    ONE: THREE.TOUCH.ROTATE,
	    TWO: THREE.TOUCH.DOLLY_PAN
	  }; // for reset

	  this.target0 = this.target.clone();
	  this.position0 = this.object.position.clone();
	  this.zoom0 = this.object.zoom; //
	  // public methods
	  //

	  this.getPolarAngle = function () {
	    return spherical.phi;
	  };

	  this.getAzimuthalAngle = function () {
	    return spherical.theta;
	  };

	  this.saveState = function () {
	    scope.target0.copy(scope.target);
	    scope.position0.copy(scope.object.position);
	    scope.zoom0 = scope.object.zoom;
	  };

	  this.reset = function () {
	    scope.target.copy(scope.target0);
	    scope.object.position.copy(scope.position0);
	    scope.object.zoom = scope.zoom0;
	    scope.object.updateProjectionMatrix();
	    scope.dispatchEvent(changeEvent);
	    scope.update();
	    state = STATE.NONE;
	  }; // this method is exposed, but perhaps it would be better if we can make it private...


	  this.update = function () {
	    var offset = new THREE.Vector3(); // so camera.up is the orbit axis

	    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
	    var quatInverse = quat.clone().inverse();
	    var lastPosition = new THREE.Vector3();
	    var lastQuaternion = new THREE.Quaternion();
	    return function update() {
	      var position = scope.object.position;
	      offset.copy(position).sub(scope.target); // rotate offset to "y-axis-is-up" space

	      offset.applyQuaternion(quat); // angle from z-axis around y-axis

	      spherical.setFromVector3(offset);

	      if (scope.autoRotate && state === STATE.NONE) {
	        rotateLeft(getAutoRotationAngle());
	      }

	      if (scope.enableDamping) {
	        spherical.theta += sphericalDelta.theta * scope.dampingFactor;
	        spherical.phi += sphericalDelta.phi * scope.dampingFactor;
	      } else {
	        spherical.theta += sphericalDelta.theta;
	        spherical.phi += sphericalDelta.phi;
	      } // restrict theta to be between desired limits


	      spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta)); // restrict phi to be between desired limits

	      spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
	      spherical.makeSafe();
	      spherical.radius *= scale; // restrict radius to be between desired limits

	      spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)); // move target to panned location

	      if (scope.enableDamping === true) {
	        scope.target.addScaledVector(panOffset, scope.dampingFactor);
	      } else {
	        scope.target.add(panOffset);
	      }

	      offset.setFromSpherical(spherical); // rotate offset back to "camera-up-vector-is-up" space

	      offset.applyQuaternion(quatInverse);
	      position.copy(scope.target).add(offset);
	      scope.object.lookAt(scope.target);

	      if (scope.enableDamping === true) {
	        sphericalDelta.theta *= 1 - scope.dampingFactor;
	        sphericalDelta.phi *= 1 - scope.dampingFactor;
	        panOffset.multiplyScalar(1 - scope.dampingFactor);
	      } else {
	        sphericalDelta.set(0, 0, 0);
	        panOffset.set(0, 0, 0);
	      }

	      scale = 1; // update condition is:
	      // min(camera displacement, camera rotation in radians)^2 > EPS
	      // using small-angle approximation cos(x/2) = 1 - x^2 / 8

	      if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
	        scope.dispatchEvent(changeEvent);
	        lastPosition.copy(scope.object.position);
	        lastQuaternion.copy(scope.object.quaternion);
	        zoomChanged = false;
	        return true;
	      }

	      return false;
	    };
	  }();

	  this.dispose = function () {
	    scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
	    scope.domElement.removeEventListener('mousedown', onMouseDown, false);
	    scope.domElement.removeEventListener('wheel', onMouseWheel, false);
	    scope.domElement.removeEventListener('touchstart', onTouchStart, false);
	    scope.domElement.removeEventListener('touchend', onTouchEnd, false);
	    scope.domElement.removeEventListener('touchmove', onTouchMove, false);
	    document.removeEventListener('mousemove', onMouseMove, false);
	    document.removeEventListener('mouseup', onMouseUp, false);
	    scope.domElement.removeEventListener('keydown', onKeyDown, false); //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
	  }; //
	  // internals
	  //


	  var scope = this;
	  var changeEvent = {
	    type: 'change'
	  };
	  var startEvent = {
	    type: 'start'
	  };
	  var endEvent = {
	    type: 'end'
	  };
	  var STATE = {
	    NONE: -1,
	    ROTATE: 0,
	    DOLLY: 1,
	    PAN: 2,
	    TOUCH_ROTATE: 3,
	    TOUCH_PAN: 4,
	    TOUCH_DOLLY_PAN: 5,
	    TOUCH_DOLLY_ROTATE: 6
	  };
	  var state = STATE.NONE;
	  var EPS = 0.000001; // current position in spherical coordinates

	  var spherical = new THREE.Spherical();
	  var sphericalDelta = new THREE.Spherical();
	  var scale = 1;
	  var panOffset = new THREE.Vector3();
	  var zoomChanged = false;
	  var rotateStart = new THREE.Vector2();
	  var rotateEnd = new THREE.Vector2();
	  var rotateDelta = new THREE.Vector2();
	  var panStart = new THREE.Vector2();
	  var panEnd = new THREE.Vector2();
	  var panDelta = new THREE.Vector2();
	  var dollyStart = new THREE.Vector2();
	  var dollyEnd = new THREE.Vector2();
	  var dollyDelta = new THREE.Vector2();

	  function getAutoRotationAngle() {
	    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
	  }

	  function getZoomScale() {
	    return Math.pow(0.95, scope.zoomSpeed);
	  }

	  function rotateLeft(angle) {
	    sphericalDelta.theta -= angle;
	  }

	  function rotateUp(angle) {
	    sphericalDelta.phi -= angle;
	  }

	  var panLeft = function () {
	    var v = new THREE.Vector3();
	    return function panLeft(distance, objectMatrix) {
	      v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix

	      v.multiplyScalar(-distance);
	      panOffset.add(v);
	    };
	  }();

	  var panUp = function () {
	    var v = new THREE.Vector3();
	    return function panUp(distance, objectMatrix) {
	      if (scope.screenSpacePanning === true) {
	        v.setFromMatrixColumn(objectMatrix, 1);
	      } else {
	        v.setFromMatrixColumn(objectMatrix, 0);
	        v.crossVectors(scope.object.up, v);
	      }

	      v.multiplyScalar(distance);
	      panOffset.add(v);
	    };
	  }(); // deltaX and deltaY are in pixels; right and down are positive


	  var pan = function () {
	    var offset = new THREE.Vector3();
	    return function pan(deltaX, deltaY) {
	      var element = scope.domElement;

	      if (scope.object.isPerspectiveCamera) {
	        // perspective
	        var position = scope.object.position;
	        offset.copy(position).sub(scope.target);
	        var targetDistance = offset.length(); // half of the fov is center to top of screen

	        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed

	        panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
	        panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
	      } else if (scope.object.isOrthographicCamera) {
	        // orthographic
	        panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
	        panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
	      } else {
	        // camera neither orthographic nor perspective
	        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
	        scope.enablePan = false;
	      }
	    };
	  }();

	  function dollyIn(dollyScale) {
	    if (scope.object.isPerspectiveCamera) {
	      scale /= dollyScale;
	    } else if (scope.object.isOrthographicCamera) {
	      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
	      scope.object.updateProjectionMatrix();
	      zoomChanged = true;
	    } else {
	      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
	      scope.enableZoom = false;
	    }
	  }

	  function dollyOut(dollyScale) {
	    if (scope.object.isPerspectiveCamera) {
	      scale *= dollyScale;
	    } else if (scope.object.isOrthographicCamera) {
	      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
	      scope.object.updateProjectionMatrix();
	      zoomChanged = true;
	    } else {
	      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
	      scope.enableZoom = false;
	    }
	  } //
	  // event callbacks - update the object state
	  //


	  function handleMouseDownRotate(event) {
	    rotateStart.set(event.clientX, event.clientY);
	  }

	  function handleMouseDownDolly(event) {
	    dollyStart.set(event.clientX, event.clientY);
	  }

	  function handleMouseDownPan(event) {
	    panStart.set(event.clientX, event.clientY);
	  }

	  function handleMouseMoveRotate(event) {
	    rotateEnd.set(event.clientX, event.clientY);
	    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
	    var element = scope.domElement;
	    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

	    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
	    rotateStart.copy(rotateEnd);
	    scope.update();
	  }

	  function handleMouseMoveDolly(event) {
	    dollyEnd.set(event.clientX, event.clientY);
	    dollyDelta.subVectors(dollyEnd, dollyStart);

	    if (dollyDelta.y > 0) {
	      dollyIn(getZoomScale());
	    } else if (dollyDelta.y < 0) {
	      dollyOut(getZoomScale());
	    }

	    dollyStart.copy(dollyEnd);
	    scope.update();
	  }

	  function handleMouseMovePan(event) {
	    panEnd.set(event.clientX, event.clientY);
	    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
	    pan(panDelta.x, panDelta.y);
	    panStart.copy(panEnd);
	    scope.update();
	  }

	  function handleMouseWheel(event) {
	    if (event.deltaY < 0) {
	      dollyOut(getZoomScale());
	    } else if (event.deltaY > 0) {
	      dollyIn(getZoomScale());
	    }

	    scope.update();
	  }

	  function handleKeyDown(event) {
	    var needsUpdate = false;

	    switch (event.keyCode) {
	      case scope.keys.UP:
	        pan(0, scope.keyPanSpeed);
	        needsUpdate = true;
	        break;

	      case scope.keys.BOTTOM:
	        pan(0, -scope.keyPanSpeed);
	        needsUpdate = true;
	        break;

	      case scope.keys.LEFT:
	        pan(scope.keyPanSpeed, 0);
	        needsUpdate = true;
	        break;

	      case scope.keys.RIGHT:
	        pan(-scope.keyPanSpeed, 0);
	        needsUpdate = true;
	        break;
	    }

	    if (needsUpdate) {
	      // prevent the browser from scrolling on cursor keys
	      event.preventDefault();
	      scope.update();
	    }
	  }

	  function handleTouchStartRotate(event) {
	    if (event.touches.length == 1) {
	      rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
	    } else {
	      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
	      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
	      rotateStart.set(x, y);
	    }
	  }

	  function handleTouchStartPan(event) {
	    if (event.touches.length == 1) {
	      panStart.set(event.touches[0].pageX, event.touches[0].pageY);
	    } else {
	      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
	      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
	      panStart.set(x, y);
	    }
	  }

	  function handleTouchStartDolly(event) {
	    var dx = event.touches[0].pageX - event.touches[1].pageX;
	    var dy = event.touches[0].pageY - event.touches[1].pageY;
	    var distance = Math.sqrt(dx * dx + dy * dy);
	    dollyStart.set(0, distance);
	  }

	  function handleTouchStartDollyPan(event) {
	    if (scope.enableZoom) handleTouchStartDolly(event);
	    if (scope.enablePan) handleTouchStartPan(event);
	  }

	  function handleTouchStartDollyRotate(event) {
	    if (scope.enableZoom) handleTouchStartDolly(event);
	    if (scope.enableRotate) handleTouchStartRotate(event);
	  }

	  function handleTouchMoveRotate(event) {
	    if (event.touches.length == 1) {
	      rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
	    } else {
	      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
	      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
	      rotateEnd.set(x, y);
	    }

	    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
	    var element = scope.domElement;
	    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

	    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
	    rotateStart.copy(rotateEnd);
	  }

	  function handleTouchMovePan(event) {
	    if (event.touches.length == 1) {
	      panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
	    } else {
	      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
	      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
	      panEnd.set(x, y);
	    }

	    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
	    pan(panDelta.x, panDelta.y);
	    panStart.copy(panEnd);
	  }

	  function handleTouchMoveDolly(event) {
	    var dx = event.touches[0].pageX - event.touches[1].pageX;
	    var dy = event.touches[0].pageY - event.touches[1].pageY;
	    var distance = Math.sqrt(dx * dx + dy * dy);
	    dollyEnd.set(0, distance);
	    dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
	    dollyIn(dollyDelta.y);
	    dollyStart.copy(dollyEnd);
	  }

	  function handleTouchMoveDollyPan(event) {
	    if (scope.enableZoom) handleTouchMoveDolly(event);
	    if (scope.enablePan) handleTouchMovePan(event);
	  }

	  function handleTouchMoveDollyRotate(event) {
	    if (scope.enableZoom) handleTouchMoveDolly(event);
	    if (scope.enableRotate) handleTouchMoveRotate(event);
	  }
	  //
	  // event handlers - FSM: listen for events and reset state
	  //


	  function onMouseDown(event) {
	    if (scope.enabled === false) return; // Prevent the browser from scrolling.

	    event.preventDefault(); // Manually set the focus since calling preventDefault above
	    // prevents the browser from setting it automatically.

	    scope.domElement.focus ? scope.domElement.focus() : window.focus();
	    var mouseAction;

	    switch (event.button) {
	      case 0:
	        mouseAction = scope.mouseButtons.LEFT;
	        break;

	      case 1:
	        mouseAction = scope.mouseButtons.MIDDLE;
	        break;

	      case 2:
	        mouseAction = scope.mouseButtons.RIGHT;
	        break;

	      default:
	        mouseAction = -1;
	    }

	    switch (mouseAction) {
	      case THREE.MOUSE.DOLLY:
	        if (scope.enableZoom === false) return;
	        handleMouseDownDolly(event);
	        state = STATE.DOLLY;
	        break;

	      case THREE.MOUSE.ROTATE:
	        if (event.ctrlKey || event.metaKey || event.shiftKey) {
	          if (scope.enablePan === false) return;
	          handleMouseDownPan(event);
	          state = STATE.PAN;
	        } else {
	          if (scope.enableRotate === false) return;
	          handleMouseDownRotate(event);
	          state = STATE.ROTATE;
	        }

	        break;

	      case THREE.MOUSE.PAN:
	        if (event.ctrlKey || event.metaKey || event.shiftKey) {
	          if (scope.enableRotate === false) return;
	          handleMouseDownRotate(event);
	          state = STATE.ROTATE;
	        } else {
	          if (scope.enablePan === false) return;
	          handleMouseDownPan(event);
	          state = STATE.PAN;
	        }

	        break;

	      default:
	        state = STATE.NONE;
	    }

	    if (state !== STATE.NONE) {
	      document.addEventListener('mousemove', onMouseMove, false);
	      document.addEventListener('mouseup', onMouseUp, false);
	      scope.dispatchEvent(startEvent);
	    }
	  }

	  function onMouseMove(event) {
	    if (scope.enabled === false) return;
	    event.preventDefault();

	    switch (state) {
	      case STATE.ROTATE:
	        if (scope.enableRotate === false) return;
	        handleMouseMoveRotate(event);
	        break;

	      case STATE.DOLLY:
	        if (scope.enableZoom === false) return;
	        handleMouseMoveDolly(event);
	        break;

	      case STATE.PAN:
	        if (scope.enablePan === false) return;
	        handleMouseMovePan(event);
	        break;
	    }
	  }

	  function onMouseUp(event) {
	    if (scope.enabled === false) return;
	    document.removeEventListener('mousemove', onMouseMove, false);
	    document.removeEventListener('mouseup', onMouseUp, false);
	    scope.dispatchEvent(endEvent);
	    state = STATE.NONE;
	  }

	  function onMouseWheel(event) {
	    if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;
	    event.preventDefault();
	    event.stopPropagation();
	    scope.dispatchEvent(startEvent);
	    handleMouseWheel(event);
	    scope.dispatchEvent(endEvent);
	  }

	  function onKeyDown(event) {
	    if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;
	    handleKeyDown(event);
	  }

	  function onTouchStart(event) {
	    if (scope.enabled === false) return;
	    event.preventDefault();

	    switch (event.touches.length) {
	      case 1:
	        switch (scope.touches.ONE) {
	          case THREE.TOUCH.ROTATE:
	            if (scope.enableRotate === false) return;
	            handleTouchStartRotate(event);
	            state = STATE.TOUCH_ROTATE;
	            break;

	          case THREE.TOUCH.PAN:
	            if (scope.enablePan === false) return;
	            handleTouchStartPan(event);
	            state = STATE.TOUCH_PAN;
	            break;

	          default:
	            state = STATE.NONE;
	        }

	        break;

	      case 2:
	        switch (scope.touches.TWO) {
	          case THREE.TOUCH.DOLLY_PAN:
	            if (scope.enableZoom === false && scope.enablePan === false) return;
	            handleTouchStartDollyPan(event);
	            state = STATE.TOUCH_DOLLY_PAN;
	            break;

	          case THREE.TOUCH.DOLLY_ROTATE:
	            if (scope.enableZoom === false && scope.enableRotate === false) return;
	            handleTouchStartDollyRotate(event);
	            state = STATE.TOUCH_DOLLY_ROTATE;
	            break;

	          default:
	            state = STATE.NONE;
	        }

	        break;

	      default:
	        state = STATE.NONE;
	    }

	    if (state !== STATE.NONE) {
	      scope.dispatchEvent(startEvent);
	    }
	  }

	  function onTouchMove(event) {
	    if (scope.enabled === false) return;
	    event.preventDefault();
	    event.stopPropagation();

	    switch (state) {
	      case STATE.TOUCH_ROTATE:
	        if (scope.enableRotate === false) return;
	        handleTouchMoveRotate(event);
	        scope.update();
	        break;

	      case STATE.TOUCH_PAN:
	        if (scope.enablePan === false) return;
	        handleTouchMovePan(event);
	        scope.update();
	        break;

	      case STATE.TOUCH_DOLLY_PAN:
	        if (scope.enableZoom === false && scope.enablePan === false) return;
	        handleTouchMoveDollyPan(event);
	        scope.update();
	        break;

	      case STATE.TOUCH_DOLLY_ROTATE:
	        if (scope.enableZoom === false && scope.enableRotate === false) return;
	        handleTouchMoveDollyRotate(event);
	        scope.update();
	        break;

	      default:
	        state = STATE.NONE;
	    }
	  }

	  function onTouchEnd(event) {
	    if (scope.enabled === false) return;
	    scope.dispatchEvent(endEvent);
	    state = STATE.NONE;
	  }

	  function onContextMenu(event) {
	    if (scope.enabled === false) return;
	    event.preventDefault();
	  } //


	  scope.domElement.addEventListener('contextmenu', onContextMenu, false);
	  scope.domElement.addEventListener('mousedown', onMouseDown, false);
	  scope.domElement.addEventListener('wheel', onMouseWheel, false);
	  scope.domElement.addEventListener('touchstart', onTouchStart, false);
	  scope.domElement.addEventListener('touchend', onTouchEnd, false);
	  scope.domElement.addEventListener('touchmove', onTouchMove, false);
	  scope.domElement.addEventListener('keydown', onKeyDown, false); // make sure element can receive keys.

	  if (scope.domElement.tabIndex === -1) {
	    scope.domElement.tabIndex = 0;
	  } // force an update at start


	  this.update();
	};

	THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
	THREE.OrbitControls.prototype.constructor = THREE.OrbitControls; // This set of controls performs orbiting, dollying (zooming), and panning.
	// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
	// This is very similar to OrbitControls, another set of touch behavior
	//
	//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
	//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
	//    Pan - left mouse, or arrow keys / touch: one-finger move

	THREE.MapControls = function (object, domElement) {
	  THREE.OrbitControls.call(this, object, domElement);
	  this.mouseButtons.LEFT = THREE.MOUSE.PAN;
	  this.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
	  this.touches.ONE = THREE.TOUCH.PAN;
	  this.touches.TWO = THREE.TOUCH.DOLLY_ROTATE;
	};

	THREE.MapControls.prototype = Object.create(THREE.EventDispatcher.prototype);
	THREE.MapControls.prototype.constructor = THREE.MapControls;

	THREE.TransformControls = function (camera, domElement) {
	  if (domElement === undefined) {
	    console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.');
	    domElement = document;
	  }

	  THREE.Object3D.call(this);
	  this.visible = false;
	  this.domElement = domElement;

	  var _gizmo = new THREE.TransformControlsGizmo();

	  this.add(_gizmo);

	  var _plane = new THREE.TransformControlsPlane();

	  this.add(_plane);
	  var scope = this; // Define properties with getters/setter
	  // Setting the defined property will automatically trigger change event
	  // Defined properties are passed down to gizmo and plane

	  defineProperty("camera", camera);
	  defineProperty("object", undefined);
	  defineProperty("enabled", true);
	  defineProperty("axis", null);
	  defineProperty("mode", "translate");
	  defineProperty("translationSnap", null);
	  defineProperty("rotationSnap", null);
	  defineProperty("scaleSnap", null);
	  defineProperty("space", "world");
	  defineProperty("size", 1);
	  defineProperty("dragging", false);
	  defineProperty("showX", true);
	  defineProperty("showY", true);
	  defineProperty("showZ", true);
	  var changeEvent = {
	    type: "change"
	  };
	  var mouseDownEvent = {
	    type: "mouseDown"
	  };
	  var mouseUpEvent = {
	    type: "mouseUp",
	    mode: scope.mode
	  };
	  var objectChangeEvent = {
	    type: "objectChange"
	  }; // Reusable utility variables

	  var ray = new THREE.Raycaster();

	  var _tempVector = new THREE.Vector3();

	  var _tempVector2 = new THREE.Vector3();

	  var _tempQuaternion = new THREE.Quaternion();

	  var _unit = {
	    X: new THREE.Vector3(1, 0, 0),
	    Y: new THREE.Vector3(0, 1, 0),
	    Z: new THREE.Vector3(0, 0, 1)
	  };
	  var pointStart = new THREE.Vector3();
	  var pointEnd = new THREE.Vector3();
	  var offset = new THREE.Vector3();
	  var rotationAxis = new THREE.Vector3();
	  var startNorm = new THREE.Vector3();
	  var endNorm = new THREE.Vector3();
	  var rotationAngle = 0;
	  var cameraPosition = new THREE.Vector3();
	  var cameraQuaternion = new THREE.Quaternion();
	  var cameraScale = new THREE.Vector3();
	  var parentPosition = new THREE.Vector3();
	  var parentQuaternion = new THREE.Quaternion();
	  var parentQuaternionInv = new THREE.Quaternion();
	  var parentScale = new THREE.Vector3();
	  var worldPositionStart = new THREE.Vector3();
	  var worldQuaternionStart = new THREE.Quaternion();
	  var worldScaleStart = new THREE.Vector3();
	  var worldPosition = new THREE.Vector3();
	  var worldQuaternion = new THREE.Quaternion();
	  var worldQuaternionInv = new THREE.Quaternion();
	  var worldScale = new THREE.Vector3();
	  var eye = new THREE.Vector3();
	  var positionStart = new THREE.Vector3();
	  var quaternionStart = new THREE.Quaternion();
	  var scaleStart = new THREE.Vector3(); // TODO: remove properties unused in plane and gizmo

	  defineProperty("worldPosition", worldPosition);
	  defineProperty("worldPositionStart", worldPositionStart);
	  defineProperty("worldQuaternion", worldQuaternion);
	  defineProperty("worldQuaternionStart", worldQuaternionStart);
	  defineProperty("cameraPosition", cameraPosition);
	  defineProperty("cameraQuaternion", cameraQuaternion);
	  defineProperty("pointStart", pointStart);
	  defineProperty("pointEnd", pointEnd);
	  defineProperty("rotationAxis", rotationAxis);
	  defineProperty("rotationAngle", rotationAngle);
	  defineProperty("eye", eye);
	  {
	    domElement.addEventListener("mousedown", onPointerDown, false);
	    domElement.addEventListener("touchstart", onPointerDown, false);
	    domElement.addEventListener("mousemove", onPointerHover, false);
	    domElement.addEventListener("touchmove", onPointerHover, false);
	    domElement.addEventListener("touchmove", onPointerMove, false);
	    document.addEventListener("mouseup", onPointerUp, false);
	    domElement.addEventListener("touchend", onPointerUp, false);
	    domElement.addEventListener("touchcancel", onPointerUp, false);
	    domElement.addEventListener("touchleave", onPointerUp, false);
	  }

	  this.dispose = function () {
	    domElement.removeEventListener("mousedown", onPointerDown);
	    domElement.removeEventListener("touchstart", onPointerDown);
	    domElement.removeEventListener("mousemove", onPointerHover);
	    document.removeEventListener("mousemove", onPointerMove);
	    domElement.removeEventListener("touchmove", onPointerHover);
	    domElement.removeEventListener("touchmove", onPointerMove);
	    document.removeEventListener("mouseup", onPointerUp);
	    domElement.removeEventListener("touchend", onPointerUp);
	    domElement.removeEventListener("touchcancel", onPointerUp);
	    domElement.removeEventListener("touchleave", onPointerUp);
	    this.traverse(function (child) {
	      if (child.geometry) child.geometry.dispose();
	      if (child.material) child.material.dispose();
	    });
	  }; // Set current object


	  this.attach = function (object) {
	    this.object = object;
	    this.visible = true;
	    return this;
	  }; // Detatch from object


	  this.detach = function () {
	    this.object = undefined;
	    this.visible = false;
	    this.axis = null;
	    return this;
	  }; // Defined getter, setter and store for a property


	  function defineProperty(propName, defaultValue) {
	    var propValue = defaultValue;
	    Object.defineProperty(scope, propName, {
	      get: function () {
	        return propValue !== undefined ? propValue : defaultValue;
	      },
	      set: function (value) {
	        if (propValue !== value) {
	          propValue = value;
	          _plane[propName] = value;
	          _gizmo[propName] = value;
	          scope.dispatchEvent({
	            type: propName + "-changed",
	            value: value
	          });
	          scope.dispatchEvent(changeEvent);
	        }
	      }
	    });
	    scope[propName] = defaultValue;
	    _plane[propName] = defaultValue;
	    _gizmo[propName] = defaultValue;
	  } // updateMatrixWorld  updates key transformation variables


	  this.updateMatrixWorld = function () {
	    if (this.object !== undefined) {
	      this.object.updateMatrixWorld();
	      this.object.parent.matrixWorld.decompose(parentPosition, parentQuaternion, parentScale);
	      this.object.matrixWorld.decompose(worldPosition, worldQuaternion, worldScale);
	      parentQuaternionInv.copy(parentQuaternion).inverse();
	      worldQuaternionInv.copy(worldQuaternion).inverse();
	    }

	    this.camera.updateMatrixWorld();
	    this.camera.matrixWorld.decompose(cameraPosition, cameraQuaternion, cameraScale);
	    eye.copy(cameraPosition).sub(worldPosition).normalize();
	    THREE.Object3D.prototype.updateMatrixWorld.call(this);
	  };

	  this.pointerHover = function (pointer) {
	    if (this.object === undefined || this.dragging === true || pointer.button !== undefined && pointer.button !== 0) return;
	    ray.setFromCamera(pointer, this.camera);
	    var intersect = ray.intersectObjects(_gizmo.picker[this.mode].children, true)[0] || false;

	    if (intersect) {
	      this.axis = intersect.object.name;
	    } else {
	      this.axis = null;
	    }
	  };

	  this.pointerDown = function (pointer) {
	    if (this.object === undefined || this.dragging === true || pointer.button !== undefined && pointer.button !== 0) return;

	    if ((pointer.button === 0 || pointer.button === undefined) && this.axis !== null) {
	      ray.setFromCamera(pointer, this.camera);
	      var planeIntersect = ray.intersectObjects([_plane], true)[0] || false;

	      if (planeIntersect) {
	        var space = this.space;

	        if (this.mode === 'scale') {
	          space = 'local';
	        } else if (this.axis === 'E' || this.axis === 'XYZE' || this.axis === 'XYZ') {
	          space = 'world';
	        }

	        if (space === 'local' && this.mode === 'rotate') {
	          var snap = this.rotationSnap;
	          if (this.axis === 'X' && snap) this.object.rotation.x = Math.round(this.object.rotation.x / snap) * snap;
	          if (this.axis === 'Y' && snap) this.object.rotation.y = Math.round(this.object.rotation.y / snap) * snap;
	          if (this.axis === 'Z' && snap) this.object.rotation.z = Math.round(this.object.rotation.z / snap) * snap;
	        }

	        this.object.updateMatrixWorld();
	        this.object.parent.updateMatrixWorld();
	        positionStart.copy(this.object.position);
	        quaternionStart.copy(this.object.quaternion);
	        scaleStart.copy(this.object.scale);
	        this.object.matrixWorld.decompose(worldPositionStart, worldQuaternionStart, worldScaleStart);
	        pointStart.copy(planeIntersect.point).sub(worldPositionStart);
	      }

	      this.dragging = true;
	      mouseDownEvent.mode = this.mode;
	      this.dispatchEvent(mouseDownEvent);
	    }
	  };

	  this.pointerMove = function (pointer) {
	    var axis = this.axis;
	    var mode = this.mode;
	    var object = this.object;
	    var space = this.space;

	    if (mode === 'scale') {
	      space = 'local';
	    } else if (axis === 'E' || axis === 'XYZE' || axis === 'XYZ') {
	      space = 'world';
	    }

	    if (object === undefined || axis === null || this.dragging === false || pointer.button !== undefined && pointer.button !== 0) return;
	    ray.setFromCamera(pointer, this.camera);
	    var planeIntersect = ray.intersectObjects([_plane], true)[0] || false;
	    if (planeIntersect === false) return;
	    pointEnd.copy(planeIntersect.point).sub(worldPositionStart);

	    if (mode === 'translate') {
	      // Apply translate
	      offset.copy(pointEnd).sub(pointStart);

	      if (space === 'local' && axis !== 'XYZ') {
	        offset.applyQuaternion(worldQuaternionInv);
	      }

	      if (axis.indexOf('X') === -1) offset.x = 0;
	      if (axis.indexOf('Y') === -1) offset.y = 0;
	      if (axis.indexOf('Z') === -1) offset.z = 0;

	      if (space === 'local' && axis !== 'XYZ') {
	        offset.applyQuaternion(quaternionStart).divide(parentScale);
	      } else {
	        offset.applyQuaternion(parentQuaternionInv).divide(parentScale);
	      }

	      object.position.copy(offset).add(positionStart); // Apply translation snap

	      if (this.translationSnap) {
	        if (space === 'local') {
	          object.position.applyQuaternion(_tempQuaternion.copy(quaternionStart).inverse());

	          if (axis.search('X') !== -1) {
	            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
	          }

	          if (axis.search('Y') !== -1) {
	            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
	          }

	          if (axis.search('Z') !== -1) {
	            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
	          }

	          object.position.applyQuaternion(quaternionStart);
	        }

	        if (space === 'world') {
	          if (object.parent) {
	            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
	          }

	          if (axis.search('X') !== -1) {
	            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
	          }

	          if (axis.search('Y') !== -1) {
	            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
	          }

	          if (axis.search('Z') !== -1) {
	            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
	          }

	          if (object.parent) {
	            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
	          }
	        }
	      }
	    } else if (mode === 'scale') {
	      if (axis.search('XYZ') !== -1) {
	        var d = pointEnd.length() / pointStart.length();
	        if (pointEnd.dot(pointStart) < 0) d *= -1;

	        _tempVector2.set(d, d, d);
	      } else {
	        _tempVector.copy(pointStart);

	        _tempVector2.copy(pointEnd);

	        _tempVector.applyQuaternion(worldQuaternionInv);

	        _tempVector2.applyQuaternion(worldQuaternionInv);

	        _tempVector2.divide(_tempVector);

	        if (axis.search('X') === -1) {
	          _tempVector2.x = 1;
	        }

	        if (axis.search('Y') === -1) {
	          _tempVector2.y = 1;
	        }

	        if (axis.search('Z') === -1) {
	          _tempVector2.z = 1;
	        }
	      } // Apply scale


	      object.scale.copy(scaleStart).multiply(_tempVector2);

	      if (this.scaleSnap) {
	        if (axis.search('X') !== -1) {
	          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
	        }

	        if (axis.search('Y') !== -1) {
	          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
	        }

	        if (axis.search('Z') !== -1) {
	          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
	        }
	      }
	    } else if (mode === 'rotate') {
	      offset.copy(pointEnd).sub(pointStart);
	      var ROTATION_SPEED = 20 / worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));

	      if (axis === 'E') {
	        rotationAxis.copy(eye);
	        rotationAngle = pointEnd.angleTo(pointStart);
	        startNorm.copy(pointStart).normalize();
	        endNorm.copy(pointEnd).normalize();
	        rotationAngle *= endNorm.cross(startNorm).dot(eye) < 0 ? 1 : -1;
	      } else if (axis === 'XYZE') {
	        rotationAxis.copy(offset).cross(eye).normalize();
	        rotationAngle = offset.dot(_tempVector.copy(rotationAxis).cross(this.eye)) * ROTATION_SPEED;
	      } else if (axis === 'X' || axis === 'Y' || axis === 'Z') {
	        rotationAxis.copy(_unit[axis]);

	        _tempVector.copy(_unit[axis]);

	        if (space === 'local') {
	          _tempVector.applyQuaternion(worldQuaternion);
	        }

	        rotationAngle = offset.dot(_tempVector.cross(eye).normalize()) * ROTATION_SPEED;
	      } // Apply rotation snap


	      if (this.rotationSnap) rotationAngle = Math.round(rotationAngle / this.rotationSnap) * this.rotationSnap;
	      this.rotationAngle = rotationAngle; // Apply rotate

	      if (space === 'local' && axis !== 'E' && axis !== 'XYZE') {
	        object.quaternion.copy(quaternionStart);
	        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(rotationAxis, rotationAngle)).normalize();
	      } else {
	        rotationAxis.applyQuaternion(parentQuaternionInv);
	        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(rotationAxis, rotationAngle));
	        object.quaternion.multiply(quaternionStart).normalize();
	      }
	    }

	    this.dispatchEvent(changeEvent);
	    this.dispatchEvent(objectChangeEvent);
	  };

	  this.pointerUp = function (pointer) {
	    if (pointer.button !== undefined && pointer.button !== 0) return;

	    if (this.dragging && this.axis !== null) {
	      mouseUpEvent.mode = this.mode;
	      this.dispatchEvent(mouseUpEvent);
	    }

	    this.dragging = false;
	    if (pointer.button === undefined) this.axis = null;
	  }; // normalize mouse / touch pointer and remap {x,y} to view space.


	  function getPointer(event) {
	    if (document.pointerLockElement) {
	      return {
	        x: 0,
	        y: 0,
	        button: event.button
	      };
	    } else {
	      var pointer = event.changedTouches ? event.changedTouches[0] : event;
	      var rect = domElement.getBoundingClientRect();
	      return {
	        x: (pointer.clientX - rect.left) / rect.width * 2 - 1,
	        y: -(pointer.clientY - rect.top) / rect.height * 2 + 1,
	        button: event.button
	      };
	    }
	  } // mouse / touch event handlers


	  function onPointerHover(event) {
	    if (!scope.enabled) return;
	    scope.pointerHover(getPointer(event));
	  }

	  function onPointerDown(event) {
	    if (!scope.enabled) return;
	    document.addEventListener("mousemove", onPointerMove, false);
	    scope.pointerHover(getPointer(event));
	    scope.pointerDown(getPointer(event));
	  }

	  function onPointerMove(event) {
	    if (!scope.enabled) return;
	    scope.pointerMove(getPointer(event));
	  }

	  function onPointerUp(event) {
	    if (!scope.enabled) return;
	    document.removeEventListener("mousemove", onPointerMove, false);
	    scope.pointerUp(getPointer(event));
	  } // TODO: deprecate


	  this.getMode = function () {
	    return scope.mode;
	  };

	  this.setMode = function (mode) {
	    scope.mode = mode;
	  };

	  this.setTranslationSnap = function (translationSnap) {
	    scope.translationSnap = translationSnap;
	  };

	  this.setRotationSnap = function (rotationSnap) {
	    scope.rotationSnap = rotationSnap;
	  };

	  this.setScaleSnap = function (scaleSnap) {
	    scope.scaleSnap = scaleSnap;
	  };

	  this.setSize = function (size) {
	    scope.size = size;
	  };

	  this.setSpace = function (space) {
	    scope.space = space;
	  };

	  this.update = function () {
	    console.warn('THREE.TransformControls: update function has no more functionality and therefore has been deprecated.');
	  };
	};

	THREE.TransformControls.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	  constructor: THREE.TransformControls,
	  isTransformControls: true
	});

	THREE.TransformControlsGizmo = function () {

	  THREE.Object3D.call(this);
	  this.type = 'TransformControlsGizmo'; // shared materials

	  var gizmoMaterial = new THREE.MeshBasicMaterial({
	    depthTest: false,
	    depthWrite: false,
	    transparent: true,
	    side: THREE.DoubleSide,
	    fog: false
	  });
	  var gizmoLineMaterial = new THREE.LineBasicMaterial({
	    depthTest: false,
	    depthWrite: false,
	    transparent: true,
	    linewidth: 1,
	    fog: false
	  }); // Make unique material for each axis/color

	  var matInvisible = gizmoMaterial.clone();
	  matInvisible.opacity = 0.15;
	  var matHelper = gizmoMaterial.clone();
	  matHelper.opacity = 0.33;
	  var matRed = gizmoMaterial.clone();
	  matRed.color.set(0xff0000);
	  var matGreen = gizmoMaterial.clone();
	  matGreen.color.set(0x00ff00);
	  var matBlue = gizmoMaterial.clone();
	  matBlue.color.set(0x0000ff);
	  var matWhiteTransparent = gizmoMaterial.clone();
	  matWhiteTransparent.opacity = 0.25;
	  var matYellowTransparent = matWhiteTransparent.clone();
	  matYellowTransparent.color.set(0xffff00);
	  var matCyanTransparent = matWhiteTransparent.clone();
	  matCyanTransparent.color.set(0x00ffff);
	  var matMagentaTransparent = matWhiteTransparent.clone();
	  matMagentaTransparent.color.set(0xff00ff);
	  var matYellow = gizmoMaterial.clone();
	  matYellow.color.set(0xffff00);
	  var matLineRed = gizmoLineMaterial.clone();
	  matLineRed.color.set(0xff0000);
	  var matLineGreen = gizmoLineMaterial.clone();
	  matLineGreen.color.set(0x00ff00);
	  var matLineBlue = gizmoLineMaterial.clone();
	  matLineBlue.color.set(0x0000ff);
	  var matLineCyan = gizmoLineMaterial.clone();
	  matLineCyan.color.set(0x00ffff);
	  var matLineMagenta = gizmoLineMaterial.clone();
	  matLineMagenta.color.set(0xff00ff);
	  var matLineYellow = gizmoLineMaterial.clone();
	  matLineYellow.color.set(0xffff00);
	  var matLineGray = gizmoLineMaterial.clone();
	  matLineGray.color.set(0x787878);
	  var matLineYellowTransparent = matLineYellow.clone();
	  matLineYellowTransparent.opacity = 0.25; // reusable geometry

	  var arrowGeometry = new THREE.CylinderBufferGeometry(0, 0.05, 0.2, 12, 1, false);
	  var scaleHandleGeometry = new THREE.BoxBufferGeometry(0.125, 0.125, 0.125);
	  var lineGeometry = new THREE.BufferGeometry();
	  lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));

	  var CircleGeometry = function (radius, arc) {
	    var geometry = new THREE.BufferGeometry();
	    var vertices = [];

	    for (var i = 0; i <= 64 * arc; ++i) {
	      vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);
	    }

	    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
	    return geometry;
	  }; // Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position


	  var TranslateHelperGeometry = function () {
	    var geometry = new THREE.BufferGeometry();
	    geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
	    return geometry;
	  }; // Gizmo definitions - custom hierarchy definitions for setupGizmo() function


	  var gizmoTranslate = {
	    X: [[new THREE.Mesh(arrowGeometry, matRed), [1, 0, 0], [0, 0, -Math.PI / 2], null, 'fwd'], [new THREE.Mesh(arrowGeometry, matRed), [1, 0, 0], [0, 0, Math.PI / 2], null, 'bwd'], [new THREE.Line(lineGeometry, matLineRed)]],
	    Y: [[new THREE.Mesh(arrowGeometry, matGreen), [0, 1, 0], null, null, 'fwd'], [new THREE.Mesh(arrowGeometry, matGreen), [0, 1, 0], [Math.PI, 0, 0], null, 'bwd'], [new THREE.Line(lineGeometry, matLineGreen), null, [0, 0, Math.PI / 2]]],
	    Z: [[new THREE.Mesh(arrowGeometry, matBlue), [0, 0, 1], [Math.PI / 2, 0, 0], null, 'fwd'], [new THREE.Mesh(arrowGeometry, matBlue), [0, 0, 1], [-Math.PI / 2, 0, 0], null, 'bwd'], [new THREE.Line(lineGeometry, matLineBlue), null, [0, -Math.PI / 2, 0]]],
	    XYZ: [[new THREE.Mesh(new THREE.OctahedronBufferGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0], [0, 0, 0]]],
	    XY: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.295, 0.295), matYellowTransparent.clone()), [0.15, 0.15, 0]], [new THREE.Line(lineGeometry, matLineYellow), [0.18, 0.3, 0], null, [0.125, 1, 1]], [new THREE.Line(lineGeometry, matLineYellow), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]],
	    YZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.295, 0.295), matCyanTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]], [new THREE.Line(lineGeometry, matLineCyan), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]], [new THREE.Line(lineGeometry, matLineCyan), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],
	    XZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.295, 0.295), matMagentaTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]], [new THREE.Line(lineGeometry, matLineMagenta), [0.18, 0, 0.3], null, [0.125, 1, 1]], [new THREE.Line(lineGeometry, matLineMagenta), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]]
	  };
	  var pickerTranslate = {
	    X: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
	    Y: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0, 0.6, 0]]],
	    Z: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), matInvisible), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
	    XYZ: [[new THREE.Mesh(new THREE.OctahedronBufferGeometry(0.2, 0), matInvisible)]],
	    XY: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), matInvisible), [0.2, 0.2, 0]]],
	    YZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), matInvisible), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
	    XZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), matInvisible), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
	  };
	  var helperTranslate = {
	    START: [[new THREE.Mesh(new THREE.OctahedronBufferGeometry(0.01, 2), matHelper), null, null, null, 'helper']],
	    END: [[new THREE.Mesh(new THREE.OctahedronBufferGeometry(0.01, 2), matHelper), null, null, null, 'helper']],
	    DELTA: [[new THREE.Line(TranslateHelperGeometry(), matHelper), null, null, null, 'helper']],
	    X: [[new THREE.Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']],
	    Y: [[new THREE.Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']],
	    Z: [[new THREE.Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']]
	  };
	  var gizmoRotate = {
	    X: [[new THREE.Line(CircleGeometry(1, 0.5), matLineRed)], [new THREE.Mesh(new THREE.OctahedronBufferGeometry(0.04, 0), matRed), [0, 0, 0.99], null, [1, 3, 1]]],
	    Y: [[new THREE.Line(CircleGeometry(1, 0.5), matLineGreen), null, [0, 0, -Math.PI / 2]], [new THREE.Mesh(new THREE.OctahedronBufferGeometry(0.04, 0), matGreen), [0, 0, 0.99], null, [3, 1, 1]]],
	    Z: [[new THREE.Line(CircleGeometry(1, 0.5), matLineBlue), null, [0, Math.PI / 2, 0]], [new THREE.Mesh(new THREE.OctahedronBufferGeometry(0.04, 0), matBlue), [0.99, 0, 0], null, [1, 3, 1]]],
	    E: [[new THREE.Line(CircleGeometry(1.25, 1), matLineYellowTransparent), null, [0, Math.PI / 2, 0]], [new THREE.Mesh(new THREE.CylinderBufferGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [1.17, 0, 0], [0, 0, -Math.PI / 2], [1, 1, 0.001]], [new THREE.Mesh(new THREE.CylinderBufferGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [-1.17, 0, 0], [0, 0, Math.PI / 2], [1, 1, 0.001]], [new THREE.Mesh(new THREE.CylinderBufferGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [0, -1.17, 0], [Math.PI, 0, 0], [1, 1, 0.001]], [new THREE.Mesh(new THREE.CylinderBufferGeometry(0.03, 0, 0.15, 4, 1, false), matLineYellowTransparent), [0, 1.17, 0], [0, 0, 0], [1, 1, 0.001]]],
	    XYZE: [[new THREE.Line(CircleGeometry(1, 1), matLineGray), null, [0, Math.PI / 2, 0]]]
	  };
	  var helperRotate = {
	    AXIS: [[new THREE.Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']]
	  };
	  var pickerRotate = {
	    X: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
	    Y: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]],
	    Z: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]],
	    E: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1.25, 0.1, 2, 24), matInvisible)]],
	    XYZE: [[new THREE.Mesh(new THREE.SphereBufferGeometry(0.7, 10, 8), matInvisible)]]
	  };
	  var gizmoScale = {
	    X: [[new THREE.Mesh(scaleHandleGeometry, matRed), [0.8, 0, 0], [0, 0, -Math.PI / 2]], [new THREE.Line(lineGeometry, matLineRed), null, null, [0.8, 1, 1]]],
	    Y: [[new THREE.Mesh(scaleHandleGeometry, matGreen), [0, 0.8, 0]], [new THREE.Line(lineGeometry, matLineGreen), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]],
	    Z: [[new THREE.Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.8], [Math.PI / 2, 0, 0]], [new THREE.Line(lineGeometry, matLineBlue), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]],
	    XY: [[new THREE.Mesh(scaleHandleGeometry, matYellowTransparent), [0.85, 0.85, 0], null, [2, 2, 0.2]], [new THREE.Line(lineGeometry, matLineYellow), [0.855, 0.98, 0], null, [0.125, 1, 1]], [new THREE.Line(lineGeometry, matLineYellow), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]],
	    YZ: [[new THREE.Mesh(scaleHandleGeometry, matCyanTransparent), [0, 0.85, 0.85], null, [0.2, 2, 2]], [new THREE.Line(lineGeometry, matLineCyan), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]], [new THREE.Line(lineGeometry, matLineCyan), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],
	    XZ: [[new THREE.Mesh(scaleHandleGeometry, matMagentaTransparent), [0.85, 0, 0.85], null, [2, 0.2, 2]], [new THREE.Line(lineGeometry, matLineMagenta), [0.855, 0, 0.98], null, [0.125, 1, 1]], [new THREE.Line(lineGeometry, matLineMagenta), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],
	    XYZX: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [1.1, 0, 0]]],
	    XYZY: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [0, 1.1, 0]]],
	    XYZZ: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.125, 0.125, 0.125), matWhiteTransparent.clone()), [0, 0, 1.1]]]
	  };
	  var pickerScale = {
	    X: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
	    Y: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0, 0.5, 0]]],
	    Z: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 0.8, 4, 1, false), matInvisible), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
	    XY: [[new THREE.Mesh(scaleHandleGeometry, matInvisible), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
	    YZ: [[new THREE.Mesh(scaleHandleGeometry, matInvisible), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
	    XZ: [[new THREE.Mesh(scaleHandleGeometry, matInvisible), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
	    XYZX: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.2, 0.2, 0.2), matInvisible), [1.1, 0, 0]]],
	    XYZY: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.2, 0.2, 0.2), matInvisible), [0, 1.1, 0]]],
	    XYZZ: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 1.1]]]
	  };
	  var helperScale = {
	    X: [[new THREE.Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']],
	    Y: [[new THREE.Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']],
	    Z: [[new THREE.Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']]
	  }; // Creates an Object3D with gizmos described in custom hierarchy definition.

	  var setupGizmo = function (gizmoMap) {
	    var gizmo = new THREE.Object3D();

	    for (var name in gizmoMap) {
	      for (var i = gizmoMap[name].length; i--;) {
	        var object = gizmoMap[name][i][0].clone();
	        var position = gizmoMap[name][i][1];
	        var rotation = gizmoMap[name][i][2];
	        var scale = gizmoMap[name][i][3];
	        var tag = gizmoMap[name][i][4]; // name and tag properties are essential for picking and updating logic.

	        object.name = name;
	        object.tag = tag;

	        if (position) {
	          object.position.set(position[0], position[1], position[2]);
	        }

	        if (rotation) {
	          object.rotation.set(rotation[0], rotation[1], rotation[2]);
	        }

	        if (scale) {
	          object.scale.set(scale[0], scale[1], scale[2]);
	        }

	        object.updateMatrix();
	        var tempGeometry = object.geometry.clone();
	        tempGeometry.applyMatrix4(object.matrix);
	        object.geometry = tempGeometry;
	        object.renderOrder = Infinity;
	        object.position.set(0, 0, 0);
	        object.rotation.set(0, 0, 0);
	        object.scale.set(1, 1, 1);
	        gizmo.add(object);
	      }
	    }

	    return gizmo;
	  }; // Reusable utility variables


	  var tempVector = new THREE.Vector3(0, 0, 0);
	  var tempEuler = new THREE.Euler();
	  var alignVector = new THREE.Vector3(0, 1, 0);
	  var zeroVector = new THREE.Vector3(0, 0, 0);
	  var lookAtMatrix = new THREE.Matrix4();
	  var tempQuaternion = new THREE.Quaternion();
	  var tempQuaternion2 = new THREE.Quaternion();
	  var identityQuaternion = new THREE.Quaternion();
	  var unitX = new THREE.Vector3(1, 0, 0);
	  var unitY = new THREE.Vector3(0, 1, 0);
	  var unitZ = new THREE.Vector3(0, 0, 1); // Gizmo creation

	  this.gizmo = {};
	  this.picker = {};
	  this.helper = {};
	  this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
	  this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
	  this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
	  this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
	  this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
	  this.add(this.picker["scale"] = setupGizmo(pickerScale));
	  this.add(this.helper["translate"] = setupGizmo(helperTranslate));
	  this.add(this.helper["rotate"] = setupGizmo(helperRotate));
	  this.add(this.helper["scale"] = setupGizmo(helperScale)); // Pickers should be hidden always

	  this.picker["translate"].visible = false;
	  this.picker["rotate"].visible = false;
	  this.picker["scale"].visible = false; // updateMatrixWorld will update transformations and appearance of individual handles

	  this.updateMatrixWorld = function () {
	    var space = this.space;
	    if (this.mode === 'scale') space = 'local'; // scale always oriented to local rotation

	    var quaternion = space === "local" ? this.worldQuaternion : identityQuaternion; // Show only gizmos for current transform mode

	    this.gizmo["translate"].visible = this.mode === "translate";
	    this.gizmo["rotate"].visible = this.mode === "rotate";
	    this.gizmo["scale"].visible = this.mode === "scale";
	    this.helper["translate"].visible = this.mode === "translate";
	    this.helper["rotate"].visible = this.mode === "rotate";
	    this.helper["scale"].visible = this.mode === "scale";
	    var handles = [];
	    handles = handles.concat(this.picker[this.mode].children);
	    handles = handles.concat(this.gizmo[this.mode].children);
	    handles = handles.concat(this.helper[this.mode].children);

	    for (var i = 0; i < handles.length; i++) {
	      var handle = handles[i]; // hide aligned to camera

	      handle.visible = true;
	      handle.rotation.set(0, 0, 0);
	      handle.position.copy(this.worldPosition);
	      var eyeDistance = this.worldPosition.distanceTo(this.cameraPosition);
	      handle.scale.set(1, 1, 1).multiplyScalar(eyeDistance * this.size / 7); // TODO: simplify helpers and consider decoupling from gizmo

	      if (handle.tag === 'helper') {
	        handle.visible = false;

	        if (handle.name === 'AXIS') {
	          handle.position.copy(this.worldPositionStart);
	          handle.visible = !!this.axis;

	          if (this.axis === 'X') {
	            tempQuaternion.setFromEuler(tempEuler.set(0, 0, 0));
	            handle.quaternion.copy(quaternion).multiply(tempQuaternion);

	            if (Math.abs(alignVector.copy(unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
	              handle.visible = false;
	            }
	          }

	          if (this.axis === 'Y') {
	            tempQuaternion.setFromEuler(tempEuler.set(0, 0, Math.PI / 2));
	            handle.quaternion.copy(quaternion).multiply(tempQuaternion);

	            if (Math.abs(alignVector.copy(unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
	              handle.visible = false;
	            }
	          }

	          if (this.axis === 'Z') {
	            tempQuaternion.setFromEuler(tempEuler.set(0, Math.PI / 2, 0));
	            handle.quaternion.copy(quaternion).multiply(tempQuaternion);

	            if (Math.abs(alignVector.copy(unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
	              handle.visible = false;
	            }
	          }

	          if (this.axis === 'XYZE') {
	            tempQuaternion.setFromEuler(tempEuler.set(0, Math.PI / 2, 0));
	            alignVector.copy(this.rotationAxis);
	            handle.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(zeroVector, alignVector, unitY));
	            handle.quaternion.multiply(tempQuaternion);
	            handle.visible = this.dragging;
	          }

	          if (this.axis === 'E') {
	            handle.visible = false;
	          }
	        } else if (handle.name === 'START') {
	          handle.position.copy(this.worldPositionStart);
	          handle.visible = this.dragging;
	        } else if (handle.name === 'END') {
	          handle.position.copy(this.worldPosition);
	          handle.visible = this.dragging;
	        } else if (handle.name === 'DELTA') {
	          handle.position.copy(this.worldPositionStart);
	          handle.quaternion.copy(this.worldQuaternionStart);
	          tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
	          tempVector.applyQuaternion(this.worldQuaternionStart.clone().inverse());
	          handle.scale.copy(tempVector);
	          handle.visible = this.dragging;
	        } else {
	          handle.quaternion.copy(quaternion);

	          if (this.dragging) {
	            handle.position.copy(this.worldPositionStart);
	          } else {
	            handle.position.copy(this.worldPosition);
	          }

	          if (this.axis) {
	            handle.visible = this.axis.search(handle.name) !== -1;
	          }
	        } // If updating helper, skip rest of the loop


	        continue;
	      } // Align handles to current local or world rotation


	      handle.quaternion.copy(quaternion);

	      if (this.mode === 'translate' || this.mode === 'scale') {
	        // Hide translate and scale axis facing the camera
	        var AXIS_HIDE_TRESHOLD = 0.99;
	        var PLANE_HIDE_TRESHOLD = 0.2;
	        var AXIS_FLIP_TRESHOLD = 0.0;

	        if (handle.name === 'X' || handle.name === 'XYZX') {
	          if (Math.abs(alignVector.copy(unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {
	            handle.scale.set(1e-10, 1e-10, 1e-10);
	            handle.visible = false;
	          }
	        }

	        if (handle.name === 'Y' || handle.name === 'XYZY') {
	          if (Math.abs(alignVector.copy(unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {
	            handle.scale.set(1e-10, 1e-10, 1e-10);
	            handle.visible = false;
	          }
	        }

	        if (handle.name === 'Z' || handle.name === 'XYZZ') {
	          if (Math.abs(alignVector.copy(unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_TRESHOLD) {
	            handle.scale.set(1e-10, 1e-10, 1e-10);
	            handle.visible = false;
	          }
	        }

	        if (handle.name === 'XY') {
	          if (Math.abs(alignVector.copy(unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {
	            handle.scale.set(1e-10, 1e-10, 1e-10);
	            handle.visible = false;
	          }
	        }

	        if (handle.name === 'YZ') {
	          if (Math.abs(alignVector.copy(unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {
	            handle.scale.set(1e-10, 1e-10, 1e-10);
	            handle.visible = false;
	          }
	        }

	        if (handle.name === 'XZ') {
	          if (Math.abs(alignVector.copy(unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_TRESHOLD) {
	            handle.scale.set(1e-10, 1e-10, 1e-10);
	            handle.visible = false;
	          }
	        } // Flip translate and scale axis ocluded behind another axis


	        if (handle.name.search('X') !== -1) {
	          if (alignVector.copy(unitX).applyQuaternion(quaternion).dot(this.eye) < AXIS_FLIP_TRESHOLD) {
	            if (handle.tag === 'fwd') {
	              handle.visible = false;
	            } else {
	              handle.scale.x *= -1;
	            }
	          } else if (handle.tag === 'bwd') {
	            handle.visible = false;
	          }
	        }

	        if (handle.name.search('Y') !== -1) {
	          if (alignVector.copy(unitY).applyQuaternion(quaternion).dot(this.eye) < AXIS_FLIP_TRESHOLD) {
	            if (handle.tag === 'fwd') {
	              handle.visible = false;
	            } else {
	              handle.scale.y *= -1;
	            }
	          } else if (handle.tag === 'bwd') {
	            handle.visible = false;
	          }
	        }

	        if (handle.name.search('Z') !== -1) {
	          if (alignVector.copy(unitZ).applyQuaternion(quaternion).dot(this.eye) < AXIS_FLIP_TRESHOLD) {
	            if (handle.tag === 'fwd') {
	              handle.visible = false;
	            } else {
	              handle.scale.z *= -1;
	            }
	          } else if (handle.tag === 'bwd') {
	            handle.visible = false;
	          }
	        }
	      } else if (this.mode === 'rotate') {
	        // Align handles to current local or world rotation
	        tempQuaternion2.copy(quaternion);
	        alignVector.copy(this.eye).applyQuaternion(tempQuaternion.copy(quaternion).inverse());

	        if (handle.name.search("E") !== -1) {
	          handle.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(this.eye, zeroVector, unitY));
	        }

	        if (handle.name === 'X') {
	          tempQuaternion.setFromAxisAngle(unitX, Math.atan2(-alignVector.y, alignVector.z));
	          tempQuaternion.multiplyQuaternions(tempQuaternion2, tempQuaternion);
	          handle.quaternion.copy(tempQuaternion);
	        }

	        if (handle.name === 'Y') {
	          tempQuaternion.setFromAxisAngle(unitY, Math.atan2(alignVector.x, alignVector.z));
	          tempQuaternion.multiplyQuaternions(tempQuaternion2, tempQuaternion);
	          handle.quaternion.copy(tempQuaternion);
	        }

	        if (handle.name === 'Z') {
	          tempQuaternion.setFromAxisAngle(unitZ, Math.atan2(alignVector.y, alignVector.x));
	          tempQuaternion.multiplyQuaternions(tempQuaternion2, tempQuaternion);
	          handle.quaternion.copy(tempQuaternion);
	        }
	      } // Hide disabled axes


	      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
	      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
	      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
	      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ); // highlight selected axis

	      handle.material._opacity = handle.material._opacity || handle.material.opacity;
	      handle.material._color = handle.material._color || handle.material.color.clone();
	      handle.material.color.copy(handle.material._color);
	      handle.material.opacity = handle.material._opacity;

	      if (!this.enabled) {
	        handle.material.opacity *= 0.5;
	        handle.material.color.lerp(new THREE.Color(1, 1, 1), 0.5);
	      } else if (this.axis) {
	        if (handle.name === this.axis) {
	          handle.material.opacity = 1.0;
	          handle.material.color.lerp(new THREE.Color(1, 1, 1), 0.5);
	        } else if (this.axis.split('').some(function (a) {
	          return handle.name === a;
	        })) {
	          handle.material.opacity = 1.0;
	          handle.material.color.lerp(new THREE.Color(1, 1, 1), 0.5);
	        } else {
	          handle.material.opacity *= 0.25;
	          handle.material.color.lerp(new THREE.Color(1, 1, 1), 0.5);
	        }
	      }
	    }

	    THREE.Object3D.prototype.updateMatrixWorld.call(this);
	  };
	};

	THREE.TransformControlsGizmo.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	  constructor: THREE.TransformControlsGizmo,
	  isTransformControlsGizmo: true
	});

	THREE.TransformControlsPlane = function () {

	  THREE.Mesh.call(this, new THREE.PlaneBufferGeometry(100000, 100000, 2, 2), new THREE.MeshBasicMaterial({
	    visible: false,
	    wireframe: true,
	    side: THREE.DoubleSide,
	    transparent: true,
	    opacity: 0.1
	  }));
	  this.type = 'TransformControlsPlane';
	  var unitX = new THREE.Vector3(1, 0, 0);
	  var unitY = new THREE.Vector3(0, 1, 0);
	  var unitZ = new THREE.Vector3(0, 0, 1);
	  var tempVector = new THREE.Vector3();
	  var dirVector = new THREE.Vector3();
	  var alignVector = new THREE.Vector3();
	  var tempMatrix = new THREE.Matrix4();
	  var identityQuaternion = new THREE.Quaternion();

	  this.updateMatrixWorld = function () {
	    var space = this.space;
	    this.position.copy(this.worldPosition);
	    if (this.mode === 'scale') space = 'local'; // scale always oriented to local rotation

	    unitX.set(1, 0, 0).applyQuaternion(space === "local" ? this.worldQuaternion : identityQuaternion);
	    unitY.set(0, 1, 0).applyQuaternion(space === "local" ? this.worldQuaternion : identityQuaternion);
	    unitZ.set(0, 0, 1).applyQuaternion(space === "local" ? this.worldQuaternion : identityQuaternion); // Align the plane for current transform mode, axis and space.

	    alignVector.copy(unitY);

	    switch (this.mode) {
	      case 'translate':
	      case 'scale':
	        switch (this.axis) {
	          case 'X':
	            alignVector.copy(this.eye).cross(unitX);
	            dirVector.copy(unitX).cross(alignVector);
	            break;

	          case 'Y':
	            alignVector.copy(this.eye).cross(unitY);
	            dirVector.copy(unitY).cross(alignVector);
	            break;

	          case 'Z':
	            alignVector.copy(this.eye).cross(unitZ);
	            dirVector.copy(unitZ).cross(alignVector);
	            break;

	          case 'XY':
	            dirVector.copy(unitZ);
	            break;

	          case 'YZ':
	            dirVector.copy(unitX);
	            break;

	          case 'XZ':
	            alignVector.copy(unitZ);
	            dirVector.copy(unitY);
	            break;

	          case 'XYZ':
	          case 'E':
	            dirVector.set(0, 0, 0);
	            break;
	        }

	        break;

	      case 'rotate':
	      default:
	        // special case for rotate
	        dirVector.set(0, 0, 0);
	    }

	    if (dirVector.length() === 0) {
	      // If in rotate mode, make the plane parallel to camera
	      this.quaternion.copy(this.cameraQuaternion);
	    } else {
	      tempMatrix.lookAt(tempVector.set(0, 0, 0), dirVector, alignVector);
	      this.quaternion.setFromRotationMatrix(tempMatrix);
	    }

	    THREE.Object3D.prototype.updateMatrixWorld.call(this);
	  };
	};

	THREE.TransformControlsPlane.prototype = Object.assign(Object.create(THREE.Mesh.prototype), {
	  constructor: THREE.TransformControlsPlane,
	  isTransformControlsPlane: true
	});

	THREE.DecalGeometry = function (mesh, position, orientation, size) {
	  THREE.BufferGeometry.call(this); // buffers

	  var vertices = [];
	  var normals = [];
	  var uvs = []; // helpers

	  var plane = new THREE.Vector3(); // this matrix represents the transformation of the decal projector

	  var projectorMatrix = new THREE.Matrix4();
	  projectorMatrix.makeRotationFromEuler(orientation);
	  projectorMatrix.setPosition(position);
	  var projectorMatrixInverse = new THREE.Matrix4().getInverse(projectorMatrix); // generate buffers

	  generate(); // build geometry

	  this.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
	  this.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
	  this.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));

	  function generate() {
	    var i;
	    var geometry = new THREE.BufferGeometry();
	    var decalVertices = [];
	    var vertex = new THREE.Vector3();
	    var normal = new THREE.Vector3(); // handle different geometry types

	    if (mesh.geometry.isGeometry) {
	      geometry.fromGeometry(mesh.geometry);
	    } else {
	      geometry.copy(mesh.geometry);
	    }

	    var positionAttribute = geometry.attributes.position;
	    var normalAttribute = geometry.attributes.normal; // first, create an array of 'DecalVertex' objects
	    // three consecutive 'DecalVertex' objects represent a single face
	    //
	    // this data structure will be later used to perform the clipping

	    if (geometry.index !== null) {
	      // indexed BufferGeometry
	      var index = geometry.index;

	      for (i = 0; i < index.count; i++) {
	        vertex.fromBufferAttribute(positionAttribute, index.getX(i));
	        normal.fromBufferAttribute(normalAttribute, index.getX(i));
	        pushDecalVertex(decalVertices, vertex, normal);
	      }
	    } else {
	      // non-indexed BufferGeometry
	      for (i = 0; i < positionAttribute.count; i++) {
	        vertex.fromBufferAttribute(positionAttribute, i);
	        normal.fromBufferAttribute(normalAttribute, i);
	        pushDecalVertex(decalVertices, vertex, normal);
	      }
	    } // second, clip the geometry so that it doesn't extend out from the projector


	    decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));
	    decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));
	    decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));
	    decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));
	    decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));
	    decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1)); // third, generate final vertices, normals and uvs

	    for (i = 0; i < decalVertices.length; i++) {
	      var decalVertex = decalVertices[i]; // create texture coordinates (we are still in projector space)

	      uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y); // transform the vertex back to world space

	      decalVertex.position.applyMatrix4(projectorMatrix); // now create vertex and normal buffer data

	      vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);
	      normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);
	    }
	  }

	  function pushDecalVertex(decalVertices, vertex, normal) {
	    // transform the vertex to world space, then to projector space
	    vertex.applyMatrix4(mesh.matrixWorld);
	    vertex.applyMatrix4(projectorMatrixInverse);
	    normal.transformDirection(mesh.matrixWorld);
	    decalVertices.push(new THREE.DecalVertex(vertex.clone(), normal.clone()));
	  }

	  function clipGeometry(inVertices, plane) {
	    var outVertices = [];
	    var s = 0.5 * Math.abs(size.dot(plane)); // a single iteration clips one face,
	    // which consists of three consecutive 'DecalVertex' objects

	    for (var i = 0; i < inVertices.length; i += 3) {
	      var v1Out,
	          v2Out,
	          v3Out,
	          total = 0;
	      var nV1, nV2, nV3, nV4;
	      var d1 = inVertices[i + 0].position.dot(plane) - s;
	      var d2 = inVertices[i + 1].position.dot(plane) - s;
	      var d3 = inVertices[i + 2].position.dot(plane) - s;
	      v1Out = d1 > 0;
	      v2Out = d2 > 0;
	      v3Out = d3 > 0; // calculate, how many vertices of the face lie outside of the clipping plane

	      total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);

	      switch (total) {
	        case 0:
	          {
	            // the entire face lies inside of the plane, no clipping needed
	            outVertices.push(inVertices[i]);
	            outVertices.push(inVertices[i + 1]);
	            outVertices.push(inVertices[i + 2]);
	            break;
	          }

	        case 1:
	          {
	            // one vertex lies outside of the plane, perform clipping
	            if (v1Out) {
	              nV1 = inVertices[i + 1];
	              nV2 = inVertices[i + 2];
	              nV3 = clip(inVertices[i], nV1, plane, s);
	              nV4 = clip(inVertices[i], nV2, plane, s);
	            }

	            if (v2Out) {
	              nV1 = inVertices[i];
	              nV2 = inVertices[i + 2];
	              nV3 = clip(inVertices[i + 1], nV1, plane, s);
	              nV4 = clip(inVertices[i + 1], nV2, plane, s);
	              outVertices.push(nV3);
	              outVertices.push(nV2.clone());
	              outVertices.push(nV1.clone());
	              outVertices.push(nV2.clone());
	              outVertices.push(nV3.clone());
	              outVertices.push(nV4);
	              break;
	            }

	            if (v3Out) {
	              nV1 = inVertices[i];
	              nV2 = inVertices[i + 1];
	              nV3 = clip(inVertices[i + 2], nV1, plane, s);
	              nV4 = clip(inVertices[i + 2], nV2, plane, s);
	            }

	            outVertices.push(nV1.clone());
	            outVertices.push(nV2.clone());
	            outVertices.push(nV3);
	            outVertices.push(nV4);
	            outVertices.push(nV3.clone());
	            outVertices.push(nV2.clone());
	            break;
	          }

	        case 2:
	          {
	            // two vertices lies outside of the plane, perform clipping
	            if (!v1Out) {
	              nV1 = inVertices[i].clone();
	              nV2 = clip(nV1, inVertices[i + 1], plane, s);
	              nV3 = clip(nV1, inVertices[i + 2], plane, s);
	              outVertices.push(nV1);
	              outVertices.push(nV2);
	              outVertices.push(nV3);
	            }

	            if (!v2Out) {
	              nV1 = inVertices[i + 1].clone();
	              nV2 = clip(nV1, inVertices[i + 2], plane, s);
	              nV3 = clip(nV1, inVertices[i], plane, s);
	              outVertices.push(nV1);
	              outVertices.push(nV2);
	              outVertices.push(nV3);
	            }

	            if (!v3Out) {
	              nV1 = inVertices[i + 2].clone();
	              nV2 = clip(nV1, inVertices[i], plane, s);
	              nV3 = clip(nV1, inVertices[i + 1], plane, s);
	              outVertices.push(nV1);
	              outVertices.push(nV2);
	              outVertices.push(nV3);
	            }

	            break;
	          }
	      }
	    }

	    return outVertices;
	  }

	  function clip(v0, v1, p, s) {
	    var d0 = v0.position.dot(p) - s;
	    var d1 = v1.position.dot(p) - s;
	    var s0 = d0 / (d0 - d1);
	    var v = new THREE.DecalVertex(new THREE.Vector3(v0.position.x + s0 * (v1.position.x - v0.position.x), v0.position.y + s0 * (v1.position.y - v0.position.y), v0.position.z + s0 * (v1.position.z - v0.position.z)), new THREE.Vector3(v0.normal.x + s0 * (v1.normal.x - v0.normal.x), v0.normal.y + s0 * (v1.normal.y - v0.normal.y), v0.normal.z + s0 * (v1.normal.z - v0.normal.z))); // need to clip more values (texture coordinates)? do it this way:
	    // intersectpoint.value = a.value + s * ( b.value - a.value );

	    return v;
	  }
	};

	THREE.DecalGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.DecalGeometry.prototype.constructor = THREE.DecalGeometry; // helper

	THREE.DecalVertex = function (position, normal) {
	  this.position = position;
	  this.normal = normal;
	};

	THREE.DecalVertex.prototype.clone = function () {
	  return new this.constructor(this.position.clone(), this.normal.clone());
	};

	THREE.TeapotBufferGeometry = function (size, segments, bottom, lid, body, fitLid, blinn) {
	  // 32 * 4 * 4 Bezier spline patches
	  var teapotPatches = [
	  /*rim*/
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 3, 16, 17, 18, 7, 19, 20, 21, 11, 22, 23, 24, 15, 25, 26, 27, 18, 28, 29, 30, 21, 31, 32, 33, 24, 34, 35, 36, 27, 37, 38, 39, 30, 40, 41, 0, 33, 42, 43, 4, 36, 44, 45, 8, 39, 46, 47, 12,
	  /*body*/
	  12, 13, 14, 15, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 15, 25, 26, 27, 51, 60, 61, 62, 55, 63, 64, 65, 59, 66, 67, 68, 27, 37, 38, 39, 62, 69, 70, 71, 65, 72, 73, 74, 68, 75, 76, 77, 39, 46, 47, 12, 71, 78, 79, 48, 74, 80, 81, 52, 77, 82, 83, 56, 56, 57, 58, 59, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 59, 66, 67, 68, 87, 96, 97, 98, 91, 99, 100, 101, 95, 102, 103, 104, 68, 75, 76, 77, 98, 105, 106, 107, 101, 108, 109, 110, 104, 111, 112, 113, 77, 82, 83, 56, 107, 114, 115, 84, 110, 116, 117, 88, 113, 118, 119, 92,
	  /*handle*/
	  120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 123, 136, 137, 120, 127, 138, 139, 124, 131, 140, 141, 128, 135, 142, 143, 132, 132, 133, 134, 135, 144, 145, 146, 147, 148, 149, 150, 151, 68, 152, 153, 154, 135, 142, 143, 132, 147, 155, 156, 144, 151, 157, 158, 148, 154, 159, 160, 68,
	  /*spout*/
	  161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 164, 177, 178, 161, 168, 179, 180, 165, 172, 181, 182, 169, 176, 183, 184, 173, 173, 174, 175, 176, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 176, 183, 184, 173, 188, 197, 198, 185, 192, 199, 200, 189, 196, 201, 202, 193,
	  /*lid*/
	  203, 203, 203, 203, 204, 205, 206, 207, 208, 208, 208, 208, 209, 210, 211, 212, 203, 203, 203, 203, 207, 213, 214, 215, 208, 208, 208, 208, 212, 216, 217, 218, 203, 203, 203, 203, 215, 219, 220, 221, 208, 208, 208, 208, 218, 222, 223, 224, 203, 203, 203, 203, 221, 225, 226, 204, 208, 208, 208, 208, 224, 227, 228, 209, 209, 210, 211, 212, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 212, 216, 217, 218, 232, 241, 242, 243, 236, 244, 245, 246, 240, 247, 248, 249, 218, 222, 223, 224, 243, 250, 251, 252, 246, 253, 254, 255, 249, 256, 257, 258, 224, 227, 228, 209, 252, 259, 260, 229, 255, 261, 262, 233, 258, 263, 264, 237,
	  /*bottom*/
	  265, 265, 265, 265, 266, 267, 268, 269, 270, 271, 272, 273, 92, 119, 118, 113, 265, 265, 265, 265, 269, 274, 275, 276, 273, 277, 278, 279, 113, 112, 111, 104, 265, 265, 265, 265, 276, 280, 281, 282, 279, 283, 284, 285, 104, 103, 102, 95, 265, 265, 265, 265, 282, 286, 287, 266, 285, 288, 289, 270, 95, 94, 93, 92];
	  var teapotVertices = [1.4, 0, 2.4, 1.4, -0.784, 2.4, 0.784, -1.4, 2.4, 0, -1.4, 2.4, 1.3375, 0, 2.53125, 1.3375, -0.749, 2.53125, 0.749, -1.3375, 2.53125, 0, -1.3375, 2.53125, 1.4375, 0, 2.53125, 1.4375, -0.805, 2.53125, 0.805, -1.4375, 2.53125, 0, -1.4375, 2.53125, 1.5, 0, 2.4, 1.5, -0.84, 2.4, 0.84, -1.5, 2.4, 0, -1.5, 2.4, -0.784, -1.4, 2.4, -1.4, -0.784, 2.4, -1.4, 0, 2.4, -0.749, -1.3375, 2.53125, -1.3375, -0.749, 2.53125, -1.3375, 0, 2.53125, -0.805, -1.4375, 2.53125, -1.4375, -0.805, 2.53125, -1.4375, 0, 2.53125, -0.84, -1.5, 2.4, -1.5, -0.84, 2.4, -1.5, 0, 2.4, -1.4, 0.784, 2.4, -0.784, 1.4, 2.4, 0, 1.4, 2.4, -1.3375, 0.749, 2.53125, -0.749, 1.3375, 2.53125, 0, 1.3375, 2.53125, -1.4375, 0.805, 2.53125, -0.805, 1.4375, 2.53125, 0, 1.4375, 2.53125, -1.5, 0.84, 2.4, -0.84, 1.5, 2.4, 0, 1.5, 2.4, 0.784, 1.4, 2.4, 1.4, 0.784, 2.4, 0.749, 1.3375, 2.53125, 1.3375, 0.749, 2.53125, 0.805, 1.4375, 2.53125, 1.4375, 0.805, 2.53125, 0.84, 1.5, 2.4, 1.5, 0.84, 2.4, 1.75, 0, 1.875, 1.75, -0.98, 1.875, 0.98, -1.75, 1.875, 0, -1.75, 1.875, 2, 0, 1.35, 2, -1.12, 1.35, 1.12, -2, 1.35, 0, -2, 1.35, 2, 0, 0.9, 2, -1.12, 0.9, 1.12, -2, 0.9, 0, -2, 0.9, -0.98, -1.75, 1.875, -1.75, -0.98, 1.875, -1.75, 0, 1.875, -1.12, -2, 1.35, -2, -1.12, 1.35, -2, 0, 1.35, -1.12, -2, 0.9, -2, -1.12, 0.9, -2, 0, 0.9, -1.75, 0.98, 1.875, -0.98, 1.75, 1.875, 0, 1.75, 1.875, -2, 1.12, 1.35, -1.12, 2, 1.35, 0, 2, 1.35, -2, 1.12, 0.9, -1.12, 2, 0.9, 0, 2, 0.9, 0.98, 1.75, 1.875, 1.75, 0.98, 1.875, 1.12, 2, 1.35, 2, 1.12, 1.35, 1.12, 2, 0.9, 2, 1.12, 0.9, 2, 0, 0.45, 2, -1.12, 0.45, 1.12, -2, 0.45, 0, -2, 0.45, 1.5, 0, 0.225, 1.5, -0.84, 0.225, 0.84, -1.5, 0.225, 0, -1.5, 0.225, 1.5, 0, 0.15, 1.5, -0.84, 0.15, 0.84, -1.5, 0.15, 0, -1.5, 0.15, -1.12, -2, 0.45, -2, -1.12, 0.45, -2, 0, 0.45, -0.84, -1.5, 0.225, -1.5, -0.84, 0.225, -1.5, 0, 0.225, -0.84, -1.5, 0.15, -1.5, -0.84, 0.15, -1.5, 0, 0.15, -2, 1.12, 0.45, -1.12, 2, 0.45, 0, 2, 0.45, -1.5, 0.84, 0.225, -0.84, 1.5, 0.225, 0, 1.5, 0.225, -1.5, 0.84, 0.15, -0.84, 1.5, 0.15, 0, 1.5, 0.15, 1.12, 2, 0.45, 2, 1.12, 0.45, 0.84, 1.5, 0.225, 1.5, 0.84, 0.225, 0.84, 1.5, 0.15, 1.5, 0.84, 0.15, -1.6, 0, 2.025, -1.6, -0.3, 2.025, -1.5, -0.3, 2.25, -1.5, 0, 2.25, -2.3, 0, 2.025, -2.3, -0.3, 2.025, -2.5, -0.3, 2.25, -2.5, 0, 2.25, -2.7, 0, 2.025, -2.7, -0.3, 2.025, -3, -0.3, 2.25, -3, 0, 2.25, -2.7, 0, 1.8, -2.7, -0.3, 1.8, -3, -0.3, 1.8, -3, 0, 1.8, -1.5, 0.3, 2.25, -1.6, 0.3, 2.025, -2.5, 0.3, 2.25, -2.3, 0.3, 2.025, -3, 0.3, 2.25, -2.7, 0.3, 2.025, -3, 0.3, 1.8, -2.7, 0.3, 1.8, -2.7, 0, 1.575, -2.7, -0.3, 1.575, -3, -0.3, 1.35, -3, 0, 1.35, -2.5, 0, 1.125, -2.5, -0.3, 1.125, -2.65, -0.3, 0.9375, -2.65, 0, 0.9375, -2, -0.3, 0.9, -1.9, -0.3, 0.6, -1.9, 0, 0.6, -3, 0.3, 1.35, -2.7, 0.3, 1.575, -2.65, 0.3, 0.9375, -2.5, 0.3, 1.125, -1.9, 0.3, 0.6, -2, 0.3, 0.9, 1.7, 0, 1.425, 1.7, -0.66, 1.425, 1.7, -0.66, 0.6, 1.7, 0, 0.6, 2.6, 0, 1.425, 2.6, -0.66, 1.425, 3.1, -0.66, 0.825, 3.1, 0, 0.825, 2.3, 0, 2.1, 2.3, -0.25, 2.1, 2.4, -0.25, 2.025, 2.4, 0, 2.025, 2.7, 0, 2.4, 2.7, -0.25, 2.4, 3.3, -0.25, 2.4, 3.3, 0, 2.4, 1.7, 0.66, 0.6, 1.7, 0.66, 1.425, 3.1, 0.66, 0.825, 2.6, 0.66, 1.425, 2.4, 0.25, 2.025, 2.3, 0.25, 2.1, 3.3, 0.25, 2.4, 2.7, 0.25, 2.4, 2.8, 0, 2.475, 2.8, -0.25, 2.475, 3.525, -0.25, 2.49375, 3.525, 0, 2.49375, 2.9, 0, 2.475, 2.9, -0.15, 2.475, 3.45, -0.15, 2.5125, 3.45, 0, 2.5125, 2.8, 0, 2.4, 2.8, -0.15, 2.4, 3.2, -0.15, 2.4, 3.2, 0, 2.4, 3.525, 0.25, 2.49375, 2.8, 0.25, 2.475, 3.45, 0.15, 2.5125, 2.9, 0.15, 2.475, 3.2, 0.15, 2.4, 2.8, 0.15, 2.4, 0, 0, 3.15, 0.8, 0, 3.15, 0.8, -0.45, 3.15, 0.45, -0.8, 3.15, 0, -0.8, 3.15, 0, 0, 2.85, 0.2, 0, 2.7, 0.2, -0.112, 2.7, 0.112, -0.2, 2.7, 0, -0.2, 2.7, -0.45, -0.8, 3.15, -0.8, -0.45, 3.15, -0.8, 0, 3.15, -0.112, -0.2, 2.7, -0.2, -0.112, 2.7, -0.2, 0, 2.7, -0.8, 0.45, 3.15, -0.45, 0.8, 3.15, 0, 0.8, 3.15, -0.2, 0.112, 2.7, -0.112, 0.2, 2.7, 0, 0.2, 2.7, 0.45, 0.8, 3.15, 0.8, 0.45, 3.15, 0.112, 0.2, 2.7, 0.2, 0.112, 2.7, 0.4, 0, 2.55, 0.4, -0.224, 2.55, 0.224, -0.4, 2.55, 0, -0.4, 2.55, 1.3, 0, 2.55, 1.3, -0.728, 2.55, 0.728, -1.3, 2.55, 0, -1.3, 2.55, 1.3, 0, 2.4, 1.3, -0.728, 2.4, 0.728, -1.3, 2.4, 0, -1.3, 2.4, -0.224, -0.4, 2.55, -0.4, -0.224, 2.55, -0.4, 0, 2.55, -0.728, -1.3, 2.55, -1.3, -0.728, 2.55, -1.3, 0, 2.55, -0.728, -1.3, 2.4, -1.3, -0.728, 2.4, -1.3, 0, 2.4, -0.4, 0.224, 2.55, -0.224, 0.4, 2.55, 0, 0.4, 2.55, -1.3, 0.728, 2.55, -0.728, 1.3, 2.55, 0, 1.3, 2.55, -1.3, 0.728, 2.4, -0.728, 1.3, 2.4, 0, 1.3, 2.4, 0.224, 0.4, 2.55, 0.4, 0.224, 2.55, 0.728, 1.3, 2.55, 1.3, 0.728, 2.55, 0.728, 1.3, 2.4, 1.3, 0.728, 2.4, 0, 0, 0, 1.425, 0, 0, 1.425, 0.798, 0, 0.798, 1.425, 0, 0, 1.425, 0, 1.5, 0, 0.075, 1.5, 0.84, 0.075, 0.84, 1.5, 0.075, 0, 1.5, 0.075, -0.798, 1.425, 0, -1.425, 0.798, 0, -1.425, 0, 0, -0.84, 1.5, 0.075, -1.5, 0.84, 0.075, -1.5, 0, 0.075, -1.425, -0.798, 0, -0.798, -1.425, 0, 0, -1.425, 0, -1.5, -0.84, 0.075, -0.84, -1.5, 0.075, 0, -1.5, 0.075, 0.798, -1.425, 0, 1.425, -0.798, 0, 0.84, -1.5, 0.075, 1.5, -0.84, 0.075];
	  THREE.BufferGeometry.call(this);
	  size = size || 50; // number of segments per patch

	  segments = segments !== undefined ? Math.max(2, Math.floor(segments) || 10) : 10; // which parts should be visible

	  bottom = bottom === undefined ? true : bottom;
	  lid = lid === undefined ? true : lid;
	  body = body === undefined ? true : body; // Should the lid be snug? It's not traditional, but we make it snug by default

	  fitLid = fitLid === undefined ? true : fitLid; // Jim Blinn scaled the teapot down in size by about 1.3 for
	  // some rendering tests. He liked the new proportions that he kept
	  // the data in this form. The model was distributed with these new
	  // proportions and became the norm. Trivia: comparing images of the
	  // real teapot and the computer model, the ratio for the bowl of the
	  // real teapot is more like 1.25, but since 1.3 is the traditional
	  // value given, we use it here.

	  var blinnScale = 1.3;
	  blinn = blinn === undefined ? true : blinn; // scale the size to be the real scaling factor

	  var maxHeight = 3.15 * (blinn ? 1 : blinnScale);
	  var maxHeight2 = maxHeight / 2;
	  var trueSize = size / maxHeight2; // Number of elements depends on what is needed. Subtract degenerate
	  // triangles at tip of bottom and lid out in advance.

	  var numTriangles = bottom ? (8 * segments - 4) * segments : 0;
	  numTriangles += lid ? (16 * segments - 4) * segments : 0;
	  numTriangles += body ? 40 * segments * segments : 0;
	  var indices = new Uint32Array(numTriangles * 3);
	  var numVertices = bottom ? 4 : 0;
	  numVertices += lid ? 8 : 0;
	  numVertices += body ? 20 : 0;
	  numVertices *= (segments + 1) * (segments + 1);
	  var vertices = new Float32Array(numVertices * 3);
	  var normals = new Float32Array(numVertices * 3);
	  var uvs = new Float32Array(numVertices * 2); // Bezier form

	  var ms = new THREE.Matrix4();
	  ms.set(-1.0, 3.0, -3.0, 1.0, 3.0, -6.0, 3.0, 0.0, -3.0, 3.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
	  var g = [];
	  var i, r, c;
	  var sp = [];
	  var tp = [];
	  var dsp = [];
	  var dtp = []; // M * G * M matrix, sort of see
	  // http://www.cs.helsinki.fi/group/goa/mallinnus/curves/surfaces.html

	  var mgm = [];
	  var vert = [];
	  var sdir = [];
	  var tdir = [];
	  var norm = new THREE.Vector3();
	  var tcoord;
	  var sstep, tstep;
	  var vertPerRow;
	  var s, t, sval, tval, p;
	  var dsval = 0;
	  var dtval = 0;
	  var normOut = new THREE.Vector3();
	  var v1, v2, v3, v4;
	  var gmx = new THREE.Matrix4();
	  var tmtx = new THREE.Matrix4();
	  var vsp = new THREE.Vector4();
	  var vtp = new THREE.Vector4();
	  var vdsp = new THREE.Vector4();
	  var vdtp = new THREE.Vector4();
	  var vsdir = new THREE.Vector3();
	  var vtdir = new THREE.Vector3();
	  var mst = ms.clone();
	  mst.transpose(); // internal function: test if triangle has any matching vertices;
	  // if so, don't save triangle, since it won't display anything.

	  var notDegenerate = function (vtx1, vtx2, vtx3) {
	    // if any vertex matches, return false
	    return !(vertices[vtx1 * 3] === vertices[vtx2 * 3] && vertices[vtx1 * 3 + 1] === vertices[vtx2 * 3 + 1] && vertices[vtx1 * 3 + 2] === vertices[vtx2 * 3 + 2] || vertices[vtx1 * 3] === vertices[vtx3 * 3] && vertices[vtx1 * 3 + 1] === vertices[vtx3 * 3 + 1] && vertices[vtx1 * 3 + 2] === vertices[vtx3 * 3 + 2] || vertices[vtx2 * 3] === vertices[vtx3 * 3] && vertices[vtx2 * 3 + 1] === vertices[vtx3 * 3 + 1] && vertices[vtx2 * 3 + 2] === vertices[vtx3 * 3 + 2]);
	  };

	  for (i = 0; i < 3; i++) {
	    mgm[i] = new THREE.Matrix4();
	  }

	  var minPatches = body ? 0 : 20;
	  var maxPatches = bottom ? 32 : 28;
	  vertPerRow = segments + 1;
	  var surfCount = 0;
	  var vertCount = 0;
	  var normCount = 0;
	  var uvCount = 0;
	  var indexCount = 0;

	  for (var surf = minPatches; surf < maxPatches; surf++) {
	    // lid is in the middle of the data, patches 20-27,
	    // so ignore it for this part of the loop if the lid is not desired
	    if (lid || surf < 20 || surf >= 28) {
	      // get M * G * M matrix for x,y,z
	      for (i = 0; i < 3; i++) {
	        // get control patches
	        for (r = 0; r < 4; r++) {
	          for (c = 0; c < 4; c++) {
	            // transposed
	            g[c * 4 + r] = teapotVertices[teapotPatches[surf * 16 + r * 4 + c] * 3 + i]; // is the lid to be made larger, and is this a point on the lid
	            // that is X or Y?

	            if (fitLid && surf >= 20 && surf < 28 && i !== 2) {
	              // increase XY size by 7.7%, found empirically. I don't
	              // increase Z so that the teapot will continue to fit in the
	              // space -1 to 1 for Y (Y is up for the final model).
	              g[c * 4 + r] *= 1.077;
	            } // Blinn "fixed" the teapot by dividing Z by blinnScale, and that's the
	            // data we now use. The original teapot is taller. Fix it:


	            if (!blinn && i === 2) {
	              g[c * 4 + r] *= blinnScale;
	            }
	          }
	        }

	        gmx.set(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], g[8], g[9], g[10], g[11], g[12], g[13], g[14], g[15]);
	        tmtx.multiplyMatrices(gmx, ms);
	        mgm[i].multiplyMatrices(mst, tmtx);
	      } // step along, get points, and output


	      for (sstep = 0; sstep <= segments; sstep++) {
	        s = sstep / segments;

	        for (tstep = 0; tstep <= segments; tstep++) {
	          t = tstep / segments; // point from basis
	          // get power vectors and their derivatives

	          for (p = 4, sval = tval = 1.0; p--;) {
	            sp[p] = sval;
	            tp[p] = tval;
	            sval *= s;
	            tval *= t;

	            if (p === 3) {
	              dsp[p] = dtp[p] = 0.0;
	              dsval = dtval = 1.0;
	            } else {
	              dsp[p] = dsval * (3 - p);
	              dtp[p] = dtval * (3 - p);
	              dsval *= s;
	              dtval *= t;
	            }
	          }

	          vsp.fromArray(sp);
	          vtp.fromArray(tp);
	          vdsp.fromArray(dsp);
	          vdtp.fromArray(dtp); // do for x,y,z

	          for (i = 0; i < 3; i++) {
	            // multiply power vectors times matrix to get value
	            tcoord = vsp.clone();
	            tcoord.applyMatrix4(mgm[i]);
	            vert[i] = tcoord.dot(vtp); // get s and t tangent vectors

	            tcoord = vdsp.clone();
	            tcoord.applyMatrix4(mgm[i]);
	            sdir[i] = tcoord.dot(vtp);
	            tcoord = vsp.clone();
	            tcoord.applyMatrix4(mgm[i]);
	            tdir[i] = tcoord.dot(vdtp);
	          } // find normal


	          vsdir.fromArray(sdir);
	          vtdir.fromArray(tdir);
	          norm.crossVectors(vtdir, vsdir);
	          norm.normalize(); // if X and Z length is 0, at the cusp, so point the normal up or down, depending on patch number

	          if (vert[0] === 0 && vert[1] === 0) {
	            // if above the middle of the teapot, normal points up, else down
	            normOut.set(0, vert[2] > maxHeight2 ? 1 : -1, 0);
	          } else {
	            // standard output: rotate on X axis
	            normOut.set(norm.x, norm.z, -norm.y);
	          } // store it all


	          vertices[vertCount++] = trueSize * vert[0];
	          vertices[vertCount++] = trueSize * (vert[2] - maxHeight2);
	          vertices[vertCount++] = -trueSize * vert[1];
	          normals[normCount++] = normOut.x;
	          normals[normCount++] = normOut.y;
	          normals[normCount++] = normOut.z;
	          uvs[uvCount++] = 1 - t;
	          uvs[uvCount++] = 1 - s;
	        }
	      } // save the faces


	      for (sstep = 0; sstep < segments; sstep++) {
	        for (tstep = 0; tstep < segments; tstep++) {
	          v1 = surfCount * vertPerRow * vertPerRow + sstep * vertPerRow + tstep;
	          v2 = v1 + 1;
	          v3 = v2 + vertPerRow;
	          v4 = v1 + vertPerRow; // Normals and UVs cannot be shared. Without clone(), you can see the consequences
	          // of sharing if you call geometry.applyMatrix4( matrix ).

	          if (notDegenerate(v1, v2, v3)) {
	            indices[indexCount++] = v1;
	            indices[indexCount++] = v2;
	            indices[indexCount++] = v3;
	          }

	          if (notDegenerate(v1, v3, v4)) {
	            indices[indexCount++] = v1;
	            indices[indexCount++] = v3;
	            indices[indexCount++] = v4;
	          }
	        }
	      } // increment only if a surface was used


	      surfCount++;
	    }
	  }

	  this.setIndex(new THREE.BufferAttribute(indices, 1));
	  this.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
	  this.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
	  this.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
	  this.computeBoundingSphere();
	};

	THREE.TeapotBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
	THREE.TeapotBufferGeometry.prototype.constructor = THREE.TeapotBufferGeometry;

	// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
	// Read Stefan's excellent paper for details on how this code works.
	//
	// Sean McCullough banksean@gmail.com
	//
	// Added 4D noise
	// Joshua Koo zz85nus@gmail.com

	/**
	 * You can pass in a random number generator object if you like.
	 * It is assumed to have a random() method.
	 */
	THREE.SimplexNoise = function (r) {
	  if (r == undefined) r = Math;
	  this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];
	  this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]];
	  this.p = [];

	  for (var i = 0; i < 256; i++) {
	    this.p[i] = Math.floor(r.random() * 256);
	  } // To remove the need for index wrapping, double the permutation table length


	  this.perm = [];

	  for (var i = 0; i < 512; i++) {
	    this.perm[i] = this.p[i & 255];
	  } // A lookup table to traverse the simplex around a given point in 4D.
	  // Details can be found where this table is used, in the 4D noise method.


	  this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];
	};

	THREE.SimplexNoise.prototype.dot = function (g, x, y) {
	  return g[0] * x + g[1] * y;
	};

	THREE.SimplexNoise.prototype.dot3 = function (g, x, y, z) {
	  return g[0] * x + g[1] * y + g[2] * z;
	};

	THREE.SimplexNoise.prototype.dot4 = function (g, x, y, z, w) {
	  return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
	};

	THREE.SimplexNoise.prototype.noise = function (xin, yin) {
	  var n0, n1, n2; // Noise contributions from the three corners
	  // Skew the input space to determine which simplex cell we're in

	  var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
	  var s = (xin + yin) * F2; // Hairy factor for 2D

	  var i = Math.floor(xin + s);
	  var j = Math.floor(yin + s);
	  var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
	  var t = (i + j) * G2;
	  var X0 = i - t; // Unskew the cell origin back to (x,y) space

	  var Y0 = j - t;
	  var x0 = xin - X0; // The x,y distances from the cell origin

	  var y0 = yin - Y0; // For the 2D case, the simplex shape is an equilateral triangle.
	  // Determine which simplex we are in.

	  var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords

	  if (x0 > y0) {
	    i1 = 1;
	    j1 = 0; // lower triangle, XY order: (0,0)->(1,0)->(1,1)
	  } else {
	    i1 = 0;
	    j1 = 1;
	  } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
	  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
	  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
	  // c = (3-sqrt(3))/6


	  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords

	  var y1 = y0 - j1 + G2;
	  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords

	  var y2 = y0 - 1.0 + 2.0 * G2; // Work out the hashed gradient indices of the three simplex corners

	  var ii = i & 255;
	  var jj = j & 255;
	  var gi0 = this.perm[ii + this.perm[jj]] % 12;
	  var gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
	  var gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12; // Calculate the contribution from the three corners

	  var t0 = 0.5 - x0 * x0 - y0 * y0;
	  if (t0 < 0) n0 = 0.0;else {
	    t0 *= t0;
	    n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
	  }
	  var t1 = 0.5 - x1 * x1 - y1 * y1;
	  if (t1 < 0) n1 = 0.0;else {
	    t1 *= t1;
	    n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
	  }
	  var t2 = 0.5 - x2 * x2 - y2 * y2;
	  if (t2 < 0) n2 = 0.0;else {
	    t2 *= t2;
	    n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
	  } // Add contributions from each corner to get the final noise value.
	  // The result is scaled to return values in the interval [-1,1].

	  return 70.0 * (n0 + n1 + n2);
	}; // 3D simplex noise


	THREE.SimplexNoise.prototype.noise3d = function (xin, yin, zin) {
	  var n0, n1, n2, n3; // Noise contributions from the four corners
	  // Skew the input space to determine which simplex cell we're in

	  var F3 = 1.0 / 3.0;
	  var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D

	  var i = Math.floor(xin + s);
	  var j = Math.floor(yin + s);
	  var k = Math.floor(zin + s);
	  var G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too

	  var t = (i + j + k) * G3;
	  var X0 = i - t; // Unskew the cell origin back to (x,y,z) space

	  var Y0 = j - t;
	  var Z0 = k - t;
	  var x0 = xin - X0; // The x,y,z distances from the cell origin

	  var y0 = yin - Y0;
	  var z0 = zin - Z0; // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
	  // Determine which simplex we are in.

	  var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords

	  var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords

	  if (x0 >= y0) {
	    if (y0 >= z0) {
	      i1 = 1;
	      j1 = 0;
	      k1 = 0;
	      i2 = 1;
	      j2 = 1;
	      k2 = 0; // X Y Z order
	    } else if (x0 >= z0) {
	      i1 = 1;
	      j1 = 0;
	      k1 = 0;
	      i2 = 1;
	      j2 = 0;
	      k2 = 1; // X Z Y order
	    } else {
	      i1 = 0;
	      j1 = 0;
	      k1 = 1;
	      i2 = 1;
	      j2 = 0;
	      k2 = 1;
	    } // Z X Y order

	  } else {
	    // x0<y0
	    if (y0 < z0) {
	      i1 = 0;
	      j1 = 0;
	      k1 = 1;
	      i2 = 0;
	      j2 = 1;
	      k2 = 1; // Z Y X order
	    } else if (x0 < z0) {
	      i1 = 0;
	      j1 = 1;
	      k1 = 0;
	      i2 = 0;
	      j2 = 1;
	      k2 = 1; // Y Z X order
	    } else {
	      i1 = 0;
	      j1 = 1;
	      k1 = 0;
	      i2 = 1;
	      j2 = 1;
	      k2 = 0;
	    } // Y X Z order

	  } // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
	  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
	  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
	  // c = 1/6.


	  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords

	  var y1 = y0 - j1 + G3;
	  var z1 = z0 - k1 + G3;
	  var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords

	  var y2 = y0 - j2 + 2.0 * G3;
	  var z2 = z0 - k2 + 2.0 * G3;
	  var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords

	  var y3 = y0 - 1.0 + 3.0 * G3;
	  var z3 = z0 - 1.0 + 3.0 * G3; // Work out the hashed gradient indices of the four simplex corners

	  var ii = i & 255;
	  var jj = j & 255;
	  var kk = k & 255;
	  var gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
	  var gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
	  var gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
	  var gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12; // Calculate the contribution from the four corners

	  var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
	  if (t0 < 0) n0 = 0.0;else {
	    t0 *= t0;
	    n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
	  }
	  var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
	  if (t1 < 0) n1 = 0.0;else {
	    t1 *= t1;
	    n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
	  }
	  var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
	  if (t2 < 0) n2 = 0.0;else {
	    t2 *= t2;
	    n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);
	  }
	  var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
	  if (t3 < 0) n3 = 0.0;else {
	    t3 *= t3;
	    n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
	  } // Add contributions from each corner to get the final noise value.
	  // The result is scaled to stay just inside [-1,1]

	  return 32.0 * (n0 + n1 + n2 + n3);
	}; // 4D simplex noise


	THREE.SimplexNoise.prototype.noise4d = function (x, y, z, w) {
	  // For faster and easier lookups
	  var grad4 = this.grad4;
	  var simplex = this.simplex;
	  var perm = this.perm; // The skewing and unskewing factors are hairy again for the 4D case

	  var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
	  var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;
	  var n0, n1, n2, n3, n4; // Noise contributions from the five corners
	  // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in

	  var s = (x + y + z + w) * F4; // Factor for 4D skewing

	  var i = Math.floor(x + s);
	  var j = Math.floor(y + s);
	  var k = Math.floor(z + s);
	  var l = Math.floor(w + s);
	  var t = (i + j + k + l) * G4; // Factor for 4D unskewing

	  var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space

	  var Y0 = j - t;
	  var Z0 = k - t;
	  var W0 = l - t;
	  var x0 = x - X0; // The x,y,z,w distances from the cell origin

	  var y0 = y - Y0;
	  var z0 = z - Z0;
	  var w0 = w - W0; // For the 4D case, the simplex is a 4D shape I won't even try to describe.
	  // To find out which of the 24 possible simplices we're in, we need to
	  // determine the magnitude ordering of x0, y0, z0 and w0.
	  // The method below is a good way of finding the ordering of x,y,z,w and
	  // then find the correct traversal order for the simplex we’re in.
	  // First, six pair-wise comparisons are performed between each possible pair
	  // of the four coordinates, and the results are used to add up binary bits
	  // for an integer index.

	  var c1 = x0 > y0 ? 32 : 0;
	  var c2 = x0 > z0 ? 16 : 0;
	  var c3 = y0 > z0 ? 8 : 0;
	  var c4 = x0 > w0 ? 4 : 0;
	  var c5 = y0 > w0 ? 2 : 0;
	  var c6 = z0 > w0 ? 1 : 0;
	  var c = c1 + c2 + c3 + c4 + c5 + c6;
	  var i1, j1, k1, l1; // The integer offsets for the second simplex corner

	  var i2, j2, k2, l2; // The integer offsets for the third simplex corner

	  var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
	  // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
	  // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
	  // impossible. Only the 24 indices which have non-zero entries make any sense.
	  // We use a thresholding to set the coordinates in turn from the largest magnitude.
	  // The number 3 in the "simplex" array is at the position of the largest coordinate.

	  i1 = simplex[c][0] >= 3 ? 1 : 0;
	  j1 = simplex[c][1] >= 3 ? 1 : 0;
	  k1 = simplex[c][2] >= 3 ? 1 : 0;
	  l1 = simplex[c][3] >= 3 ? 1 : 0; // The number 2 in the "simplex" array is at the second largest coordinate.

	  i2 = simplex[c][0] >= 2 ? 1 : 0;
	  j2 = simplex[c][1] >= 2 ? 1 : 0;
	  k2 = simplex[c][2] >= 2 ? 1 : 0;
	  l2 = simplex[c][3] >= 2 ? 1 : 0; // The number 1 in the "simplex" array is at the second smallest coordinate.

	  i3 = simplex[c][0] >= 1 ? 1 : 0;
	  j3 = simplex[c][1] >= 1 ? 1 : 0;
	  k3 = simplex[c][2] >= 1 ? 1 : 0;
	  l3 = simplex[c][3] >= 1 ? 1 : 0; // The fifth corner has all coordinate offsets = 1, so no need to look that up.

	  var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords

	  var y1 = y0 - j1 + G4;
	  var z1 = z0 - k1 + G4;
	  var w1 = w0 - l1 + G4;
	  var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords

	  var y2 = y0 - j2 + 2.0 * G4;
	  var z2 = z0 - k2 + 2.0 * G4;
	  var w2 = w0 - l2 + 2.0 * G4;
	  var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords

	  var y3 = y0 - j3 + 3.0 * G4;
	  var z3 = z0 - k3 + 3.0 * G4;
	  var w3 = w0 - l3 + 3.0 * G4;
	  var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords

	  var y4 = y0 - 1.0 + 4.0 * G4;
	  var z4 = z0 - 1.0 + 4.0 * G4;
	  var w4 = w0 - 1.0 + 4.0 * G4; // Work out the hashed gradient indices of the five simplex corners

	  var ii = i & 255;
	  var jj = j & 255;
	  var kk = k & 255;
	  var ll = l & 255;
	  var gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
	  var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
	  var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
	  var gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
	  var gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32; // Calculate the contribution from the five corners

	  var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
	  if (t0 < 0) n0 = 0.0;else {
	    t0 *= t0;
	    n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);
	  }
	  var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
	  if (t1 < 0) n1 = 0.0;else {
	    t1 *= t1;
	    n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);
	  }
	  var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
	  if (t2 < 0) n2 = 0.0;else {
	    t2 *= t2;
	    n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);
	  }
	  var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
	  if (t3 < 0) n3 = 0.0;else {
	    t3 *= t3;
	    n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);
	  }
	  var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
	  if (t4 < 0) n4 = 0.0;else {
	    t4 *= t4;
	    n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);
	  } // Sum up and scale the result to cover the range [-1,1]

	  return 27.0 * (n0 + n1 + n2 + n3 + n4);
	};

	THREE.ImprovedNoise = function () {
	  var p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];

	  for (var i = 0; i < 256; i++) {
	    p[256 + i] = p[i];
	  }

	  function fade(t) {
	    return t * t * t * (t * (t * 6 - 15) + 10);
	  }

	  function lerp(t, a, b) {
	    return a + t * (b - a);
	  }

	  function grad(hash, x, y, z) {
	    var h = hash & 15;
	    var u = h < 8 ? x : y,
	        v = h < 4 ? y : h == 12 || h == 14 ? x : z;
	    return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
	  }

	  return {
	    noise: function (x, y, z) {
	      var floorX = Math.floor(x),
	          floorY = Math.floor(y),
	          floorZ = Math.floor(z);
	      var X = floorX & 255,
	          Y = floorY & 255,
	          Z = floorZ & 255;
	      x -= floorX;
	      y -= floorY;
	      z -= floorZ;
	      var xMinus1 = x - 1,
	          yMinus1 = y - 1,
	          zMinus1 = z - 1;
	      var u = fade(x),
	          v = fade(y),
	          w = fade(z);
	      var A = p[X] + Y,
	          AA = p[A] + Z,
	          AB = p[A + 1] + Z,
	          B = p[X + 1] + Y,
	          BA = p[B] + Z,
	          BB = p[B + 1] + Z;
	      return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], xMinus1, y, z)), lerp(u, grad(p[AB], x, yMinus1, z), grad(p[BB], xMinus1, yMinus1, z))), lerp(v, lerp(u, grad(p[AA + 1], x, y, zMinus1), grad(p[BA + 1], xMinus1, y, z - 1)), lerp(u, grad(p[AB + 1], x, yMinus1, zMinus1), grad(p[BB + 1], xMinus1, yMinus1, zMinus1))));
	    }
	  };
	};

	THREE.TGALoader = function (manager) {
	  THREE.Loader.call(this, manager);
	};

	THREE.TGALoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {
	  constructor: THREE.TGALoader,
	  load: function (url, onLoad, onProgress, onError) {
	    var scope = this;
	    var texture = new THREE.Texture();
	    var loader = new THREE.FileLoader(this.manager);
	    loader.setResponseType('arraybuffer');
	    loader.setPath(this.path);
	    loader.load(url, function (buffer) {
	      texture.image = scope.parse(buffer);
	      texture.needsUpdate = true;

	      if (onLoad !== undefined) {
	        onLoad(texture);
	      }
	    }, onProgress, onError);
	    return texture;
	  },
	  parse: function (buffer) {
	    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js
	    function tgaCheckHeader(header) {
	      switch (header.image_type) {
	        // check indexed type
	        case TGA_TYPE_INDEXED:
	        case TGA_TYPE_RLE_INDEXED:
	          if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {
	            console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');
	          }

	          break;
	        // check colormap type

	        case TGA_TYPE_RGB:
	        case TGA_TYPE_GREY:
	        case TGA_TYPE_RLE_RGB:
	        case TGA_TYPE_RLE_GREY:
	          if (header.colormap_type) {
	            console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');
	          }

	          break;
	        // What the need of a file without data ?

	        case TGA_TYPE_NO_DATA:
	          console.error('THREE.TGALoader: No data.');
	        // Invalid type ?

	        default:
	          console.error('THREE.TGALoader: Invalid type "%s".', header.image_type);
	      } // check image width and height


	      if (header.width <= 0 || header.height <= 0) {
	        console.error('THREE.TGALoader: Invalid image size.');
	      } // check image pixel size


	      if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {
	        console.error('THREE.TGALoader: Invalid pixel size "%s".', header.pixel_size);
	      }
	    } // parse tga image buffer


	    function tgaParse(use_rle, use_pal, header, offset, data) {
	      var pixel_data, pixel_size, pixel_total, palettes;
	      pixel_size = header.pixel_size >> 3;
	      pixel_total = header.width * header.height * pixel_size; // read palettes

	      if (use_pal) {
	        palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));
	      } // read RLE


	      if (use_rle) {
	        pixel_data = new Uint8Array(pixel_total);
	        var c, count, i;
	        var shift = 0;
	        var pixels = new Uint8Array(pixel_size);

	        while (shift < pixel_total) {
	          c = data[offset++];
	          count = (c & 0x7f) + 1; // RLE pixels

	          if (c & 0x80) {
	            // bind pixel tmp array
	            for (i = 0; i < pixel_size; ++i) {
	              pixels[i] = data[offset++];
	            } // copy pixel array


	            for (i = 0; i < count; ++i) {
	              pixel_data.set(pixels, shift + i * pixel_size);
	            }

	            shift += pixel_size * count;
	          } else {
	            // raw pixels
	            count *= pixel_size;

	            for (i = 0; i < count; ++i) {
	              pixel_data[shift + i] = data[offset++];
	            }

	            shift += count;
	          }
	        }
	      } else {
	        // raw pixels
	        pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);
	      }

	      return {
	        pixel_data: pixel_data,
	        palettes: palettes
	      };
	    }

	    function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {
	      var colormap = palettes;
	      var color,
	          i = 0,
	          x,
	          y;
	      var width = header.width;

	      for (y = y_start; y !== y_end; y += y_step) {
	        for (x = x_start; x !== x_end; x += x_step, i++) {
	          color = image[i];
	          imageData[(x + width * y) * 4 + 3] = 255;
	          imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];
	          imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];
	          imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];
	        }
	      }

	      return imageData;
	    }

	    function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
	      var color,
	          i = 0,
	          x,
	          y;
	      var width = header.width;

	      for (y = y_start; y !== y_end; y += y_step) {
	        for (x = x_start; x !== x_end; x += x_step, i += 2) {
	          color = image[i + 0] + (image[i + 1] << 8); // Inversed ?

	          imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;
	          imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;
	          imageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;
	          imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;
	        }
	      }

	      return imageData;
	    }

	    function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
	      var i = 0,
	          x,
	          y;
	      var width = header.width;

	      for (y = y_start; y !== y_end; y += y_step) {
	        for (x = x_start; x !== x_end; x += x_step, i += 3) {
	          imageData[(x + width * y) * 4 + 3] = 255;
	          imageData[(x + width * y) * 4 + 2] = image[i + 0];
	          imageData[(x + width * y) * 4 + 1] = image[i + 1];
	          imageData[(x + width * y) * 4 + 0] = image[i + 2];
	        }
	      }

	      return imageData;
	    }

	    function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
	      var i = 0,
	          x,
	          y;
	      var width = header.width;

	      for (y = y_start; y !== y_end; y += y_step) {
	        for (x = x_start; x !== x_end; x += x_step, i += 4) {
	          imageData[(x + width * y) * 4 + 2] = image[i + 0];
	          imageData[(x + width * y) * 4 + 1] = image[i + 1];
	          imageData[(x + width * y) * 4 + 0] = image[i + 2];
	          imageData[(x + width * y) * 4 + 3] = image[i + 3];
	        }
	      }

	      return imageData;
	    }

	    function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
	      var color,
	          i = 0,
	          x,
	          y;
	      var width = header.width;

	      for (y = y_start; y !== y_end; y += y_step) {
	        for (x = x_start; x !== x_end; x += x_step, i++) {
	          color = image[i];
	          imageData[(x + width * y) * 4 + 0] = color;
	          imageData[(x + width * y) * 4 + 1] = color;
	          imageData[(x + width * y) * 4 + 2] = color;
	          imageData[(x + width * y) * 4 + 3] = 255;
	        }
	      }

	      return imageData;
	    }

	    function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {
	      var i = 0,
	          x,
	          y;
	      var width = header.width;

	      for (y = y_start; y !== y_end; y += y_step) {
	        for (x = x_start; x !== x_end; x += x_step, i += 2) {
	          imageData[(x + width * y) * 4 + 0] = image[i + 0];
	          imageData[(x + width * y) * 4 + 1] = image[i + 0];
	          imageData[(x + width * y) * 4 + 2] = image[i + 0];
	          imageData[(x + width * y) * 4 + 3] = image[i + 1];
	        }
	      }

	      return imageData;
	    }

	    function getTgaRGBA(data, width, height, image, palette) {
	      var x_start, y_start, x_step, y_step, x_end, y_end;

	      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {
	        default:
	        case TGA_ORIGIN_UL:
	          x_start = 0;
	          x_step = 1;
	          x_end = width;
	          y_start = 0;
	          y_step = 1;
	          y_end = height;
	          break;

	        case TGA_ORIGIN_BL:
	          x_start = 0;
	          x_step = 1;
	          x_end = width;
	          y_start = height - 1;
	          y_step = -1;
	          y_end = -1;
	          break;

	        case TGA_ORIGIN_UR:
	          x_start = width - 1;
	          x_step = -1;
	          x_end = -1;
	          y_start = 0;
	          y_step = 1;
	          y_end = height;
	          break;

	        case TGA_ORIGIN_BR:
	          x_start = width - 1;
	          x_step = -1;
	          x_end = -1;
	          y_start = height - 1;
	          y_step = -1;
	          y_end = -1;
	          break;
	      }

	      if (use_grey) {
	        switch (header.pixel_size) {
	          case 8:
	            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
	            break;

	          case 16:
	            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
	            break;

	          default:
	            console.error('THREE.TGALoader: Format not supported.');
	            break;
	        }
	      } else {
	        switch (header.pixel_size) {
	          case 8:
	            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);
	            break;

	          case 16:
	            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
	            break;

	          case 24:
	            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
	            break;

	          case 32:
	            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);
	            break;

	          default:
	            console.error('THREE.TGALoader: Format not supported.');
	            break;
	        }
	      } // Load image data according to specific method
	      // var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
	      // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );


	      return data;
	    } // TGA constants


	    var TGA_TYPE_NO_DATA = 0,
	        TGA_TYPE_INDEXED = 1,
	        TGA_TYPE_RGB = 2,
	        TGA_TYPE_GREY = 3,
	        TGA_TYPE_RLE_INDEXED = 9,
	        TGA_TYPE_RLE_RGB = 10,
	        TGA_TYPE_RLE_GREY = 11,
	        TGA_ORIGIN_MASK = 0x30,
	        TGA_ORIGIN_SHIFT = 0x04,
	        TGA_ORIGIN_BL = 0x00,
	        TGA_ORIGIN_BR = 0x01,
	        TGA_ORIGIN_UL = 0x02,
	        TGA_ORIGIN_UR = 0x03;
	    if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');
	    var content = new Uint8Array(buffer),
	        offset = 0,
	        header = {
	      id_length: content[offset++],
	      colormap_type: content[offset++],
	      image_type: content[offset++],
	      colormap_index: content[offset++] | content[offset++] << 8,
	      colormap_length: content[offset++] | content[offset++] << 8,
	      colormap_size: content[offset++],
	      origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],
	      width: content[offset++] | content[offset++] << 8,
	      height: content[offset++] | content[offset++] << 8,
	      pixel_size: content[offset++],
	      flags: content[offset++]
	    }; // check tga if it is valid format

	    tgaCheckHeader(header);

	    if (header.id_length + offset > buffer.length) {
	      console.error('THREE.TGALoader: No data.');
	    } // skip the needn't data


	    offset += header.id_length; // get targa information about RLE compression and palette

	    var use_rle = false,
	        use_pal = false,
	        use_grey = false;

	    switch (header.image_type) {
	      case TGA_TYPE_RLE_INDEXED:
	        use_rle = true;
	        use_pal = true;
	        break;

	      case TGA_TYPE_INDEXED:
	        use_pal = true;
	        break;

	      case TGA_TYPE_RLE_RGB:
	        use_rle = true;
	        break;

	      case TGA_TYPE_RGB:
	        break;

	      case TGA_TYPE_RLE_GREY:
	        use_rle = true;
	        use_grey = true;
	        break;

	      case TGA_TYPE_GREY:
	        use_grey = true;
	        break;
	    } //


	    var useOffscreen = typeof OffscreenCanvas !== 'undefined';
	    var canvas = useOffscreen ? new OffscreenCanvas(header.width, header.height) : document.createElement('canvas');
	    canvas.width = header.width;
	    canvas.height = header.height;
	    var context = canvas.getContext('2d');
	    var imageData = context.createImageData(header.width, header.height);
	    var result = tgaParse(use_rle, use_pal, header, offset, content);
	    var rgbaData = getTgaRGBA(imageData.data, header.width, header.height, result.pixel_data, result.palettes);
	    context.putImageData(imageData, 0, 0);
	    return useOffscreen ? canvas.transferToImageBitmap() : canvas;
	  }
	});

	THREE.GPUComputationRenderer = function (sizeX, sizeY, renderer) {
	  this.variables = [];
	  this.currentTextureIndex = 0;
	  var scene = new THREE.Scene();
	  var camera = new THREE.Camera();
	  camera.position.z = 1;
	  var passThruUniforms = {
	    passThruTexture: {
	      value: null
	    }
	  };
	  var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);
	  var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), passThruShader);
	  scene.add(mesh);

	  this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {
	    var material = this.createShaderMaterial(computeFragmentShader);
	    var variable = {
	      name: variableName,
	      initialValueTexture: initialValueTexture,
	      material: material,
	      dependencies: null,
	      renderTargets: [],
	      wrapS: null,
	      wrapT: null,
	      minFilter: THREE.NearestFilter,
	      magFilter: THREE.NearestFilter
	    };
	    this.variables.push(variable);
	    return variable;
	  };

	  this.setVariableDependencies = function (variable, dependencies) {
	    variable.dependencies = dependencies;
	  };

	  this.init = function () {
	    if (!renderer.capabilities.isWebGL2 && !renderer.extensions.get("OES_texture_float")) {
	      return "No OES_texture_float support for float textures.";
	    }

	    if (renderer.capabilities.maxVertexTextures === 0) {
	      return "No support for vertex shader textures.";
	    }

	    for (var i = 0; i < this.variables.length; i++) {
	      var variable = this.variables[i]; // Creates rendertargets and initialize them with input texture

	      variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
	      variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);
	      this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);
	      this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]); // Adds dependencies uniforms to the ShaderMaterial

	      var material = variable.material;
	      var uniforms = material.uniforms;

	      if (variable.dependencies !== null) {
	        for (var d = 0; d < variable.dependencies.length; d++) {
	          var depVar = variable.dependencies[d];

	          if (depVar.name !== variable.name) {
	            // Checks if variable exists
	            var found = false;

	            for (var j = 0; j < this.variables.length; j++) {
	              if (depVar.name === this.variables[j].name) {
	                found = true;
	                break;
	              }
	            }

	            if (!found) {
	              return "Variable dependency not found. Variable=" + variable.name + ", dependency=" + depVar.name;
	            }
	          }

	          uniforms[depVar.name] = {
	            value: null
	          };
	          material.fragmentShader = "\nuniform sampler2D " + depVar.name + ";\n" + material.fragmentShader;
	        }
	      }
	    }

	    this.currentTextureIndex = 0;
	    return null;
	  };

	  this.compute = function () {
	    var currentTextureIndex = this.currentTextureIndex;
	    var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;

	    for (var i = 0, il = this.variables.length; i < il; i++) {
	      var variable = this.variables[i]; // Sets texture dependencies uniforms

	      if (variable.dependencies !== null) {
	        var uniforms = variable.material.uniforms;

	        for (var d = 0, dl = variable.dependencies.length; d < dl; d++) {
	          var depVar = variable.dependencies[d];
	          uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;
	        }
	      } // Performs the computation for this variable


	      this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);
	    }

	    this.currentTextureIndex = nextTextureIndex;
	  };

	  this.getCurrentRenderTarget = function (variable) {
	    return variable.renderTargets[this.currentTextureIndex];
	  };

	  this.getAlternateRenderTarget = function (variable) {
	    return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
	  };

	  function addResolutionDefine(materialShader) {
	    materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed(1) + ', ' + sizeY.toFixed(1) + " )";
	  }

	  this.addResolutionDefine = addResolutionDefine; // The following functions can be used to compute things manually

	  function createShaderMaterial(computeFragmentShader, uniforms) {
	    uniforms = uniforms || {};
	    var material = new THREE.ShaderMaterial({
	      uniforms: uniforms,
	      vertexShader: getPassThroughVertexShader(),
	      fragmentShader: computeFragmentShader
	    });
	    addResolutionDefine(material);
	    return material;
	  }

	  this.createShaderMaterial = createShaderMaterial;

	  this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {
	    sizeXTexture = sizeXTexture || sizeX;
	    sizeYTexture = sizeYTexture || sizeY;
	    wrapS = wrapS || THREE.ClampToEdgeWrapping;
	    wrapT = wrapT || THREE.ClampToEdgeWrapping;
	    minFilter = minFilter || THREE.NearestFilter;
	    magFilter = magFilter || THREE.NearestFilter;
	    var renderTarget = new THREE.WebGLRenderTarget(sizeXTexture, sizeYTexture, {
	      wrapS: wrapS,
	      wrapT: wrapT,
	      minFilter: minFilter,
	      magFilter: magFilter,
	      format: THREE.RGBAFormat,
	      type: /(iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType,
	      stencilBuffer: false,
	      depthBuffer: false
	    });
	    return renderTarget;
	  };

	  this.createTexture = function () {
	    var data = new Float32Array(sizeX * sizeY * 4);
	    return new THREE.DataTexture(data, sizeX, sizeY, THREE.RGBAFormat, THREE.FloatType);
	  };

	  this.renderTexture = function (input, output) {
	    // Takes a texture, and render out in rendertarget
	    // input = Texture
	    // output = RenderTarget
	    passThruUniforms.passThruTexture.value = input;
	    this.doRenderTarget(passThruShader, output);
	    passThruUniforms.passThruTexture.value = null;
	  };

	  this.doRenderTarget = function (material, output) {
	    var currentRenderTarget = renderer.getRenderTarget();
	    mesh.material = material;
	    renderer.setRenderTarget(output);
	    renderer.render(scene, camera);
	    mesh.material = passThruShader;
	    renderer.setRenderTarget(currentRenderTarget);
	  }; // Shaders


	  function getPassThroughVertexShader() {
	    return "void main()	{\n" + "\n" + "	gl_Position = vec4( position, 1.0 );\n" + "\n" + "}\n";
	  }

	  function getPassThroughFragmentShader() {
	    return "uniform sampler2D passThruTexture;\n" + "\n" + "void main() {\n" + "\n" + "	vec2 uv = gl_FragCoord.xy / resolution.xy;\n" + "\n" + "	gl_FragColor = texture2D( passThruTexture, uv );\n" + "\n" + "}\n";
	  }
	};

	THREE.Sky = function () {
	  var shader = THREE.Sky.SkyShader;
	  var material = new THREE.ShaderMaterial({
	    fragmentShader: shader.fragmentShader,
	    vertexShader: shader.vertexShader,
	    uniforms: THREE.UniformsUtils.clone(shader.uniforms),
	    side: THREE.BackSide
	  });
	  THREE.Mesh.call(this, new THREE.BoxBufferGeometry(1, 1, 1), material);
	};

	THREE.Sky.prototype = Object.create(THREE.Mesh.prototype);
	THREE.Sky.SkyShader = {
	  uniforms: {
	    "luminance": {
	      value: 1
	    },
	    "turbidity": {
	      value: 2
	    },
	    "rayleigh": {
	      value: 1
	    },
	    "mieCoefficient": {
	      value: 0.005
	    },
	    "mieDirectionalG": {
	      value: 0.8
	    },
	    "sunPosition": {
	      value: new THREE.Vector3()
	    },
	    "up": {
	      value: new THREE.Vector3(0, 1, 0)
	    }
	  },
	  vertexShader: ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', // constants for atmospheric scattering
	  'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', // wavelength of used primaries, according to preetham
	  'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );', // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
	  // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
	  'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );', // mie stuff
	  // K coefficient for the primaries
	  'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );', // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
	  'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );', // earth shadow hack
	  // cutoffAngle = pi / 1.95;
	  'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '	float c = ( 0.2 * T ) * 10E-18;', '	return 0.434 * c * MieConst;', '}', 'void main() {', '	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '	vWorldPosition = worldPosition.xyz;', '	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '	gl_Position.z = gl_Position.w;', // set z to camera.far
	  '	vSunDirection = normalize( sunPosition );', '	vSunE = sunIntensity( dot( vSunDirection, up ) );', '	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );', // extinction (absorbtion + out scattering)
	  // rayleigh coefficients
	  '	vBetaR = totalRayleigh * rayleighCoefficient;', // mie coefficients
	  '	vBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\n'),
	  fragmentShader: ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float luminance;', 'uniform float mieDirectionalG;', 'uniform vec3 up;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );', // constants for atmospheric scattering
	  'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air
	  'const float N = 2.545E25;', // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)
	  // optical length at zenith for molecules
	  'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', // 66 arc seconds -> degrees, and the cosine of that
	  'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', // 3.0 / ( 16.0 * pi )
	  'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;', // 1.0 / ( 4.0 * pi )
	  'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '	float g2 = pow( g, 2.0 );', '	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}', // Filmic ToneMapping http://filmicgames.com/archives/75
	  'const float A = 0.15;', 'const float B = 0.50;', 'const float C = 0.10;', 'const float D = 0.20;', 'const float E = 0.02;', 'const float F = 0.30;', 'const float whiteScale = 1.0748724675633854;', // 1.0 / Uncharted2Tonemap(1000.0)
	  'vec3 Uncharted2Tonemap( vec3 x ) {', '	return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;', '}', 'void main() {', // optical length
	  // cutoff angle at 90 to avoid singularity in next formula.
	  '	float zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );', '	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '	float sR = rayleighZenithLength * inverse;', '	float sM = mieZenithLength * inverse;', // combined extinction factor
	  '	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );', // in scattering
	  '	float cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );', '	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '	vec3 betaRTheta = vBetaR * rPhase;', '	float mPhase = hgPhase( cosTheta, mieDirectionalG );', '	vec3 betaMTheta = vBetaM * mPhase;', '	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );', // nightsky
	  '	vec3 direction = normalize( vWorldPosition - cameraPos );', '	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]', '	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]', '	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '	vec3 L0 = vec3( 0.1 ) * Fex;', // composition + solar disc
	  '	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );', '	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;', '	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );', '	vec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );', '	vec3 color = curr * whiteScale;', '	vec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '	gl_FragColor = vec4( retColor, 1.0 );', '}'].join('\n')
	};

	THREE.Reflector = function (geometry, options) {
	  THREE.Mesh.call(this, geometry);
	  this.type = 'Reflector';
	  var scope = this;
	  options = options || {};
	  var color = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(0x7F7F7F);
	  var textureWidth = options.textureWidth || 512;
	  var textureHeight = options.textureHeight || 512;
	  var clipBias = options.clipBias || 0;
	  var shader = options.shader || THREE.Reflector.ReflectorShader;
	  var recursion = options.recursion !== undefined ? options.recursion : 0; //

	  var reflectorPlane = new THREE.Plane();
	  var normal = new THREE.Vector3();
	  var reflectorWorldPosition = new THREE.Vector3();
	  var cameraWorldPosition = new THREE.Vector3();
	  var rotationMatrix = new THREE.Matrix4();
	  var lookAtPosition = new THREE.Vector3(0, 0, -1);
	  var clipPlane = new THREE.Vector4();
	  var view = new THREE.Vector3();
	  var target = new THREE.Vector3();
	  var q = new THREE.Vector4();
	  var textureMatrix = new THREE.Matrix4();
	  var virtualCamera = new THREE.PerspectiveCamera();
	  var parameters = {
	    minFilter: THREE.LinearFilter,
	    magFilter: THREE.LinearFilter,
	    format: THREE.RGBFormat,
	    stencilBuffer: false
	  };
	  var renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);

	  if (!THREE.MathUtils.isPowerOfTwo(textureWidth) || !THREE.MathUtils.isPowerOfTwo(textureHeight)) {
	    renderTarget.texture.generateMipmaps = false;
	  }

	  var material = new THREE.ShaderMaterial({
	    uniforms: THREE.UniformsUtils.clone(shader.uniforms),
	    fragmentShader: shader.fragmentShader,
	    vertexShader: shader.vertexShader
	  });
	  material.uniforms["tDiffuse"].value = renderTarget.texture;
	  material.uniforms["color"].value = color;
	  material.uniforms["textureMatrix"].value = textureMatrix;
	  this.material = material;

	  this.onBeforeRender = function (renderer, scene, camera) {
	    if ('recursion' in camera.userData) {
	      if (camera.userData.recursion === recursion) return;
	      camera.userData.recursion++;
	    }

	    reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
	    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
	    rotationMatrix.extractRotation(scope.matrixWorld);
	    normal.set(0, 0, 1);
	    normal.applyMatrix4(rotationMatrix);
	    view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away

	    if (view.dot(normal) > 0) return;
	    view.reflect(normal).negate();
	    view.add(reflectorWorldPosition);
	    rotationMatrix.extractRotation(camera.matrixWorld);
	    lookAtPosition.set(0, 0, -1);
	    lookAtPosition.applyMatrix4(rotationMatrix);
	    lookAtPosition.add(cameraWorldPosition);
	    target.subVectors(reflectorWorldPosition, lookAtPosition);
	    target.reflect(normal).negate();
	    target.add(reflectorWorldPosition);
	    virtualCamera.position.copy(view);
	    virtualCamera.up.set(0, 1, 0);
	    virtualCamera.up.applyMatrix4(rotationMatrix);
	    virtualCamera.up.reflect(normal);
	    virtualCamera.lookAt(target);
	    virtualCamera.far = camera.far; // Used in WebGLBackground

	    virtualCamera.updateMatrixWorld();
	    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
	    virtualCamera.userData.recursion = 0; // Update the texture matrix

	    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
	    textureMatrix.multiply(virtualCamera.projectionMatrix);
	    textureMatrix.multiply(virtualCamera.matrixWorldInverse);
	    textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
	    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf

	    reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
	    reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
	    clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
	    var projectionMatrix = virtualCamera.projectionMatrix;
	    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
	    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
	    q.z = -1.0;
	    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector

	    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix

	    projectionMatrix.elements[2] = clipPlane.x;
	    projectionMatrix.elements[6] = clipPlane.y;
	    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;
	    projectionMatrix.elements[14] = clipPlane.w; // Render

	    scope.visible = false;
	    var currentRenderTarget = renderer.getRenderTarget();
	    var currentXrEnabled = renderer.xr.enabled;
	    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
	    renderer.xr.enabled = false; // Avoid camera modification and recursion

	    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows

	    renderer.setRenderTarget(renderTarget);
	    renderer.clear();
	    renderer.render(scene, virtualCamera);
	    renderer.xr.enabled = currentXrEnabled;
	    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
	    renderer.setRenderTarget(currentRenderTarget); // Restore viewport

	    var viewport = camera.viewport;

	    if (viewport !== undefined) {
	      renderer.state.viewport(viewport);
	    }

	    scope.visible = true;
	  };

	  this.getRenderTarget = function () {
	    return renderTarget;
	  };
	};

	THREE.Reflector.prototype = Object.create(THREE.Mesh.prototype);
	THREE.Reflector.prototype.constructor = THREE.Reflector;
	THREE.Reflector.ReflectorShader = {
	  uniforms: {
	    'color': {
	      value: null
	    },
	    'tDiffuse': {
	      value: null
	    },
	    'textureMatrix': {
	      value: null
	    }
	  },
	  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '	vUv = textureMatrix * vec4( position, 1.0 );', '	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\n'),
	  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '	vec4 base = texture2DProj( tDiffuse, vUv );', '	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\n')
	};

	THREE.Lensflare = function () {
	  THREE.Mesh.call(this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial({
	    opacity: 0,
	    transparent: true
	  }));
	  this.type = 'Lensflare';
	  this.frustumCulled = false;
	  this.renderOrder = Infinity; //

	  var positionScreen = new THREE.Vector3();
	  var positionView = new THREE.Vector3(); // textures

	  var tempMap = new THREE.DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, THREE.RGBFormat);
	  tempMap.minFilter = THREE.NearestFilter;
	  tempMap.magFilter = THREE.NearestFilter;
	  tempMap.wrapS = THREE.ClampToEdgeWrapping;
	  tempMap.wrapT = THREE.ClampToEdgeWrapping;
	  var occlusionMap = new THREE.DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, THREE.RGBFormat);
	  occlusionMap.minFilter = THREE.NearestFilter;
	  occlusionMap.magFilter = THREE.NearestFilter;
	  occlusionMap.wrapS = THREE.ClampToEdgeWrapping;
	  occlusionMap.wrapT = THREE.ClampToEdgeWrapping; // material

	  var geometry = THREE.Lensflare.Geometry;
	  var material1a = new THREE.RawShaderMaterial({
	    uniforms: {
	      'scale': {
	        value: null
	      },
	      'screenPosition': {
	        value: null
	      }
	    },
	    vertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'attribute vec3 position;', 'void main() {', '	gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );', '}'].join('\n'),
	    fragmentShader: ['precision highp float;', 'void main() {', '	gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );', '}'].join('\n'),
	    depthTest: true,
	    depthWrite: false,
	    transparent: false
	  });
	  var material1b = new THREE.RawShaderMaterial({
	    uniforms: {
	      'map': {
	        value: tempMap
	      },
	      'scale': {
	        value: null
	      },
	      'screenPosition': {
	        value: null
	      }
	    },
	    vertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'attribute vec3 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', '	vUV = uv;', '	gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );', '}'].join('\n'),
	    fragmentShader: ['precision highp float;', 'uniform sampler2D map;', 'varying vec2 vUV;', 'void main() {', '	gl_FragColor = texture2D( map, vUV );', '}'].join('\n'),
	    depthTest: false,
	    depthWrite: false,
	    transparent: false
	  }); // the following object is used for occlusionMap generation

	  var mesh1 = new THREE.Mesh(geometry, material1a); //

	  var elements = [];
	  var shader = THREE.LensflareElement.Shader;
	  var material2 = new THREE.RawShaderMaterial({
	    uniforms: {
	      'map': {
	        value: null
	      },
	      'occlusionMap': {
	        value: occlusionMap
	      },
	      'color': {
	        value: new THREE.Color(0xffffff)
	      },
	      'scale': {
	        value: new THREE.Vector2()
	      },
	      'screenPosition': {
	        value: new THREE.Vector3()
	      }
	    },
	    vertexShader: shader.vertexShader,
	    fragmentShader: shader.fragmentShader,
	    blending: THREE.AdditiveBlending,
	    transparent: true,
	    depthWrite: false
	  });
	  var mesh2 = new THREE.Mesh(geometry, material2);

	  this.addElement = function (element) {
	    elements.push(element);
	  }; //


	  var scale = new THREE.Vector2();
	  var screenPositionPixels = new THREE.Vector2();
	  var validArea = new THREE.Box2();
	  var viewport = new THREE.Vector4();

	  this.onBeforeRender = function (renderer, scene, camera) {
	    renderer.getCurrentViewport(viewport);
	    var invAspect = viewport.w / viewport.z;
	    var halfViewportWidth = viewport.z / 2.0;
	    var halfViewportHeight = viewport.w / 2.0;
	    var size = 16 / viewport.w;
	    scale.set(size * invAspect, size);
	    validArea.min.set(viewport.x, viewport.y);
	    validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16)); // calculate position in screen space

	    positionView.setFromMatrixPosition(this.matrixWorld);
	    positionView.applyMatrix4(camera.matrixWorldInverse);
	    if (positionView.z > 0) return; // lensflare is behind the camera

	    positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix); // horizontal and vertical coordinate of the lower left corner of the pixels to copy

	    screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;
	    screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8; // screen cull

	    if (validArea.containsPoint(screenPositionPixels)) {
	      // save current RGB to temp texture
	      renderer.copyFramebufferToTexture(screenPositionPixels, tempMap); // render pink quad

	      var uniforms = material1a.uniforms;
	      uniforms["scale"].value = scale;
	      uniforms["screenPosition"].value = positionScreen;
	      renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null); // copy result to occlusionMap

	      renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap); // restore graphics

	      var uniforms = material1b.uniforms;
	      uniforms["scale"].value = scale;
	      uniforms["screenPosition"].value = positionScreen;
	      renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null); // render elements

	      var vecX = -positionScreen.x * 2;
	      var vecY = -positionScreen.y * 2;

	      for (var i = 0, l = elements.length; i < l; i++) {
	        var element = elements[i];
	        var uniforms = material2.uniforms;
	        uniforms["color"].value.copy(element.color);
	        uniforms["map"].value = element.texture;
	        uniforms["screenPosition"].value.x = positionScreen.x + vecX * element.distance;
	        uniforms["screenPosition"].value.y = positionScreen.y + vecY * element.distance;
	        var size = element.size / viewport.w;
	        var invAspect = viewport.w / viewport.z;
	        uniforms["scale"].value.set(size * invAspect, size);
	        material2.uniformsNeedUpdate = true;
	        renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);
	      }
	    }
	  };

	  this.dispose = function () {
	    material1a.dispose();
	    material1b.dispose();
	    material2.dispose();
	    tempMap.dispose();
	    occlusionMap.dispose();

	    for (var i = 0, l = elements.length; i < l; i++) {
	      elements[i].texture.dispose();
	    }
	  };
	};

	THREE.Lensflare.prototype = Object.create(THREE.Mesh.prototype);
	THREE.Lensflare.prototype.constructor = THREE.Lensflare;
	THREE.Lensflare.prototype.isLensflare = true; //

	THREE.LensflareElement = function (texture, size, distance, color) {
	  this.texture = texture;
	  this.size = size || 1;
	  this.distance = distance || 0;
	  this.color = color || new THREE.Color(0xffffff);
	};

	THREE.LensflareElement.Shader = {
	  uniforms: {
	    'map': {
	      value: null
	    },
	    'occlusionMap': {
	      value: null
	    },
	    'color': {
	      value: null
	    },
	    'scale': {
	      value: null
	    },
	    'screenPosition': {
	      value: null
	    }
	  },
	  vertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'uniform sampler2D occlusionMap;', 'attribute vec3 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'varying float vVisibility;', 'void main() {', '	vUV = uv;', '	vec2 pos = position.xy;', '	vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );', '	visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );', '	vVisibility =        visibility.r / 9.0;', '	vVisibility *= 1.0 - visibility.g / 9.0;', '	vVisibility *=       visibility.b / 9.0;', '	gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );', '}'].join('\n'),
	  fragmentShader: ['precision highp float;', 'uniform sampler2D map;', 'uniform vec3 color;', 'varying vec2 vUV;', 'varying float vVisibility;', 'void main() {', '	vec4 texture = texture2D( map, vUV );', '	texture.a *= vVisibility;', '	gl_FragColor = texture;', '	gl_FragColor.rgb *= color;', '}'].join('\n')
	};

	THREE.Lensflare.Geometry = function () {
	  var geometry = new THREE.BufferGeometry();
	  var float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
	  var interleavedBuffer = new THREE.InterleavedBuffer(float32Array, 5);
	  geometry.setIndex([0, 1, 2, 0, 2, 3]);
	  geometry.setAttribute('position', new THREE.InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
	  geometry.setAttribute('uv', new THREE.InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
	  return geometry;
	}();

	THREE.FXAAShader = {
	  uniforms: {
	    "tDiffuse": {
	      value: null
	    },
	    "resolution": {
	      value: new THREE.Vector2(1 / 1024, 1 / 512)
	    }
	  },
	  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
	  fragmentShader: ["precision highp float;", "", "uniform sampler2D tDiffuse;", "", "uniform vec2 resolution;", "", "varying vec2 vUv;", "", "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)", "", "//----------------------------------------------------------------------------------", "// File:        es3-kepler\FXAA\assets\shaders/FXAA_DefaultES.frag", "// SDK Version: v3.00", "// Email:       gameworks@nvidia.com", "// Site:        http://developer.nvidia.com/", "//", "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.", "//", "// Redistribution and use in source and binary forms, with or without", "// modification, are permitted provided that the following conditions", "// are met:", "//  * Redistributions of source code must retain the above copyright", "//    notice, this list of conditions and the following disclaimer.", "//  * Redistributions in binary form must reproduce the above copyright", "//    notice, this list of conditions and the following disclaimer in the", "//    documentation and/or other materials provided with the distribution.", "//  * Neither the name of NVIDIA CORPORATION nor the names of its", "//    contributors may be used to endorse or promote products derived", "//    from this software without specific prior written permission.", "//", "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY", "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR", "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,", "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,", "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR", "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY", "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT", "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE", "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", "//", "//----------------------------------------------------------------------------------", "", "#define FXAA_PC 1", "#define FXAA_GLSL_100 1", "#define FXAA_QUALITY_PRESET 12", "", "#define FXAA_GREEN_AS_LUMA 1", "", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_PC_CONSOLE", "    //", "    // The console algorithm for PC is included", "    // for developers targeting really low spec machines.", "    // Likely better to just run FXAA_PC, and use a really low preset.", "    //", "    #define FXAA_PC_CONSOLE 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_120", "    #define FXAA_GLSL_120 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_130", "    #define FXAA_GLSL_130 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_3", "    #define FXAA_HLSL_3 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_4", "    #define FXAA_HLSL_4 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_5", "    #define FXAA_HLSL_5 0", "#endif", "/*==========================================================================*/", "#ifndef FXAA_GREEN_AS_LUMA", "    //", "    // For those using non-linear color,", "    // and either not able to get luma in alpha, or not wanting to,", "    // this enables FXAA to run using green as a proxy for luma.", "    // So with this enabled, no need to pack luma in alpha.", "    //", "    // This will turn off AA on anything which lacks some amount of green.", "    // Pure red and blue or combination of only R and B, will get no AA.", "    //", "    // Might want to lower the settings for both,", "    //    fxaaConsoleEdgeThresholdMin", "    //    fxaaQualityEdgeThresholdMin", "    // In order to insure AA does not get turned off on colors", "    // which contain a minor amount of green.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_GREEN_AS_LUMA 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_EARLY_EXIT", "    //", "    // Controls algorithm's early exit path.", "    // On PS3 turning this ON adds 2 cycles to the shader.", "    // On 360 turning this OFF adds 10ths of a millisecond to the shader.", "    // Turning this off on console will result in a more blurry image.", "    // So this defaults to on.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_EARLY_EXIT 1", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_DISCARD", "    //", "    // Only valid for PC OpenGL currently.", "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.", "    //", "    // 1 = Use discard on pixels which don't need AA.", "    //     For APIs which enable concurrent TEX+ROP from same surface.", "    // 0 = Return unchanged color on pixels which don't need AA.", "    //", "    #define FXAA_DISCARD 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_FAST_PIXEL_OFFSET", "    //", "    // Used for GLSL 120 only.", "    //", "    // 1 = GL API supports fast pixel offsets", "    // 0 = do not use fast pixel offsets", "    //", "    #ifdef GL_EXT_gpu_shader4", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifndef FXAA_FAST_PIXEL_OFFSET", "        #define FXAA_FAST_PIXEL_OFFSET 0", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GATHER4_ALPHA", "    //", "    // 1 = API supports gather4 on alpha channel.", "    // 0 = API does not support gather4 on alpha channel.", "    //", "    #if (FXAA_HLSL_5 == 1)", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifndef FXAA_GATHER4_ALPHA", "        #define FXAA_GATHER4_ALPHA 0", "    #endif", "#endif", "", "", "/*============================================================================", "                        FXAA QUALITY - TUNING KNOBS", "------------------------------------------------------------------------------", "NOTE the other tuning knobs are now in the shader function inputs!", "============================================================================*/", "#ifndef FXAA_QUALITY_PRESET", "    //", "    // Choose the quality preset.", "    // This needs to be compiled into the shader as it effects code.", "    // Best option to include multiple presets is to", "    // in each shader define the preset, then include this file.", "    //", "    // OPTIONS", "    // -----------------------------------------------------------------------", "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)", "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)", "    // 39       - no dither, very expensive", "    //", "    // NOTES", "    // -----------------------------------------------------------------------", "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)", "    // 13 = about same speed as FXAA 3.9 and better than 12", "    // 23 = closest to FXAA 3.9 visually and performance wise", "    //  _ = the lowest digit is directly related to performance", "    // _  = the highest digit is directly related to style", "    //", "    #define FXAA_QUALITY_PRESET 12", "#endif", "", "", "/*============================================================================", "", "                           FXAA QUALITY - PRESETS", "", "============================================================================*/", "", "/*============================================================================", "                     FXAA QUALITY - MEDIUM DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 10)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 3.0", "    #define FXAA_QUALITY_P2 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 11)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 3.0", "    #define FXAA_QUALITY_P3 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 12)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 4.0", "    #define FXAA_QUALITY_P4 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 13)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 4.0", "    #define FXAA_QUALITY_P5 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 14)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 4.0", "    #define FXAA_QUALITY_P6 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 15)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 12.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - LOW DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 20)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 2.0", "    #define FXAA_QUALITY_P2 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 21)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 22)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 23)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 24)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 3.0", "    #define FXAA_QUALITY_P6 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 25)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 26)", "    #define FXAA_QUALITY_PS 9", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 4.0", "    #define FXAA_QUALITY_P8 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 27)", "    #define FXAA_QUALITY_PS 10", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 4.0", "    #define FXAA_QUALITY_P9 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 28)", "    #define FXAA_QUALITY_PS 11", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 4.0", "    #define FXAA_QUALITY_P10 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 29)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - EXTREME QUALITY", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 39)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.0", "    #define FXAA_QUALITY_P2 1.0", "    #define FXAA_QUALITY_P3 1.0", "    #define FXAA_QUALITY_P4 1.0", "    #define FXAA_QUALITY_P5 1.5", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "", "", "/*============================================================================", "", "                                API PORTING", "", "============================================================================*/", "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)", "    #define FxaaBool bool", "    #define FxaaDiscard discard", "    #define FxaaFloat float", "    #define FxaaFloat2 vec2", "    #define FxaaFloat3 vec3", "    #define FxaaFloat4 vec4", "    #define FxaaHalf float", "    #define FxaaHalf2 vec2", "    #define FxaaHalf3 vec3", "    #define FxaaHalf4 vec4", "    #define FxaaInt2 ivec2", "    #define FxaaSat(x) clamp(x, 0.0, 1.0)", "    #define FxaaTex sampler2D", "#else", "    #define FxaaBool bool", "    #define FxaaDiscard clip(-1)", "    #define FxaaFloat float", "    #define FxaaFloat2 float2", "    #define FxaaFloat3 float3", "    #define FxaaFloat4 float4", "    #define FxaaHalf half", "    #define FxaaHalf2 half2", "    #define FxaaHalf3 half3", "    #define FxaaHalf4 half4", "    #define FxaaSat(x) saturate(x)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_100 == 1)", "  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)", "  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_120 == 1)", "    // Requires,", "    //  #version 120", "    // And at least,", "    //  #extension GL_EXT_gpu_shader4 : enable", "    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)", "    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)", "    #if (FXAA_FAST_PIXEL_OFFSET == 1)", "        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)", "    #else", "        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)", "    #endif", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_130 == 1)", "    // Requires \"#version 130\" or better", "    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_3 == 1)", "    #define FxaaInt2 float2", "    #define FxaaTex sampler2D", "    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))", "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_4 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_5 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)", "    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)", "    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)", "    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)", "#endif", "", "", "/*============================================================================", "                   GREEN AS LUMA OPTION SUPPORT FUNCTION", "============================================================================*/", "#if (FXAA_GREEN_AS_LUMA == 0)", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }", "#else", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }", "#endif", "", "", "", "", "/*============================================================================", "", "                             FXAA3 QUALITY - PC", "", "============================================================================*/", "#if (FXAA_PC == 1)", "/*--------------------------------------------------------------------------*/", "FxaaFloat4 FxaaPixelShader(", "    //", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy} = center of pixel", "    FxaaFloat2 pos,", "    //", "    // Used only for FXAA Console, and not used on the 360 version.", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy_} = upper left of pixel", "    // {_zw} = lower right of pixel", "    FxaaFloat4 fxaaConsolePosPos,", "    //", "    // Input color texture.", "    // {rgb_} = color in linear or perceptual color space", "    // if (FXAA_GREEN_AS_LUMA == 0)", "    //     {__a} = luma in perceptual color space (not linear)", "    FxaaTex tex,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", "    // For everything but 360, just use the same input here as for \"tex\".", "    // For 360, same texture, just alias with a 2nd sampler.", "    // This sampler needs to have an exponent bias of -1.", "    FxaaTex fxaaConsole360TexExpBiasNegOne,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", "    // For everything but 360, just use the same input here as for \"tex\".", "    // For 360, same texture, just alias with a 3nd sampler.", "    // This sampler needs to have an exponent bias of -2.", "    FxaaTex fxaaConsole360TexExpBiasNegTwo,", "    //", "    // Only used on FXAA Quality.", "    // This must be from a constant/uniform.", "    // {x_} = 1.0/screenWidthInPixels", "    // {_y} = 1.0/screenHeightInPixels", "    FxaaFloat2 fxaaQualityRcpFrame,", "    //", "    // Only used on FXAA Console.", "    // This must be from a constant/uniform.", "    // This effects sub-pixel AA quality and inversely sharpness.", "    //   Where N ranges between,", "    //     N = 0.50 (default)", "    //     N = 0.33 (sharper)", "    // {x__} = -N/screenWidthInPixels", "    // {_y_} = -N/screenHeightInPixels", "    // {_z_} =  N/screenWidthInPixels", "    // {__w} =  N/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt,", "    //", "    // Only used on FXAA Console.", "    // Not used on 360, but used on PS3 and PC.", "    // This must be from a constant/uniform.", "    // {x__} = -2.0/screenWidthInPixels", "    // {_y_} = -2.0/screenHeightInPixels", "    // {_z_} =  2.0/screenWidthInPixels", "    // {__w} =  2.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,", "    //", "    // Only used on FXAA Console.", "    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.", "    // This must be from a constant/uniform.", "    // {x__} =  8.0/screenWidthInPixels", "    // {_y_} =  8.0/screenHeightInPixels", "    // {_z_} = -4.0/screenWidthInPixels", "    // {__w} = -4.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_SUBPIX define.", "    // It is here now to allow easier tuning.", "    // Choose the amount of sub-pixel aliasing removal.", "    // This can effect sharpness.", "    //   1.00 - upper limit (softer)", "    //   0.75 - default amount of filtering", "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)", "    //   0.25 - almost off", "    //   0.00 - completely off", "    FxaaFloat fxaaQualitySubpix,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // The minimum amount of local contrast required to apply algorithm.", "    //   0.333 - too little (faster)", "    //   0.250 - low quality", "    //   0.166 - default", "    //   0.125 - high quality", "    //   0.063 - overkill (slower)", "    FxaaFloat fxaaQualityEdgeThreshold,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)", "    //   0.0625 - high quality (faster)", "    //   0.0312 - visible limit (slower)", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaQualityEdgeThresholdMin,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only three safe values here: 2 and 4 and 8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // For all other platforms can be a non-power of two.", "    //   8.0 is sharper (default!!!)", "    //   4.0 is softer", "    //   2.0 is really soft (good only for vector graphics inputs)", "    FxaaFloat fxaaConsoleEdgeSharpness,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only two safe values here: 1/4 and 1/8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // The console setting has a different mapping than the quality setting.", "    // Other platforms can use other values.", "    //   0.125 leaves less aliasing, but is softer (default!!!)", "    //   0.25 leaves more aliasing, and is sharper", "    FxaaFloat fxaaConsoleEdgeThreshold,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    // The console setting has a different mapping than the quality setting.", "    // This only applies when FXAA_EARLY_EXIT is 1.", "    // This does not apply to PS3,", "    // PS3 was simplified to avoid more shader instructions.", "    //   0.06 - faster but more aliasing in darks", "    //   0.05 - default", "    //   0.04 - slower and less aliasing in darks", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaConsoleEdgeThresholdMin,", "    //", "    // Extra constants for 360 FXAA Console only.", "    // Use zeros or anything else for other platforms.", "    // These must be in physical constant registers and NOT immediates.", "    // Immediates will result in compiler un-optimizing.", "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)", "    FxaaFloat4 fxaaConsole360ConstDir", ") {", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posM;", "    posM.x = pos.x;", "    posM.y = pos.y;", "    #if (FXAA_GATHER4_ALPHA == 1)", "        #if (FXAA_DISCARD == 0)", "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "            #if (FXAA_GREEN_AS_LUMA == 0)", "                #define lumaM rgbyM.w", "            #else", "                #define lumaM rgbyM.y", "            #endif", "        #endif", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));", "        #else", "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));", "        #endif", "        #if (FXAA_DISCARD == 1)", "            #define lumaM luma4A.w", "        #endif", "        #define lumaE luma4A.z", "        #define lumaS luma4A.x", "        #define lumaSE luma4A.y", "        #define lumaNW luma4B.w", "        #define lumaN luma4B.z", "        #define lumaW luma4B.x", "    #else", "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            #define lumaM rgbyM.w", "        #else", "            #define lumaM rgbyM.y", "        #endif", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));", "        #endif", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat maxSM = max(lumaS, lumaM);", "    FxaaFloat minSM = min(lumaS, lumaM);", "    FxaaFloat maxESM = max(lumaE, maxSM);", "    FxaaFloat minESM = min(lumaE, minSM);", "    FxaaFloat maxWN = max(lumaN, lumaW);", "    FxaaFloat minWN = min(lumaN, lumaW);", "    FxaaFloat rangeMax = max(maxWN, maxESM);", "    FxaaFloat rangeMin = min(minWN, minESM);", "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;", "    FxaaFloat range = rangeMax - rangeMin;", "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);", "    FxaaBool earlyExit = range < rangeMaxClamped;", "/*--------------------------------------------------------------------------*/", "    if(earlyExit)", "        #if (FXAA_DISCARD == 1)", "            FxaaDiscard;", "        #else", "            return rgbyM;", "        #endif", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_GATHER4_ALPHA == 0)", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "        #endif", "    #else", "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));", "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNS = lumaN + lumaS;", "    FxaaFloat lumaWE = lumaW + lumaE;", "    FxaaFloat subpixRcpRange = 1.0/range;", "    FxaaFloat subpixNSWE = lumaNS + lumaWE;", "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;", "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNESE = lumaNE + lumaSE;", "    FxaaFloat lumaNWNE = lumaNW + lumaNE;", "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;", "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNWSW = lumaNW + lumaSW;", "    FxaaFloat lumaSWSE = lumaSW + lumaSE;", "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);", "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);", "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;", "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;", "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;", "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;", "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;", "    FxaaBool horzSpan = edgeHorz >= edgeVert;", "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;", "/*--------------------------------------------------------------------------*/", "    if(!horzSpan) lumaN = lumaW;", "    if(!horzSpan) lumaS = lumaE;", "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;", "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat gradientN = lumaN - lumaM;", "    FxaaFloat gradientS = lumaS - lumaM;", "    FxaaFloat lumaNN = lumaN + lumaM;", "    FxaaFloat lumaSS = lumaS + lumaM;", "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);", "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));", "    if(pairN) lengthSign = -lengthSign;", "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posB;", "    posB.x = posM.x;", "    posB.y = posM.y;", "    FxaaFloat2 offNP;", "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;", "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;", "    if(!horzSpan) posB.x += lengthSign * 0.5;", "    if( horzSpan) posB.y += lengthSign * 0.5;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posN;", "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;", "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat2 posP;", "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;", "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;", "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));", "    FxaaFloat subpixE = subpixC * subpixC;", "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));", "/*--------------------------------------------------------------------------*/", "    if(!pairN) lumaNN = lumaSS;", "    FxaaFloat gradientScaled = gradient * 1.0/4.0;", "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;", "    FxaaFloat subpixF = subpixD * subpixE;", "    FxaaBool lumaMLTZero = lumaMM < 0.0;", "/*--------------------------------------------------------------------------*/", "    lumaEndN -= lumaNN * 0.5;", "    lumaEndP -= lumaNN * 0.5;", "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;", "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;", "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;", "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;", "    FxaaBool doneNP = (!doneN) || (!doneP);", "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;", "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;", "/*--------------------------------------------------------------------------*/", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 3)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 4)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 5)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 6)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;", "/*--------------------------------------------------------------------------*/", "                        #if (FXAA_QUALITY_PS > 7)", "                        if(doneNP) {", "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                            doneN = abs(lumaEndN) >= gradientScaled;", "                            doneP = abs(lumaEndP) >= gradientScaled;", "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;", "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;", "                            doneNP = (!doneN) || (!doneP);", "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;", "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_QUALITY_PS > 8)", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 9)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 10)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 11)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 12)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "    #endif", "/*--------------------------------------------------------------------------*/", "                        }", "                        #endif", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "/*--------------------------------------------------------------------------*/", "    FxaaFloat dstN = posM.x - posN.x;", "    FxaaFloat dstP = posP.x - posM.x;", "    if(!horzSpan) dstN = posM.y - posN.y;", "    if(!horzSpan) dstP = posP.y - posM.y;", "/*--------------------------------------------------------------------------*/", "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;", "    FxaaFloat spanLength = (dstP + dstN);", "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;", "    FxaaFloat spanLengthRcp = 1.0/spanLength;", "/*--------------------------------------------------------------------------*/", "    FxaaBool directionN = dstN < dstP;", "    FxaaFloat dst = min(dstN, dstP);", "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;", "    FxaaFloat subpixG = subpixF * subpixF;", "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;", "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;", "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);", "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;", "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;", "    #if (FXAA_DISCARD == 1)", "        return FxaaTexTop(tex, posM);", "    #else", "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);", "    #endif", "}", "/*==========================================================================*/", "#endif", "", "void main() {", "  gl_FragColor = FxaaPixelShader(", "    vUv,", "    vec4(0.0),", "    tDiffuse,", "    tDiffuse,", "    tDiffuse,", "    resolution,", "    vec4(0.0),", "    vec4(0.0),", "    vec4(0.0),", "    0.75,", "    0.166,", "    0.0833,", "    0.0,", "    0.0,", "    0.0,", "    vec4(0.0)", "  );", "", "  // TODO avoid querying texture twice for same texel", "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;", "}"].join("\n")
	};

	THREE.TerrainShader = {
	  /* -------------------------------------------------------------------------
	  //	Dynamic terrain shader
	  //		- Blinn-Phong
	  //		- height + normal + diffuse1 + diffuse2 + specular + detail maps
	  //		- point, directional and hemisphere lights (use with "lights: true" material option)
	  //		- shadow maps receiving
	   ------------------------------------------------------------------------- */
	  uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], {
	    "enableDiffuse1": {
	      value: 0
	    },
	    "enableDiffuse2": {
	      value: 0
	    },
	    "enableSpecular": {
	      value: 0
	    },
	    "enableReflection": {
	      value: 0
	    },
	    "tDiffuse1": {
	      value: null
	    },
	    "tDiffuse2": {
	      value: null
	    },
	    "tDetail": {
	      value: null
	    },
	    "tNormal": {
	      value: null
	    },
	    "tSpecular": {
	      value: null
	    },
	    "tDisplacement": {
	      value: null
	    },
	    "uNormalScale": {
	      value: 1.0
	    },
	    "uDisplacementBias": {
	      value: 0.0
	    },
	    "uDisplacementScale": {
	      value: 1.0
	    },
	    "diffuse": {
	      value: new THREE.Color(0xeeeeee)
	    },
	    "specular": {
	      value: new THREE.Color(0x111111)
	    },
	    "shininess": {
	      value: 30
	    },
	    "opacity": {
	      value: 1
	    },
	    "uRepeatBase": {
	      value: new THREE.Vector2(1, 1)
	    },
	    "uRepeatOverlay": {
	      value: new THREE.Vector2(1, 1)
	    },
	    "uOffset": {
	      value: new THREE.Vector2(0, 0)
	    }
	  }]),
	  fragmentShader: ["uniform vec3 diffuse;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", "uniform bool enableDiffuse1;", "uniform bool enableDiffuse2;", "uniform bool enableSpecular;", "uniform sampler2D tDiffuse1;", "uniform sampler2D tDiffuse2;", "uniform sampler2D tDetail;", "uniform sampler2D tNormal;", "uniform sampler2D tSpecular;", "uniform sampler2D tDisplacement;", "uniform float uNormalScale;", "uniform vec2 uRepeatOverlay;", "uniform vec2 uRepeatBase;", "uniform vec2 uOffset;", "varying vec3 vTangent;", "varying vec3 vBinormal;", "varying vec3 vNormal;", "varying vec2 vUv;", "varying vec3 vViewPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["bsdfs"], THREE.ShaderChunk["lights_pars_begin"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], "float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {", "if ( decayExponent > 0.0 ) {", "return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );", "}", "return 1.0;", "}", "void main() {", "vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
	  "vec4 diffuseColor = vec4( diffuse, opacity );", "vec3 specularTex = vec3( 1.0 );", "vec2 uvOverlay = uRepeatOverlay * vUv + uOffset;", "vec2 uvBase = uRepeatBase * vUv;", "vec3 normalTex = texture2D( tDetail, uvOverlay ).xyz * 2.0 - 1.0;", "normalTex.xy *= uNormalScale;", "normalTex = normalize( normalTex );", "if( enableDiffuse1 && enableDiffuse2 ) {", "vec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );", "vec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );", "colDiffuse1 = GammaToLinear( colDiffuse1, float( GAMMA_FACTOR ) );", "colDiffuse2 = GammaToLinear( colDiffuse2, float( GAMMA_FACTOR ) );", "diffuseColor *= mix ( colDiffuse1, colDiffuse2, 1.0 - texture2D( tDisplacement, uvBase ) );", " } else if( enableDiffuse1 ) {", "diffuseColor *= texture2D( tDiffuse1, uvOverlay );", "} else if( enableDiffuse2 ) {", "diffuseColor *= texture2D( tDiffuse2, uvOverlay );", "}", "if( enableSpecular )", "specularTex = texture2D( tSpecular, uvOverlay ).xyz;", "mat3 tsb = mat3( vTangent, vBinormal, vNormal );", "vec3 finalNormal = tsb * normalTex;", "vec3 normal = normalize( finalNormal );", "vec3 viewPosition = normalize( vViewPosition );", "vec3 totalDiffuseLight = vec3( 0.0 );", "vec3 totalSpecularLight = vec3( 0.0 );", // point lights
	  "#if NUM_POINT_LIGHTS > 0", "for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {", "vec3 lVector = pointLights[ i ].position + vViewPosition.xyz;", "float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );", "lVector = normalize( lVector );", "vec3 pointHalfVector = normalize( lVector + viewPosition );", "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );", "float pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );", "float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );", "totalDiffuseLight += attenuation * pointLights[ i ].color * pointDiffuseWeight;", "totalSpecularLight += attenuation * pointLights[ i ].color * specular * pointSpecularWeight * pointDiffuseWeight;", "}", "#endif", // directional lights
	  "#if NUM_DIR_LIGHTS > 0", "vec3 dirDiffuse = vec3( 0.0 );", "vec3 dirSpecular = vec3( 0.0 );", "for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {", "vec3 dirVector = directionalLights[ i ].direction;", "vec3 dirHalfVector = normalize( dirVector + viewPosition );", "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );", "float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );", "float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );", "totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;", "totalSpecularLight += directionalLights[ i ].color * specular * dirSpecularWeight * dirDiffuseWeight;", "}", "#endif", // hemisphere lights
	  "#if NUM_HEMI_LIGHTS > 0", "vec3 hemiDiffuse  = vec3( 0.0 );", "vec3 hemiSpecular = vec3( 0.0 );", "for( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {", "vec3 lVector = hemisphereLightDirection[ i ];", // diffuse
	  "float dotProduct = dot( normal, lVector );", "float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;", "totalDiffuseLight += mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight );", // specular (sky light)
	  "float hemiSpecularWeight = 0.0;", "vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );", "float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;", "hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );", // specular (ground light)
	  "vec3 lVectorGround = -lVector;", "vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );", "float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;", "hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );", "totalSpecularLight += specular * mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight ) * hemiSpecularWeight * hemiDiffuseWeight;", "}", "#endif", "outgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor + totalSpecularLight );", "gl_FragColor = vec4( outgoingLight, diffuseColor.a );", // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects
	  THREE.ShaderChunk["fog_fragment"], "}"].join("\n"),
	  vertexShader: ["attribute vec4 tangent;", "uniform vec2 uRepeatBase;", "uniform sampler2D tNormal;", "#ifdef VERTEX_TEXTURES", "uniform sampler2D tDisplacement;", "uniform float uDisplacementScale;", "uniform float uDisplacementBias;", "#endif", "varying vec3 vTangent;", "varying vec3 vBinormal;", "varying vec3 vNormal;", "varying vec2 vUv;", "varying vec3 vViewPosition;", THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["fog_pars_vertex"], "void main() {", "vNormal = normalize( normalMatrix * normal );", // tangent and binormal vectors
	  "vTangent = normalize( normalMatrix * tangent.xyz );", "vBinormal = cross( vNormal, vTangent ) * tangent.w;", "vBinormal = normalize( vBinormal );", // texture coordinates
	  "vUv = uv;", "vec2 uvBase = uv * uRepeatBase;", // displacement mapping
	  "#ifdef VERTEX_TEXTURES", "vec3 dv = texture2D( tDisplacement, uvBase ).xyz;", "float df = uDisplacementScale * dv.x + uDisplacementBias;", "vec3 displacedPosition = normal * df + position;", "vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );", "vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );", "#else", "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "#endif", "gl_Position = projectionMatrix * mvPosition;", "vViewPosition = -mvPosition.xyz;", "vec3 normalTex = texture2D( tNormal, uvBase ).xyz * 2.0 - 1.0;", "vNormal = normalMatrix * normalTex;", THREE.ShaderChunk["shadowmap_vertex"], THREE.ShaderChunk["fog_vertex"], "}"].join("\n")
	};

	THREE.BufferGeometryUtils = {
	  computeTangents: function (geometry) {
	    var index = geometry.index;
	    var attributes = geometry.attributes; // based on http://www.terathon.com/code/tangent.html
	    // (per vertex tangents)

	    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
	      console.warn('THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');
	      return;
	    }

	    var indices = index.array;
	    var positions = attributes.position.array;
	    var normals = attributes.normal.array;
	    var uvs = attributes.uv.array;
	    var nVertices = positions.length / 3;

	    if (attributes.tangent === undefined) {
	      geometry.setAttribute('tangent', new THREE.BufferAttribute(new Float32Array(4 * nVertices), 4));
	    }

	    var tangents = attributes.tangent.array;
	    var tan1 = [],
	        tan2 = [];

	    for (var i = 0; i < nVertices; i++) {
	      tan1[i] = new THREE.Vector3();
	      tan2[i] = new THREE.Vector3();
	    }

	    var vA = new THREE.Vector3(),
	        vB = new THREE.Vector3(),
	        vC = new THREE.Vector3(),
	        uvA = new THREE.Vector2(),
	        uvB = new THREE.Vector2(),
	        uvC = new THREE.Vector2(),
	        sdir = new THREE.Vector3(),
	        tdir = new THREE.Vector3();

	    function handleTriangle(a, b, c) {
	      vA.fromArray(positions, a * 3);
	      vB.fromArray(positions, b * 3);
	      vC.fromArray(positions, c * 3);
	      uvA.fromArray(uvs, a * 2);
	      uvB.fromArray(uvs, b * 2);
	      uvC.fromArray(uvs, c * 2);
	      vB.sub(vA);
	      vC.sub(vA);
	      uvB.sub(uvA);
	      uvC.sub(uvA);
	      var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

	      if (!isFinite(r)) return;
	      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
	      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
	      tan1[a].add(sdir);
	      tan1[b].add(sdir);
	      tan1[c].add(sdir);
	      tan2[a].add(tdir);
	      tan2[b].add(tdir);
	      tan2[c].add(tdir);
	    }

	    var groups = geometry.groups;

	    if (groups.length === 0) {
	      groups = [{
	        start: 0,
	        count: indices.length
	      }];
	    }

	    for (var i = 0, il = groups.length; i < il; ++i) {
	      var group = groups[i];
	      var start = group.start;
	      var count = group.count;

	      for (var j = start, jl = start + count; j < jl; j += 3) {
	        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
	      }
	    }

	    var tmp = new THREE.Vector3(),
	        tmp2 = new THREE.Vector3();
	    var n = new THREE.Vector3(),
	        n2 = new THREE.Vector3();
	    var w, t, test;

	    function handleVertex(v) {
	      n.fromArray(normals, v * 3);
	      n2.copy(n);
	      t = tan1[v]; // Gram-Schmidt orthogonalize

	      tmp.copy(t);
	      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

	      tmp2.crossVectors(n2, t);
	      test = tmp2.dot(tan2[v]);
	      w = test < 0.0 ? -1.0 : 1.0;
	      tangents[v * 4] = tmp.x;
	      tangents[v * 4 + 1] = tmp.y;
	      tangents[v * 4 + 2] = tmp.z;
	      tangents[v * 4 + 3] = w;
	    }

	    for (var i = 0, il = groups.length; i < il; ++i) {
	      var group = groups[i];
	      var start = group.start;
	      var count = group.count;

	      for (var j = start, jl = start + count; j < jl; j += 3) {
	        handleVertex(indices[j + 0]);
	        handleVertex(indices[j + 1]);
	        handleVertex(indices[j + 2]);
	      }
	    }
	  },

	  /**
	   * @param  {Array<THREE.BufferGeometry>} geometries
	   * @param  {Boolean} useGroups
	   * @return {THREE.BufferGeometry}
	   */
	  mergeBufferGeometries: function (geometries, useGroups) {
	    var isIndexed = geometries[0].index !== null;
	    var attributesUsed = new Set(Object.keys(geometries[0].attributes));
	    var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
	    var attributes = {};
	    var morphAttributes = {};
	    var morphTargetsRelative = geometries[0].morphTargetsRelative;
	    var mergedGeometry = new THREE.BufferGeometry();
	    var offset = 0;

	    for (var i = 0; i < geometries.length; ++i) {
	      var geometry = geometries[i]; // ensure that all geometries are indexed, or none

	      if (isIndexed !== (geometry.index !== null)) return null; // gather attributes, exit early if they're different

	      for (var name in geometry.attributes) {
	        if (!attributesUsed.has(name)) return null;
	        if (attributes[name] === undefined) attributes[name] = [];
	        attributes[name].push(geometry.attributes[name]);
	      } // gather morph attributes, exit early if they're different


	      if (morphTargetsRelative !== geometry.morphTargetsRelative) return null;

	      for (var name in geometry.morphAttributes) {
	        if (!morphAttributesUsed.has(name)) return null;
	        if (morphAttributes[name] === undefined) morphAttributes[name] = [];
	        morphAttributes[name].push(geometry.morphAttributes[name]);
	      } // gather .userData


	      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
	      mergedGeometry.userData.mergedUserData.push(geometry.userData);

	      if (useGroups) {
	        var count;

	        if (isIndexed) {
	          count = geometry.index.count;
	        } else if (geometry.attributes.position !== undefined) {
	          count = geometry.attributes.position.count;
	        } else {
	          return null;
	        }

	        mergedGeometry.addGroup(offset, count, i);
	        offset += count;
	      }
	    } // merge indices


	    if (isIndexed) {
	      var indexOffset = 0;
	      var mergedIndex = [];

	      for (var i = 0; i < geometries.length; ++i) {
	        var index = geometries[i].index;

	        for (var j = 0; j < index.count; ++j) {
	          mergedIndex.push(index.getX(j) + indexOffset);
	        }

	        indexOffset += geometries[i].attributes.position.count;
	      }

	      mergedGeometry.setIndex(mergedIndex);
	    } // merge attributes


	    for (var name in attributes) {
	      var mergedAttribute = this.mergeBufferAttributes(attributes[name]);
	      if (!mergedAttribute) return null;
	      mergedGeometry.setAttribute(name, mergedAttribute);
	    } // merge morph attributes


	    for (var name in morphAttributes) {
	      var numMorphTargets = morphAttributes[name][0].length;
	      if (numMorphTargets === 0) break;
	      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
	      mergedGeometry.morphAttributes[name] = [];

	      for (var i = 0; i < numMorphTargets; ++i) {
	        var morphAttributesToMerge = [];

	        for (var j = 0; j < morphAttributes[name].length; ++j) {
	          morphAttributesToMerge.push(morphAttributes[name][j][i]);
	        }

	        var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);
	        if (!mergedMorphAttribute) return null;
	        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
	      }
	    }

	    return mergedGeometry;
	  },

	  /**
	   * @param {Array<THREE.BufferAttribute>} attributes
	   * @return {THREE.BufferAttribute}
	   */
	  mergeBufferAttributes: function (attributes) {
	    var TypedArray;
	    var itemSize;
	    var normalized;
	    var arrayLength = 0;

	    for (var i = 0; i < attributes.length; ++i) {
	      var attribute = attributes[i];
	      if (attribute.isInterleavedBufferAttribute) return null;
	      if (TypedArray === undefined) TypedArray = attribute.array.constructor;
	      if (TypedArray !== attribute.array.constructor) return null;
	      if (itemSize === undefined) itemSize = attribute.itemSize;
	      if (itemSize !== attribute.itemSize) return null;
	      if (normalized === undefined) normalized = attribute.normalized;
	      if (normalized !== attribute.normalized) return null;
	      arrayLength += attribute.array.length;
	    }

	    var array = new TypedArray(arrayLength);
	    var offset = 0;

	    for (var i = 0; i < attributes.length; ++i) {
	      array.set(attributes[i].array, offset);
	      offset += attributes[i].array.length;
	    }

	    return new THREE.BufferAttribute(array, itemSize, normalized);
	  },

	  /**
	   * @param {Array<THREE.BufferAttribute>} attributes
	   * @return {Array<THREE.InterleavedBufferAttribute>}
	   */
	  interleaveAttributes: function (attributes) {
	    // Interleaves the provided attributes into an InterleavedBuffer and returns
	    // a set of InterleavedBufferAttributes for each attribute
	    var TypedArray;
	    var arrayLength = 0;
	    var stride = 0; // calculate the the length and type of the interleavedBuffer

	    for (var i = 0, l = attributes.length; i < l; ++i) {
	      var attribute = attributes[i];
	      if (TypedArray === undefined) TypedArray = attribute.array.constructor;

	      if (TypedArray !== attribute.array.constructor) {
	        console.warn('AttributeBuffers of different types cannot be interleaved');
	        return null;
	      }

	      arrayLength += attribute.array.length;
	      stride += attribute.itemSize;
	    } // Create the set of buffer attributes


	    var interleavedBuffer = new THREE.InterleavedBuffer(new TypedArray(arrayLength), stride);
	    var offset = 0;
	    var res = [];
	    var getters = ['getX', 'getY', 'getZ', 'getW'];
	    var setters = ['setX', 'setY', 'setZ', 'setW'];

	    for (var j = 0, l = attributes.length; j < l; j++) {
	      var attribute = attributes[j];
	      var itemSize = attribute.itemSize;
	      var count = attribute.count;
	      var iba = new THREE.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);
	      res.push(iba);
	      offset += itemSize; // Move the data for each attribute into the new interleavedBuffer
	      // at the appropriate offset

	      for (var c = 0; c < count; c++) {
	        for (var k = 0; k < itemSize; k++) {
	          iba[setters[k]](c, attribute[getters[k]](c));
	        }
	      }
	    }

	    return res;
	  },

	  /**
	   * @param {Array<THREE.BufferGeometry>} geometry
	   * @return {number}
	   */
	  estimateBytesUsed: function (geometry) {
	    // Return the estimated memory used by this geometry in bytes
	    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account
	    // for InterleavedBufferAttributes.
	    var mem = 0;

	    for (var name in geometry.attributes) {
	      var attr = geometry.getAttribute(name);
	      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
	    }

	    var indices = geometry.getIndex();
	    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
	    return mem;
	  },

	  /**
	   * @param {THREE.BufferGeometry} geometry
	   * @param {number} tolerance
	   * @return {THREE.BufferGeometry>}
	   */
	  mergeVertices: function (geometry, tolerance = 1e-4) {
	    tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it
	    // if it's already available.

	    var hashToIndex = {};
	    var indices = geometry.getIndex();
	    var positions = geometry.getAttribute('position');
	    var vertexCount = indices ? indices.count : positions.count; // next value for triangle indices

	    var nextIndex = 0; // attributes and new attribute arrays

	    var attributeNames = Object.keys(geometry.attributes);
	    var attrArrays = {};
	    var morphAttrsArrays = {};
	    var newIndices = [];
	    var getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays

	    for (var i = 0, l = attributeNames.length; i < l; i++) {
	      var name = attributeNames[i];
	      attrArrays[name] = [];
	      var morphAttr = geometry.morphAttributes[name];

	      if (morphAttr) {
	        morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(() => []);
	      }
	    } // convert the error tolerance to an amount of decimal places to truncate to


	    var decimalShift = Math.log10(1 / tolerance);
	    var shiftMultiplier = Math.pow(10, decimalShift);

	    for (var i = 0; i < vertexCount; i++) {
	      var index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'

	      var hash = '';

	      for (var j = 0, l = attributeNames.length; j < l; j++) {
	        var name = attributeNames[j];
	        var attribute = geometry.getAttribute(name);
	        var itemSize = attribute.itemSize;

	        for (var k = 0; k < itemSize; k++) {
	          // double tilde truncates the decimal value
	          hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;
	        }
	      } // Add another reference to the vertex if it's already
	      // used by another index


	      if (hash in hashToIndex) {
	        newIndices.push(hashToIndex[hash]);
	      } else {
	        // copy data to the new index in the attribute arrays
	        for (var j = 0, l = attributeNames.length; j < l; j++) {
	          var name = attributeNames[j];
	          var attribute = geometry.getAttribute(name);
	          var morphAttr = geometry.morphAttributes[name];
	          var itemSize = attribute.itemSize;
	          var newarray = attrArrays[name];
	          var newMorphArrays = morphAttrsArrays[name];

	          for (var k = 0; k < itemSize; k++) {
	            var getterFunc = getters[k];
	            newarray.push(attribute[getterFunc](index));

	            if (morphAttr) {
	              for (var m = 0, ml = morphAttr.length; m < ml; m++) {
	                newMorphArrays[m].push(morphAttr[m][getterFunc](index));
	              }
	            }
	          }
	        }

	        hashToIndex[hash] = nextIndex;
	        newIndices.push(nextIndex);
	        nextIndex++;
	      }
	    } // Generate typed arrays from new attribute arrays and update
	    // the attributeBuffers


	    const result = geometry.clone();

	    for (var i = 0, l = attributeNames.length; i < l; i++) {
	      var name = attributeNames[i];
	      var oldAttribute = geometry.getAttribute(name);
	      var buffer = new oldAttribute.array.constructor(attrArrays[name]);
	      var attribute = new THREE.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);
	      result.setAttribute(name, attribute); // Update the attribute arrays

	      if (name in morphAttrsArrays) {
	        for (var j = 0; j < morphAttrsArrays[name].length; j++) {
	          var oldMorphAttribute = geometry.morphAttributes[name][j];
	          var buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);
	          var morphAttribute = new THREE.BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);
	          result.morphAttributes[name][j] = morphAttribute;
	        }
	      }
	    } // indices


	    result.setIndex(newIndices);
	    return result;
	  },

	  /**
	   * @param {THREE.BufferGeometry} geometry
	   * @param {number} drawMode
	   * @return {THREE.BufferGeometry>}
	   */
	  toTrianglesDrawMode: function (geometry, drawMode) {
	    if (drawMode === THREE.TrianglesDrawMode) {
	      console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');
	      return geometry;
	    }

	    if (drawMode === THREE.TriangleFanDrawMode || drawMode === THREE.TriangleStripDrawMode) {
	      var index = geometry.getIndex(); // generate index if not present

	      if (index === null) {
	        var indices = [];
	        var position = geometry.getAttribute('position');

	        if (position !== undefined) {
	          for (var i = 0; i < position.count; i++) {
	            indices.push(i);
	          }

	          geometry.setIndex(indices);
	          index = geometry.getIndex();
	        } else {
	          console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
	          return geometry;
	        }
	      } //


	      var numberOfTriangles = index.count - 2;
	      var newIndices = [];

	      if (drawMode === THREE.TriangleFanDrawMode) {
	        // gl.TRIANGLE_FAN
	        for (var i = 1; i <= numberOfTriangles; i++) {
	          newIndices.push(index.getX(0));
	          newIndices.push(index.getX(i));
	          newIndices.push(index.getX(i + 1));
	        }
	      } else {
	        // gl.TRIANGLE_STRIP
	        for (var i = 0; i < numberOfTriangles; i++) {
	          if (i % 2 === 0) {
	            newIndices.push(index.getX(i));
	            newIndices.push(index.getX(i + 1));
	            newIndices.push(index.getX(i + 2));
	          } else {
	            newIndices.push(index.getX(i + 2));
	            newIndices.push(index.getX(i + 1));
	            newIndices.push(index.getX(i));
	          }
	        }
	      }

	      if (newIndices.length / 3 !== numberOfTriangles) {
	        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
	      } // build final geometry


	      var newGeometry = geometry.clone();
	      newGeometry.setIndex(newIndices);
	      newGeometry.clearGroups();
	      return newGeometry;
	    } else {
	      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);
	      return geometry;
	    }
	  }
	};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var js_cookie = createCommonjsModule(function (module, exports) {

	  (function (factory) {
	    var registeredInModuleLoader;

	    {
	      module.exports = factory();
	      registeredInModuleLoader = true;
	    }

	    if (!registeredInModuleLoader) {
	      var OldCookies = window.Cookies;
	      var api = window.Cookies = factory();

	      api.noConflict = function () {
	        window.Cookies = OldCookies;
	        return api;
	      };
	    }
	  })(function () {
	    function extend() {
	      var i = 0;
	      var result = {};

	      for (; i < arguments.length; i++) {
	        var attributes = arguments[i];

	        for (var key in attributes) {
	          result[key] = attributes[key];
	        }
	      }

	      return result;
	    }

	    function decode(s) {
	      return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
	    }

	    function init(converter) {
	      function api() {}

	      function set(key, value, attributes) {
	        if (typeof document === 'undefined') {
	          return;
	        }

	        attributes = extend({
	          path: '/'
	        }, api.defaults, attributes);

	        if (typeof attributes.expires === 'number') {
	          attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
	        } // We're using "expires" because "max-age" is not supported by IE


	        attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

	        try {
	          var result = JSON.stringify(value);

	          if (/^[\{\[]/.test(result)) {
	            value = result;
	          }
	        } catch (e) {}

	        value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
	        key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
	        var stringifiedAttributes = '';

	        for (var attributeName in attributes) {
	          if (!attributes[attributeName]) {
	            continue;
	          }

	          stringifiedAttributes += '; ' + attributeName;

	          if (attributes[attributeName] === true) {
	            continue;
	          } // Considers RFC 6265 section 5.2:
	          // ...
	          // 3.  If the remaining unparsed-attributes contains a %x3B (";")
	          //     character:
	          // Consume the characters of the unparsed-attributes up to,
	          // not including, the first %x3B (";") character.
	          // ...


	          stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
	        }

	        return document.cookie = key + '=' + value + stringifiedAttributes;
	      }

	      function get(key, json) {
	        if (typeof document === 'undefined') {
	          return;
	        }

	        var jar = {}; // To prevent the for loop in the first place assign an empty array
	        // in case there are no cookies at all.

	        var cookies = document.cookie ? document.cookie.split('; ') : [];
	        var i = 0;

	        for (; i < cookies.length; i++) {
	          var parts = cookies[i].split('=');
	          var cookie = parts.slice(1).join('=');

	          if (!json && cookie.charAt(0) === '"') {
	            cookie = cookie.slice(1, -1);
	          }

	          try {
	            var name = decode(parts[0]);
	            cookie = (converter.read || converter)(cookie, name) || decode(cookie);

	            if (json) {
	              try {
	                cookie = JSON.parse(cookie);
	              } catch (e) {}
	            }

	            jar[name] = cookie;

	            if (key === name) {
	              break;
	            }
	          } catch (e) {}
	        }

	        return key ? jar[key] : jar;
	      }

	      api.set = set;

	      api.get = function (key) {
	        return get(key, false
	        /* read as raw */
	        );
	      };

	      api.getJSON = function (key) {
	        return get(key, true
	        /* read as json */
	        );
	      };

	      api.remove = function (key, attributes) {
	        set(key, '', extend(attributes, {
	          expires: -1
	        }));
	      };

	      api.defaults = {};
	      api.withConverter = init;
	      return api;
	    }

	    return init(function () {});
	  });
	});

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function _typeof(obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function _typeof(obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _objectSpread(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? Object(arguments[i]) : {};
	    var ownKeys = Object.keys(source);

	    if (typeof Object.getOwnPropertySymbols === 'function') {
	      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
	      }));
	    }

	    ownKeys.forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    });
	  }

	  return target;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (_typeof(call) === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) {
	    arr2[i] = arr[i];
	  }

	  return arr2;
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArrayLimit(arr, i) {
	  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	}

	var consoleLogger = {
	  type: 'logger',
	  log: function log(args) {
	    this.output('log', args);
	  },
	  warn: function warn(args) {
	    this.output('warn', args);
	  },
	  error: function error(args) {
	    this.output('error', args);
	  },
	  output: function output(type, args) {
	    var _console;
	    /* eslint no-console: 0 */


	    if (console && console[type]) (_console = console)[type].apply(_console, _toConsumableArray(args));
	  }
	};

	var Logger = /*#__PURE__*/function () {
	  function Logger(concreteLogger) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Logger);

	    this.init(concreteLogger, options);
	  }

	  _createClass(Logger, [{
	    key: "init",
	    value: function init(concreteLogger) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      this.prefix = options.prefix || 'i18next:';
	      this.logger = concreteLogger || consoleLogger;
	      this.options = options;
	      this.debug = options.debug;
	    }
	  }, {
	    key: "setDebug",
	    value: function setDebug(bool) {
	      this.debug = bool;
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      return this.forward(args, 'log', '', true);
	    }
	  }, {
	    key: "warn",
	    value: function warn() {
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      return this.forward(args, 'warn', '', true);
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }

	      return this.forward(args, 'error', '');
	    }
	  }, {
	    key: "deprecate",
	    value: function deprecate() {
	      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	        args[_key4] = arguments[_key4];
	      }

	      return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
	    }
	  }, {
	    key: "forward",
	    value: function forward(args, lvl, prefix, debugOnly) {
	      if (debugOnly && !this.debug) return null;
	      if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
	      return this.logger[lvl](args);
	    }
	  }, {
	    key: "create",
	    value: function create(moduleName) {
	      return new Logger(this.logger, _objectSpread({}, {
	        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
	      }, this.options));
	    }
	  }]);

	  return Logger;
	}();

	var baseLogger = new Logger();

	var EventEmitter = /*#__PURE__*/function () {
	  function EventEmitter() {
	    _classCallCheck(this, EventEmitter);

	    this.observers = {};
	  }

	  _createClass(EventEmitter, [{
	    key: "on",
	    value: function on(events, listener) {
	      var _this = this;

	      events.split(' ').forEach(function (event) {
	        _this.observers[event] = _this.observers[event] || [];

	        _this.observers[event].push(listener);
	      });
	      return this;
	    }
	  }, {
	    key: "off",
	    value: function off(event, listener) {
	      if (!this.observers[event]) return;

	      if (!listener) {
	        delete this.observers[event];
	        return;
	      }

	      this.observers[event] = this.observers[event].filter(function (l) {
	        return l !== listener;
	      });
	    }
	  }, {
	    key: "emit",
	    value: function emit(event) {
	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      if (this.observers[event]) {
	        var cloned = [].concat(this.observers[event]);
	        cloned.forEach(function (observer) {
	          observer.apply(void 0, args);
	        });
	      }

	      if (this.observers['*']) {
	        var _cloned = [].concat(this.observers['*']);

	        _cloned.forEach(function (observer) {
	          observer.apply(observer, [event].concat(args));
	        });
	      }
	    }
	  }]);

	  return EventEmitter;
	}(); // http://lea.verou.me/2016/12/resolve-promises-externally-with-this-one-weird-trick/


	function defer() {
	  var res;
	  var rej;
	  var promise = new Promise(function (resolve, reject) {
	    res = resolve;
	    rej = reject;
	  });
	  promise.resolve = res;
	  promise.reject = rej;
	  return promise;
	}

	function makeString(object) {
	  if (object == null) return '';
	  /* eslint prefer-template: 0 */

	  return '' + object;
	}

	function copy(a, s, t) {
	  a.forEach(function (m) {
	    if (s[m]) t[m] = s[m];
	  });
	}

	function getLastOfPath(object, path, Empty) {
	  function cleanKey(key) {
	    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
	  }

	  function canNotTraverseDeeper() {
	    return !object || typeof object === 'string';
	  }

	  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

	  while (stack.length > 1) {
	    if (canNotTraverseDeeper()) return {};
	    var key = cleanKey(stack.shift());
	    if (!object[key] && Empty) object[key] = new Empty();
	    object = object[key];
	  }

	  if (canNotTraverseDeeper()) return {};
	  return {
	    obj: object,
	    k: cleanKey(stack.shift())
	  };
	}

	function setPath(object, path, newValue) {
	  var _getLastOfPath = getLastOfPath(object, path, Object),
	      obj = _getLastOfPath.obj,
	      k = _getLastOfPath.k;

	  obj[k] = newValue;
	}

	function pushPath(object, path, newValue, concat) {
	  var _getLastOfPath2 = getLastOfPath(object, path, Object),
	      obj = _getLastOfPath2.obj,
	      k = _getLastOfPath2.k;

	  obj[k] = obj[k] || [];
	  if (concat) obj[k] = obj[k].concat(newValue);
	  if (!concat) obj[k].push(newValue);
	}

	function getPath(object, path) {
	  var _getLastOfPath3 = getLastOfPath(object, path),
	      obj = _getLastOfPath3.obj,
	      k = _getLastOfPath3.k;

	  if (!obj) return undefined;
	  return obj[k];
	}

	function getPathWithDefaults(data, defaultData, key) {
	  var value = getPath(data, key);

	  if (value !== undefined) {
	    return value;
	  } // Fallback to default values


	  return getPath(defaultData, key);
	}

	function deepExtend(target, source, overwrite) {
	  /* eslint no-restricted-syntax: 0 */
	  for (var prop in source) {
	    if (prop in target) {
	      // If we reached a leaf string in target or source then replace with source or skip depending on the 'overwrite' switch
	      if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
	        if (overwrite) target[prop] = source[prop];
	      } else {
	        deepExtend(target[prop], source[prop], overwrite);
	      }
	    } else {
	      target[prop] = source[prop];
	    }
	  }

	  return target;
	}

	function regexEscape(str) {
	  /* eslint no-useless-escape: 0 */
	  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
	}
	/* eslint-disable */


	var _entityMap = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;',
	  '/': '&#x2F;'
	};
	/* eslint-enable */

	function escape$1(data) {
	  if (typeof data === 'string') {
	    return data.replace(/[&<>"'\/]/g, function (s) {
	      return _entityMap[s];
	    });
	  }

	  return data;
	}

	var ResourceStore = /*#__PURE__*/function (_EventEmitter) {
	  _inherits(ResourceStore, _EventEmitter);

	  function ResourceStore(data) {
	    var _this;

	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
	      ns: ['translation'],
	      defaultNS: 'translation'
	    };

	    _classCallCheck(this, ResourceStore);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore).call(this));
	    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

	    _this.data = data || {};
	    _this.options = options;

	    if (_this.options.keySeparator === undefined) {
	      _this.options.keySeparator = '.';
	    }

	    return _this;
	  }

	  _createClass(ResourceStore, [{
	    key: "addNamespaces",
	    value: function addNamespaces(ns) {
	      if (this.options.ns.indexOf(ns) < 0) {
	        this.options.ns.push(ns);
	      }
	    }
	  }, {
	    key: "removeNamespaces",
	    value: function removeNamespaces(ns) {
	      var index = this.options.ns.indexOf(ns);

	      if (index > -1) {
	        this.options.ns.splice(index, 1);
	      }
	    }
	  }, {
	    key: "getResource",
	    value: function getResource(lng, ns, key) {
	      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
	      var path = [lng, ns];
	      if (key && typeof key !== 'string') path = path.concat(key);
	      if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);

	      if (lng.indexOf('.') > -1) {
	        path = lng.split('.');
	      }

	      return getPath(this.data, path);
	    }
	  }, {
	    key: "addResource",
	    value: function addResource(lng, ns, key, value) {
	      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
	        silent: false
	      };
	      var keySeparator = this.options.keySeparator;
	      if (keySeparator === undefined) keySeparator = '.';
	      var path = [lng, ns];
	      if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

	      if (lng.indexOf('.') > -1) {
	        path = lng.split('.');
	        value = ns;
	        ns = path[1];
	      }

	      this.addNamespaces(ns);
	      setPath(this.data, path, value);
	      if (!options.silent) this.emit('added', lng, ns, key, value);
	    }
	  }, {
	    key: "addResources",
	    value: function addResources(lng, ns, resources) {
	      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
	        silent: false
	      };
	      /* eslint no-restricted-syntax: 0 */

	      for (var m in resources) {
	        if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
	          silent: true
	        });
	      }

	      if (!options.silent) this.emit('added', lng, ns, resources);
	    }
	  }, {
	    key: "addResourceBundle",
	    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
	      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
	        silent: false
	      };
	      var path = [lng, ns];

	      if (lng.indexOf('.') > -1) {
	        path = lng.split('.');
	        deep = resources;
	        resources = ns;
	        ns = path[1];
	      }

	      this.addNamespaces(ns);
	      var pack = getPath(this.data, path) || {};

	      if (deep) {
	        deepExtend(pack, resources, overwrite);
	      } else {
	        pack = _objectSpread({}, pack, resources);
	      }

	      setPath(this.data, path, pack);
	      if (!options.silent) this.emit('added', lng, ns, resources);
	    }
	  }, {
	    key: "removeResourceBundle",
	    value: function removeResourceBundle(lng, ns) {
	      if (this.hasResourceBundle(lng, ns)) {
	        delete this.data[lng][ns];
	      }

	      this.removeNamespaces(ns);
	      this.emit('removed', lng, ns);
	    }
	  }, {
	    key: "hasResourceBundle",
	    value: function hasResourceBundle(lng, ns) {
	      return this.getResource(lng, ns) !== undefined;
	    }
	  }, {
	    key: "getResourceBundle",
	    value: function getResourceBundle(lng, ns) {
	      if (!ns) ns = this.options.defaultNS; // COMPATIBILITY: remove extend in v2.1.0

	      if (this.options.compatibilityAPI === 'v1') return _objectSpread({}, {}, this.getResource(lng, ns));
	      return this.getResource(lng, ns);
	    }
	  }, {
	    key: "getDataByLanguage",
	    value: function getDataByLanguage(lng) {
	      return this.data[lng];
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      return this.data;
	    }
	  }]);

	  return ResourceStore;
	}(EventEmitter);

	var postProcessor = {
	  processors: {},
	  addPostProcessor: function addPostProcessor(module) {
	    this.processors[module.name] = module;
	  },
	  handle: function handle(processors, value, key, options, translator) {
	    var _this = this;

	    processors.forEach(function (processor) {
	      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
	    });
	    return value;
	  }
	};

	var Translator = /*#__PURE__*/function (_EventEmitter) {
	  _inherits(Translator, _EventEmitter);

	  function Translator(services) {
	    var _this;

	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Translator);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator).call(this));
	    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

	    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, _assertThisInitialized(_this));
	    _this.options = options;

	    if (_this.options.keySeparator === undefined) {
	      _this.options.keySeparator = '.';
	    }

	    _this.logger = baseLogger.create('translator');
	    return _this;
	  }

	  _createClass(Translator, [{
	    key: "changeLanguage",
	    value: function changeLanguage(lng) {
	      if (lng) this.language = lng;
	    }
	  }, {
	    key: "exists",
	    value: function exists(key) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
	        interpolation: {}
	      };
	      var resolved = this.resolve(key, options);
	      return resolved && resolved.res !== undefined;
	    }
	  }, {
	    key: "extractFromKey",
	    value: function extractFromKey(key, options) {
	      var nsSeparator = options.nsSeparator || this.options.nsSeparator;
	      if (nsSeparator === undefined) nsSeparator = ':';
	      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
	      var namespaces = options.ns || this.options.defaultNS;

	      if (nsSeparator && key.indexOf(nsSeparator) > -1) {
	        var parts = key.split(nsSeparator);
	        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
	        key = parts.join(keySeparator);
	      }

	      if (typeof namespaces === 'string') namespaces = [namespaces];
	      return {
	        key: key,
	        namespaces: namespaces
	      };
	    }
	  }, {
	    key: "translate",
	    value: function translate(keys, options) {
	      var _this2 = this;

	      if (_typeof(options) !== 'object' && this.options.overloadTranslationOptionHandler) {
	        /* eslint prefer-rest-params: 0 */
	        options = this.options.overloadTranslationOptionHandler(arguments);
	      }

	      if (!options) options = {}; // non valid keys handling

	      if (keys === undefined || keys === null) return '';
	      if (!Array.isArray(keys)) keys = [String(keys)]; // separators

	      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator; // get namespace(s)

	      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
	          key = _this$extractFromKey.key,
	          namespaces = _this$extractFromKey.namespaces;

	      var namespace = namespaces[namespaces.length - 1]; // return key on CIMode

	      var lng = options.lng || this.language;
	      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;

	      if (lng && lng.toLowerCase() === 'cimode') {
	        if (appendNamespaceToCIMode) {
	          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
	          return namespace + nsSeparator + key;
	        }

	        return key;
	      } // resolve from store


	      var resolved = this.resolve(keys, options);
	      var res = resolved && resolved.res;
	      var resUsedKey = resolved && resolved.usedKey || key;
	      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
	      var resType = Object.prototype.toString.apply(res);
	      var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
	      var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays; // object

	      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
	      var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';

	      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
	        if (!options.returnObjects && !this.options.returnObjects) {
	          this.logger.warn('accessing an object - but returnObjects options is not enabled!');
	          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
	        } // if we got a separator we loop over children - else we just return object as is
	        // as having it set to false means no hierarchy so no lookup for nested values


	        if (keySeparator) {
	          var resTypeIsArray = resType === '[object Array]';
	          var copy$$1 = resTypeIsArray ? [] : {}; // apply child translation on a copy

	          /* eslint no-restricted-syntax: 0 */

	          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;

	          for (var m in res) {
	            if (Object.prototype.hasOwnProperty.call(res, m)) {
	              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
	              copy$$1[m] = this.translate(deepKey, _objectSpread({}, options, {
	                joinArrays: false,
	                ns: namespaces
	              }));
	              if (copy$$1[m] === deepKey) copy$$1[m] = res[m]; // if nothing found use orginal value as fallback
	            }
	          }

	          res = copy$$1;
	        }
	      } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
	        // array special treatment
	        res = res.join(joinArrays);
	        if (res) res = this.extendTranslation(res, keys, options);
	      } else {
	        // string, empty or null
	        var usedDefault = false;
	        var usedKey = false; // fallback value

	        if (!this.isValidLookup(res) && options.defaultValue !== undefined) {
	          usedDefault = true;

	          if (options.count !== undefined) {
	            var suffix = this.pluralResolver.getSuffix(lng, options.count);
	            res = options["defaultValue".concat(suffix)];
	          }

	          if (!res) res = options.defaultValue;
	        }

	        if (!this.isValidLookup(res)) {
	          usedKey = true;
	          res = key;
	        } // save missing


	        var updateMissing = options.defaultValue && options.defaultValue !== res && this.options.updateMissing;

	        if (usedKey || usedDefault || updateMissing) {
	          this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? options.defaultValue : res);
	          var lngs = [];
	          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);

	          if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
	            for (var i = 0; i < fallbackLngs.length; i++) {
	              lngs.push(fallbackLngs[i]);
	            }
	          } else if (this.options.saveMissingTo === 'all') {
	            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
	          } else {
	            lngs.push(options.lng || this.language);
	          }

	          var send = function send(l, k) {
	            if (_this2.options.missingKeyHandler) {
	              _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
	            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
	              _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
	            }

	            _this2.emit('missingKey', l, namespace, k, res);
	          };

	          if (this.options.saveMissing) {
	            var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';

	            if (this.options.saveMissingPlurals && needsPluralHandling) {
	              lngs.forEach(function (l) {
	                var plurals = _this2.pluralResolver.getPluralFormsOfKey(l, key);

	                plurals.forEach(function (p) {
	                  return send([l], p);
	                });
	              });
	            } else {
	              send(lngs, key);
	            }
	          }
	        } // extend


	        res = this.extendTranslation(res, keys, options, resolved); // append namespace if still key

	        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key); // parseMissingKeyHandler

	        if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
	      } // return


	      return res;
	    }
	  }, {
	    key: "extendTranslation",
	    value: function extendTranslation(res, key, options, resolved) {
	      var _this3 = this;

	      if (this.i18nFormat && this.i18nFormat.parse) {
	        res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
	          resolved: resolved
	        });
	      } else if (!options.skipInterpolation) {
	        // i18next.parsing
	        if (options.interpolation) this.interpolator.init(_objectSpread({}, options, {
	          interpolation: _objectSpread({}, this.options.interpolation, options.interpolation)
	        })); // interpolate

	        var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
	        if (this.options.interpolation.defaultVariables) data = _objectSpread({}, this.options.interpolation.defaultVariables, data);
	        res = this.interpolator.interpolate(res, data, options.lng || this.language, options); // nesting

	        if (options.nest !== false) res = this.interpolator.nest(res, function () {
	          return _this3.translate.apply(_this3, arguments);
	        }, options);
	        if (options.interpolation) this.interpolator.reset();
	      } // post process


	      var postProcess = options.postProcess || this.options.postProcess;
	      var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

	      if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
	        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread({
	          i18nResolved: resolved
	        }, options) : options, this);
	      }

	      return res;
	    }
	  }, {
	    key: "resolve",
	    value: function resolve(keys) {
	      var _this4 = this;

	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var found;
	      var usedKey; // plain key

	      var exactUsedKey; // key with context / plural

	      var usedLng;
	      var usedNS;
	      if (typeof keys === 'string') keys = [keys]; // forEach possible key

	      keys.forEach(function (k) {
	        if (_this4.isValidLookup(found)) return;

	        var extracted = _this4.extractFromKey(k, options);

	        var key = extracted.key;
	        usedKey = key;
	        var namespaces = extracted.namespaces;
	        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
	        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
	        var needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';
	        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
	        namespaces.forEach(function (ns) {
	          if (_this4.isValidLookup(found)) return;
	          usedNS = ns;

	          if (_this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
	            _this4.logger.warn("key \"".concat(usedKey, "\" for namespace \"").concat(usedNS, "\" won't get resolved as namespace was not yet loaded"), 'This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
	          }

	          codes.forEach(function (code) {
	            if (_this4.isValidLookup(found)) return;
	            usedLng = code;
	            var finalKey = key;
	            var finalKeys = [finalKey];

	            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
	              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
	            } else {
	              var pluralSuffix;
	              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count); // fallback for plural if context not found

	              if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix); // get key for context if needed

	              if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options.context)); // get key for plural if needed

	              if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
	            } // iterate over finalKeys starting with most specific pluralkey (-> contextkey only) -> singularkey only


	            var possibleKey;
	            /* eslint no-cond-assign: 0 */

	            while (possibleKey = finalKeys.pop()) {
	              if (!_this4.isValidLookup(found)) {
	                exactUsedKey = possibleKey;
	                found = _this4.getResource(code, ns, possibleKey, options);
	              }
	            }
	          });
	        });
	      });
	      return {
	        res: found,
	        usedKey: usedKey,
	        exactUsedKey: exactUsedKey,
	        usedLng: usedLng,
	        usedNS: usedNS
	      };
	    }
	  }, {
	    key: "isValidLookup",
	    value: function isValidLookup(res) {
	      return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
	    }
	  }, {
	    key: "getResource",
	    value: function getResource(code, ns, key) {
	      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
	      return this.resourceStore.getResource(code, ns, key, options);
	    }
	  }]);

	  return Translator;
	}(EventEmitter);

	function capitalize(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

	var LanguageUtil = /*#__PURE__*/function () {
	  function LanguageUtil(options) {
	    _classCallCheck(this, LanguageUtil);

	    this.options = options;
	    this.whitelist = this.options.whitelist || false;
	    this.logger = baseLogger.create('languageUtils');
	  }

	  _createClass(LanguageUtil, [{
	    key: "getScriptPartFromCode",
	    value: function getScriptPartFromCode(code) {
	      if (!code || code.indexOf('-') < 0) return null;
	      var p = code.split('-');
	      if (p.length === 2) return null;
	      p.pop();
	      return this.formatLanguageCode(p.join('-'));
	    }
	  }, {
	    key: "getLanguagePartFromCode",
	    value: function getLanguagePartFromCode(code) {
	      if (!code || code.indexOf('-') < 0) return code;
	      var p = code.split('-');
	      return this.formatLanguageCode(p[0]);
	    }
	  }, {
	    key: "formatLanguageCode",
	    value: function formatLanguageCode(code) {
	      // http://www.iana.org/assignments/language-tags/language-tags.xhtml
	      if (typeof code === 'string' && code.indexOf('-') > -1) {
	        var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
	        var p = code.split('-');

	        if (this.options.lowerCaseLng) {
	          p = p.map(function (part) {
	            return part.toLowerCase();
	          });
	        } else if (p.length === 2) {
	          p[0] = p[0].toLowerCase();
	          p[1] = p[1].toUpperCase();
	          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
	        } else if (p.length === 3) {
	          p[0] = p[0].toLowerCase(); // if lenght 2 guess it's a country

	          if (p[1].length === 2) p[1] = p[1].toUpperCase();
	          if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
	          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
	          if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
	        }

	        return p.join('-');
	      }

	      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
	    }
	  }, {
	    key: "isWhitelisted",
	    value: function isWhitelisted(code) {
	      if (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist) {
	        code = this.getLanguagePartFromCode(code);
	      }

	      return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code) > -1;
	    }
	  }, {
	    key: "getFallbackCodes",
	    value: function getFallbackCodes(fallbacks, code) {
	      if (!fallbacks) return [];
	      if (typeof fallbacks === 'string') fallbacks = [fallbacks];
	      if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
	      if (!code) return fallbacks["default"] || []; // asume we have an object defining fallbacks

	      var found = fallbacks[code];
	      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
	      if (!found) found = fallbacks[this.formatLanguageCode(code)];
	      if (!found) found = fallbacks["default"];
	      return found || [];
	    }
	  }, {
	    key: "toResolveHierarchy",
	    value: function toResolveHierarchy(code, fallbackCode) {
	      var _this = this;

	      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
	      var codes = [];

	      var addCode = function addCode(c) {
	        if (!c) return;

	        if (_this.isWhitelisted(c)) {
	          codes.push(c);
	        } else {
	          _this.logger.warn("rejecting non-whitelisted language code: ".concat(c));
	        }
	      };

	      if (typeof code === 'string' && code.indexOf('-') > -1) {
	        if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
	        if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
	        if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
	      } else if (typeof code === 'string') {
	        addCode(this.formatLanguageCode(code));
	      }

	      fallbackCodes.forEach(function (fc) {
	        if (codes.indexOf(fc) < 0) addCode(_this.formatLanguageCode(fc));
	      });
	      return codes;
	    }
	  }]);

	  return LanguageUtil;
	}();
	/* eslint-disable */


	var sets = [{
	  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'ti', 'tr', 'uz', 'wa'],
	  nr: [1, 2],
	  fc: 1
	}, {
	  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
	  nr: [1, 2],
	  fc: 2
	}, {
	  lngs: ['ay', 'bo', 'cgg', 'fa', 'id', 'ja', 'jbo', 'ka', 'kk', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
	  nr: [1],
	  fc: 3
	}, {
	  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
	  nr: [1, 2, 5],
	  fc: 4
	}, {
	  lngs: ['ar'],
	  nr: [0, 1, 2, 3, 11, 100],
	  fc: 5
	}, {
	  lngs: ['cs', 'sk'],
	  nr: [1, 2, 5],
	  fc: 6
	}, {
	  lngs: ['csb', 'pl'],
	  nr: [1, 2, 5],
	  fc: 7
	}, {
	  lngs: ['cy'],
	  nr: [1, 2, 3, 8],
	  fc: 8
	}, {
	  lngs: ['fr'],
	  nr: [1, 2],
	  fc: 9
	}, {
	  lngs: ['ga'],
	  nr: [1, 2, 3, 7, 11],
	  fc: 10
	}, {
	  lngs: ['gd'],
	  nr: [1, 2, 3, 20],
	  fc: 11
	}, {
	  lngs: ['is'],
	  nr: [1, 2],
	  fc: 12
	}, {
	  lngs: ['jv'],
	  nr: [0, 1],
	  fc: 13
	}, {
	  lngs: ['kw'],
	  nr: [1, 2, 3, 4],
	  fc: 14
	}, {
	  lngs: ['lt'],
	  nr: [1, 2, 10],
	  fc: 15
	}, {
	  lngs: ['lv'],
	  nr: [1, 2, 0],
	  fc: 16
	}, {
	  lngs: ['mk'],
	  nr: [1, 2],
	  fc: 17
	}, {
	  lngs: ['mnk'],
	  nr: [0, 1, 2],
	  fc: 18
	}, {
	  lngs: ['mt'],
	  nr: [1, 2, 11, 20],
	  fc: 19
	}, {
	  lngs: ['or'],
	  nr: [2, 1],
	  fc: 2
	}, {
	  lngs: ['ro'],
	  nr: [1, 2, 20],
	  fc: 20
	}, {
	  lngs: ['sl'],
	  nr: [5, 1, 2, 3],
	  fc: 21
	}, {
	  lngs: ['he'],
	  nr: [1, 2, 20, 21],
	  fc: 22
	}];
	var _rulesPluralsTypes = {
	  1: function _(n) {
	    return Number(n > 1);
	  },
	  2: function _(n) {
	    return Number(n != 1);
	  },
	  3: function _(n) {
	    return 0;
	  },
	  4: function _(n) {
	    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
	  },
	  5: function _(n) {
	    return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
	  },
	  6: function _(n) {
	    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
	  },
	  7: function _(n) {
	    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
	  },
	  8: function _(n) {
	    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
	  },
	  9: function _(n) {
	    return Number(n >= 2);
	  },
	  10: function _(n) {
	    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
	  },
	  11: function _(n) {
	    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
	  },
	  12: function _(n) {
	    return Number(n % 10 != 1 || n % 100 == 11);
	  },
	  13: function _(n) {
	    return Number(n !== 0);
	  },
	  14: function _(n) {
	    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
	  },
	  15: function _(n) {
	    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
	  },
	  16: function _(n) {
	    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
	  },
	  17: function _(n) {
	    return Number(n == 1 || n % 10 == 1 ? 0 : 1);
	  },
	  18: function _(n) {
	    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
	  },
	  19: function _(n) {
	    return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
	  },
	  20: function _(n) {
	    return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
	  },
	  21: function _(n) {
	    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
	  },
	  22: function _(n) {
	    return Number(n === 1 ? 0 : n === 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
	  }
	};
	/* eslint-enable */

	function createRules() {
	  var rules = {};
	  sets.forEach(function (set) {
	    set.lngs.forEach(function (l) {
	      rules[l] = {
	        numbers: set.nr,
	        plurals: _rulesPluralsTypes[set.fc]
	      };
	    });
	  });
	  return rules;
	}

	var PluralResolver = /*#__PURE__*/function () {
	  function PluralResolver(languageUtils) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, PluralResolver);

	    this.languageUtils = languageUtils;
	    this.options = options;
	    this.logger = baseLogger.create('pluralResolver');
	    this.rules = createRules();
	  }

	  _createClass(PluralResolver, [{
	    key: "addRule",
	    value: function addRule(lng, obj) {
	      this.rules[lng] = obj;
	    }
	  }, {
	    key: "getRule",
	    value: function getRule(code) {
	      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
	    }
	  }, {
	    key: "needsPlural",
	    value: function needsPlural(code) {
	      var rule = this.getRule(code);
	      return rule && rule.numbers.length > 1;
	    }
	  }, {
	    key: "getPluralFormsOfKey",
	    value: function getPluralFormsOfKey(code, key) {
	      var _this = this;

	      var ret = [];
	      var rule = this.getRule(code);
	      if (!rule) return ret;
	      rule.numbers.forEach(function (n) {
	        var suffix = _this.getSuffix(code, n);

	        ret.push("".concat(key).concat(suffix));
	      });
	      return ret;
	    }
	  }, {
	    key: "getSuffix",
	    value: function getSuffix(code, count) {
	      var _this2 = this;

	      var rule = this.getRule(code);

	      if (rule) {
	        // if (rule.numbers.length === 1) return ''; // only singular
	        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
	        var suffix = rule.numbers[idx]; // special treatment for lngs only having singular and plural

	        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
	          if (suffix === 2) {
	            suffix = 'plural';
	          } else if (suffix === 1) {
	            suffix = '';
	          }
	        }

	        var returnSuffix = function returnSuffix() {
	          return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
	        }; // COMPATIBILITY JSON
	        // v1


	        if (this.options.compatibilityJSON === 'v1') {
	          if (suffix === 1) return '';
	          if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
	          return returnSuffix();
	        } else if (
	        /* v2 */
	        this.options.compatibilityJSON === 'v2') {
	          return returnSuffix();
	        } else if (
	        /* v3 - gettext index */
	        this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
	          return returnSuffix();
	        }

	        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
	      }

	      this.logger.warn("no plural rule found for: ".concat(code));
	      return '';
	    }
	  }]);

	  return PluralResolver;
	}();

	var Interpolator = /*#__PURE__*/function () {
	  function Interpolator() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, Interpolator);

	    this.logger = baseLogger.create('interpolator');
	    this.options = options;

	    this.format = options.interpolation && options.interpolation.format || function (value) {
	      return value;
	    };

	    this.init(options);
	  }
	  /* eslint no-param-reassign: 0 */


	  _createClass(Interpolator, [{
	    key: "init",
	    value: function init() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      if (!options.interpolation) options.interpolation = {
	        escapeValue: true
	      };
	      var iOpts = options.interpolation;
	      this.escape = iOpts.escape !== undefined ? iOpts.escape : escape$1;
	      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
	      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
	      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
	      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
	      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
	      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
	      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
	      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
	      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
	      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000; // the regexp

	      this.resetRegExp();
	    }
	  }, {
	    key: "reset",
	    value: function reset() {
	      if (this.options) this.init(this.options);
	    }
	  }, {
	    key: "resetRegExp",
	    value: function resetRegExp() {
	      // the regexp
	      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
	      this.regexp = new RegExp(regexpStr, 'g');
	      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
	      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
	      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
	      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
	    }
	  }, {
	    key: "interpolate",
	    value: function interpolate(str, data, lng, options) {
	      var _this = this;

	      var match;
	      var value;
	      var replaces;
	      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

	      function regexSafe(val) {
	        return val.replace(/\$/g, '$$$$');
	      }

	      var handleFormat = function handleFormat(key) {
	        if (key.indexOf(_this.formatSeparator) < 0) {
	          return getPathWithDefaults(data, defaultData, key);
	        }

	        var p = key.split(_this.formatSeparator);
	        var k = p.shift().trim();
	        var f = p.join(_this.formatSeparator).trim();
	        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng);
	      };

	      this.resetRegExp();
	      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
	      replaces = 0; // unescape if has unescapePrefix/Suffix

	      /* eslint no-cond-assign: 0 */

	      while (match = this.regexpUnescape.exec(str)) {
	        value = handleFormat(match[1].trim());

	        if (value === undefined) {
	          if (typeof missingInterpolationHandler === 'function') {
	            var temp = missingInterpolationHandler(str, match, options);
	            value = typeof temp === 'string' ? temp : '';
	          } else {
	            this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
	            value = '';
	          }
	        } else if (typeof value !== 'string' && !this.useRawValueToEscape) {
	          value = makeString(value);
	        }

	        str = str.replace(match[0], regexSafe(value));
	        this.regexpUnescape.lastIndex = 0;
	        replaces++;

	        if (replaces >= this.maxReplaces) {
	          break;
	        }
	      }

	      replaces = 0; // regular escape on demand

	      while (match = this.regexp.exec(str)) {
	        value = handleFormat(match[1].trim());

	        if (value === undefined) {
	          if (typeof missingInterpolationHandler === 'function') {
	            var _temp = missingInterpolationHandler(str, match, options);

	            value = typeof _temp === 'string' ? _temp : '';
	          } else {
	            this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
	            value = '';
	          }
	        } else if (typeof value !== 'string' && !this.useRawValueToEscape) {
	          value = makeString(value);
	        }

	        value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);
	        str = str.replace(match[0], value);
	        this.regexp.lastIndex = 0;
	        replaces++;

	        if (replaces >= this.maxReplaces) {
	          break;
	        }
	      }

	      return str;
	    }
	  }, {
	    key: "nest",
	    value: function nest(str, fc) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var match;
	      var value;

	      var clonedOptions = _objectSpread({}, options);

	      clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup

	      delete clonedOptions.defaultValue; // assert we do not get a endless loop on interpolating defaultValue again and again
	      // if value is something like "myKey": "lorem $(anotherKey, { "count": {{aValueInOptions}} })"

	      function handleHasOptions(key, inheritedOptions) {
	        if (key.indexOf(',') < 0) return key;
	        var p = key.split(',');
	        key = p.shift();
	        var optionsString = p.join(',');
	        optionsString = this.interpolate(optionsString, clonedOptions);
	        optionsString = optionsString.replace(/'/g, '"');

	        try {
	          clonedOptions = JSON.parse(optionsString);
	          if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
	        } catch (e) {
	          this.logger.error("failed parsing options string in nesting for key ".concat(key), e);
	        } // assert we do not get a endless loop on interpolating defaultValue again and again


	        delete clonedOptions.defaultValue;
	        return key;
	      } // regular escape on demand


	      while (match = this.nestingRegexp.exec(str)) {
	        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions); // is only the nesting key (key1 = '$(key2)') return the value without stringify

	        if (value && match[0] === str && typeof value !== 'string') return value; // no string to include or empty

	        if (typeof value !== 'string') value = makeString(value);

	        if (!value) {
	          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
	          value = '';
	        } // Nested keys should not be escaped by default #854
	        // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);


	        str = str.replace(match[0], value);
	        this.regexp.lastIndex = 0;
	      }

	      return str;
	    }
	  }]);

	  return Interpolator;
	}();

	function remove(arr, what) {
	  var found = arr.indexOf(what);

	  while (found !== -1) {
	    arr.splice(found, 1);
	    found = arr.indexOf(what);
	  }
	}

	var Connector = /*#__PURE__*/function (_EventEmitter) {
	  _inherits(Connector, _EventEmitter);

	  function Connector(backend, store, services) {
	    var _this;

	    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

	    _classCallCheck(this, Connector);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector).call(this));
	    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

	    _this.backend = backend;
	    _this.store = store;
	    _this.services = services;
	    _this.languageUtils = services.languageUtils;
	    _this.options = options;
	    _this.logger = baseLogger.create('backendConnector');
	    _this.state = {};
	    _this.queue = [];

	    if (_this.backend && _this.backend.init) {
	      _this.backend.init(services, options.backend, options);
	    }

	    return _this;
	  }

	  _createClass(Connector, [{
	    key: "queueLoad",
	    value: function queueLoad(languages, namespaces, options, callback) {
	      var _this2 = this; // find what needs to be loaded


	      var toLoad = [];
	      var pending = [];
	      var toLoadLanguages = [];
	      var toLoadNamespaces = [];
	      languages.forEach(function (lng) {
	        var hasAllNamespaces = true;
	        namespaces.forEach(function (ns) {
	          var name = "".concat(lng, "|").concat(ns);

	          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
	            _this2.state[name] = 2; // loaded
	          } else if (_this2.state[name] < 0) ;else if (_this2.state[name] === 1) {
	            if (pending.indexOf(name) < 0) pending.push(name);
	          } else {
	            _this2.state[name] = 1; // pending

	            hasAllNamespaces = false;
	            if (pending.indexOf(name) < 0) pending.push(name);
	            if (toLoad.indexOf(name) < 0) toLoad.push(name);
	            if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
	          }
	        });
	        if (!hasAllNamespaces) toLoadLanguages.push(lng);
	      });

	      if (toLoad.length || pending.length) {
	        this.queue.push({
	          pending: pending,
	          loaded: {},
	          errors: [],
	          callback: callback
	        });
	      }

	      return {
	        toLoad: toLoad,
	        pending: pending,
	        toLoadLanguages: toLoadLanguages,
	        toLoadNamespaces: toLoadNamespaces
	      };
	    }
	  }, {
	    key: "loaded",
	    value: function loaded(name, err, data) {
	      var _name$split = name.split('|'),
	          _name$split2 = _slicedToArray(_name$split, 2),
	          lng = _name$split2[0],
	          ns = _name$split2[1];

	      if (err) this.emit('failedLoading', lng, ns, err);

	      if (data) {
	        this.store.addResourceBundle(lng, ns, data);
	      } // set loaded


	      this.state[name] = err ? -1 : 2; // consolidated loading done in this run - only emit once for a loaded namespace

	      var loaded = {}; // callback if ready

	      this.queue.forEach(function (q) {
	        pushPath(q.loaded, [lng], ns);
	        remove(q.pending, name);
	        if (err) q.errors.push(err);

	        if (q.pending.length === 0 && !q.done) {
	          // only do once per loaded -> this.emit('loaded', q.loaded);
	          Object.keys(q.loaded).forEach(function (l) {
	            if (!loaded[l]) loaded[l] = [];

	            if (q.loaded[l].length) {
	              q.loaded[l].forEach(function (ns) {
	                if (loaded[l].indexOf(ns) < 0) loaded[l].push(ns);
	              });
	            }
	          });
	          /* eslint no-param-reassign: 0 */

	          q.done = true;

	          if (q.errors.length) {
	            q.callback(q.errors);
	          } else {
	            q.callback();
	          }
	        }
	      }); // emit consolidated loaded event

	      this.emit('loaded', loaded); // remove done load requests

	      this.queue = this.queue.filter(function (q) {
	        return !q.done;
	      });
	    }
	  }, {
	    key: "read",
	    value: function read(lng, ns, fcName) {
	      var _this3 = this;

	      var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	      var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;
	      var callback = arguments.length > 5 ? arguments[5] : undefined;
	      if (!lng.length) return callback(null, {}); // noting to load

	      return this.backend[fcName](lng, ns, function (err, data) {
	        if (err && data
	        /* = retryFlag */
	        && tried < 5) {
	          setTimeout(function () {
	            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
	          }, wait);
	          return;
	        }

	        callback(err, data);
	      });
	    }
	    /* eslint consistent-return: 0 */

	  }, {
	    key: "prepareLoading",
	    value: function prepareLoading(languages, namespaces) {
	      var _this4 = this;

	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var callback = arguments.length > 3 ? arguments[3] : undefined;

	      if (!this.backend) {
	        this.logger.warn('No backend was added via i18next.use. Will not load resources.');
	        return callback && callback();
	      }

	      if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
	      if (typeof namespaces === 'string') namespaces = [namespaces];
	      var toLoad = this.queueLoad(languages, namespaces, options, callback);

	      if (!toLoad.toLoad.length) {
	        if (!toLoad.pending.length) callback(); // nothing to load and no pendings...callback now

	        return null; // pendings will trigger callback
	      }

	      toLoad.toLoad.forEach(function (name) {
	        _this4.loadOne(name);
	      });
	    }
	  }, {
	    key: "load",
	    value: function load(languages, namespaces, callback) {
	      this.prepareLoading(languages, namespaces, {}, callback);
	    }
	  }, {
	    key: "reload",
	    value: function reload(languages, namespaces, callback) {
	      this.prepareLoading(languages, namespaces, {
	        reload: true
	      }, callback);
	    }
	  }, {
	    key: "loadOne",
	    value: function loadOne(name) {
	      var _this5 = this;

	      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

	      var _name$split3 = name.split('|'),
	          _name$split4 = _slicedToArray(_name$split3, 2),
	          lng = _name$split4[0],
	          ns = _name$split4[1];

	      this.read(lng, ns, 'read', null, null, function (err, data) {
	        if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
	        if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);

	        _this5.loaded(name, err, data);
	      });
	    }
	  }, {
	    key: "saveMissing",
	    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
	      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

	      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
	        this.logger.warn("did not save key \"".concat(key, "\" for namespace \"").concat(namespace, "\" as the namespace was not yet loaded"), 'This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
	        return;
	      }

	      if (this.backend && this.backend.create) {
	        this.backend.create(languages, namespace, key, fallbackValue, null
	        /* unused callback */
	        , _objectSpread({}, options, {
	          isUpdate: isUpdate
	        }));
	      } // write to store to avoid resending


	      if (!languages || !languages[0]) return;
	      this.store.addResource(languages[0], namespace, key, fallbackValue);
	    }
	  }]);

	  return Connector;
	}(EventEmitter);

	function get() {
	  return {
	    debug: false,
	    initImmediate: true,
	    ns: ['translation'],
	    defaultNS: ['translation'],
	    fallbackLng: ['dev'],
	    fallbackNS: false,
	    // string or array of namespaces
	    whitelist: false,
	    // array with whitelisted languages
	    nonExplicitWhitelist: false,
	    load: 'all',
	    // | currentOnly | languageOnly
	    preload: false,
	    // array with preload languages
	    simplifyPluralSuffix: true,
	    keySeparator: '.',
	    nsSeparator: ':',
	    pluralSeparator: '_',
	    contextSeparator: '_',
	    partialBundledLanguages: false,
	    // allow bundling certain languages that are not remotely fetched
	    saveMissing: false,
	    // enable to send missing values
	    updateMissing: false,
	    // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
	    saveMissingTo: 'fallback',
	    // 'current' || 'all'
	    saveMissingPlurals: true,
	    // will save all forms not only singular key
	    missingKeyHandler: false,
	    // function(lng, ns, key, fallbackValue) -> override if prefer on handling
	    missingInterpolationHandler: false,
	    // function(str, match)
	    postProcess: false,
	    // string or array of postProcessor names
	    postProcessPassResolved: false,
	    // pass resolved object into 'options.i18nResolved' for postprocessor
	    returnNull: true,
	    // allows null value as valid translation
	    returnEmptyString: true,
	    // allows empty string value as valid translation
	    returnObjects: false,
	    joinArrays: false,
	    // or string to join array
	    returnedObjectHandler: false,
	    // function(key, value, options) triggered if key returns object but returnObjects is set to false
	    parseMissingKeyHandler: false,
	    // function(key) parsed a key that was not found in t() before returning
	    appendNamespaceToMissingKey: false,
	    appendNamespaceToCIMode: false,
	    overloadTranslationOptionHandler: function handle(args) {
	      var ret = {};
	      if (_typeof(args[1]) === 'object') ret = args[1];
	      if (typeof args[1] === 'string') ret.defaultValue = args[1];
	      if (typeof args[2] === 'string') ret.tDescription = args[2];

	      if (_typeof(args[2]) === 'object' || _typeof(args[3]) === 'object') {
	        var options = args[3] || args[2];
	        Object.keys(options).forEach(function (key) {
	          ret[key] = options[key];
	        });
	      }

	      return ret;
	    },
	    interpolation: {
	      escapeValue: true,
	      format: function format(value, _format, lng) {
	        return value;
	      },
	      prefix: '{{',
	      suffix: '}}',
	      formatSeparator: ',',
	      // prefixEscaped: '{{',
	      // suffixEscaped: '}}',
	      // unescapeSuffix: '',
	      unescapePrefix: '-',
	      nestingPrefix: '$t(',
	      nestingSuffix: ')',
	      // nestingPrefixEscaped: '$t(',
	      // nestingSuffixEscaped: ')',
	      // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
	      maxReplaces: 1000 // max replaces to prevent endless loop

	    }
	  };
	}
	/* eslint no-param-reassign: 0 */


	function transformOptions(options) {
	  // create namespace object if namespace is passed in as string
	  if (typeof options.ns === 'string') options.ns = [options.ns];
	  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
	  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS]; // extend whitelist with cimode

	  if (options.whitelist && options.whitelist.indexOf('cimode') < 0) {
	    options.whitelist = options.whitelist.concat(['cimode']);
	  }

	  return options;
	}

	function noop() {}

	var I18n = /*#__PURE__*/function (_EventEmitter) {
	  _inherits(I18n, _EventEmitter);

	  function I18n() {
	    var _this;

	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var callback = arguments.length > 1 ? arguments[1] : undefined;

	    _classCallCheck(this, I18n);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n).call(this));
	    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

	    _this.options = transformOptions(options);
	    _this.services = {};
	    _this.logger = baseLogger;
	    _this.modules = {
	      external: []
	    };

	    if (callback && !_this.isInitialized && !options.isClone) {
	      // https://github.com/i18next/i18next/issues/879
	      if (!_this.options.initImmediate) {
	        _this.init(options, callback);

	        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
	      }

	      setTimeout(function () {
	        _this.init(options, callback);
	      }, 0);
	    }

	    return _this;
	  }

	  _createClass(I18n, [{
	    key: "init",
	    value: function init() {
	      var _this2 = this;

	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var callback = arguments.length > 1 ? arguments[1] : undefined;

	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }

	      this.options = _objectSpread({}, get(), this.options, transformOptions(options));
	      this.format = this.options.interpolation.format;
	      if (!callback) callback = noop;

	      function createClassOnDemand(ClassOrObject) {
	        if (!ClassOrObject) return null;
	        if (typeof ClassOrObject === 'function') return new ClassOrObject();
	        return ClassOrObject;
	      } // init services


	      if (!this.options.isClone) {
	        if (this.modules.logger) {
	          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
	        } else {
	          baseLogger.init(null, this.options);
	        }

	        var lu = new LanguageUtil(this.options);
	        this.store = new ResourceStore(this.options.resources, this.options);
	        var s = this.services;
	        s.logger = baseLogger;
	        s.resourceStore = this.store;
	        s.languageUtils = lu;
	        s.pluralResolver = new PluralResolver(lu, {
	          prepend: this.options.pluralSeparator,
	          compatibilityJSON: this.options.compatibilityJSON,
	          simplifyPluralSuffix: this.options.simplifyPluralSuffix
	        });
	        s.interpolator = new Interpolator(this.options);
	        s.utils = {
	          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
	        };
	        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options); // pipe events from backendConnector

	        s.backendConnector.on('*', function (event) {
	          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            args[_key - 1] = arguments[_key];
	          }

	          _this2.emit.apply(_this2, [event].concat(args));
	        });

	        if (this.modules.languageDetector) {
	          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
	          s.languageDetector.init(s, this.options.detection, this.options);
	        }

	        if (this.modules.i18nFormat) {
	          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
	          if (s.i18nFormat.init) s.i18nFormat.init(this);
	        }

	        this.translator = new Translator(this.services, this.options); // pipe events from translator

	        this.translator.on('*', function (event) {
	          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	            args[_key2 - 1] = arguments[_key2];
	          }

	          _this2.emit.apply(_this2, [event].concat(args));
	        });
	        this.modules.external.forEach(function (m) {
	          if (m.init) m.init(_this2);
	        });
	      } // append api


	      var storeApi = ['getResource', 'addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
	      storeApi.forEach(function (fcName) {
	        _this2[fcName] = function () {
	          var _this2$store;

	          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
	        };
	      });
	      var deferred = defer();

	      var load = function load() {
	        _this2.changeLanguage(_this2.options.lng, function (err, t) {
	          _this2.isInitialized = true;

	          _this2.logger.log('initialized', _this2.options);

	          _this2.emit('initialized', _this2.options);

	          deferred.resolve(t); // not rejecting on err (as err is only a loading translation failed warning)

	          callback(err, t);
	        });
	      };

	      if (this.options.resources || !this.options.initImmediate) {
	        load();
	      } else {
	        setTimeout(load, 0);
	      }

	      return deferred;
	    }
	    /* eslint consistent-return: 0 */

	  }, {
	    key: "loadResources",
	    value: function loadResources() {
	      var _this3 = this;

	      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

	      if (!this.options.resources || this.options.partialBundledLanguages) {
	        if (this.language && this.language.toLowerCase() === 'cimode') return callback(); // avoid loading resources for cimode

	        var toLoad = [];

	        var append = function append(lng) {
	          if (!lng) return;

	          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);

	          lngs.forEach(function (l) {
	            if (toLoad.indexOf(l) < 0) toLoad.push(l);
	          });
	        };

	        if (!this.language) {
	          // at least load fallbacks in this case
	          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
	          fallbacks.forEach(function (l) {
	            return append(l);
	          });
	        } else {
	          append(this.language);
	        }

	        if (this.options.preload) {
	          this.options.preload.forEach(function (l) {
	            return append(l);
	          });
	        }

	        this.services.backendConnector.load(toLoad, this.options.ns, callback);
	      } else {
	        callback(null);
	      }
	    }
	  }, {
	    key: "reloadResources",
	    value: function reloadResources(lngs, ns, callback) {
	      var deferred = defer();
	      if (!lngs) lngs = this.languages;
	      if (!ns) ns = this.options.ns;
	      if (!callback) callback = noop;
	      this.services.backendConnector.reload(lngs, ns, function (err) {
	        deferred.resolve(); // not rejecting on err (as err is only a loading translation failed warning)

	        callback(err);
	      });
	      return deferred;
	    }
	  }, {
	    key: "use",
	    value: function use(module) {
	      if (module.type === 'backend') {
	        this.modules.backend = module;
	      }

	      if (module.type === 'logger' || module.log && module.warn && module.error) {
	        this.modules.logger = module;
	      }

	      if (module.type === 'languageDetector') {
	        this.modules.languageDetector = module;
	      }

	      if (module.type === 'i18nFormat') {
	        this.modules.i18nFormat = module;
	      }

	      if (module.type === 'postProcessor') {
	        postProcessor.addPostProcessor(module);
	      }

	      if (module.type === '3rdParty') {
	        this.modules.external.push(module);
	      }

	      return this;
	    }
	  }, {
	    key: "changeLanguage",
	    value: function changeLanguage(lng, callback) {
	      var _this4 = this;

	      var deferred = defer();
	      this.emit('languageChanging', lng);

	      var done = function done(err, l) {
	        _this4.translator.changeLanguage(l);

	        if (l) {
	          _this4.emit('languageChanged', l);

	          _this4.logger.log('languageChanged', l);
	        }

	        deferred.resolve(function () {
	          return _this4.t.apply(_this4, arguments);
	        });
	        if (callback) callback(err, function () {
	          return _this4.t.apply(_this4, arguments);
	        });
	      };

	      var setLng = function setLng(l) {
	        if (l) {
	          _this4.language = l;
	          _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
	          if (!_this4.translator.language) _this4.translator.changeLanguage(l);
	          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
	        }

	        _this4.loadResources(function (err) {
	          done(err, l);
	        });
	      };

	      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
	        setLng(this.services.languageDetector.detect());
	      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
	        this.services.languageDetector.detect(setLng);
	      } else {
	        setLng(lng);
	      }

	      return deferred;
	    }
	  }, {
	    key: "getFixedT",
	    value: function getFixedT(lng, ns) {
	      var _this5 = this;

	      var fixedT = function fixedT(key, opts) {
	        var options;

	        if (_typeof(opts) !== 'object') {
	          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
	            rest[_key3 - 2] = arguments[_key3];
	          }

	          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
	        } else {
	          options = _objectSpread({}, opts);
	        }

	        options.lng = options.lng || fixedT.lng;
	        options.lngs = options.lngs || fixedT.lngs;
	        options.ns = options.ns || fixedT.ns;
	        return _this5.t(key, options);
	      };

	      if (typeof lng === 'string') {
	        fixedT.lng = lng;
	      } else {
	        fixedT.lngs = lng;
	      }

	      fixedT.ns = ns;
	      return fixedT;
	    }
	  }, {
	    key: "t",
	    value: function t() {
	      var _this$translator;

	      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
	    }
	  }, {
	    key: "exists",
	    value: function exists() {
	      var _this$translator2;

	      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
	    }
	  }, {
	    key: "setDefaultNamespace",
	    value: function setDefaultNamespace(ns) {
	      this.options.defaultNS = ns;
	    }
	  }, {
	    key: "hasLoadedNamespace",
	    value: function hasLoadedNamespace(ns) {
	      var _this6 = this;

	      if (!this.isInitialized) {
	        this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
	        return false;
	      }

	      if (!this.languages || !this.languages.length) {
	        this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
	        return false;
	      }

	      var lng = this.languages[0];
	      var fallbackLng = this.options ? this.options.fallbackLng : false;
	      var lastLng = this.languages[this.languages.length - 1]; // we're in cimode so this shall pass

	      if (lng.toLowerCase() === 'cimode') return true;

	      var loadNotPending = function loadNotPending(l, n) {
	        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];

	        return loadState === -1 || loadState === 2;
	      }; // loaded -> SUCCESS


	      if (this.hasResourceBundle(lng, ns)) return true; // were not loading at all -> SEMI SUCCESS

	      if (!this.services.backendConnector.backend) return true; // failed loading ns - but at least fallback is not pending -> SEMI SUCCESS

	      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
	      return false;
	    }
	  }, {
	    key: "loadNamespaces",
	    value: function loadNamespaces(ns, callback) {
	      var _this7 = this;

	      var deferred = defer();

	      if (!this.options.ns) {
	        callback && callback();
	        return Promise.resolve();
	      }

	      if (typeof ns === 'string') ns = [ns];
	      ns.forEach(function (n) {
	        if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);
	      });
	      this.loadResources(function (err) {
	        deferred.resolve();
	        if (callback) callback(err);
	      });
	      return deferred;
	    }
	  }, {
	    key: "loadLanguages",
	    value: function loadLanguages(lngs, callback) {
	      var deferred = defer();
	      if (typeof lngs === 'string') lngs = [lngs];
	      var preloaded = this.options.preload || [];
	      var newLngs = lngs.filter(function (lng) {
	        return preloaded.indexOf(lng) < 0;
	      }); // Exit early if all given languages are already preloaded

	      if (!newLngs.length) {
	        if (callback) callback();
	        return Promise.resolve();
	      }

	      this.options.preload = preloaded.concat(newLngs);
	      this.loadResources(function (err) {
	        deferred.resolve();
	        if (callback) callback(err);
	      });
	      return deferred;
	    }
	  }, {
	    key: "dir",
	    value: function dir(lng) {
	      if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
	      if (!lng) return 'rtl';
	      var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam'];
	      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';
	    }
	    /* eslint class-methods-use-this: 0 */

	  }, {
	    key: "createInstance",
	    value: function createInstance() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var callback = arguments.length > 1 ? arguments[1] : undefined;
	      return new I18n(options, callback);
	    }
	  }, {
	    key: "cloneInstance",
	    value: function cloneInstance() {
	      var _this8 = this;

	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	      var mergedOptions = _objectSpread({}, this.options, options, {
	        isClone: true
	      });

	      var clone = new I18n(mergedOptions);
	      var membersToCopy = ['store', 'services', 'language'];
	      membersToCopy.forEach(function (m) {
	        clone[m] = _this8[m];
	      });
	      clone.translator = new Translator(clone.services, clone.options);
	      clone.translator.on('*', function (event) {
	        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	          args[_key4 - 1] = arguments[_key4];
	        }

	        clone.emit.apply(clone, [event].concat(args));
	      });
	      clone.init(mergedOptions, callback);
	      clone.translator.options = clone.options; // sync options

	      return clone;
	    }
	  }]);

	  return I18n;
	}(EventEmitter);

	var i18next = new I18n();

	var arr = [];
	var each = arr.forEach;
	var slice = arr.slice;

	function defaults(obj) {
	  each.call(slice.call(arguments, 1), function (source) {
	    if (source) {
	      for (var prop in source) {
	        if (obj[prop] === undefined) obj[prop] = source[prop];
	      }
	    }
	  });
	  return obj;
	}

	function addQueryString(url, params) {
	  if (params && _typeof(params) === 'object') {
	    var queryString = '',
	        e = encodeURIComponent; // Must encode data

	    for (var paramName in params) {
	      queryString += '&' + e(paramName) + '=' + e(params[paramName]);
	    }

	    if (!queryString) {
	      return url;
	    }

	    url = url + (url.indexOf('?') !== -1 ? '&' : '?') + queryString.slice(1);
	  }

	  return url;
	} // https://gist.github.com/Xeoncross/7663273


	function ajax(url, options, callback, data, cache) {
	  if (data && _typeof(data) === 'object') {
	    if (!cache) {
	      data['_t'] = new Date();
	    } // URL encoded form data must be in querystring format


	    data = addQueryString('', data).slice(1);
	  }

	  if (options.queryStringParams) {
	    url = addQueryString(url, options.queryStringParams);
	  }

	  try {
	    var x;

	    if (XMLHttpRequest) {
	      x = new XMLHttpRequest();
	    } else {
	      x = new ActiveXObject('MSXML2.XMLHTTP.3.0');
	    }

	    x.open(data ? 'POST' : 'GET', url, 1);

	    if (!options.crossDomain) {
	      x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	    }

	    x.withCredentials = !!options.withCredentials;

	    if (data) {
	      x.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
	    }

	    if (x.overrideMimeType) {
	      x.overrideMimeType("application/json");
	    }

	    var h = options.customHeaders;
	    h = typeof h === 'function' ? h() : h;

	    if (h) {
	      for (var i in h) {
	        x.setRequestHeader(i, h[i]);
	      }
	    }

	    x.onreadystatechange = function () {
	      x.readyState > 3 && callback && callback(x.responseText, x);
	    };

	    x.send(data);
	  } catch (e) {
	    console && console.log(e);
	  }
	}

	function getDefaults() {
	  return {
	    loadPath: '/locales/{{lng}}/{{ns}}.json',
	    addPath: '/locales/add/{{lng}}/{{ns}}',
	    allowMultiLoading: false,
	    parse: JSON.parse,
	    parsePayload: function parsePayload(namespace, key, fallbackValue) {
	      return _defineProperty({}, key, fallbackValue || '');
	    },
	    crossDomain: false,
	    ajax: ajax
	  };
	}

	var Backend = /*#__PURE__*/function () {
	  function Backend(services) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Backend);

	    this.init(services, options);
	    this.type = 'backend';
	  }

	  _createClass(Backend, [{
	    key: "init",
	    value: function init(services) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      this.services = services;
	      this.options = defaults(options, this.options || {}, getDefaults());
	    }
	  }, {
	    key: "readMulti",
	    value: function readMulti(languages, namespaces, callback) {
	      var loadPath = this.options.loadPath;

	      if (typeof this.options.loadPath === 'function') {
	        loadPath = this.options.loadPath(languages, namespaces);
	      }

	      var url = this.services.interpolator.interpolate(loadPath, {
	        lng: languages.join('+'),
	        ns: namespaces.join('+')
	      });
	      this.loadUrl(url, callback);
	    }
	  }, {
	    key: "read",
	    value: function read(language, namespace, callback) {
	      var loadPath = this.options.loadPath;

	      if (typeof this.options.loadPath === 'function') {
	        loadPath = this.options.loadPath([language], [namespace]);
	      }

	      var url = this.services.interpolator.interpolate(loadPath, {
	        lng: language,
	        ns: namespace
	      });
	      this.loadUrl(url, callback);
	    }
	  }, {
	    key: "loadUrl",
	    value: function loadUrl(url, callback) {
	      var _this = this;

	      this.options.ajax(url, this.options, function (data, xhr) {
	        if (xhr.status >= 500 && xhr.status < 600) return callback('failed loading ' + url, true
	        /* retry */
	        );
	        if (xhr.status >= 400 && xhr.status < 500) return callback('failed loading ' + url, false
	        /* no retry */
	        );
	        var ret, err;

	        try {
	          ret = _this.options.parse(data, url);
	        } catch (e) {
	          err = 'failed parsing ' + url + ' to json';
	        }

	        if (err) return callback(err, false);
	        callback(null, ret);
	      });
	    }
	  }, {
	    key: "create",
	    value: function create(languages, namespace, key, fallbackValue) {
	      var _this2 = this;

	      if (typeof languages === 'string') languages = [languages];
	      var payload = this.options.parsePayload(namespace, key, fallbackValue);
	      languages.forEach(function (lng) {
	        var url = _this2.services.interpolator.interpolate(_this2.options.addPath, {
	          lng: lng,
	          ns: namespace
	        });

	        _this2.options.ajax(url, _this2.options, function (data, xhr) {//const statusCode = xhr.status.toString();
	          // TODO: if statusCode === 4xx do log
	        }, payload);
	      });
	    }
	  }]);

	  return Backend;
	}();

	Backend.type = 'backend';

	var bind = createCommonjsModule(function (module) {
	  /*!
	    Copyright (c) 2017 Jed Watson.
	    Licensed under the MIT License (MIT), see
	    http://jedwatson.github.io/classnames
	  */

	  /* global define */
	  (function () {

	    var hasOwn = {}.hasOwnProperty;

	    function classNames() {
	      var classes = [];

	      for (var i = 0; i < arguments.length; i++) {
	        var arg = arguments[i];
	        if (!arg) continue;
	        var argType = typeof arg;

	        if (argType === 'string' || argType === 'number') {
	          classes.push(this && this[arg] || arg);
	        } else if (Array.isArray(arg)) {
	          classes.push(classNames.apply(this, arg));
	        } else if (argType === 'object') {
	          for (var key in arg) {
	            if (hasOwn.call(arg, key) && arg[key]) {
	              classes.push(this && this[key] || key);
	            }
	          }
	        }
	      }

	      return classes.join(' ');
	    }

	    if ( module.exports) {
	      classNames.default = classNames;
	      module.exports = classNames;
	    } else {
	      window.classNames = classNames;
	    }
	  })();
	});

	var reactIs_production_min = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: !0
	  });
	  var b = "function" === typeof Symbol && Symbol.for,
	      c = b ? Symbol.for("react.element") : 60103,
	      d = b ? Symbol.for("react.portal") : 60106,
	      e = b ? Symbol.for("react.fragment") : 60107,
	      f = b ? Symbol.for("react.strict_mode") : 60108,
	      g = b ? Symbol.for("react.profiler") : 60114,
	      h = b ? Symbol.for("react.provider") : 60109,
	      k = b ? Symbol.for("react.context") : 60110,
	      l = b ? Symbol.for("react.async_mode") : 60111,
	      m = b ? Symbol.for("react.concurrent_mode") : 60111,
	      n = b ? Symbol.for("react.forward_ref") : 60112,
	      p = b ? Symbol.for("react.suspense") : 60113,
	      q = b ? Symbol.for("react.memo") : 60115,
	      r = b ? Symbol.for("react.lazy") : 60116;

	  function t(a) {
	    if ("object" === typeof a && null !== a) {
	      var u = a.$$typeof;

	      switch (u) {
	        case c:
	          switch (a = a.type, a) {
	            case l:
	            case m:
	            case e:
	            case g:
	            case f:
	            case p:
	              return a;

	            default:
	              switch (a = a && a.$$typeof, a) {
	                case k:
	                case n:
	                case h:
	                  return a;

	                default:
	                  return u;
	              }

	          }

	        case r:
	        case q:
	        case d:
	          return u;
	      }
	    }
	  }

	  function v(a) {
	    return t(a) === m;
	  }

	  exports.typeOf = t;
	  exports.AsyncMode = l;
	  exports.ConcurrentMode = m;
	  exports.ContextConsumer = k;
	  exports.ContextProvider = h;
	  exports.Element = c;
	  exports.ForwardRef = n;
	  exports.Fragment = e;
	  exports.Lazy = r;
	  exports.Memo = q;
	  exports.Portal = d;
	  exports.Profiler = g;
	  exports.StrictMode = f;
	  exports.Suspense = p;

	  exports.isValidElementType = function (a) {
	    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || "object" === typeof a && null !== a && (a.$$typeof === r || a.$$typeof === q || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n);
	  };

	  exports.isAsyncMode = function (a) {
	    return v(a) || t(a) === l;
	  };

	  exports.isConcurrentMode = v;

	  exports.isContextConsumer = function (a) {
	    return t(a) === k;
	  };

	  exports.isContextProvider = function (a) {
	    return t(a) === h;
	  };

	  exports.isElement = function (a) {
	    return "object" === typeof a && null !== a && a.$$typeof === c;
	  };

	  exports.isForwardRef = function (a) {
	    return t(a) === n;
	  };

	  exports.isFragment = function (a) {
	    return t(a) === e;
	  };

	  exports.isLazy = function (a) {
	    return t(a) === r;
	  };

	  exports.isMemo = function (a) {
	    return t(a) === q;
	  };

	  exports.isPortal = function (a) {
	    return t(a) === d;
	  };

	  exports.isProfiler = function (a) {
	    return t(a) === g;
	  };

	  exports.isStrictMode = function (a) {
	    return t(a) === f;
	  };

	  exports.isSuspense = function (a) {
	    return t(a) === p;
	  };
	});
	unwrapExports(reactIs_production_min);
	var reactIs_production_min_1 = reactIs_production_min.typeOf;
	var reactIs_production_min_2 = reactIs_production_min.AsyncMode;
	var reactIs_production_min_3 = reactIs_production_min.ConcurrentMode;
	var reactIs_production_min_4 = reactIs_production_min.ContextConsumer;
	var reactIs_production_min_5 = reactIs_production_min.ContextProvider;
	var reactIs_production_min_6 = reactIs_production_min.Element;
	var reactIs_production_min_7 = reactIs_production_min.ForwardRef;
	var reactIs_production_min_8 = reactIs_production_min.Fragment;
	var reactIs_production_min_9 = reactIs_production_min.Lazy;
	var reactIs_production_min_10 = reactIs_production_min.Memo;
	var reactIs_production_min_11 = reactIs_production_min.Portal;
	var reactIs_production_min_12 = reactIs_production_min.Profiler;
	var reactIs_production_min_13 = reactIs_production_min.StrictMode;
	var reactIs_production_min_14 = reactIs_production_min.Suspense;
	var reactIs_production_min_15 = reactIs_production_min.isValidElementType;
	var reactIs_production_min_16 = reactIs_production_min.isAsyncMode;
	var reactIs_production_min_17 = reactIs_production_min.isConcurrentMode;
	var reactIs_production_min_18 = reactIs_production_min.isContextConsumer;
	var reactIs_production_min_19 = reactIs_production_min.isContextProvider;
	var reactIs_production_min_20 = reactIs_production_min.isElement;
	var reactIs_production_min_21 = reactIs_production_min.isForwardRef;
	var reactIs_production_min_22 = reactIs_production_min.isFragment;
	var reactIs_production_min_23 = reactIs_production_min.isLazy;
	var reactIs_production_min_24 = reactIs_production_min.isMemo;
	var reactIs_production_min_25 = reactIs_production_min.isPortal;
	var reactIs_production_min_26 = reactIs_production_min.isProfiler;
	var reactIs_production_min_27 = reactIs_production_min.isStrictMode;
	var reactIs_production_min_28 = reactIs_production_min.isSuspense;

	var reactIs_development = createCommonjsModule(function (module, exports) {

	  {
	    (function () {

	      Object.defineProperty(exports, '__esModule', {
	        value: true
	      }); // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	      // nor polyfill, then a plain number is used for performance.

	      var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	      var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	      var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	      var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	      var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	      var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	      var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	      var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
	      var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	      var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	      var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	      var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	      var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	      var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

	      function isValidElementType(type) {
	        return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	        type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
	      }
	      /**
	       * Forked from fbjs/warning:
	       * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
	       *
	       * Only change is we use console.warn instead of console.error,
	       * and do nothing when 'console' is not supported.
	       * This really simplifies the code.
	       * ---
	       * Similar to invariant but only logs a warning if the condition is not met.
	       * This can be used to log issues in development environments in critical
	       * paths. Removing the logging code for production environments will keep the
	       * same logic and follow the same code paths.
	       */


	      var lowPriorityWarning = function () {};

	      {
	        var printWarning = function (format) {
	          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            args[_key - 1] = arguments[_key];
	          }

	          var argIndex = 0;
	          var message = 'Warning: ' + format.replace(/%s/g, function () {
	            return args[argIndex++];
	          });

	          if (typeof console !== 'undefined') {
	            console.warn(message);
	          }

	          try {
	            // --- Welcome to debugging React ---
	            // This error was thrown as a convenience so that you can use this stack
	            // to find the callsite that caused this warning to fire.
	            throw new Error(message);
	          } catch (x) {}
	        };

	        lowPriorityWarning = function (condition, format) {
	          if (format === undefined) {
	            throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
	          }

	          if (!condition) {
	            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	              args[_key2 - 2] = arguments[_key2];
	            }

	            printWarning.apply(undefined, [format].concat(args));
	          }
	        };
	      }
	      var lowPriorityWarning$1 = lowPriorityWarning;

	      function typeOf(object) {
	        if (typeof object === 'object' && object !== null) {
	          var $$typeof = object.$$typeof;

	          switch ($$typeof) {
	            case REACT_ELEMENT_TYPE:
	              var type = object.type;

	              switch (type) {
	                case REACT_ASYNC_MODE_TYPE:
	                case REACT_CONCURRENT_MODE_TYPE:
	                case REACT_FRAGMENT_TYPE:
	                case REACT_PROFILER_TYPE:
	                case REACT_STRICT_MODE_TYPE:
	                case REACT_SUSPENSE_TYPE:
	                  return type;

	                default:
	                  var $$typeofType = type && type.$$typeof;

	                  switch ($$typeofType) {
	                    case REACT_CONTEXT_TYPE:
	                    case REACT_FORWARD_REF_TYPE:
	                    case REACT_PROVIDER_TYPE:
	                      return $$typeofType;

	                    default:
	                      return $$typeof;
	                  }

	              }

	            case REACT_LAZY_TYPE:
	            case REACT_MEMO_TYPE:
	            case REACT_PORTAL_TYPE:
	              return $$typeof;
	          }
	        }

	        return undefined;
	      } // AsyncMode is deprecated along with isAsyncMode


	      var AsyncMode = REACT_ASYNC_MODE_TYPE;
	      var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	      var ContextConsumer = REACT_CONTEXT_TYPE;
	      var ContextProvider = REACT_PROVIDER_TYPE;
	      var Element = REACT_ELEMENT_TYPE;
	      var ForwardRef = REACT_FORWARD_REF_TYPE;
	      var Fragment = REACT_FRAGMENT_TYPE;
	      var Lazy = REACT_LAZY_TYPE;
	      var Memo = REACT_MEMO_TYPE;
	      var Portal = REACT_PORTAL_TYPE;
	      var Profiler = REACT_PROFILER_TYPE;
	      var StrictMode = REACT_STRICT_MODE_TYPE;
	      var Suspense = REACT_SUSPENSE_TYPE;
	      var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	      function isAsyncMode(object) {
	        {
	          if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	            hasWarnedAboutDeprecatedIsAsyncMode = true;
	            lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	          }
	        }
	        return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	      }

	      function isConcurrentMode(object) {
	        return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	      }

	      function isContextConsumer(object) {
	        return typeOf(object) === REACT_CONTEXT_TYPE;
	      }

	      function isContextProvider(object) {
	        return typeOf(object) === REACT_PROVIDER_TYPE;
	      }

	      function isElement(object) {
	        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	      }

	      function isForwardRef(object) {
	        return typeOf(object) === REACT_FORWARD_REF_TYPE;
	      }

	      function isFragment(object) {
	        return typeOf(object) === REACT_FRAGMENT_TYPE;
	      }

	      function isLazy(object) {
	        return typeOf(object) === REACT_LAZY_TYPE;
	      }

	      function isMemo(object) {
	        return typeOf(object) === REACT_MEMO_TYPE;
	      }

	      function isPortal(object) {
	        return typeOf(object) === REACT_PORTAL_TYPE;
	      }

	      function isProfiler(object) {
	        return typeOf(object) === REACT_PROFILER_TYPE;
	      }

	      function isStrictMode(object) {
	        return typeOf(object) === REACT_STRICT_MODE_TYPE;
	      }

	      function isSuspense(object) {
	        return typeOf(object) === REACT_SUSPENSE_TYPE;
	      }

	      exports.typeOf = typeOf;
	      exports.AsyncMode = AsyncMode;
	      exports.ConcurrentMode = ConcurrentMode;
	      exports.ContextConsumer = ContextConsumer;
	      exports.ContextProvider = ContextProvider;
	      exports.Element = Element;
	      exports.ForwardRef = ForwardRef;
	      exports.Fragment = Fragment;
	      exports.Lazy = Lazy;
	      exports.Memo = Memo;
	      exports.Portal = Portal;
	      exports.Profiler = Profiler;
	      exports.StrictMode = StrictMode;
	      exports.Suspense = Suspense;
	      exports.isValidElementType = isValidElementType;
	      exports.isAsyncMode = isAsyncMode;
	      exports.isConcurrentMode = isConcurrentMode;
	      exports.isContextConsumer = isContextConsumer;
	      exports.isContextProvider = isContextProvider;
	      exports.isElement = isElement;
	      exports.isForwardRef = isForwardRef;
	      exports.isFragment = isFragment;
	      exports.isLazy = isLazy;
	      exports.isMemo = isMemo;
	      exports.isPortal = isPortal;
	      exports.isProfiler = isProfiler;
	      exports.isStrictMode = isStrictMode;
	      exports.isSuspense = isSuspense;
	    })();
	  }
	});
	unwrapExports(reactIs_development);
	var reactIs_development_1 = reactIs_development.typeOf;
	var reactIs_development_2 = reactIs_development.AsyncMode;
	var reactIs_development_3 = reactIs_development.ConcurrentMode;
	var reactIs_development_4 = reactIs_development.ContextConsumer;
	var reactIs_development_5 = reactIs_development.ContextProvider;
	var reactIs_development_6 = reactIs_development.Element;
	var reactIs_development_7 = reactIs_development.ForwardRef;
	var reactIs_development_8 = reactIs_development.Fragment;
	var reactIs_development_9 = reactIs_development.Lazy;
	var reactIs_development_10 = reactIs_development.Memo;
	var reactIs_development_11 = reactIs_development.Portal;
	var reactIs_development_12 = reactIs_development.Profiler;
	var reactIs_development_13 = reactIs_development.StrictMode;
	var reactIs_development_14 = reactIs_development.Suspense;
	var reactIs_development_15 = reactIs_development.isValidElementType;
	var reactIs_development_16 = reactIs_development.isAsyncMode;
	var reactIs_development_17 = reactIs_development.isConcurrentMode;
	var reactIs_development_18 = reactIs_development.isContextConsumer;
	var reactIs_development_19 = reactIs_development.isContextProvider;
	var reactIs_development_20 = reactIs_development.isElement;
	var reactIs_development_21 = reactIs_development.isForwardRef;
	var reactIs_development_22 = reactIs_development.isFragment;
	var reactIs_development_23 = reactIs_development.isLazy;
	var reactIs_development_24 = reactIs_development.isMemo;
	var reactIs_development_25 = reactIs_development.isPortal;
	var reactIs_development_26 = reactIs_development.isProfiler;
	var reactIs_development_27 = reactIs_development.isStrictMode;
	var reactIs_development_28 = reactIs_development.isSuspense;

	var reactIs = createCommonjsModule(function (module) {

	  {
	    module.exports = reactIs_development;
	  }
	});

	/* eslint-disable no-unused-vars */

	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
	  if (val === null || val === undefined) {
	    throw new TypeError('Object.assign cannot be called with null or undefined');
	  }

	  return Object(val);
	}

	function shouldUseNative() {
	  try {
	    if (!Object.assign) {
	      return false;
	    } // Detect buggy property enumeration order in older V8 versions.
	    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


	    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

	    test1[5] = 'de';

	    if (Object.getOwnPropertyNames(test1)[0] === '5') {
	      return false;
	    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


	    var test2 = {};

	    for (var i = 0; i < 10; i++) {
	      test2['_' + String.fromCharCode(i)] = i;
	    }

	    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
	      return test2[n];
	    });

	    if (order2.join('') !== '0123456789') {
	      return false;
	    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


	    var test3 = {};
	    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
	      test3[letter] = letter;
	    });

	    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
	      return false;
	    }

	    return true;
	  } catch (err) {
	    // We don't expect any of the above to throw, but better to be safe.
	    return false;
	  }
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	  var from;
	  var to = toObject(target);
	  var symbols;

	  for (var s = 1; s < arguments.length; s++) {
	    from = Object(arguments[s]);

	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }

	    if (getOwnPropertySymbols) {
	      symbols = getOwnPropertySymbols(from);

	      for (var i = 0; i < symbols.length; i++) {
	        if (propIsEnumerable.call(from, symbols[i])) {
	          to[symbols[i]] = from[symbols[i]];
	        }
	      }
	    }
	  }

	  return to;
	};

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	var ReactPropTypesSecret_1 = ReactPropTypesSecret;

	var printWarning = function () {};

	{
	  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
	  var loggedTypeFailures = {};
	  var has = Function.call.bind(Object.prototype.hasOwnProperty);

	  printWarning = function (text) {
	    var message = 'Warning: ' + text;

	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }

	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */


	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  {
	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error; // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.

	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.');
	            err.name = 'Invariant Violation';
	            throw err;
	          }

	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
	        } catch (ex) {
	          error = ex;
	        }

	        if (error && !(error instanceof Error)) {
	          printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
	        }

	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;
	          var stack = getStack ? getStack() : '';
	          printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
	        }
	      }
	    }
	  }
	}
	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */


	checkPropTypes.resetWarningCache = function () {
	  {
	    loggedTypeFailures = {};
	  }
	};

	var checkPropTypes_1 = checkPropTypes;

	var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);

	var printWarning$1 = function () {};

	{
	  printWarning$1 = function (text) {
	    var message = 'Warning: ' + text;

	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }

	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	function emptyFunctionThatReturnsNull() {
	  return null;
	}

	var factoryWithTypeCheckers = function (isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */

	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);

	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */


	  var ANONYMOUS = '<<anonymous>>'; // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.

	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),
	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker
	  };
	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */

	  /*eslint-disable no-self-compare*/

	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */


	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  } // Make `instanceof Error` still work for returned errors.


	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }

	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret_1) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if ( typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;

	          if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
	          manualPropTypeWarningCount < 3) {
	            printWarning$1('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }

	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }

	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }

	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);
	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);

	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }

	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }

	      var propValue = props[propName];

	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }

	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);

	        if (error instanceof Error) {
	          return error;
	        }
	      }

	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];

	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }

	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];

	      if (!reactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }

	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }

	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      {
	        if (arguments.length > 1) {
	          printWarning$1('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
	        } else {
	          printWarning$1('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }

	      return emptyFunctionThatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];

	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);

	        if (type === 'symbol') {
	          return String(value);
	        }

	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }

	      var propValue = props[propName];
	      var propType = getPropType(propValue);

	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }

	      for (var key in propValue) {
	        if (has$1(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);

	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }

	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	       printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.') ;
	      return emptyFunctionThatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];

	      if (typeof checker !== 'function') {
	        printWarning$1('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
	        return emptyFunctionThatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];

	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
	          return null;
	        }
	      }

	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }

	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);

	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }

	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];

	        if (!checker) {
	          continue;
	        }

	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);

	        if (error) {
	          return error;
	        }
	      }

	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);

	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      } // We need to check all keys in case some are required but missing from
	      // props.


	      var allKeys = objectAssign({}, props[propName], shapeTypes);

	      for (var key in allKeys) {
	        var checker = shapeTypes[key];

	        if (!checker) {
	          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
	        }

	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);

	        if (error) {
	          return error;
	        }
	      }

	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;

	      case 'boolean':
	        return !propValue;

	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }

	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);

	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;

	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;

	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;

	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    } // falsy value can't be a Symbol


	    if (!propValue) {
	      return false;
	    } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'


	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    } // Fallback for non-spec compliant Symbols which are polyfilled.


	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  } // Equivalent of `typeof` but with special handling for array and regexp.


	  function getPropType(propValue) {
	    var propType = typeof propValue;

	    if (Array.isArray(propValue)) {
	      return 'array';
	    }

	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }

	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }

	    return propType;
	  } // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.


	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }

	    var propType = getPropType(propValue);

	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }

	    return propType;
	  } // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"


	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);

	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;

	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;

	      default:
	        return type;
	    }
	  } // Returns class name of the object, if any.


	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }

	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes_1;
	  ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;
	  return ReactPropTypes;
	};

	var propTypes = createCommonjsModule(function (module) {
	  /**
	   * Copyright (c) 2013-present, Facebook, Inc.
	   *
	   * This source code is licensed under the MIT license found in the
	   * LICENSE file in the root directory of this source tree.
	   */
	  {
	    var ReactIs = reactIs; // By explicitly using `prop-types` you are opting into new development behavior.
	    // http://fb.me/prop-types-in-prod

	    var throwOnDirectAccess = true;
	    module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
	  }
	});

	var version = '18.5.0';
	/**
	 * Tween.js - Licensed under the MIT license
	 * https://github.com/tweenjs/tween.js
	 * ----------------------------------------------
	 *
	 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
	 * Thank you all, you're awesome!
	 */

	var _Group = function () {
	  this._tweens = {};
	  this._tweensAddedDuringUpdate = {};
	};

	_Group.prototype = {
	  getAll: function () {
	    return Object.keys(this._tweens).map(function (tweenId) {
	      return this._tweens[tweenId];
	    }.bind(this));
	  },
	  removeAll: function () {
	    this._tweens = {};
	  },
	  add: function (tween) {
	    this._tweens[tween.getId()] = tween;
	    this._tweensAddedDuringUpdate[tween.getId()] = tween;
	  },
	  remove: function (tween) {
	    delete this._tweens[tween.getId()];
	    delete this._tweensAddedDuringUpdate[tween.getId()];
	  },
	  update: function (time, preserve) {
	    var tweenIds = Object.keys(this._tweens);

	    if (tweenIds.length === 0) {
	      return false;
	    }

	    time = time !== undefined ? time : TWEEN.now(); // Tweens are updated in "batches". If you add a new tween during an
	    // update, then the new tween will be updated in the next batch.
	    // If you remove a tween during an update, it may or may not be updated.
	    // However, if the removed tween was added during the current batch,
	    // then it will not be updated.

	    while (tweenIds.length > 0) {
	      this._tweensAddedDuringUpdate = {};

	      for (var i = 0; i < tweenIds.length; i++) {
	        var tween = this._tweens[tweenIds[i]];

	        if (tween && tween.update(time) === false) {
	          tween._isPlaying = false;

	          if (!preserve) {
	            delete this._tweens[tweenIds[i]];
	          }
	        }
	      }

	      tweenIds = Object.keys(this._tweensAddedDuringUpdate);
	    }

	    return true;
	  }
	};
	var TWEEN = new _Group();
	TWEEN.Group = _Group;
	TWEEN._nextId = 0;

	TWEEN.nextId = function () {
	  return TWEEN._nextId++;
	}; // Include a performance.now polyfill.
	// In node.js, use process.hrtime.


	if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
	  TWEEN.now = function () {
	    var time = process.hrtime(); // Convert [seconds, nanoseconds] to milliseconds.

	    return time[0] * 1000 + time[1] / 1000000;
	  };
	} // In a browser, use self.performance.now if it is available.
	else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
	    // This must be bound, because directly assigning this function
	    // leads to an invocation exception in Chrome.
	    TWEEN.now = self.performance.now.bind(self.performance);
	  } // Use Date.now if it is available.
	  else if (Date.now !== undefined) {
	      TWEEN.now = Date.now;
	    } // Otherwise, use 'new Date().getTime()'.
	    else {
	        TWEEN.now = function () {
	          return new Date().getTime();
	        };
	      }

	TWEEN.Tween = function (object, group) {
	  this._isPaused = false;
	  this._pauseStart = null;
	  this._object = object;
	  this._valuesStart = {};
	  this._valuesEnd = {};
	  this._valuesStartRepeat = {};
	  this._duration = 1000;
	  this._repeat = 0;
	  this._repeatDelayTime = undefined;
	  this._yoyo = false;
	  this._isPlaying = false;
	  this._reversed = false;
	  this._delayTime = 0;
	  this._startTime = null;
	  this._easingFunction = TWEEN.Easing.Linear.None;
	  this._interpolationFunction = TWEEN.Interpolation.Linear;
	  this._chainedTweens = [];
	  this._onStartCallback = null;
	  this._onStartCallbackFired = false;
	  this._onUpdateCallback = null;
	  this._onRepeatCallback = null;
	  this._onCompleteCallback = null;
	  this._onStopCallback = null;
	  this._group = group || TWEEN;
	  this._id = TWEEN.nextId();
	};

	TWEEN.Tween.prototype = {
	  getId: function () {
	    return this._id;
	  },
	  isPlaying: function () {
	    return this._isPlaying;
	  },
	  isPaused: function () {
	    return this._isPaused;
	  },
	  to: function (properties, duration) {
	    this._valuesEnd = Object.create(properties);

	    if (duration !== undefined) {
	      this._duration = duration;
	    }

	    return this;
	  },
	  duration: function duration(d) {
	    this._duration = d;
	    return this;
	  },
	  start: function (time) {
	    this._group.add(this);

	    this._isPlaying = true;
	    this._isPaused = false;
	    this._onStartCallbackFired = false;
	    this._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();
	    this._startTime += this._delayTime;

	    for (var property in this._valuesEnd) {
	      // Check if an Array was provided as property value
	      if (this._valuesEnd[property] instanceof Array) {
	        if (this._valuesEnd[property].length === 0) {
	          continue;
	        } // Create a local copy of the Array with the start value at the front


	        this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);
	      } // If `to()` specifies a property that doesn't exist in the source object,
	      // we should not set that property in the object


	      if (this._object[property] === undefined) {
	        continue;
	      } // Save the starting value, but only once.


	      if (typeof this._valuesStart[property] === 'undefined') {
	        this._valuesStart[property] = this._object[property];
	      }

	      if (this._valuesStart[property] instanceof Array === false) {
	        this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
	      }

	      this._valuesStartRepeat[property] = this._valuesStart[property] || 0;
	    }

	    return this;
	  },
	  stop: function () {
	    if (!this._isPlaying) {
	      return this;
	    }

	    this._group.remove(this);

	    this._isPlaying = false;
	    this._isPaused = false;

	    if (this._onStopCallback !== null) {
	      this._onStopCallback(this._object);
	    }

	    this.stopChainedTweens();
	    return this;
	  },
	  end: function () {
	    this.update(Infinity);
	    return this;
	  },
	  pause: function (time) {
	    if (this._isPaused || !this._isPlaying) {
	      return this;
	    }

	    this._isPaused = true;
	    this._pauseStart = time === undefined ? TWEEN.now() : time;

	    this._group.remove(this);

	    return this;
	  },
	  resume: function (time) {
	    if (!this._isPaused || !this._isPlaying) {
	      return this;
	    }

	    this._isPaused = false;
	    this._startTime += (time === undefined ? TWEEN.now() : time) - this._pauseStart;
	    this._pauseStart = 0;

	    this._group.add(this);

	    return this;
	  },
	  stopChainedTweens: function () {
	    for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
	      this._chainedTweens[i].stop();
	    }
	  },
	  group: function (group) {
	    this._group = group;
	    return this;
	  },
	  delay: function (amount) {
	    this._delayTime = amount;
	    return this;
	  },
	  repeat: function (times) {
	    this._repeat = times;
	    return this;
	  },
	  repeatDelay: function (amount) {
	    this._repeatDelayTime = amount;
	    return this;
	  },
	  yoyo: function (yoyo) {
	    this._yoyo = yoyo;
	    return this;
	  },
	  easing: function (easingFunction) {
	    this._easingFunction = easingFunction;
	    return this;
	  },
	  interpolation: function (interpolationFunction) {
	    this._interpolationFunction = interpolationFunction;
	    return this;
	  },
	  chain: function () {
	    this._chainedTweens = arguments;
	    return this;
	  },
	  onStart: function (callback) {
	    this._onStartCallback = callback;
	    return this;
	  },
	  onUpdate: function (callback) {
	    this._onUpdateCallback = callback;
	    return this;
	  },
	  onRepeat: function onRepeat(callback) {
	    this._onRepeatCallback = callback;
	    return this;
	  },
	  onComplete: function (callback) {
	    this._onCompleteCallback = callback;
	    return this;
	  },
	  onStop: function (callback) {
	    this._onStopCallback = callback;
	    return this;
	  },
	  update: function (time) {
	    var property;
	    var elapsed;
	    var value;

	    if (time < this._startTime) {
	      return true;
	    }

	    if (this._onStartCallbackFired === false) {
	      if (this._onStartCallback !== null) {
	        this._onStartCallback(this._object);
	      }

	      this._onStartCallbackFired = true;
	    }

	    elapsed = (time - this._startTime) / this._duration;
	    elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
	    value = this._easingFunction(elapsed);

	    for (property in this._valuesEnd) {
	      // Don't update properties that do not exist in the source object
	      if (this._valuesStart[property] === undefined) {
	        continue;
	      }

	      var start = this._valuesStart[property] || 0;
	      var end = this._valuesEnd[property];

	      if (end instanceof Array) {
	        this._object[property] = this._interpolationFunction(end, value);
	      } else {
	        // Parses relative end values with start as base (e.g.: +10, -3)
	        if (typeof end === 'string') {
	          if (end.charAt(0) === '+' || end.charAt(0) === '-') {
	            end = start + parseFloat(end);
	          } else {
	            end = parseFloat(end);
	          }
	        } // Protect against non numeric properties.


	        if (typeof end === 'number') {
	          this._object[property] = start + (end - start) * value;
	        }
	      }
	    }

	    if (this._onUpdateCallback !== null) {
	      this._onUpdateCallback(this._object, elapsed);
	    }

	    if (elapsed === 1) {
	      if (this._repeat > 0) {
	        if (isFinite(this._repeat)) {
	          this._repeat--;
	        } // Reassign starting values, restart by making startTime = now


	        for (property in this._valuesStartRepeat) {
	          if (typeof this._valuesEnd[property] === 'string') {
	            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
	          }

	          if (this._yoyo) {
	            var tmp = this._valuesStartRepeat[property];
	            this._valuesStartRepeat[property] = this._valuesEnd[property];
	            this._valuesEnd[property] = tmp;
	          }

	          this._valuesStart[property] = this._valuesStartRepeat[property];
	        }

	        if (this._yoyo) {
	          this._reversed = !this._reversed;
	        }

	        if (this._repeatDelayTime !== undefined) {
	          this._startTime = time + this._repeatDelayTime;
	        } else {
	          this._startTime = time + this._delayTime;
	        }

	        if (this._onRepeatCallback !== null) {
	          this._onRepeatCallback(this._object);
	        }

	        return true;
	      } else {
	        if (this._onCompleteCallback !== null) {
	          this._onCompleteCallback(this._object);
	        }

	        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
	          // Make the chained tweens start exactly at the time they should,
	          // even if the `update()` method was called way past the duration of the tween
	          this._chainedTweens[i].start(this._startTime + this._duration);
	        }

	        return false;
	      }
	    }

	    return true;
	  }
	};
	TWEEN.Easing = {
	  Linear: {
	    None: function (k) {
	      return k;
	    }
	  },
	  Quadratic: {
	    In: function (k) {
	      return k * k;
	    },
	    Out: function (k) {
	      return k * (2 - k);
	    },
	    InOut: function (k) {
	      if ((k *= 2) < 1) {
	        return 0.5 * k * k;
	      }

	      return -0.5 * (--k * (k - 2) - 1);
	    }
	  },
	  Cubic: {
	    In: function (k) {
	      return k * k * k;
	    },
	    Out: function (k) {
	      return --k * k * k + 1;
	    },
	    InOut: function (k) {
	      if ((k *= 2) < 1) {
	        return 0.5 * k * k * k;
	      }

	      return 0.5 * ((k -= 2) * k * k + 2);
	    }
	  },
	  Quartic: {
	    In: function (k) {
	      return k * k * k * k;
	    },
	    Out: function (k) {
	      return 1 - --k * k * k * k;
	    },
	    InOut: function (k) {
	      if ((k *= 2) < 1) {
	        return 0.5 * k * k * k * k;
	      }

	      return -0.5 * ((k -= 2) * k * k * k - 2);
	    }
	  },
	  Quintic: {
	    In: function (k) {
	      return k * k * k * k * k;
	    },
	    Out: function (k) {
	      return --k * k * k * k * k + 1;
	    },
	    InOut: function (k) {
	      if ((k *= 2) < 1) {
	        return 0.5 * k * k * k * k * k;
	      }

	      return 0.5 * ((k -= 2) * k * k * k * k + 2);
	    }
	  },
	  Sinusoidal: {
	    In: function (k) {
	      return 1 - Math.cos(k * Math.PI / 2);
	    },
	    Out: function (k) {
	      return Math.sin(k * Math.PI / 2);
	    },
	    InOut: function (k) {
	      return 0.5 * (1 - Math.cos(Math.PI * k));
	    }
	  },
	  Exponential: {
	    In: function (k) {
	      return k === 0 ? 0 : Math.pow(1024, k - 1);
	    },
	    Out: function (k) {
	      return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	    },
	    InOut: function (k) {
	      if (k === 0) {
	        return 0;
	      }

	      if (k === 1) {
	        return 1;
	      }

	      if ((k *= 2) < 1) {
	        return 0.5 * Math.pow(1024, k - 1);
	      }

	      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	    }
	  },
	  Circular: {
	    In: function (k) {
	      return 1 - Math.sqrt(1 - k * k);
	    },
	    Out: function (k) {
	      return Math.sqrt(1 - --k * k);
	    },
	    InOut: function (k) {
	      if ((k *= 2) < 1) {
	        return -0.5 * (Math.sqrt(1 - k * k) - 1);
	      }

	      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	    }
	  },
	  Elastic: {
	    In: function (k) {
	      if (k === 0) {
	        return 0;
	      }

	      if (k === 1) {
	        return 1;
	      }

	      return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
	    },
	    Out: function (k) {
	      if (k === 0) {
	        return 0;
	      }

	      if (k === 1) {
	        return 1;
	      }

	      return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;
	    },
	    InOut: function (k) {
	      if (k === 0) {
	        return 0;
	      }

	      if (k === 1) {
	        return 1;
	      }

	      k *= 2;

	      if (k < 1) {
	        return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
	      }

	      return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;
	    }
	  },
	  Back: {
	    In: function (k) {
	      var s = 1.70158;
	      return k * k * ((s + 1) * k - s);
	    },
	    Out: function (k) {
	      var s = 1.70158;
	      return --k * k * ((s + 1) * k + s) + 1;
	    },
	    InOut: function (k) {
	      var s = 1.70158 * 1.525;

	      if ((k *= 2) < 1) {
	        return 0.5 * (k * k * ((s + 1) * k - s));
	      }

	      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	    }
	  },
	  Bounce: {
	    In: function (k) {
	      return 1 - TWEEN.Easing.Bounce.Out(1 - k);
	    },
	    Out: function (k) {
	      if (k < 1 / 2.75) {
	        return 7.5625 * k * k;
	      } else if (k < 2 / 2.75) {
	        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
	      } else if (k < 2.5 / 2.75) {
	        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
	      } else {
	        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
	      }
	    },
	    InOut: function (k) {
	      if (k < 0.5) {
	        return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
	      }

	      return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
	    }
	  }
	};
	TWEEN.Interpolation = {
	  Linear: function (v, k) {
	    var m = v.length - 1;
	    var f = m * k;
	    var i = Math.floor(f);
	    var fn = TWEEN.Interpolation.Utils.Linear;

	    if (k < 0) {
	      return fn(v[0], v[1], f);
	    }

	    if (k > 1) {
	      return fn(v[m], v[m - 1], m - f);
	    }

	    return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
	  },
	  Bezier: function (v, k) {
	    var b = 0;
	    var n = v.length - 1;
	    var pw = Math.pow;
	    var bn = TWEEN.Interpolation.Utils.Bernstein;

	    for (var i = 0; i <= n; i++) {
	      b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
	    }

	    return b;
	  },
	  CatmullRom: function (v, k) {
	    var m = v.length - 1;
	    var f = m * k;
	    var i = Math.floor(f);
	    var fn = TWEEN.Interpolation.Utils.CatmullRom;

	    if (v[0] === v[m]) {
	      if (k < 0) {
	        i = Math.floor(f = m * (1 + k));
	      }

	      return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
	    } else {
	      if (k < 0) {
	        return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
	      }

	      if (k > 1) {
	        return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
	      }

	      return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
	    }
	  },
	  Utils: {
	    Linear: function (p0, p1, t) {
	      return (p1 - p0) * t + p0;
	    },
	    Bernstein: function (n, i) {
	      var fc = TWEEN.Interpolation.Utils.Factorial;
	      return fc(n) / fc(i) / fc(n - i);
	    },
	    Factorial: function () {
	      var a = [1];
	      return function (n) {
	        var s = 1;

	        if (a[n]) {
	          return a[n];
	        }

	        for (var i = n; i > 1; i--) {
	          s *= i;
	        }

	        a[n] = s;
	        return s;
	      };
	    }(),
	    CatmullRom: function (p0, p1, p2, p3, t) {
	      var v0 = (p2 - p0) * 0.5;
	      var v1 = (p3 - p1) * 0.5;
	      var t2 = t * t;
	      var t3 = t * t2;
	      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	    }
	  }
	};
	TWEEN.version = version;

	var noop$1 = {
	  value: function () {}
	};

	function dispatch() {
	  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
	    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
	    _[t] = [];
	  }

	  return new Dispatch(_);
	}

	function Dispatch(_) {
	  this._ = _;
	}

	function parseTypenames(typenames, types) {
	  return typenames.trim().split(/^|\s+/).map(function (t) {
	    var name = "",
	        i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
	    return {
	      type: t,
	      name: name
	    };
	  });
	}

	Dispatch.prototype = dispatch.prototype = {
	  constructor: Dispatch,
	  on: function (typename, callback) {
	    var _ = this._,
	        T = parseTypenames(typename + "", _),
	        t,
	        i = -1,
	        n = T.length; // If no callback was specified, return the callback of the given type and name.

	    if (arguments.length < 2) {
	      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;

	      return;
	    } // If a type was specified, set the callback for the given type and name.
	    // Otherwise, if a null callback was specified, remove callbacks of the given name.


	    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);

	    while (++i < n) {
	      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
	    }

	    return this;
	  },
	  copy: function () {
	    var copy = {},
	        _ = this._;

	    for (var t in _) copy[t] = _[t].slice();

	    return new Dispatch(copy);
	  },
	  call: function (type, that) {
	    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

	    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  },
	  apply: function (type, that, args) {
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

	    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  }
	};

	function get$1(type, name) {
	  for (var i = 0, n = type.length, c; i < n; ++i) {
	    if ((c = type[i]).name === name) {
	      return c.value;
	    }
	  }
	}

	function set(type, name, callback) {
	  for (var i = 0, n = type.length; i < n; ++i) {
	    if (type[i].name === name) {
	      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
	      break;
	    }
	  }

	  if (callback != null) type.push({
	    name: name,
	    value: callback
	  });
	  return type;
	}

	const PackageList = [{
	  name: 'NRRDLoader',
	  assets: ['assets/js/misc/Volume.js', 'assets/js/misc/VolumeSlice.js', 'assets/js/loaders/NRRDLoader.js']
	}, {
	  name: '3MFLoader',
	  assets: ['assets/js/loaders/3MFLoader.js']
	}, {
	  name: 'AMFLoader',
	  assets: ['assets/js/loaders/AMFLoader.js']
	}, {
	  name: 'AssimpLoader',
	  assets: ['assets/js/loaders/AssimpLoader.js']
	}, {
	  name: 'AWDLoader',
	  assets: ['assets/js/loaders/AWDLoader.js']
	}, {
	  name: 'BabylonLoader',
	  assets: ['assets/js/loaders/BabylonLoader.js']
	}, {
	  name: 'BinaryLoader',
	  assets: ['assets/js/loaders/BinaryLoader.js']
	}, {
	  name: 'BVHLoader',
	  assets: ['assets/js/loaders/BVHLoader.js']
	}, {
	  name: 'ColladaLoader',
	  assets: ['assets/js/loaders/ColladaLoader.js']
	}, {
	  name: 'FBXLoader',
	  assets: ['assets/js/curves/NURBSCurve.js', 'assets/js/curves/NURBSUtils.js', 'assets/js/loaders/FBXLoader.js']
	}, {
	  name: 'GCodeLoader',
	  assets: ['assets/js/loaders/GCodeLoader.js']
	}, {
	  name: 'DRACOLoader',
	  assets: ['assets/js/loaders/DRACOLoader.js']
	}, {
	  name: 'GLTFLoader',
	  assets: ['assets/js/loaders/GLTFLoader.js']
	}, {
	  name: 'LegacyJSONLoader',
	  assets: ['assets/js/loaders/deprecated/LegacyJSONLoader.js']
	}, {
	  name: 'KMZLoader',
	  assets: ['assets/js/loaders/KMZLoader.js']
	}, {
	  name: 'MD2Loader',
	  assets: ['assets/js/loaders/MD2Loader.js', 'assets/js/MD2Character.js']
	}, {
	  name: 'OBJLoader',
	  assets: ['assets/js/loaders/OBJLoader.js']
	}, {
	  name: 'OBJLoader2',
	  assets: ['assets/js/loaders/OBJLoader2.js']
	}, {
	  name: 'PCDLoader',
	  assets: ['assets/js/loaders/PCDLoader.js']
	}, {
	  name: 'PDBLoader',
	  assets: ['assets/js/loaders/PDBLoader.js']
	}, {
	  name: 'PLYLoader',
	  assets: ['assets/js/loaders/PLYLoader.js']
	}, {
	  name: 'PRWMLoader',
	  assets: ['assets/js/loaders/PRWMLoader.js']
	}, {
	  name: 'STLLoader',
	  assets: ['assets/js/loaders/STLLoader.js']
	}, {
	  name: 'TDSLoader',
	  assets: ['assets/js/loaders/TDSLoader.js']
	}, {
	  name: 'VRMLoader',
	  assets: ['assets/js/loaders/VRMLoader.js']
	}, {
	  name: 'VRMLLoader',
	  assets: ['assets/js/loaders/VRMLLoader.js']
	}, {
	  name: 'VTKLoader',
	  assets: ['assets/js/loaders/VTKLoader.js']
	}, {
	  name: 'CTMLoader',
	  assets: ['assets/js/libs/ctm.js', 'assets/js/loaders/ctm/CTMLoader.js']
	}, {
	  name: 'XLoader',
	  assets: ['assets/js/loaders/XLoader.js']
	}, {
	  name: 'SEA3D',
	  assets: ['assets/js/loaders/sea3d/SEA3D.js', 'assets/js/loaders/sea3d/SEA3DLZMA.js', 'assets/js/loaders/sea3d/SEA3DLoader.js', 'assets/js/libs/draco/draco_decoder.js', 'assets/js/loaders/sea3d/SEA3DDraco.js']
	}, {
	  name: 'lzma',
	  assets: ['assets/js/libs/lzma.js']
	}, {
	  name: 'codemirror',
	  assets: ['assets/css/codemirror.css', 'assets/css/theme/monokai.css', 'assets/js/codemirror.js', 'assets/js/mode/javascript.js', 'assets/js/mode/glsl.js']
	}, {
	  name: 'codemirror-addon',
	  assets: ['assets/css/addon/dialog.css', 'assets/css/addon/show-hint.css', 'assets/css/addon/tern.css', 'assets/js/addon/dialog.js', 'assets/js/addon/show-hint.js']
	}, {
	  name: 'esprima',
	  assets: ['assets/js/esprima.js']
	}, {
	  name: 'jsonlint',
	  assets: ['assets/js/jsonlint.js']
	}, {
	  name: 'glslprep',
	  assets: ['assets/js/glslprep.min.js']
	}, {
	  name: 'acorn',
	  assets: ['assets/js/acorn/acorn.js', 'assets/js/acorn/acorn_loose.js', 'assets/js/acorn/walk.js']
	}, {
	  name: 'ternjs',
	  assets: ['assets/js/addon/tern.js', 'assets/js/ternjs/polyfill.js', 'assets/js/ternjs/signal.js', 'assets/js/ternjs/tern.js', 'assets/js/ternjs/def.js', 'assets/js/ternjs/comment.js', 'assets/js/ternjs/infer.js', 'assets/js/ternjs/doc_comment.js', 'assets/js/tern-threejs/threejs.js']
	}, {
	  name: 'line',
	  assets: ['assets/js/lines/LineSegmentsGeometry.js', 'assets/js/lines/LineGeometry.js', 'assets/js/lines/WireframeGeometry2.js', 'assets/js/lines/LineMaterial.js', 'assets/js/lines/LineSegments2.js', 'assets/js/lines/Line2.js', 'assets/js/lines/Wireframe.js']
	}, {
	  name: 'GLTFExporter',
	  assets: ['assets/js/exporters/GLTFExporter.js']
	}, {
	  name: 'OBJExporter',
	  assets: ['assets/js/exporters/OBJExporter.js']
	}, {
	  name: 'PLYExporter',
	  assets: ['assets/js/exporters/PLYExporter.js']
	}, {
	  name: 'STLBinaryExporter',
	  assets: ['assets/js/exporters/STLBinaryExporter.js']
	}, {
	  name: 'STLExporter',
	  assets: ['assets/js/exporters/STLExporter.js']
	}, {
	  name: 'MMD',
	  assets: ['assets/js/libs/mmdparser.min.js', 'assets/js/loaders/MMDLoader.js', 'assets/js/animation/CCDIKSolver.js', 'assets/js/animation/MMDPhysics.js', 'assets/js/animation/MMDAnimationHelper.js']
	}, {
	  name: 'gl-matrix',
	  assets: ['assets/js/libs/gl-matrix.js']
	}, {
	  name: 'pako',
	  assets: ['assets/js/libs/pako.js']
	}, {
	  name: 'NormalMapShader',
	  assets: ['assets/js/shaders/NormalMapShader.js']
	}, {
	  name: 'FXAAShader',
	  assets: ['assets/js/shaders/FXAAShader.js']
	}, {
	  name: 'DotScreenShader',
	  assets: ['assets/js/shaders/DotScreenShader.js']
	}, {
	  name: 'RGBShiftShader',
	  assets: ['assets/js/shaders/RGBShiftShader.js']
	}, {
	  name: 'AfterimageShader',
	  assets: ['assets/js/shaders/AfterimageShader.js']
	}, {
	  name: 'BokehShader',
	  assets: ['assets/js/shaders/BokehShader.js']
	}, {
	  name: 'DigitalGlitch',
	  assets: ['assets/js/shaders/DigitalGlitch.js']
	}, {
	  name: 'HalftoneShader',
	  assets: ['assets/js/shaders/HalftoneShader.js']
	}, {
	  name: 'DepthLimitedBlurShader',
	  assets: ['assets/js/shaders/DepthLimitedBlurShader.js']
	}, {
	  name: 'UnpackDepthRGBAShader',
	  assets: ['assets/js/shaders/UnpackDepthRGBAShader.js']
	}, {
	  name: 'PixelShader',
	  assets: ['assets/js/shaders/PixelShader.js']
	}, {
	  name: 'SAOShader',
	  assets: ['assets/js/shaders/SAOShader.js']
	}, {
	  name: 'SMAAShader',
	  assets: ['assets/js/shaders/SMAAShader.js']
	}, {
	  name: 'SSAOShader',
	  assets: ['assets/js/shaders/SSAOShader.js']
	}, {
	  name: 'MaskPass',
	  assets: ['assets/js/postprocessing/MaskPass.js']
	}, {
	  name: 'AfterimagePass',
	  assets: ['assets/js/postprocessing/AfterimagePass.js']
	}, {
	  name: 'BokehPass',
	  assets: ['assets/js/postprocessing/BokehPass.js']
	}, {
	  name: 'GlitchPass',
	  assets: ['assets/js/postprocessing/GlitchPass.js']
	}, {
	  name: 'HalftonePass',
	  assets: ['assets/js/postprocessing/HalftonePass.js']
	}, {
	  name: 'SSAARenderPass',
	  assets: ['assets/js/postprocessing/SSAARenderPass.js']
	}, {
	  name: 'SMAAPass',
	  assets: ['assets/js/postprocessing/SMAAPass.js']
	}, {
	  name: 'TAARenderPass',
	  assets: ['assets/js/postprocessing/TAARenderPass.js']
	}, {
	  name: 'CopyShader',
	  assets: ['assets/js/shaders/CopyShader.js']
	}, {
	  name: 'EffectComposer',
	  assets: ['assets/js/postprocessing/EffectComposer.js']
	}, {
	  name: 'RenderPass',
	  assets: ['assets/js/postprocessing/RenderPass.js']
	}, {
	  name: 'ShaderPass',
	  assets: ['assets/js/postprocessing/ShaderPass.js']
	}, {
	  name: 'OutlinePass',
	  assets: ['assets/js/postprocessing/OutlinePass.js']
	}, {
	  name: 'SAOPass',
	  assets: ['assets/js/postprocessing/SAOPass.js']
	}, {
	  name: 'SSAOPass',
	  assets: ['assets/js/postprocessing/SSAOPass.js']
	}, {
	  name: 'FirstPersonControls',
	  assets: ['assets/js/controls/FirstPersonControls.js']
	}, {
	  name: 'FlyControls',
	  assets: ['assets/js/controls/FlyControls.js']
	}, {
	  name: 'EditorControls',
	  assets: ['assets/js/controls/EditorControls.js']
	}, {
	  name: 'OrbitControls',
	  assets: ['assets/js/controls/OrbitControls.js']
	}, {
	  name: 'PointerLockControls',
	  assets: ['assets/js/controls/PointerLockControls.js']
	}, {
	  name: 'TrackballControls',
	  assets: ['assets/js/controls/TrackballControls.js']
	}, {
	  name: 'TransformControls',
	  assets: ['assets/js/controls/TransformControls.js']
	}, {
	  name: 'SPE',
	  assets: ['assets/js/SPE.js']
	}, {
	  name: 'VolumetricFire',
	  assets: ['assets/js/VolumetricFire.js']
	}, {
	  name: 'ammo',
	  assets: ['assets/js/libs/ammo.js']
	}, {
	  name: 'chevrotain',
	  assets: ['assets/js/libs/chevrotain.min.js']
	}, {
	  name: 'TexGen',
	  assets: ['assets/js/libs/TexGen.js']
	}, {
	  name: 'ColladaExporter',
	  assets: ['assets/js/exporters/ColladaExporter.js']
	}, {
	  name: 'DRACOExporter',
	  assets: ['assets/js/libs/draco/draco_encoder.js', 'assets/js/exporters/DRACOExporter.js']
	}, {
	  name: 'MTLLoader',
	  assets: ['assets/js/loaders/MTLLoader.js']
	}, {
	  name: 'LoaderSupport',
	  assets: ['assets/js/loaders/LoaderSupport.js']
	}, {
	  name: 'opentype',
	  assets: ['assets/js/libs/opentype.js']
	}, {
	  name: 'GodRaysShader',
	  assets: ['assets/js/shaders/GodRaysShader.js']
	}];

	/**
	 * CSS下载器
	 * @author tengge / https://github.com/tengge1
	 */
	function CssLoader() {}

	CssLoader.prototype.load = function (url) {
	  var head = document.getElementsByTagName('head')[0];
	  var link = document.createElement('link');
	  link.type = 'text/css';
	  link.rel = 'stylesheet';
	  link.href = url;
	  head.appendChild(link);
	  return new Promise(resolve => {
	    link.onload = event => {
	      link.onload = link.onerror = null;
	      resolve(link, event);
	    };

	    link.onerror = event => {
	      link.onload = link.onerror = null;
	      console.warn(`CssLoader: ${url} loaded failed.`);
	      resolve(null, event);
	    };
	  });
	};

	/**
	 * JS下载器
	 * @author tengge / https://github.com/tengge1
	 */
	function JsLoader() {
	  this.assets = [];
	}

	JsLoader.prototype.load = function (url) {
	  var data = {
	    url,
	    script: null
	  };
	  this.assets.push(data);
	  return new Promise(resolve => {
	    fetch(url).then(response => {
	      if (response.ok) {
	        response.text().then(text => {
	          data.script = text;
	          resolve(data);
	        });
	      } else {
	        console.warn(`JsLoader: ${url} loaded failed.`);
	        resolve(null);
	      }
	    }).catch(() => {
	      console.warn(`JsLoader: ${url} loaded failed.`);
	      resolve(null);
	    });
	  });
	};

	JsLoader.prototype.eval = function () {
	  var eval2 = eval;
	  var script = '';
	  this.assets.forEach(n => {
	    if (n.script) {
	      script += n.script + '\n';
	    }
	  });

	  if (script) {
	    eval2.call(window, script);
	  }
	};

	const loaded = new Map();
	/**
	 * 包管理器
	 * @author tengge / https://github.com/tengge1
	 */

	function PackageManager() {}
	/**
	 * 加载包
	 * @param {Object} names 包名或包名列表
	 * @returns {Promise} Promise
	 */


	PackageManager.prototype.require = function (names) {
	  names = Array.isArray(names) ? names : [names];
	  var promises = [];
	  names.forEach(n => {
	    if (loaded.has(n) && loaded.get(n).loading === true) {
	      promises.push(loaded.get(n).promise);
	    } else if (!loaded.has(n)) {
	      var promise = Promise.all(promises).then(() => {
	        var packages = PackageList.filter(m => m.name === n);

	        if (packages.length === 0) {
	          console.warn(`PackageManager: ${n} does not exist.`);
	          return;
	        } else if (packages.length > 1) {
	          console.warn(`PackageManager: Package name ${n} duplicated.`);
	        }

	        var assets = [];
	        packages.forEach(m => {
	          assets.push.apply(assets, m.assets);
	        });
	        return this._load(assets).then(() => {
	          loaded.set(n, {
	            loading: false,
	            loaded: true,
	            promise: null
	          });
	          return new Promise(resolve => {
	            resolve();
	          });
	        });
	      });
	      loaded.set(n, {
	        loading: true,
	        loaded: false,
	        promise: promise
	      });
	      promises.push(promise);
	    }
	  });
	  return Promise.all(promises);
	};

	PackageManager.prototype._load = function (assets = []) {
	  var cssLoader = new CssLoader();
	  var jsLoader = new JsLoader();
	  var promises = assets.map(n => {
	    if (n.toLowerCase().endsWith('.css')) {
	      return cssLoader.load(n);
	    } else if (n.toLowerCase().endsWith('.js')) {
	      return jsLoader.load(n);
	    } else {
	      console.warn(`PackageManager: unknown assets ${n}.`);
	      return new Promise(resolve => {
	        resolve();
	      });
	    }
	  });
	  return Promise.all(promises).then(() => {
	    jsLoader.eval();
	    return new Promise(resolve => {
	      resolve();
	    });
	  });
	};

	var ID = -1;
	/**
	 * 播放器组件
	 * @param {Shadow.Player} app 播放器
	 */

	function PlayerComponent(app) {
	  this.id = `${this.constructor.name}${ID--}`;
	  this.app = app;
	}
	/**
	 * 创建
	 * @param {THREE.Scene} scene 场景
	 * @param {THREE.PersPectiveCamera} camera 透视相机
	 * @param {THREE.WebGLRenderer} renderer 渲染器
	 * @param {Object} others 其他参数
	 * @returns {Promise} 任务Promise
	 */


	PlayerComponent.prototype.create = function (scene, camera, renderer, others) {
	  // eslint-disable-line
	  return new Promise(resolve => {
	    resolve();
	  });
	};
	/**
	 * 更新
	 * @param {THREE.Clock} clock 时钟
	 * @param {Number} deltaTime 间隔时间
	 */


	PlayerComponent.prototype.update = function (clock, deltaTime) {// eslint-disable-line
	};
	/**
	 * 析构
	 * @param {THREE.Scene} scene 场景
	 * @param {THREE.PersPectiveCamera} camera 透视相机
	 * @param {THREE.WebGLRenderer} renderer 渲染器
	 * @param {Object} others 其他参数
	 */


	PlayerComponent.prototype.dispose = function (scene, camera, renderer, others) {// eslint-disable-line
	};

	/**
	 * 场景序列化信息
	 * @author tengge / https://github.com/tengge1
	 */
	var Metadata = {
	  generator: 'ShadowEditor',
	  type: 'Object',
	  version: '0.0.1'
	};

	var ID$1 = -1;
	/**
	 * 序列化器基类
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseSerializer() {
	  this.id = 'BaseSerializer' + ID$1--;
	  this.metadata = Object.assign({}, Metadata, {
	    generator: this.constructor.name
	  });
	}
	/**
	 *对象转json
	 * @param {Object} obj 对象
	 * @returns {Object} JSON对象
	 */


	BaseSerializer.prototype.toJSON = function (obj) {
	  // eslint-disable-line
	  var json = {
	    metadata: this.metadata
	  };
	  return json;
	};
	/**
	 * json转对象
	 * @param {Object} json json对象
	 * @param {Object} parent 父对象
	 * @returns {Object} 对象
	 */


	BaseSerializer.prototype.fromJSON = function (json, parent) {
	  // eslint-disable-line
	  if (parent) {
	    return parent;
	  }

	  return {};
	};

	/**
	 * Object3DSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function Object3DSerializer() {
	  BaseSerializer.call(this);
	}

	Object3DSerializer.prototype = Object.create(BaseSerializer.prototype);
	Object3DSerializer.prototype.constructor = Object3DSerializer;

	Object3DSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.castShadow = obj.castShadow;
	  json.children = obj.children.map(child => {
	    return child.uuid;
	  });
	  json.frustumCulled = obj.frustumCulled;
	  json.layers = obj.layers;
	  json.matrixAutoUpdate = obj.matrixAutoUpdate;
	  json.matrixWorldNeedsUpdate = obj.matrixWorldNeedsUpdate;
	  json.modelViewMatrix = obj.modelViewMatrix;
	  json.name = obj.name;
	  json.parent = !obj.parent ? null : obj.parent.uuid;
	  json.position = obj.position;
	  json.quaternion = {
	    x: obj.quaternion.x,
	    y: obj.quaternion.y,
	    z: obj.quaternion.z,
	    w: obj.quaternion.w
	  };
	  json.receiveShadow = obj.receiveShadow;
	  json.renderOrder = obj.renderOrder;
	  json.rotation = {
	    x: obj.rotation.x,
	    y: obj.rotation.y,
	    z: obj.rotation.z,
	    order: obj.rotation.order
	  };
	  json.scale = obj.scale;
	  json.type = obj.type;
	  json.up = obj.up;
	  json.userData = {};
	  Object.assign(json.userData, obj.userData);
	  delete json.userData.helper;
	  json.uuid = obj.uuid;
	  json.visible = obj.visible;
	  json.isObject3D = obj.isObject3D;
	  return json;
	};

	Object3DSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Object3D() : parent;
	  BaseSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.castShadow = json.castShadow;
	  obj.frustumCulled = json.frustumCulled;
	  obj.type = json.type;
	  obj.uuid = json.uuid;
	  obj.matrixAutoUpdate = json.matrixAutoUpdate;
	  obj.name = json.name;
	  obj.position.copy(json.position);
	  obj.quaternion.copy(json.quaternion);
	  obj.receiveShadow = json.receiveShadow;
	  obj.renderOrder = json.renderOrder;
	  obj.rotation.set(json.rotation.x, json.rotation.y, json.rotation.z, json.rotation.order);
	  obj.scale.copy(json.scale);
	  obj.up.copy(json.up);
	  obj.visible = json.visible;

	  for (var i in json.userData) {
	    if (json.userData[i]) {
	      obj.userData[i] = json.userData[i];
	    }
	  }

	  return obj;
	};

	/**
	 * 产生一个单像素画布
	 * @param {String} color 默认颜色
	 * @returns {HTMLCanvasElement} 画布
	 */
	function onePixelCanvas(color = '#000000') {
	  var canvas = document.createElement('canvas');
	  canvas.width = 1;
	  canvas.height = 1;
	  var ctx = canvas.getContext('2d');
	  ctx.fillStyle = color;
	  ctx.fillRect(0, 0, 1, 1);
	  return canvas;
	}
	/**
	 * 图片工具类
	 */


	const ImageUtils = {
	  onePixelCanvas: onePixelCanvas
	};

	/**
	 * TextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TextureSerializer() {
	  BaseSerializer.call(this);
	}

	TextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	TextureSerializer.prototype.constructor = TextureSerializer;

	TextureSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.anisotropy = obj.anisotropy;
	  json.center = obj.center;
	  json.encoding = obj.encoding;
	  json.flipY = obj.flipY;
	  json.format = obj.format;
	  json.generateMipmaps = obj.generateMipmaps; // 说明：立体贴图obj.image是一个图片数组。

	  if (obj.image && !Array.isArray(obj.image) && obj.image.tagName && obj.image.tagName.toLowerCase() === 'img') {
	    // 图片
	    var src = obj.image.src;

	    if (!src.startsWith('data:') && !src.startsWith('blob')) {
	      // data和blob地址不应该被修改
	      src = src.replace(location.href, '/');
	    }

	    json.image = {
	      tagName: 'img',
	      src: src,
	      width: obj.image.width,
	      height: obj.image.height
	    };
	  } else if (obj.image && !Array.isArray(obj.image) && obj.image.tagName && obj.image.tagName.toLowerCase() === 'canvas') {
	    // 画布
	    json.image = {
	      tagName: 'canvas',
	      src: obj.image.toDataURL(),
	      width: obj.image.width,
	      height: obj.image.height
	    };
	  } else {
	    json.image = null;
	  }

	  json.magFilter = obj.magFilter;
	  json.mapping = obj.mapping;
	  json.matrixAutoUpdate = obj.matrixAutoUpdate;
	  json.minFilter = obj.minFilter;
	  json.mipmaps = obj.mipmaps;
	  json.name = obj.name;
	  json.offset = obj.offset;
	  json.premultiplyAlpha = obj.premultiplyAlpha;
	  json.repeat = obj.repeat;
	  json.rotation = obj.rotation;
	  json.type = obj.type;
	  json.unpackAlignment = obj.unpackAlignment;
	  json.uuid = obj.uuid;
	  json.version = obj.version;
	  json.wrapS = obj.wrapS;
	  json.wrapT = obj.wrapT;
	  json.isTexture = obj.isTexture;
	  json.needsUpdate = obj.needsUpdate;
	  return json;
	};

	TextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  // 用一个像素的图片初始化Texture，避免图片载入前的警告信息。
	  var img = ImageUtils.onePixelCanvas();
	  var obj = parent === undefined ? new THREE.Texture(img) : parent;
	  obj.anisotropy = json.anisotropy;
	  obj.center.copy(json.center);
	  obj.encoding = json.encoding;
	  obj.flipY = json.flipY;
	  obj.format = json.format;
	  obj.generateMipmaps = json.generateMipmaps;

	  if (json.image && !Array.isArray(json.image) && json.image.tagName === 'img') {
	    // 图片
	    img = document.createElement('img');

	    if (!json.image.src.startsWith('blob:http://')) {
	      // 这种类型不能被反序列化，例如：blob:http://localhost:2000/d6590b48-8b50-44d0-a3a7-248a8047bc89
	      if (json.image.src && json.image.src.startsWith('/')) {
	        img.src = server + json.image.src;
	      } else {
	        img.src = json.image.src;
	      }
	    }

	    img.width = json.image.width;
	    img.height = json.image.height;

	    img.onload = function () {
	      obj.image = img;
	      obj.needsUpdate = true;
	    };
	  } else if (json.image && !Array.isArray(obj.image) && json.image.tagName === 'canvas') {
	    // 画布
	    var canvas = document.createElement('canvas');
	    canvas.width = 256;
	    canvas.height = 256;
	    var ctx = canvas.getContext('2d');
	    img = document.createElement('img');

	    if (json.image.src && json.image.src.startsWith('/')) {
	      img.src = server + json.image.src;
	    } else {
	      img.src = json.image.src;
	    }

	    img.onload = function () {
	      canvas.width = img.width;
	      canvas.height = img.height;
	      ctx.drawImage(img, 0, 0);
	      obj.needsUpdate = true;
	    };

	    obj.image = canvas;
	  }

	  obj.magFilter = json.magFilter;
	  obj.mapping = json.mapping;
	  obj.matrixAutoUpdate = json.matrixAutoUpdate;
	  obj.minFilter = json.minFilter;
	  obj.mipmaps = json.mipmaps;
	  obj.name = json.name;
	  obj.offset.copy(json.offset);
	  obj.premultiplyAlpha = json.premultiplyAlpha;
	  obj.repeat.copy(json.repeat);
	  obj.rotation = json.rotation;
	  obj.type = json.type;
	  obj.unpackAlignment = json.unpackAlignment;
	  obj.uuid = json.uuid;
	  obj.version = json.version;
	  obj.wrapS = json.wrapS;
	  obj.wrapT = json.wrapT;
	  obj.isTexture = json.isTexture;
	  obj.needsUpdate = true;
	  return obj;
	};

	/**
	 * CanvasTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CanvasTextureSerializer() {
	  BaseSerializer.call(this);
	}

	CanvasTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	CanvasTextureSerializer.prototype.constructor = CanvasTextureSerializer;

	CanvasTextureSerializer.prototype.toJSON = function (obj) {
	  return TextureSerializer.prototype.toJSON.call(this, obj);
	};

	CanvasTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.CanvasTexture() : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * CompressedTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CompressedTextureSerializer() {
	  BaseSerializer.call(this);
	}

	CompressedTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	CompressedTextureSerializer.prototype.constructor = CompressedTextureSerializer;

	CompressedTextureSerializer.prototype.toJSON = function (obj) {
	  return TextureSerializer.prototype.toJSON.call(this, obj);
	};

	CompressedTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.CompressedTexture() : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * CubeTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CubeTextureSerializer() {
	  BaseSerializer.call(this);
	}

	CubeTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	CubeTextureSerializer.prototype.constructor = CubeTextureSerializer;

	CubeTextureSerializer.prototype.toJSON = function (obj) {
	  var json = TextureSerializer.prototype.toJSON.call(this, obj);
	  json.image = [];
	  obj.image.forEach(n => {
	    if (n.src.startsWith('data')) {
	      // base64
	      json.image.push({
	        tagName: 'img',
	        src: n.src,
	        width: n.width,
	        height: n.height
	      });
	    } else {
	      // url
	      json.image.push({
	        tagName: 'img',
	        src: n.src.replace(location.href, '/'),
	        width: n.width,
	        height: n.height
	      });
	    }
	  });
	  return json;
	};

	CubeTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  // 用一个像素的图片初始化CubeTexture，避免图片载入前的警告信息。
	  var img = ImageUtils.onePixelCanvas();
	  var obj = parent === undefined ? new THREE.CubeTexture([img, img, img, img, img, img]) : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);

	  if (Array.isArray(json.image)) {
	    var promises = json.image.map(n => {
	      return new Promise(resolve => {
	        var img = document.createElement('img');

	        if (n.src && n.src.startsWith('/')) {
	          img.src = server + n.src;
	        } else {
	          img.src = n.src;
	        }

	        img.width = n.width;
	        img.height = n.height;

	        img.onload = () => {
	          resolve(img);
	        };
	      });
	    });
	    Promise.all(promises).then(imgs => {
	      obj.image = imgs;
	      obj.needsUpdate = true;
	    });
	  }

	  return obj;
	};

	/**
	 * DataTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function DataTextureSerializer() {
	  BaseSerializer.call(this);
	}

	DataTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	DataTextureSerializer.prototype.constructor = DataTextureSerializer;

	DataTextureSerializer.prototype.toJSON = function (obj) {
	  return TextureSerializer.prototype.toJSON.call(this, obj);
	};

	DataTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.DataTexture() : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * DepthTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function DepthTextureSerializer() {
	  BaseSerializer.call(this);
	}

	DepthTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	DepthTextureSerializer.prototype.constructor = DepthTextureSerializer;

	DepthTextureSerializer.prototype.toJSON = function (obj) {
	  return TextureSerializer.prototype.toJSON.call(this, obj);
	};

	DepthTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.DataTexture() : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * VideoTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function VideoTextureSerializer() {
	  BaseSerializer.call(this);
	}

	VideoTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	VideoTextureSerializer.prototype.constructor = VideoTextureSerializer;

	VideoTextureSerializer.prototype.toJSON = function (obj) {
	  var json = TextureSerializer.prototype.toJSON.call(this, obj);
	  json.image = {
	    tagName: 'video',
	    src: obj.image.src.replace(location.href, '/')
	  };
	  return json;
	};

	VideoTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  let video = document.createElement('video');
	  video.setAttribute('src', server + json.image.src);
	  video.setAttribute('autoplay', 'autoplay');
	  video.setAttribute('loop', 'loop');
	  video.setAttribute('crossorigin', 'anonymous');
	  var obj = parent === undefined ? new THREE.VideoTexture(video) : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	var Serializers = {
	  'CanvasTexture': CanvasTextureSerializer,
	  'CompressedTexture': CompressedTextureSerializer,
	  'CubeTexture': CubeTextureSerializer,
	  'DataTexture': DataTextureSerializer,
	  'DepthTexture': DepthTextureSerializer,
	  'VideoTexture': VideoTextureSerializer,
	  'Texture': TextureSerializer
	};
	/**
	 * TexturesSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TexturesSerializer() {
	  BaseSerializer.call(this);
	}

	TexturesSerializer.prototype = Object.create(BaseSerializer.prototype);
	TexturesSerializer.prototype.constructor = TexturesSerializer;

	TexturesSerializer.prototype.toJSON = function (obj) {
	  var serializer = Serializers[obj.constructor.name];

	  if (serializer === undefined) {
	    console.warn(`TexturesSerializer: No serializer with ${obj.type}.`);
	    return null;
	  }

	  return new serializer().toJSON(obj);
	};

	TexturesSerializer.prototype.fromJSON = function (json, parent, server) {
	  var generator = json.metadata.generator;
	  var serializer = Serializers[generator.replace('Serializer', '')];

	  if (serializer === undefined) {
	    console.warn(`TexturesSerializer: No deserializer with ${generator}.`);
	    return null;
	  }

	  return new serializer().fromJSON(json, parent, server);
	};

	/**
	 * MaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MaterialSerializer.prototype.constructor = MaterialSerializer;

	MaterialSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.alphaMap = !obj.alphaMap ? null : new TexturesSerializer().toJSON(obj.alphaMap);
	  json.alphaTest = obj.alphaTest;
	  json.aoMap = !obj.aoMap ? null : new TexturesSerializer().toJSON(obj.aoMap);
	  json.aoMapIntensity = obj.aoMapIntensity;
	  json.blendDst = obj.blendDst;
	  json.blendDstAlpha = obj.blendDstAlpha;
	  json.blendEquation = obj.blendEquation;
	  json.blendEquationAlpha = obj.blendEquationAlpha;
	  json.blendSrc = obj.blendSrc;
	  json.blendSrcAlpha = obj.blendSrcAlpha;
	  json.blending = obj.blending;
	  json.bumpMap = !obj.bumpMap ? null : new TexturesSerializer().toJSON(obj.bumpMap);
	  json.bumpScale = obj.bumpScale;
	  json.clipIntersection = obj.clipIntersection;
	  json.clipShadow = obj.clipShadow;
	  json.clippingPlanes = obj.clippingPlanes;
	  json.color = obj.color;
	  json.colorWrite = obj.colorWrite;
	  json.depthFunc = obj.depthFunc;
	  json.depthTest = obj.depthTest;
	  json.depthWrite = obj.depthWrite;
	  json.displacementBias = obj.displacementBias;
	  json.displacementMap = !obj.displacementMap ? null : new TexturesSerializer().toJSON(obj.displacementMap);
	  json.displacementScale = obj.displacementScale;
	  json.dithering = obj.dithering;
	  json.emissive = obj.emissive;
	  json.emissiveIntensity = obj.emissiveIntensity;
	  json.emissiveMap = !obj.emissiveMap ? null : new TexturesSerializer().toJSON(obj.emissiveMap);

	  if (obj.specular) {
	    json.specular = obj.specular;
	  }

	  if (obj.specularMap) {
	    json.specularMap = new TexturesSerializer().toJSON(obj.specularMap);
	  }

	  json.envMap = !obj.envMap ? null : new TexturesSerializer().toJSON(obj.envMap);
	  json.envMapIntensity = obj.envMapIntensity;
	  json.flatShading = obj.flatShading;
	  json.fog = obj.fog;
	  json.lightMap = !obj.lightMap ? null : new TexturesSerializer().toJSON(obj.lightMap);
	  json.lightMapIntensity = obj.lightMapIntensity;
	  json.lights = obj.lights;
	  json.linewidth = obj.linewidth;
	  json.map = !obj.map ? null : new TexturesSerializer().toJSON(obj.map);
	  json.metalness = obj.metalness;
	  json.metalnessMap = !obj.metalnessMap ? null : new TexturesSerializer().toJSON(obj.metalnessMap);
	  json.morphNormals = obj.morphNormals;
	  json.morphTargets = obj.morphTargets;
	  json.name = obj.name;
	  json.normalMap = !obj.normalMap ? null : new TexturesSerializer().toJSON(obj.normalMap);
	  json.normalScale = obj.normalScale;
	  json.opacity = obj.opacity;
	  json.polygonOffset = obj.polygonOffset;
	  json.polygonOffsetFactor = obj.polygonOffsetFactor;
	  json.polygonOffsetUnits = obj.polygonOffsetUnits;
	  json.precision = obj.precision;
	  json.premultipliedAlpha = obj.premultipliedAlpha;
	  json.refractionRatio = obj.refractionRatio;
	  json.roughness = obj.roughness;
	  json.roughnessMap = !obj.roughnessMap ? null : new TexturesSerializer().toJSON(obj.roughnessMap);
	  json.shadowSide = obj.shadowSide;
	  json.side = obj.side;
	  json.skinning = obj.skinning;
	  json.transparent = obj.transparent;
	  json.type = obj.type;
	  json.userData = obj.userData;
	  json.uuid = obj.uuid;
	  json.vertexColors = obj.vertexColors;
	  json.visible = obj.visible;
	  json.wireframe = obj.wireframe;
	  json.wireframeLinecap = obj.wireframeLinecap;
	  json.wireframeLinejoin = obj.wireframeLinejoin;
	  json.wireframeLinewidth = obj.wireframeLinewidth;
	  return json;
	};

	MaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.Material() : parent;
	  obj.alphaMap = !json.alphaMap ? null : new TexturesSerializer().fromJSON(json.alphaMap, undefined, server);
	  obj.alphaTest = json.alphaTest;
	  obj.aoMap = !json.aoMap ? null : new TexturesSerializer().fromJSON(json.aoMap, undefined, server);
	  obj.aoMapIntensity = json.aoMapIntensity;
	  obj.blendDst = json.blendDst;
	  obj.blendDstAlpha = json.blendDstAlpha;
	  obj.blendEquation = json.blendEquation;
	  obj.blendEquationAlpha = json.blendEquationAlpha;
	  obj.blendSrc = json.blendSrc;
	  obj.blendSrcAlpha = json.blendSrcAlpha;
	  obj.blending = json.blending;
	  obj.bumpMap = !json.bumpMap ? null : new TexturesSerializer().fromJSON(json.bumpMap, undefined, server);
	  obj.bumpScale = json.bumpScale;
	  obj.clipIntersection = json.clipIntersection;
	  obj.clipShadow = json.clipShadow;
	  obj.clippingPlanes = json.clippingPlanes;
	  obj.color = !json.color ? null : new THREE.Color(json.color);
	  obj.colorWrite = json.colorWrite;
	  obj.depthFunc = json.depthFunc;
	  obj.depthTest = json.depthTest;
	  obj.depthWrite = json.depthWrite;
	  obj.displacementBias = json.displacementBias;
	  obj.displacementMap = !json.displacementMap ? null : new TexturesSerializer().fromJSON(json.displacementMap, undefined, server);
	  obj.displacementScale = json.displacementScale;
	  obj.dithering = json.dithering;
	  obj.emissive = json.emissive === undefined ? undefined : new THREE.Color(json.emissive);
	  obj.emissiveIntensity = json.emissiveIntensity;
	  obj.emissiveMap = !json.emissiveMap ? null : new TexturesSerializer().fromJSON(json.emissiveMap, undefined, server);

	  if (json.specular) {
	    // bug: json.specular是颜色值。
	    obj.specular = new THREE.Color(json.specular);
	  }

	  if (json.specularMap) {
	    obj.specularMap = new TexturesSerializer().fromJSON(json.specularMap, undefined, server);
	  }

	  obj.envMap = !json.envMap ? null : new TexturesSerializer().fromJSON(json.envMap, undefined, server);
	  obj.envMapIntensity = json.envMapIntensity;
	  obj.flatShading = json.flatShading;
	  obj.fog = json.fog;
	  obj.lightMap = !json.lightMap ? null : new TexturesSerializer().fromJSON(json.lightMap, undefined, server);
	  obj.lightMapIntensity = json.lightMapIntensity;
	  obj.lights = json.lights;
	  obj.linewidth = json.linewidth;
	  obj.map = !json.map ? null : new TexturesSerializer().fromJSON(json.map, undefined, server);
	  obj.metalness = json.metalness;
	  obj.metalnessMap = !json.metalnessMap ? null : new TexturesSerializer().fromJSON(json.metalnessMap, undefined, server);
	  obj.morphNormals = json.morphNormals;
	  obj.morphTargets = json.morphTargets;
	  obj.name = json.name;
	  obj.normalMap = !json.normalMap ? null : new TexturesSerializer().fromJSON(json.normalMap, undefined, server);
	  obj.normalScale = !json.normalScale ? null : new THREE.Vector2().copy(json.normalScale);
	  obj.opacity = json.opacity;
	  obj.polygonOffset = json.polygonOffset;
	  obj.polygonOffsetFactor = json.polygonOffsetFactor;
	  obj.polygonOffsetUnits = json.polygonOffsetUnits;
	  obj.precision = json.precision;
	  obj.premultipliedAlpha = json.premultipliedAlpha;
	  obj.refractionRatio = json.refractionRatio;
	  obj.roughness = json.roughness;
	  obj.roughnessMap = !json.roughnessMap ? null : new TexturesSerializer().fromJSON(json.roughnessMap, undefined, server);
	  obj.shadowSide = json.shadowSide;
	  obj.side = json.side;
	  obj.skinning = json.skinning;
	  obj.transparent = json.transparent;
	  obj.type = json.type;
	  obj.userData = json.userData;
	  obj.uuid = json.uuid;
	  obj.vertexColors = json.vertexColors;
	  obj.visible = json.visible;
	  obj.wireframe = json.wireframe;
	  obj.wireframeLinecap = json.wireframeLinecap;
	  obj.wireframeLinejoin = json.wireframeLinejoin;
	  obj.wireframeLinewidth = json.wireframeLinewidth;
	  return obj;
	};

	/**
	 * LineBasicMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LineBasicMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	LineBasicMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	LineBasicMaterialSerializer.prototype.constructor = LineBasicMaterialSerializer;

	LineBasicMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	LineBasicMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.LineBasicMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * LineDashedMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LineDashedMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	LineDashedMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	LineDashedMaterialSerializer.prototype.constructor = LineDashedMaterialSerializer;

	LineDashedMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	LineDashedMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.LineDashedMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshBasicMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshBasicMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshBasicMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshBasicMaterialSerializer.prototype.constructor = MeshBasicMaterialSerializer;

	MeshBasicMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshBasicMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshBasicMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshDepthMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshDepthMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshDepthMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshDepthMaterialSerializer.prototype.constructor = MeshDepthMaterialSerializer;

	MeshDepthMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshDepthMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshDepthMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshDistanceMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshDistanceMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshDistanceMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshDistanceMaterialSerializer.prototype.constructor = MeshDistanceMaterialSerializer;

	MeshDistanceMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshDistanceMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshDistanceMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshFaceMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshFaceMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshFaceMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshFaceMaterialSerializer.prototype.constructor = MeshFaceMaterialSerializer;

	MeshFaceMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshFaceMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshFaceMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshLambertMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshLambertMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshLambertMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshLambertMaterialSerializer.prototype.constructor = MeshLambertMaterialSerializer;

	MeshLambertMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshLambertMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshLambertMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshNormalMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshNormalMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshNormalMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshNormalMaterialSerializer.prototype.constructor = MeshNormalMaterialSerializer;

	MeshNormalMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshNormalMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshNormalMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshPhongMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshPhongMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshPhongMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshPhongMaterialSerializer.prototype.constructor = MeshPhongMaterialSerializer;

	MeshPhongMaterialSerializer.prototype.toJSON = function (obj) {
	  let json = MaterialSerializer.prototype.toJSON.call(this, obj);
	  json.specular = obj.specular;
	  json.shininess = obj.shininess;
	  return json;
	};

	MeshPhongMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshPhongMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  obj.specular = new THREE.Color(json.specular);
	  obj.shininess = json.shininess;
	  return obj;
	};

	/**
	 * MeshPhysicalMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshPhysicalMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshPhysicalMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshPhysicalMaterialSerializer.prototype.constructor = MeshPhysicalMaterialSerializer;

	MeshPhysicalMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshPhysicalMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshPhysicalMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshStandardMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshStandardMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshStandardMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshStandardMaterialSerializer.prototype.constructor = MeshStandardMaterialSerializer;

	MeshStandardMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshStandardMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshStandardMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshToonMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshToonMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshToonMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshToonMaterialSerializer.prototype.constructor = MeshToonMaterialSerializer;

	MeshToonMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshToonMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshToonMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MultiMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MultiMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MultiMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MultiMaterialSerializer.prototype.constructor = MultiMaterialSerializer;

	MultiMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MultiMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MultiMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * ParticleBasicMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ParticleBasicMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	ParticleBasicMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	ParticleBasicMaterialSerializer.prototype.constructor = ParticleBasicMaterialSerializer;

	ParticleBasicMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	ParticleBasicMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.ParticleBasicMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * ParticleSystemMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ParticleSystemMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	ParticleSystemMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	ParticleSystemMaterialSerializer.prototype.constructor = ParticleSystemMaterialSerializer;

	ParticleSystemMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	ParticleSystemMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.ParticleSystemMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * PointCloudMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PointCloudMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	PointCloudMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	PointCloudMaterialSerializer.prototype.constructor = PointCloudMaterialSerializer;

	PointCloudMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	PointCloudMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.PointCloudMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * PointsMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PointsMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	PointsMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	PointsMaterialSerializer.prototype.constructor = PointsMaterialSerializer;

	PointsMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	PointsMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.PointsMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * UniformsSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function UniformsSerializer() {
	  BaseSerializer.call(this);
	}

	UniformsSerializer.prototype = Object.create(BaseSerializer.prototype);
	UniformsSerializer.prototype.constructor = UniformsSerializer;

	UniformsSerializer.prototype.toJSON = function (obj) {
	  let json = {};
	  Object.keys(obj).forEach(n => {
	    const item = obj[n];

	    if (item.value === null) {
	      json[n] = {
	        type: 'null',
	        value: null
	      };
	    } else if (item.value instanceof THREE.Texture) {
	      // 纹理
	      json[n] = {
	        type: 't',
	        value: new TexturesSerializer().toJSON(item.value)
	      };
	    } else if (item.value instanceof THREE.Color) {
	      // 颜色
	      json[n] = {
	        type: 'c',
	        value: item.value
	      };
	    } else if (Number.isInteger(item.value)) {
	      // 整数
	      json[n] = {
	        type: 'i',
	        value: item.value
	      };
	    } else if (typeof item.value === 'number') {
	      // 浮点数
	      json[n] = {
	        type: 'f',
	        value: item.value
	      };
	    } else if (item.value instanceof THREE.Vector2) {
	      // Vector2
	      json[n] = {
	        type: 'v2',
	        value: item.value
	      };
	    } else if (item.value instanceof THREE.Vector3) {
	      // Vector3
	      json[n] = {
	        type: 'v3',
	        value: item.value
	      };
	    } else if (item.value instanceof THREE.Vector4) {
	      // Vector4
	      json[n] = {
	        type: 'v4',
	        value: item.value
	      };
	    } else if (item.value instanceof THREE.Matrix3) {
	      // Matrix3
	      json[n] = {
	        type: 'm3',
	        value: item.value
	      };
	    } else if (item.value instanceof THREE.Matrix4) {
	      // Matrix4
	      json[n] = {
	        type: 'm4',
	        value: item.value
	      };
	    } else if (Array.isArray(item.value) && item.value.every(n => typeof n === 'number')) {
	      // 浮点数数组
	      json[n] = {
	        type: 'af',
	        value: item.value
	      };
	    } else if (Array.isArray(item.value) && item.value.every(n => n instanceof THREE.Vector2)) {
	      // Vector2数组
	      json[n] = {
	        type: 'av2',
	        value: item.value
	      };
	    } else if (Array.isArray(item.value) && item.value.every(n => n instanceof THREE.Vector3)) {
	      // Vector3数组
	      json[n] = {
	        type: 'av3',
	        value: item.value
	      };
	    } else if (Array.isArray(item.value) && item.value.every(n => n instanceof THREE.Vector4)) {
	      // Vector4数组
	      json[n] = {
	        type: 'av4',
	        value: item.value
	      };
	    } else if (Array.isArray(item.value) && item.value.every(n => n instanceof THREE.Matrix3)) {
	      // Matrix3数组
	      json[n] = {
	        type: 'am3',
	        value: item.value
	      };
	    } else if (Array.isArray(item.value) && item.value.every(n => n instanceof THREE.Matrix4)) {
	      // Matrix4数组
	      json[n] = {
	        type: 'am4',
	        value: item.value
	      };
	    } else if (Array.isArray(item.value) && item.value.every(n => n instanceof THREE.Texture)) {
	      // Texture数组
	      json[n] = {
	        type: 'at',
	        value: item.value.map(m => new TexturesSerializer().toJSON(m))
	      };
	    } else {
	      console.warn(`UniformsSerializer: unknown uniform type: `, item.value);
	      json[n] = {
	        type: 'unknow',
	        value: item.value
	      };
	    }
	  });
	  return json;
	};

	UniformsSerializer.prototype.fromJSON = function (json, parent, server) {
	  let obj = {};
	  Object.keys(json).forEach(n => {
	    const type = json[n].type;
	    const value = json[n].value;

	    if (type === 'null') {
	      obj[n] = {
	        value: null
	      };
	    } else if (type === 't') {
	      obj[n] = {
	        value: new TexturesSerializer().fromJSON(value, undefined, server)
	      };
	    } else if (type === 'c' || type === 'color') {
	      // TODO: type === 'color'为兼容旧场景
	      obj[n] = {
	        value: new THREE.Color(value)
	      };
	    } else if (type === 'i') {
	      obj[n] = {
	        value
	      };
	    } else if (type === 'f') {
	      obj[n] = {
	        value
	      };
	    } else if (type === 'v2') {
	      obj[n] = {
	        value: new THREE.Vector2().copy(value)
	      };
	    } else if (type === 'v3') {
	      obj[n] = {
	        value: new THREE.Vector3().copy(value)
	      };
	    } else if (type === 'v4') {
	      obj[n] = {
	        value: new THREE.Vector4().copy(value)
	      };
	    } else if (type === 'm3') {
	      obj[n] = {
	        value: new THREE.Matrix3().copy(value)
	      };
	    } else if (type === 'm4') {
	      obj[n] = {
	        value: new THREE.Matrix4().copy(value)
	      };
	    } else if (type === 'af') {
	      obj[n] = {
	        value: value
	      };
	    } else if (type === 'av2') {
	      obj[n] = {
	        value: value.map(m => new THREE.Vector2().copy(m))
	      };
	    } else if (type === 'av3') {
	      obj[n] = {
	        value: value.map(m => new THREE.Vector3().copy(m))
	      };
	    } else if (type === 'av4') {
	      obj[n] = {
	        value: value.map(m => new THREE.Vector4().copy(m))
	      };
	    } else if (type === 'am3') {
	      obj[n] = {
	        value: value.map(m => new THREE.Matrix3().copy(m))
	      };
	    } else if (type === 'am4') {
	      obj[n] = {
	        value: value.map(m => new THREE.Matrix4().copy(m))
	      };
	    } else if (type === 'at') {
	      obj[n] = {
	        value: value.map(m => new TexturesSerializer().fromJSON(m, undefined, server))
	      };
	    } else {
	      console.warn(`UniformsSerializer: unknown uniform type: `, type);
	      obj[n] = {
	        value: value
	      };
	    }
	  });
	  return obj;
	};

	/**
	 * RawShaderMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function RawShaderMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	RawShaderMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	RawShaderMaterialSerializer.prototype.constructor = RawShaderMaterialSerializer;

	RawShaderMaterialSerializer.prototype.toJSON = function (obj) {
	  var json = MaterialSerializer.prototype.toJSON.call(this, obj);
	  json.defines = obj.defines;
	  json.uniforms = new UniformsSerializer().toJSON(obj.uniforms);
	  json.vertexShader = obj.vertexShader;
	  json.fragmentShader = obj.fragmentShader;
	  return json;
	};

	RawShaderMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.RawShaderMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  obj.defines = json.defines;
	  obj.uniforms = new UniformsSerializer().fromJSON(json.uniforms, undefined, server);
	  obj.vertexShader = json.vertexShader;
	  obj.fragmentShader = json.fragmentShader;
	  return obj;
	};

	/**
	 * ShaderMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ShaderMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	ShaderMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	ShaderMaterialSerializer.prototype.constructor = ShaderMaterialSerializer;

	ShaderMaterialSerializer.prototype.toJSON = function (obj) {
	  var json = MaterialSerializer.prototype.toJSON.call(this, obj);
	  json.defines = obj.defines;
	  json.uniforms = new UniformsSerializer().toJSON(obj.uniforms);
	  json.vertexShader = obj.vertexShader;
	  json.fragmentShader = obj.fragmentShader;
	  json.extensions = obj.extensions;
	  return json;
	};

	ShaderMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.ShaderMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  obj.defines = json.defines;
	  obj.uniforms = new UniformsSerializer().fromJSON(json.uniforms, undefined, server);
	  obj.vertexShader = json.vertexShader;
	  obj.fragmentShader = json.fragmentShader;
	  obj.extensions = json.extensions;
	  return obj;
	};

	/**
	 * ShadowMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ShadowMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	ShadowMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	ShadowMaterialSerializer.prototype.constructor = ShadowMaterialSerializer;

	ShadowMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	ShadowMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.ShadowMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * SpriteCanvasMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SpriteCanvasMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	SpriteCanvasMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	SpriteCanvasMaterialSerializer.prototype.constructor = SpriteCanvasMaterialSerializer;

	SpriteCanvasMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	SpriteCanvasMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.SpriteCanvasMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * SpriteMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SpriteMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	SpriteMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	SpriteMaterialSerializer.prototype.constructor = SpriteMaterialSerializer;

	SpriteMaterialSerializer.prototype.toJSON = function (obj) {
	  var json = MaterialSerializer.prototype.toJSON.call(this, obj);
	  json.isSpriteMaterial = true;
	  return json;
	};

	SpriteMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.SpriteMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	var Serializers$1 = {
	  'LineBasicMaterial': LineBasicMaterialSerializer,
	  'LineDashedMaterial': LineDashedMaterialSerializer,
	  'MeshBasicMaterial': MeshBasicMaterialSerializer,
	  'MeshDepthMaterial': MeshDepthMaterialSerializer,
	  'MeshDistanceMaterial': MeshDistanceMaterialSerializer,
	  'MeshFaceMaterial': MeshFaceMaterialSerializer,
	  'MeshLambertMaterial': MeshLambertMaterialSerializer,
	  'MeshNormalMaterial': MeshNormalMaterialSerializer,
	  'MeshPhongMaterial': MeshPhongMaterialSerializer,
	  'MeshPhysicalMaterial': MeshPhysicalMaterialSerializer,
	  'MeshStandardMaterial': MeshStandardMaterialSerializer,
	  'MeshToonMaterial': MeshToonMaterialSerializer,
	  'MultiMaterial': MultiMaterialSerializer,
	  'ParticleBasicMaterial': ParticleBasicMaterialSerializer,
	  'ParticleSystemMaterial': ParticleSystemMaterialSerializer,
	  'PointCloudMaterial': PointCloudMaterialSerializer,
	  'PointsMaterial': PointsMaterialSerializer,
	  'RawShaderMaterial': RawShaderMaterialSerializer,
	  'ShaderMaterial': ShaderMaterialSerializer,
	  'ShadowMaterial': ShadowMaterialSerializer,
	  'SpriteCanvasMaterial': SpriteCanvasMaterialSerializer,
	  'SpriteMaterial': SpriteMaterialSerializer
	};
	/**
	 * MaterialsSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MaterialsSerializer() {
	  BaseSerializer.call(this);
	}

	MaterialsSerializer.prototype = Object.create(BaseSerializer.prototype);
	MaterialsSerializer.prototype.constructor = MaterialsSerializer;

	MaterialsSerializer.prototype.toJSON = function (obj) {
	  if (Array.isArray(obj)) {
	    // 多材质
	    var list = [];
	    obj.forEach(n => {
	      var serializer = Serializers$1[n.type];

	      if (serializer === undefined) {
	        console.warn(`MaterialsSerializer: No serializer with ${n.type}.`);
	        return;
	      }

	      list.push(new serializer().toJSON(n));
	    });
	    return list;
	  } else {
	    // 单材质
	    var serializer = Serializers$1[obj.type];

	    if (serializer === undefined) {
	      console.warn(`MaterialsSerializer: No serializer with ${obj.type}.`);
	      return null;
	    }

	    return new serializer().toJSON(obj);
	  }
	};

	MaterialsSerializer.prototype.fromJSON = function (json, parent, server) {
	  if (Array.isArray(json)) {
	    // 多材质
	    var list = [];
	    json.forEach(n => {
	      var generator = n.metadata.generator;
	      var serializer = Serializers$1[generator.replace('Serializer', '')];

	      if (serializer === undefined) {
	        console.warn(`MaterialsSerializer: No deserializer with ${generator}.`);
	        return null;
	      }

	      list.push(new serializer().fromJSON(n, parent, server));
	    });
	    return list;
	  } else {
	    // 单材质
	    var generator = json.metadata.generator;
	    var serializer = Serializers$1[generator.replace('Serializer', '')];

	    if (serializer === undefined) {
	      console.warn(`MaterialsSerializer: No deserializer with ${generator}.`);
	      return null;
	    }

	    return new serializer().fromJSON(json, parent, server);
	  }
	};

	/**
	 * SceneSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SceneSerializer() {
	  BaseSerializer.call(this);
	}

	SceneSerializer.prototype = Object.create(BaseSerializer.prototype);
	SceneSerializer.prototype.constructor = SceneSerializer;

	SceneSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);

	  if (obj.background instanceof THREE.Texture) {
	    // 天空盒和背景图片
	    json.background = new TexturesSerializer().toJSON(obj.background);
	  } else {
	    // 纯色
	    json.background = obj.background;
	  }

	  json.fog = obj.fog;
	  json.overrideMaterial = !obj.overrideMaterial ? null : new MaterialsSerializer().toJSON(obj.overrideMaterial);
	  return json;
	};

	SceneSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.Scene() : parent;
	  Object3DSerializer.prototype.fromJSON(json, obj);

	  if (json.background && json.background.metadata && (json.background.metadata.generator === 'CubeTextureSerializer' || json.background.metadata.generator === 'TextureSerializer')) {
	    // 天空盒和背景图片
	    obj.background = new TexturesSerializer().fromJSON(json.background, undefined, server);
	  } else if (json.background) {
	    // 纯色
	    obj.background = new THREE.Color(json.background);
	  }

	  if (json.fog && (json.fog.type === 'Fog' || json.fog instanceof THREE.Fog)) {
	    obj.fog = new THREE.Fog(json.fog.color, json.fog.near, json.fog.far);
	  } else if (json.fog && (json.fog.type === 'FogExp2' || json.fog instanceof THREE.FogExp2)) {
	    obj.fog = new THREE.FogExp2(json.fog.color, json.fog.density);
	  } else if (json.fog) {
	    console.warn(`SceneSerializer: unknown fog type ${json.fog.type}.`);
	  }

	  obj.overrideMaterial = !json.overrideMaterial ? null : new MaterialsSerializer().fromJSON(json.overrideMaterial, undefined, server);
	  return obj;
	};

	/**
	 * BufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function BufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	BufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	BufferGeometrySerializer.prototype.constructor = BufferGeometrySerializer;

	BufferGeometrySerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj); // json.attributes太大，不要保存在Mongo
	  // json.attributes = obj.attributes;

	  json.boundingBox = obj.boundingBox;
	  json.boundingSphere = obj.boundingSphere;
	  json.drawRange = obj.drawRange;
	  json.groups = obj.groups; // json.index = obj.index;

	  json.morphAttributes = obj.morphAttributes;
	  json.name = obj.name;
	  json.parameters = obj.parameters;
	  json.type = obj.type;
	  json.userData = obj.userData;
	  json.uuid = obj.uuid;
	  return json;
	};

	BufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.BufferGeometry() : parent;
	  BaseSerializer.prototype.fromJSON.call(this, json, obj); // obj.attributes = json.attributes;
	  // if (json.boundingBox) {
	  //     obj.boundingBox = new THREE.Box3(
	  //         new THREE.Vector3().copy(json.boundingBox.min),
	  //         new THREE.Vector3().copy(json.boundingBox.max),
	  //     );
	  // }
	  // if (json.boundingSphere) {
	  //     obj.boundingSphere = new THREE.Sphere(
	  //         new THREE.Vector3().copy(json.boundingSphere.center),
	  //         json.boundingSphere.radius
	  //     );
	  // }
	  // if (json.drawRange) {
	  //     obj.drawRange.start = json.drawRange.start;
	  //     obj.drawRange.count = json.drawRange.count === null ? Infinity : json.drawRange.count;
	  // }

	  obj.groups = json.groups; // obj.index = json.index;

	  obj.morphAttributes = json.morphAttributes;
	  obj.name = json.name;
	  obj.parameters = json.parameters;
	  obj.type = json.type;
	  obj.userData = json.userData;
	  obj.uuid = json.uuid;
	  return obj;
	};

	/**
	 * BoxBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function BoxBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	BoxBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	BoxBufferGeometrySerializer.prototype.constructor = BoxBufferGeometrySerializer;

	BoxBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	BoxBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.BoxBufferGeometry(json.parameters.width, json.parameters.height, json.parameters.depth, json.parameters.widthSegments, json.parameters.heightSegments, json.parameters.depthSegments) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * CircleBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CircleBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	CircleBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	CircleBufferGeometrySerializer.prototype.constructor = CircleBufferGeometrySerializer;

	CircleBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	CircleBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.CircleBufferGeometry(json.parameters.radius, json.parameters.segments, json.parameters.thetaStart, json.parameters.thetaLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * ConeBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ConeBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	ConeBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	ConeBufferGeometrySerializer.prototype.constructor = ConeBufferGeometrySerializer;

	ConeBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	ConeBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.ConeBufferGeometry(json.parameters.radius, json.parameters.height, json.parameters.radialSegments, json.parameters.heightSegments, json.parameters.openEnded, json.parameters.thetaStart, json.parameters.thetaLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * CylinderBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CylinderBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	CylinderBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	CylinderBufferGeometrySerializer.prototype.constructor = CylinderBufferGeometrySerializer;

	CylinderBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	CylinderBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.CylinderBufferGeometry(json.parameters.radiusTop, json.parameters.radiusBottom, json.parameters.height, json.parameters.radialSegments, json.parameters.heightSegments, json.parameters.openEnded, json.parameters.thetaStart, json.parameters.thetaLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * DodecahedronBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function DodecahedronBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	DodecahedronBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	DodecahedronBufferGeometrySerializer.prototype.constructor = DodecahedronBufferGeometrySerializer;

	DodecahedronBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	DodecahedronBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.DodecahedronBufferGeometry(json.parameters.radius, json.parameters.detail) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * ExtrudeBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ExtrudeBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	ExtrudeBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	ExtrudeBufferGeometrySerializer.prototype.constructor = ExtrudeBufferGeometrySerializer;

	ExtrudeBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	ExtrudeBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  // TODO
	  var obj = parent === undefined ? new THREE.ExtrudeBufferGeometry(json.parameters.shapes, json.parameters.options) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * IcosahedronBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function IcosahedronBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	IcosahedronBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	IcosahedronBufferGeometrySerializer.prototype.constructor = IcosahedronBufferGeometrySerializer;

	IcosahedronBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	IcosahedronBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.IcosahedronBufferGeometry(json.parameters.radius, json.parameters.detail) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * InstancedBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function InstancedBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	InstancedBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	InstancedBufferGeometrySerializer.prototype.constructor = InstancedBufferGeometrySerializer;

	InstancedBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	InstancedBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.InstancedBufferGeometry() : parent; // TODO: 

	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * LatheBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LatheBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	LatheBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	LatheBufferGeometrySerializer.prototype.constructor = LatheBufferGeometrySerializer;

	LatheBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	LatheBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.LatheBufferGeometry(json.parameters.points, json.parameters.segments, json.parameters.phiStart, json.parameters.phiLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * OctahedronBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function OctahedronBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	OctahedronBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	OctahedronBufferGeometrySerializer.prototype.constructor = OctahedronBufferGeometrySerializer;

	OctahedronBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	OctahedronBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.OctahedronBufferGeometry(json.parameters.radius, json.parameters.detail) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * ParametricBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ParametricBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	ParametricBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	ParametricBufferGeometrySerializer.prototype.constructor = ParametricBufferGeometrySerializer;

	ParametricBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	ParametricBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.ParametricBufferGeometry(json.parameters.func, json.parameters.slices, json.parameters.stacks) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * PlaneBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PlaneBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	PlaneBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	PlaneBufferGeometrySerializer.prototype.constructor = PlaneBufferGeometrySerializer;

	PlaneBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	PlaneBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.PlaneBufferGeometry(json.parameters.width, json.parameters.height, json.parameters.widthSegments, json.parameters.heightSegments) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * PolyhedronBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PolyhedronBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	PolyhedronBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	PolyhedronBufferGeometrySerializer.prototype.constructor = PolyhedronBufferGeometrySerializer;

	PolyhedronBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	PolyhedronBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.PolyhedronBufferGeometry(json.parameters.vertices, json.parameters.indices, json.parameters.radius, json.parameters.detail) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * RingBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function RingBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	RingBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	RingBufferGeometrySerializer.prototype.constructor = RingBufferGeometrySerializer;

	RingBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	RingBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.RingBufferGeometry(json.parameters.innerRadius, json.parameters.outerRadius, json.parameters.thetaSegments, json.parameters.phiSegments, json.parameters.thetaStart, json.parameters.thetaLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * ShapeBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ShapeBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	ShapeBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	ShapeBufferGeometrySerializer.prototype.constructor = ShapeBufferGeometrySerializer;

	ShapeBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	ShapeBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.ShapeBufferGeometry(json.parameters.shapes, json.parameters.curveSegments) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * SphereBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SphereBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	SphereBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	SphereBufferGeometrySerializer.prototype.constructor = SphereBufferGeometrySerializer;

	SphereBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	SphereBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.SphereBufferGeometry(json.parameters.radius, json.parameters.widthSegments, json.parameters.heightSegments, json.parameters.phiStart, json.parameters.phiLength, json.parameters.thetaStart, json.parameters.thetaLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TeapotBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TeapotBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TeapotBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TeapotBufferGeometrySerializer.prototype.constructor = TeapotBufferGeometrySerializer;

	TeapotBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TeapotBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TeapotBufferGeometry(json.parameters.size, json.parameters.segments, json.parameters.bottom, json.parameters.lid, json.parameters.body, json.parameters.fitLid, json.parameters.blinn) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TetrahedronBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TetrahedronBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TetrahedronBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TetrahedronBufferGeometrySerializer.prototype.constructor = TetrahedronBufferGeometrySerializer;

	TetrahedronBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TetrahedronBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TetrahedronBufferGeometry(json.parameters.radius, json.parameters.detail) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TextBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TextBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TextBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TextBufferGeometrySerializer.prototype.constructor = TextBufferGeometrySerializer;

	TextBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TextBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TextBufferGeometry(json.parameters.text, json.parameters.parameters) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TorusBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TorusBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TorusBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TorusBufferGeometrySerializer.prototype.constructor = TorusBufferGeometrySerializer;

	TorusBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TorusBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TorusBufferGeometry(json.parameters.radius, json.parameters.tube, json.parameters.radialSegments, json.parameters.tubularSegments, json.parameters.arc) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TorusKnotBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TorusKnotBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TorusKnotBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TorusKnotBufferGeometrySerializer.prototype.constructor = TorusKnotBufferGeometrySerializer;

	TorusKnotBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TorusKnotBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TorusKnotBufferGeometry(json.parameters.radius, json.parameters.tube, json.parameters.tubularSegments, json.parameters.radialSegments, json.parameters.p, json.parameters.q) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TubeBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TubeBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TubeBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TubeBufferGeometrySerializer.prototype.constructor = TubeBufferGeometrySerializer;

	TubeBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TubeBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TubeBufferGeometry(json.parameters.path, json.parameters.tubularSegments, json.parameters.radius, json.parameters.radialSegments, json.parameters.closed) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var Serializers$2 = {
	  'BoxBufferGeometry': BoxBufferGeometrySerializer,
	  'BufferGeometry': BufferGeometrySerializer,
	  'CircleBufferGeometry': CircleBufferGeometrySerializer,
	  'ConeBufferGeometry': ConeBufferGeometrySerializer,
	  'CylinderBufferGeometry': CylinderBufferGeometrySerializer,
	  'DodecahedronBufferGeometry': DodecahedronBufferGeometrySerializer,
	  'ExtrudeBufferGeometry': ExtrudeBufferGeometrySerializer,
	  'IcosahedronBufferGeometry': IcosahedronBufferGeometrySerializer,
	  'InstancedBufferGeometry': InstancedBufferGeometrySerializer,
	  'LatheBufferGeometry': LatheBufferGeometrySerializer,
	  'OctahedronBufferGeometry': OctahedronBufferGeometrySerializer,
	  'ParametricBufferGeometry': ParametricBufferGeometrySerializer,
	  'PlaneBufferGeometry': PlaneBufferGeometrySerializer,
	  'PolyhedronBufferGeometry': PolyhedronBufferGeometrySerializer,
	  'RingBufferGeometry': RingBufferGeometrySerializer,
	  'ShapeBufferGeometry': ShapeBufferGeometrySerializer,
	  'SphereBufferGeometry': SphereBufferGeometrySerializer,
	  'TeapotBufferGeometry': TeapotBufferGeometrySerializer,
	  'TetrahedronBufferGeometry': TetrahedronBufferGeometrySerializer,
	  'TextBufferGeometry': TextBufferGeometrySerializer,
	  'TorusBufferGeometry': TorusBufferGeometrySerializer,
	  'TorusKnotBufferGeometry': TorusKnotBufferGeometrySerializer,
	  'TubeBufferGeometry': TubeBufferGeometrySerializer
	};
	/**
	 * GeometriesSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function GeometriesSerializer() {
	  BaseSerializer.call(this);
	}

	GeometriesSerializer.prototype = Object.create(BaseSerializer.prototype);
	GeometriesSerializer.prototype.constructor = GeometriesSerializer;

	GeometriesSerializer.prototype.toJSON = function (obj) {
	  var serializer = Serializers$2[obj.type];

	  if (serializer === undefined) {
	    console.warn(`GeometriesSerializer: No serializer with ${obj.type}.`);
	    return null;
	  }

	  return new serializer().toJSON(obj);
	};

	GeometriesSerializer.prototype.fromJSON = function (json, parent) {
	  var generator = json.metadata.generator;
	  var serializer = Serializers$2[generator.replace('Serializer', '')];

	  if (serializer === undefined) {
	    console.warn(`GeometriesSerializer: No deserializer with ${generator}.`);
	    return null;
	  }

	  return new serializer().fromJSON(json, parent);
	};

	/**
	 * MeshSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshSerializer() {
	  BaseSerializer.call(this);
	}

	MeshSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshSerializer.prototype.constructor = MeshSerializer;

	MeshSerializer.prototype.toJSON = function (obj, options = {}) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj); // json.drawMode = obj.drawMode;

	  json.geometry = new GeometriesSerializer().toJSON(obj.geometry);

	  if (options.saveMaterial) {
	    json.material = new MaterialsSerializer().toJSON(obj.material);
	  } else {
	    json.material = null;
	  }

	  return json;
	};

	MeshSerializer.prototype.fromJSON = function (json, parent, server) {
	  // 子类创建模型
	  if (parent !== undefined) {
	    var obj1 = parent;
	    Object3DSerializer.prototype.fromJSON.call(this, json, obj1);
	    return obj1;
	  } // 其他模型


	  if (!json.geometry) {
	    console.warn(`MeshSerializer: ${json.name} json.geometry is not defined.`);
	    return null;
	  } // TODO: 服务端模型，不保存内部组件材质，不要警告。
	  // if (!json.material) {
	  // console.warn(`MeshSerializer: ${json.name} json.material is not defined.`);
	  // return null;
	  // }


	  var geometry = new GeometriesSerializer().fromJSON(json.geometry);
	  var material = json.material ? new MaterialsSerializer().fromJSON(json.material, undefined, server) : new THREE.MeshBasicMaterial();
	  var obj = new THREE.Mesh(geometry, material);
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * GroupSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function GroupSerializer() {
	  BaseSerializer.call(this);
	}

	GroupSerializer.prototype = Object.create(BaseSerializer.prototype);
	GroupSerializer.prototype.constructor = GroupSerializer;

	GroupSerializer.prototype.toJSON = function (obj) {
	  return Object3DSerializer.prototype.toJSON.call(this, obj);
	};

	GroupSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Group() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * BoneSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function BoneSerializer() {
	  BaseSerializer.call(this);
	}

	BoneSerializer.prototype = Object.create(BaseSerializer.prototype);
	BoneSerializer.prototype.constructor = BoneSerializer;

	BoneSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	BoneSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Bone() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * SpriteSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SpriteSerializer() {
	  BaseSerializer.call(this);
	}

	SpriteSerializer.prototype = Object.create(BaseSerializer.prototype);
	SpriteSerializer.prototype.constructor = SpriteSerializer;

	SpriteSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.center = obj.center;
	  json.material = new MaterialsSerializer().toJSON(obj.material);
	  json.z = obj.z;
	  json.isSprite = obj.isSprite;
	  return json;
	};

	SpriteSerializer.prototype.fromJSON = function (json, parent, server) {
	  var material;

	  if (parent === undefined) {
	    if (!json.material) {
	      console.warn(`SpriteSerializer: ${json.name} json.material is not defined.`);
	      return null;
	    }

	    material = new MaterialsSerializer().fromJSON(json.material, undefined, server);
	  }

	  var obj = parent === undefined ? new THREE.Sprite(material) : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.center.copy(json.center);
	  obj.z = json.z;
	  return obj;
	};

	var ID$2 = -1;
	/**
	 * BaseLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseLoader() {
	  this.id = `BaseLoader${ID$2--}`;
	  this.packageManager = new PackageManager();
	  this.require = this.packageManager.require.bind(this.packageManager);
	}

	BaseLoader.prototype.load = function (url, options) {
	  // eslint-disable-line
	  return new Promise(resolve => {
	    resolve(null);
	  });
	};

	/**
	 * AMFLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function AMFLoader() {
	  BaseLoader.call(this);
	}

	AMFLoader.prototype = Object.create(BaseLoader.prototype);
	AMFLoader.prototype.constructor = AMFLoader;

	AMFLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('AMFLoader').then(() => {
	      var loader = new THREE.AMFLoader();
	      loader.load(url, group => {
	        resolve(group);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * AWDLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function AWDLoader() {
	  BaseLoader.call(this);
	}

	AWDLoader.prototype = Object.create(BaseLoader.prototype);
	AWDLoader.prototype.constructor = AWDLoader;

	AWDLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('AWDLoader').then(() => {
	      var loader = new THREE.AWDLoader();
	      loader.load(url, obj3d => {
	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * BabylonLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function BabylonLoader() {
	  BaseLoader.call(this);
	}

	BabylonLoader.prototype = Object.create(BaseLoader.prototype);
	BabylonLoader.prototype.constructor = BabylonLoader;

	BabylonLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('BabylonLoader').then(() => {
	      var loader = new THREE.BabylonLoader();
	      loader.load(url, scene => {
	        var obj3d = new THREE.Object3D();
	        obj3d.children = scene.children;
	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * BinaryLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function BinaryLoader() {
	  BaseLoader.call(this);
	}

	BinaryLoader.prototype = Object.create(BaseLoader.prototype);
	BinaryLoader.prototype.constructor = BinaryLoader;

	BinaryLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('BinaryLoader').then(() => {
	      var loader = new THREE.BinaryLoader();
	      loader.load(url, (geometry, materials) => {
	        var mesh = new THREE.Mesh(geometry, materials);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * ColladaLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function ColladaLoader() {
	  BaseLoader.call(this);
	}

	ColladaLoader.prototype = Object.create(BaseLoader.prototype);
	ColladaLoader.prototype.constructor = ColladaLoader;

	ColladaLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('ColladaLoader').then(() => {
	      var loader = new THREE.ColladaLoader();
	      loader.load(url, collada => {
	        var dae = collada.scene;
	        dae.traverse(child => {
	          if (child instanceof THREE.Mesh) {
	            child.material.flatShading = true;
	          }

	          if (child.isSkinnedMesh) {
	            child.frustumCulled = false;
	          }
	        });

	        if (isNaN(dae.scale.x) || isNaN(dae.scale.y) || isNaN(dae.scale.z)) {
	          dae.scale.x = dae.scale.y = dae.scale.z = 10.0;
	          dae.updateMatrix();
	        }

	        dae._obj = collada;
	        dae._root = dae;

	        if (collada.animations && collada.animations.length > 0) {
	          Object.assign(dae.userData, {
	            animNames: collada.animations.map(n => n.name),
	            scripts: [{
	              id: null,
	              name: `${options.Name}${_t('Animation')}`,
	              type: 'javascript',
	              source: this.createScripts(options.Name),
	              uuid: THREE.Math.generateUUID()
	            }]
	          });
	        }

	        resolve(dae);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	ColladaLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n\n` + `var obj = mesh._obj;\n\n` + `var root = mesh._root;\n\n` + `var mixer = new THREE.AnimationMixer(root);\n\n` + `mixer.clipAction(obj.animations[0]).play();\n\n` + `function update(clock, deltaTime) { \n    mixer.update(deltaTime); \n}`;
	};

	/**
	 * CTMLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function CTMLoader() {
	  BaseLoader.call(this);
	}

	CTMLoader.prototype = Object.create(BaseLoader.prototype);
	CTMLoader.prototype.constructor = CTMLoader;

	CTMLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require(['lzma', 'CTMLoader']).then(() => {
	      var loader = new THREE.CTMLoader();
	      loader.load(url, geometry => {
	        var material = new THREE.MeshStandardMaterial();
	        var mesh = new THREE.Mesh(geometry, material);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * FBXLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function FBXLoader() {
	  BaseLoader.call(this);
	}

	FBXLoader.prototype = Object.create(BaseLoader.prototype);
	FBXLoader.prototype.constructor = FBXLoader;

	FBXLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('FBXLoader').then(() => {
	      var loader = new THREE.FBXLoader();
	      loader.load(url, obj3d => {
	        obj3d._obj = obj3d;
	        obj3d._root = obj3d;

	        if (obj3d.animations && obj3d.animations.length > 0) {
	          Object.assign(obj3d.userData, {
	            animNames: obj3d.animations.map(n => n.name),
	            scripts: [{
	              id: null,
	              name: `${options.Name}${_t('Animation')}`,
	              type: 'javascript',
	              source: this.createScripts(options.Name),
	              uuid: THREE.Math.generateUUID()
	            }]
	          });
	        }

	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	FBXLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n\n` + `var obj = mesh._obj;\n\n` + `var root = mesh._root;\n\n` + `var mixer = new THREE.AnimationMixer(root);\n\n` + `mixer.clipAction(obj.animations[0]).play();\n\n` + `function update(clock, deltaTime) { \n    mixer.update(deltaTime); \n}`;
	};

	/**
	 * GLTFLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function GLTFLoader() {
	  BaseLoader.call(this);
	}

	GLTFLoader.prototype = Object.create(BaseLoader.prototype);
	GLTFLoader.prototype.constructor = GLTFLoader;

	GLTFLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require(['DRACOLoader', 'GLTFLoader']).then(() => {
	      var loader = new THREE.GLTFLoader(); // DRACOLoader

	      let dracoLoader = new THREE.DRACOLoader();
	      dracoLoader.setDecoderPath('assets/js/libs/draco/gltf/');
	      loader.setDRACOLoader(dracoLoader);
	      loader.load(url, result => {
	        var obj3d = result.scene;
	        obj3d._obj = result;
	        obj3d._root = result.scene;

	        if (result.animations && result.animations.length > 0) {
	          Object.assign(obj3d.userData, {
	            animNames: result.animations.map(n => n.name),
	            scripts: [{
	              id: null,
	              name: `${options.Name}${_t('Animation')}`,
	              type: 'javascript',
	              source: this.createScripts(options.Name),
	              uuid: THREE.Math.generateUUID()
	            }]
	          });
	        }

	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	GLTFLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n\n` + `var obj = mesh._obj;\n\n` + `var root = mesh._root;\n\n` + `var mixer = new THREE.AnimationMixer(root);\n\n` + `mixer.clipAction(obj.animations[0]).play();\n\n` + `function update(clock, deltaTime) { \n    mixer.update(deltaTime); \n}`;
	};

	/**
	 * KMZLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function KMZLoader() {
	  BaseLoader.call(this);
	}

	KMZLoader.prototype = Object.create(BaseLoader.prototype);
	KMZLoader.prototype.constructor = KMZLoader;

	KMZLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require(['ColladaLoader', 'KMZLoader']).then(() => {
	      var loader = new THREE.KMZLoader();
	      loader.load(url, collada => {
	        var obj3d = collada.scene;
	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * MD2Loader
	 * @author tengge / https://github.com/tengge1
	 */

	function MD2Loader() {
	  BaseLoader.call(this);
	}

	MD2Loader.prototype = Object.create(BaseLoader.prototype);
	MD2Loader.prototype.constructor = MD2Loader;

	MD2Loader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('MD2Loader').then(() => {
	      var loader = new THREE.MD2Loader();
	      loader.load(url, geometry => {
	        var material = new THREE.MeshStandardMaterial({
	          morphTargets: true,
	          morphNormals: true
	        });
	        var mesh = new THREE.Mesh(geometry, material);
	        mesh.mixer = new THREE.AnimationMixer(mesh);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * ObjectLoader（json文件加载器）
	 * @author tengge / https://github.com/tengge1
	 */

	function ObjectLoader() {
	  BaseLoader.call(this);
	}

	ObjectLoader.prototype = Object.create(BaseLoader.prototype);
	ObjectLoader.prototype.constructor = ObjectLoader;

	ObjectLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require(['LegacyJSONLoader']).then(() => {
	      var loader = new THREE.ObjectLoader();
	      loader.load(url, obj => {
	        if (obj.traverse) {
	          obj.traverse(n => {
	            // bug: 由于导出的json格式的模型文件，可能带有Server: true信息，
	            // 会导致同一个模型下载两次。
	            if (n.userData && n.userData.Server === true) {
	              delete n.userData.Server;
	              delete n.userData.Url;
	            }
	          });
	        }

	        if (obj instanceof THREE.Scene && obj.children.length > 0 && obj.children[0] instanceof THREE.SkinnedMesh) {
	          resolve(this.loadSkinnedMesh(obj, options));
	        } else {
	          resolve(obj);
	        }
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	ObjectLoader.prototype.loadSkinnedMesh = function (scene, options) {
	  var mesh = null;
	  scene.traverse(child => {
	    if (child instanceof THREE.SkinnedMesh) {
	      mesh = child;
	    }
	  });
	  var animations = mesh.geometry.animations;

	  if (options.Name && animations && animations.length > 0) {
	    var names = animations.map(n => n.name);
	    var source1 = `var mesh = this.getObjectByName('${options.Name}');\nvar mixer = new THREE.AnimationMixer(mesh);\n\n`;
	    var source2 = ``;
	    names.forEach(n => {
	      source2 += `var ${n}Animation = mixer.clipAction('${n}');\n`;
	    });
	    var source3 = `\n${names[0]}Animation.play();\n\n`;
	    var source4 = `function update(clock, deltaTime) { \n    mixer.update(deltaTime); \n}`;
	    var source = source1 + source2 + source3 + source4;
	    mesh.userData.scripts = [{
	      id: null,
	      name: `${options.Name}${_t('Animation')}`,
	      type: 'javascript',
	      source: source,
	      uuid: THREE.Math.generateUUID()
	    }];
	  }

	  return mesh;
	};

	/**
	 * OBJLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function OBJLoader() {
	  BaseLoader.call(this);
	}

	OBJLoader.prototype = Object.create(BaseLoader.prototype);
	OBJLoader.prototype.constructor = OBJLoader;

	OBJLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require(['LoaderSupport', 'OBJLoader2', 'MTLLoader']).then(() => {
	      var objLoader = new THREE.OBJLoader2();
	      var mtlLoader = new THREE.MTLLoader();
	      var promise = new Promise(resolve1 => {
	        mtlLoader.load(url.replace('.obj', '.mtl'), obj => {
	          resolve1(obj);
	        }, undefined, () => {
	          resolve1(null);
	        });
	      });
	      promise.then(mtl => {
	        if (mtl) {
	          mtl.preload();
	          objLoader.setMaterials(mtl.materials);
	        }

	        objLoader.load(url, obj => {
	          resolve(obj.detail.loaderRootNode);
	        }, undefined, () => {
	          resolve(null);
	        });
	      });
	    });
	  });
	};

	/**
	 * PLYLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function PLYLoader() {
	  BaseLoader.call(this);
	}

	PLYLoader.prototype = Object.create(BaseLoader.prototype);
	PLYLoader.prototype.constructor = PLYLoader;

	PLYLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('PLYLoader').then(() => {
	      var loader = new THREE.PLYLoader();
	      loader.load(url, geometry => {
	        geometry.computeVertexNormals();
	        var material = new THREE.MeshStandardMaterial();
	        var mesh = new THREE.Mesh(geometry, material);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * STLLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function STLLoader() {
	  BaseLoader.call(this);
	}

	STLLoader.prototype = Object.create(BaseLoader.prototype);
	STLLoader.prototype.constructor = STLLoader;

	STLLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('STLLoader').then(() => {
	      var loader = new THREE.STLLoader();
	      loader.load(url, geometry => {
	        var material = new THREE.MeshStandardMaterial();
	        var mesh = new THREE.Mesh(geometry, material);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * VTKLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function VTKLoader() {
	  BaseLoader.call(this);
	}

	VTKLoader.prototype = Object.create(BaseLoader.prototype);
	VTKLoader.prototype.constructor = VTKLoader;

	VTKLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('VTKLoader').then(() => {
	      var loader = new THREE.VTKLoader();
	      loader.load(url, geometry => {
	        var material = new THREE.MeshStandardMaterial();
	        var mesh = new THREE.Mesh(geometry, material);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 * @param {ArrayBuffer} buffer 缓冲区
	 */
	function DataView2(buffer) {
	  this.buffer = new DataView(buffer);
	  this.position = 0;
	}

	DataView2.prototype.getBool = function () {
	  var v = this.buffer.getUint8(this.position) !== 0;
	  this.position += 1;
	  return v;
	};

	DataView2.prototype.getUint8 = function () {
	  var v = this.buffer.getUint8(this.position);
	  this.position += 1;
	  return v;
	};

	DataView2.prototype.getInt8 = function () {
	  var v = this.buffer.getInt8(this.position);
	  this.position += 1;
	  return v;
	};

	DataView2.prototype.getUint16 = function () {
	  var v = this.buffer.getUint16(this.position, true);
	  this.position += 2;
	  return v;
	};

	DataView2.prototype.getInt16 = function () {
	  var v = this.buffer.getInt16(this.position, true);
	  this.position += 2;
	  return v;
	};

	DataView2.prototype.getUint32 = function () {
	  var v = this.buffer.getUint32(this.position, true);
	  this.position += 4;
	  return v;
	};

	DataView2.prototype.getInt32 = function () {
	  var v = this.buffer.getInt32(this.position, true);
	  this.position += 4;
	  return v;
	};

	DataView2.prototype.getFloat = function () {
	  var v = this.buffer.getFloat32(this.position, true);
	  this.position += 4;
	  return v;
	};

	DataView2.prototype.getString = function (len) {
	  if (len === undefined) len = this.getUint16();
	  var str = "";

	  for (var i = 0; i < len; ++i) {
	    str += String.fromCharCode(this.getUint8());
	  }

	  return str;
	};

	DataView2.prototype.setBool = function (v) {
	  this.buffer.setUint8(this.position, v ? 1 : 0);
	  this.position += 1;
	};

	DataView2.prototype.setUint8 = function (v) {
	  this.buffer.setUint8(this.position, v);
	  this.position += 1;
	};

	DataView2.prototype.setInt8 = function (v) {
	  this.buffer.setInt8(this.position, v);
	  this.position += 1;
	};

	DataView2.prototype.setUint16 = function (v) {
	  this.buffer.setUint16(this.position, v, true);
	  this.position += 2;
	};

	DataView2.prototype.setInt16 = function (v) {
	  this.buffer.setInt16(this.position, v, true);
	  this.position += 2;
	};

	DataView2.prototype.setUint32 = function (v) {
	  this.buffer.setUint32(this.position, v, true);
	  this.position += 4;
	};

	DataView2.prototype.setInt32 = function (v) {
	  this.buffer.setInt32(this.position, v, true);
	  this.position += 4;
	};

	DataView2.prototype.setFloat = function (v) {
	  this.buffer.setFloat32(this.position, v, true);
	  this.position += 4;
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 * @param {DataView2} r 数据视图
	 */
	function Vertex(r) {
	  var self = this,
	      i;
	  self.position = [r.getFloat(), r.getFloat(), r.getFloat()];
	  self.normal = [r.getFloat(), r.getFloat(), r.getFloat(), 0];
	  self.u = r.getFloat();
	  self.v = r.getFloat();
	  self.bones = new Array(4);

	  for (i = 0; i < 4; ++i) {
	    self.bones[i] = r.getUint8();
	  }

	  self.weights = new Array(4);

	  for (i = 0; i < 4; ++i) {
	    self.weights[i] = r.getFloat();
	  }
	}

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 * @param {Model} model 模型
	 * @param {String} url 地址
	 */
	function Texture(model, url) {
	  var self = this;
	  self.model = model;
	  self.url = url;
	  self.texture = null;
	  self.load();
	}

	Texture.prototype.load = function () {
	  var self = this;
	  self.texture = new THREE.TextureLoader().load(self.url, function (texture) {
	    self.onLoad.call(self, texture);
	  });
	};

	Texture.prototype.onLoad = function (texture) {
	  var self = this;
	  texture.flipY = false;
	  self.model.material.map = texture;
	  self.model.material.needsUpdate = true;
	  self.model.dispatch.call('loadTexture');
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 * @param {Model} model 模型
	 * @param {Number} index 索引
	 * @param {DataView2} r 数据视图
	 */
	function Bone(model, index, r) {
	  var self = this,
	      i;
	  self.model = model;
	  self.index = index;
	  self.name = r.getString().toLowerCase();
	  self.parent = r.getInt32();
	  self.scale = r.getFloat();
	  self.origMatrix = mat4.create();

	  for (i = 0; i < 16; ++i) self.origMatrix[i] = r.getFloat();

	  self.baseMatrix = mat4.clone(self.origMatrix);
	  mat4.transpose(self.baseMatrix, self.baseMatrix);
	  mat4.invert(self.baseMatrix, self.baseMatrix);
	  mat4.transpose(self.origMatrix, self.origMatrix);
	  self.incrMatrix = mat4.create();

	  if (model.version >= 2) {
	    for (i = 0; i < 16; ++i) self.incrMatrix[i] = r.getFloat();

	    mat4.transpose(self.incrMatrix, self.incrMatrix);
	  } else {
	    mat4.identity(self.incrMatrix);
	  }
	}

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 */
	var HiddenBones = {
	  12: {
	    9: {
	      recall: {},
	      all: {
	        recall_chair: true
	      }
	    },
	    10: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    11: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    12: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    13: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    14: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    15: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    16: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    17: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    18: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    }
	  },
	  21: {
	    9: {
	      all: {
	        orange: true
	      },
	      recall: {
	        l_weapon: true,
	        r_weapon: true
	      }
	    },
	    10: {
	      recall: {},
	      all: {
	        tv_joint: true,
	        tv_rabit_ears_joints: true
	      }
	    },
	    11: {
	      recall: {},
	      all: {
	        tv_joint: true,
	        tv_rabit_ears_joints: true
	      }
	    },
	    12: {
	      recall: {},
	      all: {
	        tv_joint: true,
	        tv_rabit_ears_joints: true
	      }
	    },
	    13: {
	      recall: {},
	      all: {
	        tv_joint: true,
	        tv_rabit_ears_joints: true
	      }
	    },
	    14: {
	      recall: {},
	      all: {
	        tv_joint: true,
	        tv_rabit_ears_joints: true
	      }
	    }
	  },
	  22: {
	    8: {
	      all: {
	        c_drone_base: true
	      },
	      joke: {},
	      dance: {}
	    }
	  },
	  36: {
	    9: {
	      all: {
	        recall_chair: true
	      },
	      recall: {}
	    }
	  },
	  41: {
	    0: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    1: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    2: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    3: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    4: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    5: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    6: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    7: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    }
	  },
	  44: {
	    4: {
	      all: {
	        jacket: true
	      },
	      dance: {
	        jacket: true,
	        weapon: true
	      },
	      recall: {
	        weapon: true
	      }
	    }
	  },
	  55: {
	    7: {
	      recall: {},
	      all: {
	        xmas_pole_skin07: true
	      }
	    }
	  },
	  61: {
	    7: {
	      recall: {},
	      all: {
	        planet1: true,
	        planet2: true,
	        planet3: true,
	        planet4: true,
	        planet5: true,
	        planet6: true
	      }
	    }
	  },
	  69: {
	    4: {
	      all: {
	        l_fan: true,
	        r_fan: true
	      },
	      recall: {}
	    }
	  },
	  80: {
	    8: {
	      all: {
	        oven: true
	      },
	      recall: {}
	    }
	  },
	  83: {
	    0: {
	      all: {},
	      idle2: {
	        weapon: true
	      }
	    },
	    1: {
	      all: {},
	      idle2: {
	        weapon: true
	      }
	    },
	    2: {
	      all: {},
	      idle2: {
	        weapon: true
	      }
	    }
	  },
	  103: {
	    7: {
	      recall: {},
	      all: {
	        arcade: true
	      }
	    }
	  },
	  114: {
	    5: {
	      all: {
	        weapon_krab: true,
	        root_krab: true
	      },
	      recall: {}
	    }
	  },
	  115: {
	    4: {
	      all: {
	        sled: true
	      },
	      satcheljump: {
	        bomb: true,
	        bomb_b: true
	      }
	    }
	  },
	  119: {
	    4: {
	      all: {
	        chair_root: true,
	        sun_reflector_root: true
	      },
	      recall: {}
	    }
	  },
	  136: {
	    0: {
	      all: {
	        shades_sunglass: true
	      },
	      joke: {}
	    },
	    1: {
	      all: {
	        shades_sunglass: true
	      },
	      joke: {}
	    }
	  },
	  143: {
	    4: {
	      attack1: {
	        r_wing: true,
	        l_wing: true
	      },
	      attack2: {
	        r_wing: true,
	        l_wing: true
	      },
	      dance: {
	        r_wing: true,
	        l_wing: true
	      },
	      idle1: {
	        r_wing: true,
	        l_wing: true
	      },
	      idle3: {
	        r_wing: true,
	        l_wing: true
	      },
	      idle4: {
	        r_wing: true,
	        l_wing: true
	      },
	      laugh: {
	        r_wing: true,
	        l_wing: true
	      },
	      run: {
	        r_wing: true,
	        l_wing: true
	      },
	      spell2: {
	        r_wing: true,
	        l_wing: true
	      },
	      all: {}
	    }
	  },
	  157: {
	    4: {
	      all: {
	        flute: true
	      },
	      dance: {}
	    },
	    5: {
	      all: {
	        flute: true
	      },
	      dance: {}
	    },
	    6: {
	      all: {
	        flute: true
	      },
	      dance: {}
	    },
	    7: {
	      all: {
	        flute: true
	      },
	      dance: {}
	    },
	    8: {
	      all: {
	        flute: true
	      },
	      dance: {}
	    }
	  },
	  201: {
	    3: {
	      all: {
	        poro: true
	      }
	    }
	  },
	  222: {
	    4: {
	      all: {
	        rocket_launcher: true
	      },
	      r_attack1: {},
	      r_attack2: {},
	      r_idle1: {},
	      r_idle_in: {},
	      r_run: {},
	      r_run_fast: {},
	      r_run_haste: {},
	      r_spell2: {},
	      r_spell3: {},
	      r_spell3_run: {},
	      r_spell4: {},
	      respawn_trans_rlauncher: {},
	      rlauncher_spell3: {},
	      spell1a: {}
	    }
	  },
	  238: {
	    10: {
	      all: {
	        chair_skin10: true,
	        step1_skin10: true,
	        step2_skin10: true
	      },
	      recall: {}
	    }
	  },
	  245: {
	    0: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    1: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    2: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    3: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    4: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    5: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    6: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    7: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    8: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    9: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    10: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    }
	  },
	  254: {
	    0: {
	      all: {
	        teacup: true
	      },
	      taunt2: {}
	    },
	    1: {
	      all: {
	        teacup: true
	      },
	      taunt2: {}
	    },
	    3: {
	      all: {
	        teacup: true
	      },
	      taunt2: {}
	    },
	    4: {
	      all: {
	        teacup: true
	      },
	      taunt2: {}
	    }
	  },
	  412: {
	    1: {
	      all: {
	        coin1: true,
	        coin2: true,
	        coin3: true,
	        coin4: true,
	        coin5: true,
	        coin6: true,
	        coin7: true,
	        treasure_chest: true,
	        treasure_chest_cover: true,
	        tire: true
	      },
	      recall: {
	        tire: true
	      },
	      undersea_recall_loop: {
	        tire: true
	      },
	      undersea_recall_loop2: {
	        coin1: true,
	        coin2: true,
	        coin3: true,
	        coin4: true,
	        coin5: true,
	        coin6: true,
	        coin7: true,
	        treasure_chest: true,
	        treasure_chest_cover: true
	      },
	      undersea_recall_windup: {
	        tire: true
	      },
	      undersea_recall_windup2: {
	        coin1: true,
	        coin2: true,
	        coin3: true,
	        coin4: true,
	        coin5: true,
	        coin6: true,
	        coin7: true,
	        treasure_chest: true,
	        treasure_chest_cover: true
	      }
	    },
	    5: {
	      all: {
	        mini_root: true
	      },
	      joke: {}
	    }
	  },
	  420: {
	    0: {
	      all: {
	        c_tentacle1: true
	      }
	    },
	    1: {
	      all: {
	        c_tentacle1: true
	      }
	    }
	  },
	  429: {
	    3: {
	      death: {
	        altar_spear: true,
	        buffbone_cstm_back_spear1: true,
	        buffbone_cstm_back_spear2: true,
	        buffbone_cstm_back_spear3: true
	      }
	    }
	  },
	  432: {
	    0: {
	      all: {
	        follower_root: true
	      },
	      dance: {}
	    },
	    2: {
	      all: {
	        follower_root: true
	      },
	      dance: {}
	    },
	    3: {
	      all: {
	        follower_root: true
	      },
	      dance: {}
	    },
	    4: {
	      all: {
	        follower_root: true
	      },
	      dance: {}
	    }
	  },
	  gnarbig: {
	    0: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    1: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    2: {
	      all: {
	        rock: true,
	        cane_bot: true,
	        cane_top: true
	      },
	      spell1: {
	        cane_bot: true,
	        cane_top: true
	      },
	      laugh: {
	        cane_bot: true,
	        cane_top: true
	      },
	      recall: {
	        rock: true
	      }
	    },
	    3: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    4: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    5: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    6: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    7: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    8: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    9: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    10: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    11: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    12: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    }
	  }
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 * @param {Model} model 模型
	 * @param {Animation} anim 动画
	 * @param {DataView2} r 数据视图
	 * @param {Number} version 版本
	 */
	function AnimationBone(model, anim, r, version) {
	  var self = this;
	  self.model = model;
	  self.anim = anim;
	  var numFrames = r.getUint32();
	  self.bone = r.getString().toLowerCase();
	  self.flags = r.getUint32();
	  self.frames = new Array(numFrames);
	  var scale = [1, 1, 1];

	  for (var i = 0; i < numFrames; ++i) {
	    var pos = [r.getFloat(), r.getFloat(), r.getFloat()];
	    var rot = [r.getFloat(), r.getFloat(), r.getFloat(), r.getFloat()];
	    if (version >= 3) scale = [r.getFloat(), r.getFloat(), r.getFloat()];
	    self.frames[i] = {
	      pos: pos,
	      rot: rot,
	      scale: scale
	    };
	  }

	  self.matrix = mat4.create();
	  self.tmpMat = mat4.create();
	  self.tmpMat2 = mat4.create();
	  self.tmpPos = vec3.create();
	  self.tmpRot = quat.create();
	  self.tmpScale = vec3.create();
	}

	AnimationBone.prototype.update = function (boneId, frame, r) {
	  var self = this;
	  self.index = boneId;
	  var parent = self.model.bones[boneId].parent;
	  var f0 = frame % self.frames.length,
	      f1 = (frame + 1) % self.frames.length;
	  vec3.lerp(self.tmpPos, self.frames[f0].pos, self.frames[f1].pos, r);
	  vec3.lerp(self.tmpScale, self.frames[f0].scale, self.frames[f1].scale, r);
	  quat.slerp(self.tmpRot, self.frames[f0].rot, self.frames[f1].rot, r);
	  self.translation(self.tmpMat2, self.tmpPos);
	  self.rotationQuat(self.tmpMat, self.tmpRot);
	  self.mulSlimDX(self.matrix, self.tmpMat, self.tmpMat2);

	  if (parent !== -1) {
	    self.mulSlimDX(self.matrix, self.matrix, self.model.transforms[parent]);
	  }

	  mat4.copy(self.model.transforms[boneId], self.matrix);
	};

	AnimationBone.prototype.translation = function (out, vec) {
	  mat4.identity(out);
	  out[12] = vec[0];
	  out[13] = vec[1];
	  out[14] = vec[2];
	  return out;
	};

	AnimationBone.prototype.rotationQuat = function (out, q) {
	  mat4.identity(out);
	  var xx = q[0] * q[0],
	      yy = q[1] * q[1],
	      zz = q[2] * q[2],
	      xy = q[0] * q[1],
	      zw = q[2] * q[3],
	      zx = q[2] * q[0],
	      yw = q[1] * q[3],
	      yz = q[1] * q[2],
	      xw = q[0] * q[3];
	  out[0] = 1 - 2 * (yy + zz);
	  out[1] = 2 * (xy + zw);
	  out[2] = 2 * (zx - yw);
	  out[4] = 2 * (xy - zw);
	  out[5] = 1 - 2 * (zz + xx);
	  out[6] = 2 * (yz + xw);
	  out[8] = 2 * (zx + yw);
	  out[9] = 2 * (yz - xw);
	  out[10] = 1 - 2 * (yy + xx);
	  return out;
	};

	AnimationBone.prototype.mulSlimDX = function (out, l, r) {
	  var left = {
	    M11: l[0],
	    M12: l[1],
	    M13: l[2],
	    M14: l[3],
	    M21: l[4],
	    M22: l[5],
	    M23: l[6],
	    M24: l[7],
	    M31: l[8],
	    M32: l[9],
	    M33: l[10],
	    M34: l[11],
	    M41: l[12],
	    M42: l[13],
	    M43: l[14],
	    M44: l[15]
	  };
	  var right = {
	    M11: r[0],
	    M12: r[1],
	    M13: r[2],
	    M14: r[3],
	    M21: r[4],
	    M22: r[5],
	    M23: r[6],
	    M24: r[7],
	    M31: r[8],
	    M32: r[9],
	    M33: r[10],
	    M34: r[11],
	    M41: r[12],
	    M42: r[13],
	    M43: r[14],
	    M44: r[15]
	  };
	  out[0] = left.M11 * right.M11 + left.M12 * right.M21 + left.M13 * right.M31 + left.M14 * right.M41;
	  out[1] = left.M11 * right.M12 + left.M12 * right.M22 + left.M13 * right.M32 + left.M14 * right.M42;
	  out[2] = left.M11 * right.M13 + left.M12 * right.M23 + left.M13 * right.M33 + left.M14 * right.M43;
	  out[3] = left.M11 * right.M14 + left.M12 * right.M24 + left.M13 * right.M34 + left.M14 * right.M44;
	  out[4] = left.M21 * right.M11 + left.M22 * right.M21 + left.M23 * right.M31 + left.M24 * right.M41;
	  out[5] = left.M21 * right.M12 + left.M22 * right.M22 + left.M23 * right.M32 + left.M24 * right.M42;
	  out[6] = left.M21 * right.M13 + left.M22 * right.M23 + left.M23 * right.M33 + left.M24 * right.M43;
	  out[7] = left.M21 * right.M14 + left.M22 * right.M24 + left.M23 * right.M34 + left.M24 * right.M44;
	  out[8] = left.M31 * right.M11 + left.M32 * right.M21 + left.M33 * right.M31 + left.M34 * right.M41;
	  out[9] = left.M31 * right.M12 + left.M32 * right.M22 + left.M33 * right.M32 + left.M34 * right.M42;
	  out[10] = left.M31 * right.M13 + left.M32 * right.M23 + left.M33 * right.M33 + left.M34 * right.M43;
	  out[11] = left.M31 * right.M14 + left.M32 * right.M24 + left.M33 * right.M34 + left.M34 * right.M44;
	  out[12] = left.M41 * right.M11 + left.M42 * right.M21 + left.M43 * right.M31 + left.M44 * right.M41;
	  out[13] = left.M41 * right.M12 + left.M42 * right.M22 + left.M43 * right.M32 + left.M44 * right.M42;
	  out[14] = left.M41 * right.M13 + left.M42 * right.M23 + left.M43 * right.M33 + left.M44 * right.M43;
	  out[15] = left.M41 * right.M14 + left.M42 * right.M24 + left.M43 * right.M34 + left.M44 * right.M44;
	  return out;
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 * @param {Model} model 模型
	 * @param {DataView2} r 数据视图
	 * @param {Number} version 版本
	 */

	function Animation(model, r, version) {
	  var self = this,
	      i;
	  self.model = model;
	  self.meshOverride = {};
	  self.name = r.getString().toLowerCase();
	  self.fps = r.getInt32();
	  var numBones = r.getUint32();
	  self.bones = new Array(numBones);
	  self.lookup = {};

	  for (i = 0; i < numBones; ++i) {
	    self.bones[i] = new AnimationBone(model, self, r, version);
	    self.lookup[self.bones[i].bone] = i;
	  }

	  if (numBones === 0 || self.fps <= 1) {
	    self.duration = 1e3;
	  } else {
	    self.duration = Math.floor(1e3 * (self.bones[0].frames.length / self.fps));
	  }
	}

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 */
	var BaseAnimations = {
	  19: {
	    0: {
	      all: "idle"
	    }
	  },
	  32: {
	    4: {
	      all: "idle1_bow",
	      idle1_bow: "idle1"
	    }
	  },
	  55: {
	    7: {
	      idle1_candycane_below: "idle1"
	    }
	  }
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 * @param {Object} options 参数
	 */

	function Model(options) {
	  var self = this;
	  self.champion = options.champion || "1";
	  self.skin = options.skin || 0;
	  self.meshUrl = options.meshUrl;
	  self.animUrl = options.animUrl;
	  self.textureUrl = options.textureUrl;
	  self.loaded = false;
	  self.animsLoaded = false;
	  self.meshes = null;
	  self.vertices = null;
	  self.indices = null;
	  self.transforms = null;
	  self.bones = null;
	  self.boneLookup = {};
	  self.animIndex = -1;
	  self.animName = null;
	  self.baseAnim = null;
	  self.newAnimation = false;
	  self.animTime = 0;
	  self.tmpMat = mat4.create();
	  self.tmpVec = vec4.create();
	  self.ANIMATED = true;
	  self.dispatch = dispatch('load', 'loadMesh', 'loadTexture', 'loadAnim');
	  self.hiddenBones = null;
	  var hiddenBones = HiddenBones;

	  if (hiddenBones[self.champion] !== undefined) {
	    if (hiddenBones[self.champion][self.skin] !== undefined) {
	      self.hiddenBones = hiddenBones[self.champion][self.skin];
	    }
	  }

	  self.ambientColor = [.35, .35, .35, 1];
	  self.primaryColor = [1, 1, 1, 1];
	  self.secondaryColor = [.35, .35, .35, 1];
	  self.lightDir1 = vec3.create();
	  self.lightDir2 = vec3.create();
	  self.lightDir3 = vec3.create();
	  vec3.normalize(self.lightDir1, [5, 5, -5]);
	  vec3.normalize(self.lightDir2, [5, 5, 5]);
	  vec3.normalize(self.lightDir3, [-5, -5, -5]);
	  self.texture = null;
	  self.geometry = new THREE.BufferGeometry();
	  self.material = new THREE.MeshPhongMaterial();
	  var promise1 = new Promise(resolve => {
	    self.dispatch.on('loadMesh.Model', () => {
	      resolve();
	    });
	  });
	  var promise2 = new Promise(resolve => {
	    self.dispatch.on('loadTexture.Model', () => {
	      resolve();
	    });
	  });
	  var promise3 = new Promise(resolve => {
	    self.dispatch.on('loadAnim.Model', () => {
	      resolve();
	    });
	  });
	  Promise.all([promise1, promise2, promise3]).then(() => {
	    self.dispatch.call('load');
	  });
	}

	Model.prototype.getAnimations = function () {
	  if (!this.animations) {
	    return null;
	  }

	  var names = [];
	  this.animations.forEach(function (n) {
	    names.push(n.name);
	  });
	  return names;
	};

	Model.prototype.getAnimation = function (name) {
	  var self = this,
	      i,
	      animIndex = -1;

	  if (!self.animations) {
	    return animIndex;
	  }

	  name = name.toLowerCase();

	  if (name === "idle" || name === "attack") {
	    var anims = [],
	        re = new RegExp(name + "[0-9]*");

	    for (i = 0; i < self.animations.length; ++i) {
	      if (self.animations[i].name.search(re) === 0) anims.push(i);
	    }

	    if (anims.length > 0) {
	      animIndex = anims[0];
	    }
	  } else {
	    for (i = 0; i < self.animations.length; ++i) {
	      if (self.animations[i].name === name) {
	        animIndex = i;
	        break;
	      }
	    }
	  }

	  return animIndex;
	};

	Model.prototype.setAnimation = function (name) {
	  var self = this;
	  self.animName = name;
	  self.newAnimation = true;
	};

	Model.prototype.update = function (time) {
	  var self = this,
	      i,
	      j;

	  if (self.animTime === 0) {
	    self.animTime = time;
	  }

	  if (!self.loaded || !self.vertices || !self.animations || self.animations.length === 0) {
	    return;
	  }

	  self.animIndex = self.getAnimation(self.animName);

	  if (self.animIndex === -1) {
	    self.animIndex = 0;
	    self.animName = "idle";
	  }

	  var baseAnims = BaseAnimations;

	  if (baseAnims[self.champion] !== undefined) {
	    if (baseAnims[self.champion][self.skin] !== undefined) {
	      var baseAnim = baseAnims[self.champion][self.skin],
	          baseIndex = -1;

	      if (baseAnim[self.animations[self.animIndex].name]) {
	        baseIndex = self.getAnimation(baseAnim[self.animations[self.animIndex].name]);
	      } else if (baseAnim["all"]) {
	        baseIndex = self.getAnimation(baseAnim["all"]);
	      }

	      if (baseIndex > -1) {
	        self.baseAnim = self.animations[baseIndex];
	      } else {
	        self.baseAnim = null;
	      }
	    }
	  }

	  var deltaTime = time - self.animTime;
	  var anim = self.animations[self.animIndex];

	  if (deltaTime >= anim.duration) {
	    self.animTime = time;
	    deltaTime = 0;
	  }

	  if (self.ANIMATED) {
	    var timePerFrame = 1e3 / anim.fps;
	    var frame = Math.floor(deltaTime / timePerFrame);
	    var r = deltaTime % timePerFrame / timePerFrame;
	    var hiddenBones = {};

	    if (self.hiddenBones) {
	      if (self.hiddenBones[anim.name]) {
	        hiddenBones = self.hiddenBones[anim.name];
	      } else if (self.hiddenBones["all"]) {
	        hiddenBones = self.hiddenBones["all"];
	      }
	    }

	    var b;

	    if (self.version >= 1) {
	      for (i = 0; i < self.bones.length; ++i) {
	        b = self.bones[i];

	        if (hiddenBones[b.name]) {
	          mat4.identity(self.tmpMat);
	          mat4.scale(self.tmpMat, self.tmpMat, vec3.set(self.tmpVec, 0, 0, 0));
	          mat4.copy(self.transforms[i], self.tmpMat);
	        } else if (anim.lookup[b.name] !== undefined) {
	          anim.bones[anim.lookup[b.name]].update(i, frame, r);
	        } else if (self.baseAnim && self.baseAnim.lookup[b.name] !== undefined) {
	          self.baseAnim.bones[self.baseAnim.lookup[b.name]].update(i, frame, r);
	        } else {
	          if (b.parent !== -1) {
	            AnimationBone.prototype.mulSlimDX(self.transforms[i], b.incrMatrix, self.transforms[b.parent]);
	          } else {
	            mat4.copy(self.transforms[i], b.incrMatrix);
	          }
	        }
	      }
	    } else {
	      for (i = 0; i < anim.bones.length; ++i) {
	        b = anim.bones[i];

	        if (self.boneLookup[b.bone] !== undefined) {
	          b.update(self.boneLookup[b.bone], frame, r);
	        } else {
	          var parentBone = anim.bones[i - 1];
	          if (!parentBone) continue;

	          if (parentBone.index + 1 < self.transforms.length) {
	            mat4.copy(self.transforms[parentBone.index + 1], self.transforms[parentBone.index]);
	          }

	          b.index = parentBone.index + 1;
	        }
	      }
	    }

	    var numBones = Math.min(self.transforms.length, self.bones.length);

	    for (i = 0; i < numBones; ++i) {
	      AnimationBone.prototype.mulSlimDX(self.transforms[i], self.bones[i].baseMatrix, self.transforms[i]);
	    }

	    mat4.identity(self.tmpMat);
	    var numVerts = self.vertices.length,
	        vec = self.tmpVec,
	        position = self.geometry.attributes.position.array,
	        normal = self.geometry.attributes.normal.array,
	        v,
	        w,
	        m,
	        idx;

	    for (i = 0; i < numVerts; ++i) {
	      v = self.vertices[i];
	      idx = i * 3;
	      position[idx] = position[idx + 1] = position[idx + 2] = 0;
	      normal[idx] = normal[idx + 1] = normal[idx + 2] = 0;

	      for (j = 0; j < 4; ++j) {
	        if (v.weights[j] > 0) {
	          w = v.weights[j];
	          m = anim.fps === 1 ? self.tmpMat : self.transforms[v.bones[j]];
	          vec3.transformMat4(vec, v.position, m);
	          position[idx] += vec[0] * w;
	          position[idx + 1] += vec[1] * w;
	          position[idx + 2] += vec[2] * w;
	          vec4.transformMat4(vec, v.normal, m);
	          normal[idx] += vec[0] * w;
	          normal[idx + 1] += vec[1] * w;
	          normal[idx + 2] += vec[2] * w;
	        }
	      }
	    }

	    self.geometry.attributes.position.needsUpdate = true;
	    self.geometry.attributes.normal.needsUpdate = true;
	  }

	  if (self.newAnimation) {
	    self.newAnimation = false;
	  }
	};

	Model.prototype.load = function () {
	  var self = this;
	  var loader = new THREE.FileLoader();
	  loader.setResponseType('arraybuffer');
	  loader.load(self.meshUrl, function (buffer) {
	    self.loadMesh(buffer);
	  });
	};

	Model.prototype.loadMesh = function (buffer) {
	  if (!buffer) {
	    console.error("Bad buffer for DataView");
	    return;
	  }

	  var self = this,
	      r = new DataView2(buffer),
	      i,
	      v,
	      idx;

	  try {
	    var magic = r.getUint32();

	    if (magic !== 604210091) {
	      console.log("Bad magic value");
	      return;
	    }
	  } catch (err) {
	    console.warn("Model currently isn't loading! We're sorry and hope to have this fixed soon.");
	    console.log(err);
	    return;
	  }

	  self.version = r.getUint32();
	  var animFile = r.getString();
	  var textureFile = r.getString();

	  if (animFile && animFile.length > 0) {
	    var loader = new THREE.FileLoader();
	    loader.setResponseType('arraybuffer');
	    loader.load(self.animUrl, function (buffer) {
	      self.loadAnim(buffer);
	      self.dispatch.call('loadAnim');
	    });
	  }

	  if (textureFile && textureFile.length > 0) {
	    self.texture = new Texture(self, self.textureUrl);
	  }

	  var numMeshes = r.getUint32();

	  if (numMeshes > 0) {
	    self.meshes = new Array(numMeshes);

	    for (i = 0; i < numMeshes; ++i) {
	      var name = r.getString().toLowerCase();
	      var vStart = r.getUint32();
	      var vCount = r.getUint32();
	      var iStart = r.getUint32();
	      var iCount = r.getUint32();
	      self.meshes[i] = {
	        name: name,
	        vStart: vStart,
	        vCount: vCount,
	        iStart: iStart,
	        iCount: iCount
	      };
	    }
	  }

	  var numVerts = r.getUint32();

	  if (numVerts > 0) {
	    self.vertices = new Array(numVerts);
	    self.vbData = new Float32Array(numVerts * 8);
	    var position = [];
	    var normal = [];
	    var uv = [];

	    for (i = 0; i < numVerts; ++i) {
	      idx = i * 8;
	      self.vertices[i] = v = new Vertex(r);
	      self.vbData[idx] = v.position[0];
	      self.vbData[idx + 1] = v.position[1];
	      self.vbData[idx + 2] = v.position[2];
	      self.vbData[idx + 3] = v.normal[0];
	      self.vbData[idx + 4] = v.normal[1];
	      self.vbData[idx + 5] = v.normal[2];
	      self.vbData[idx + 6] = v.u;
	      self.vbData[idx + 7] = v.v;
	      position.push(v.position[0], v.position[1], v.position[2]);
	      normal.push(v.normal[0], v.normal[1], v.normal[2]);
	      uv.push(v.u, v.v);
	    }

	    self.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(position), 3));
	    self.geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normal), 3));
	    self.geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uv), 2));
	  }

	  var numIndices = r.getUint32();

	  if (numIndices > 0) {
	    self.indices = new Array(numIndices);

	    for (i = 0; i < numIndices; ++i) {
	      self.indices[i] = r.getUint16();
	    }

	    self.geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(self.indices), 1));
	  }

	  var numBones = r.getUint32();

	  if (numBones > 0) {
	    self.transforms = new Array(numBones);
	    self.bones = new Array(numBones);

	    for (i = 0; i < numBones; ++i) {
	      self.bones[i] = new Bone(self, i, r);

	      if (self.boneLookup[self.bones[i].name] !== undefined) {
	        self.bones[i].name = self.bones[i].name + "2";
	      }

	      self.boneLookup[self.bones[i].name] = i;
	      self.transforms[i] = new mat4.create();
	    }
	  }

	  self.loaded = true;
	  self.dispatch.call('loadMesh');
	};

	Model.prototype.loadAnim = function (buffer) {
	  if (!buffer) {
	    console.error("Bad buffer for DataView");
	    return;
	  }

	  var self = this,
	      r = new DataView2(buffer),
	      i;
	  var magic = r.getUint32();

	  if (magic !== 604210092) {
	    console.log("Bad magic value");
	    return;
	  }

	  var version = r.getUint32();

	  if (version >= 2) {
	    var compressedData = new Uint8Array(buffer, r.position);
	    var data = null;

	    try {
	      data = pako.inflate(compressedData);
	    } catch (err) {
	      console.log("Decompression error: " + err);
	      return;
	    }

	    r = new DataView2(data.buffer);
	  }

	  var numAnims = r.getUint32();

	  if (numAnims > 0) {
	    self.animations = new Array(numAnims);

	    for (i = 0; i < numAnims; ++i) {
	      self.animations[i] = new Animation(self, r, version);
	    }
	  }

	  self.animsLoaded = true;
	};

	Model.prototype.on = function (eventName, callback) {
	  this.dispatch.on(eventName, callback);
	};

	/**
	 * LOLLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function LOLLoader() {
	  BaseLoader.call(this);
	}

	LOLLoader.prototype = Object.create(BaseLoader.prototype);
	LOLLoader.prototype.constructor = LOLLoader;

	LOLLoader.prototype.load = function (url, options) {
	  if (!Array.isArray(url) || url.length < 3) {
	    console.warn(`LOLLoader: url must be an array, and contains .lmesh,.lanim and .png three urls.`);
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  var lmesh = url.filter(n => n.endsWith('.lmesh'))[0];
	  var lanim = url.filter(n => n.endsWith('.lanim'))[0];
	  var png = url.filter(n => n.endsWith('.png'))[0];

	  if (lmesh === undefined) {
	    console.warn(`LOLLoader: url doesn't contain .lmesh url.`);
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  if (lanim === undefined) {
	    console.warn(`LOLLoader: url doesn't contain .lanim url.`);
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  if (png === undefined) {
	    console.warn(`LOLLoader: url doesn't contain .png url.`);
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  var fileName = lmesh.split('/')[lmesh.split('/').length - 1];
	  var fileNameNoExt = fileName.split('.')[0];
	  var champion = fileNameNoExt.split('_')[0];
	  var skin = fileNameNoExt.split('_')[1];
	  return new Promise(resolve => {
	    this.require(['gl-matrix', 'pako']).then(() => {
	      var model = new Model({
	        champion: champion,
	        skin: parseInt(skin),
	        meshUrl: lmesh,
	        animUrl: lanim,
	        textureUrl: png
	      });
	      model.load();
	      model.on('load.LOLLoader', () => {
	        var geometry = model.geometry;
	        var material = model.material;
	        var mesh = new THREE.Mesh(geometry, material);
	        mesh.name = options.Name;
	        mesh.userData.type = 'lol';
	        mesh.userData.model = model;
	        mesh.userData.scripts = [{
	          id: null,
	          name: `${options.Name}${_t('Animation')}`,
	          type: 'javascript',
	          source: this.createScripts(options.Name, model),
	          uuid: THREE.Math.generateUUID()
	        }];
	        resolve(mesh);
	      });
	    });
	  });
	};

	LOLLoader.prototype.createScripts = function (name, model) {
	  var animations = model.getAnimations();
	  return `var mesh = this.getObjectByName('${name}');\n` + `var model = mesh.userData.model;\n\n` + `// animNames: ${animations.join(',')}\n` + `model.setAnimation('${animations[0]}');\n\n` + `function update(clock, deltaTime) { \n    model.update(clock.elapsedTime * 1000); \n}`;
	};

	/**
	 * MMDLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function MMDLoader() {
	  BaseLoader.call(this);
	}

	MMDLoader.prototype = Object.create(BaseLoader.prototype);
	MMDLoader.prototype.constructor = MMDLoader;

	MMDLoader.prototype.load = function (url, options, environment) {
	  return new Promise(resolve => {
	    this.require('MMD').then(() => {
	      var loader = new THREE.MMDLoader();
	      var promise1 = options.Animation && options.Animation.Url ? this.loadWithAnimation(url, options, environment, loader) : this.loadModel(url, options, environment, loader);
	      var promise2 = this.loadCameraAnimation(url, options, environment, loader);
	      var promise3 = this.loadAudio(url, options, environment, loader);
	      Promise.all([promise1, promise2, promise3]).then(obj => {
	        var mesh = obj[0].mesh;
	        var animation = obj[0].animation;
	        var cameraAnimation = obj[1];
	        var audio = obj[2]; // 修复播放MMD报错的bug

	        mesh._animation = animation;
	        mesh._cameraAnimation = cameraAnimation;
	        mesh._audio = audio;
	        resolve(mesh);
	      });
	    });
	  });
	};

	MMDLoader.prototype.loadModel = function (url, options, environment, loader) {
	  return new Promise(resolve => {
	    loader.load(url, mesh => {
	      resolve({
	        mesh: mesh,
	        animation: null
	      });
	    }, undefined, () => {// 某个图片下载失败会导致返回null
	      // resolve(null);
	    });
	  });
	};

	MMDLoader.prototype.loadWithAnimation = function (url, options, environment, loader) {
	  if (!options.Animation || !options.Animation.Url) {
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  return new Promise(resolve => {
	    loader.loadWithAnimation(url, [environment.server + options.Animation.Url], mmd => {
	      resolve(mmd);
	    }, undefined, () => {
	      resolve(null);
	    });
	  });
	};

	MMDLoader.prototype.loadCameraAnimation = function (url, options, environment, loader) {
	  if (!options.CameraAnimation || !options.CameraAnimation.Url) {
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  return new Promise(resolve => {
	    loader.loadAnimation([environment.server + options.CameraAnimation.Url], environment.camera, vmd => {
	      resolve(vmd);
	    }, undefined, () => {
	      resolve(null);
	    });
	  });
	};

	MMDLoader.prototype.loadAudio = function (url, options, environment, loader) {
	  // eslint-disable-line
	  if (!options.Audio || !options.Audio.Url) {
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  return new Promise(resolve => {
	    var loader = new THREE.AudioLoader();
	    loader.load(environment.server + options.Audio.Url, buffer => {
	      var audio = new THREE.Audio(environment.audioListener).setBuffer(buffer);
	      Object.assign(audio.userData, options.Audio);
	      resolve(audio);
	    });
	  });
	};

	/**
	 * JsonLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function JsonLoader() {
	  BaseLoader.call(this);
	}

	JsonLoader.prototype = Object.create(BaseLoader.prototype);
	JsonLoader.prototype.constructor = JsonLoader;

	JsonLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require(['LegacyJSONLoader']).then(() => {
	      var loader = new THREE.LegacyJSONLoader();
	      loader.load(url, (geometry, materials) => {
	        for (var i = 0; i < materials.length; i++) {
	          var m = materials[i];
	          m.skinning = true;
	          m.morphTargets = true;
	        }

	        var mesh = new THREE.SkinnedMesh(geometry, materials); // TODO: 最新版three.js不再支持了

	        if (!mesh.skeleton) {
	          mesh.skeleton = {
	            update: function () {}
	          };
	        }

	        mesh._obj = [geometry, materials];
	        mesh._root = mesh;
	        Object.assign(mesh.userData, {
	          scripts: [{
	            id: null,
	            name: `${options.Name}${_t('Animation')}`,
	            type: 'javascript',
	            source: this.createScripts(options.Name),
	            uuid: THREE.Math.generateUUID()
	          }]
	        });
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	JsonLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n` + `var mixer = new THREE.AnimationMixer(mesh)\n` + `mixer.clipAction(mesh.geometry.animations[0]).play();\n\n` + `function update(clock, deltaTime) { \n    mixer.update(deltaTime); \n}`;
	};

	/**
	 * 3DSLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function _3DSLoader() {
	  BaseLoader.call(this);
	}

	_3DSLoader.prototype = Object.create(BaseLoader.prototype);
	_3DSLoader.prototype.constructor = _3DSLoader;

	_3DSLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('TDSLoader').then(() => {
	      var loader = new THREE.TDSLoader();
	      loader.load(url, group => {
	        resolve(group);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * 3MFLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function _3MFLoader() {
	  BaseLoader.call(this);
	}

	_3MFLoader.prototype = Object.create(BaseLoader.prototype);
	_3MFLoader.prototype.constructor = _3MFLoader;

	_3MFLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('3MFLoader').then(() => {
	      var loader = new THREE.ThreeMFLoader();
	      loader.load(url, object => {
	        resolve(object);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * AssimpLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function AssimpLoader() {
	  BaseLoader.call(this);
	}

	AssimpLoader.prototype = Object.create(BaseLoader.prototype);
	AssimpLoader.prototype.constructor = AssimpLoader;

	AssimpLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('AssimpLoader').then(() => {
	      var loader = new THREE.AssimpLoader();
	      loader.load(url, result => {
	        var obj = result.object;
	        obj._obj = result;
	        obj._root = obj;

	        if (result.animation) {
	          Object.assign(obj.userData, {
	            animNames: 'Animation1',
	            scripts: [{
	              id: null,
	              name: `${options.Name}${_t('Animation')}`,
	              type: 'javascript',
	              source: this.createScripts(options.Name),
	              uuid: THREE.Math.generateUUID()
	            }]
	          });
	        }

	        resolve(obj);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	AssimpLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n\n` + `var animation = mesh._obj.animation;\n\n` + `function update(clock, deltaTime) { \n  if(animation) {\n     animation.setTime( performance.now() / 1000 ); \n    } \n}`;
	};

	/**
	 * BVHLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function BVHLoader() {
	  BaseLoader.call(this);
	}

	BVHLoader.prototype = Object.create(BaseLoader.prototype);
	BVHLoader.prototype.constructor = BVHLoader;

	BVHLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('BVHLoader').then(() => {
	      var loader = new THREE.BVHLoader();
	      loader.load(url, result => {
	        var skeletonHelper = new THREE.SkeletonHelper(result.skeleton.bones[0]);
	        skeletonHelper.skeleton = result.skeleton; // allow animation mixer to bind to SkeletonHelper directly

	        var boneContainer = new THREE.Group();
	        boneContainer.add(result.skeleton.bones[0]);
	        var obj3d = new THREE.Object3D();
	        obj3d.add(skeletonHelper);
	        obj3d.add(boneContainer);
	        obj3d._obj = result;
	        obj3d._root = skeletonHelper;
	        Object.assign(obj3d.userData, {
	          animNames: 'Animation1',
	          scripts: [{
	            id: null,
	            name: `${options.Name}${_t('Animation')}`,
	            type: 'javascript',
	            source: this.createScripts(options.Name),
	            uuid: THREE.Math.generateUUID()
	          }]
	        });
	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	BVHLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n\n` + `var mixer = new THREE.AnimationMixer(mesh._root);\n\n` + `mixer.clipAction(mesh._obj.clip).setEffectiveWeight(1.0).play();` + `function update(clock, deltaTime) { \n     mixer.update(deltaTime); \n}`;
	};

	/**
	 * DRACOLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function DRACOLoader() {
	  BaseLoader.call(this);
	}

	DRACOLoader.prototype = Object.create(BaseLoader.prototype);
	DRACOLoader.prototype.constructor = DRACOLoader;

	DRACOLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('DRACOLoader').then(() => {
	      var loader = new THREE.DRACOLoader();
	      loader.setDecoderPath('assets/js/libs/draco/');
	      loader.load(url, geometry => {
	        geometry.computeVertexNormals();
	        var material = new THREE.MeshStandardMaterial();
	        var mesh = new THREE.Mesh(geometry, material); // TODO: 取消注释不能加载模型，不知道为什么。
	        // loader.releaseDecoderModule();

	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * GCodeLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function GCodeLoader() {
	  BaseLoader.call(this);
	}

	GCodeLoader.prototype = Object.create(BaseLoader.prototype);
	GCodeLoader.prototype.constructor = GCodeLoader;

	GCodeLoader.prototype.load = function (url, options) {
	  // eslint-disable-line
	  return new Promise(resolve => {
	    this.require('GCodeLoader').then(() => {
	      var loader = new THREE.GCodeLoader();
	      loader.load(url, obj3d => {
	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * NRRDLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function NRRDLoader() {
	  BaseLoader.call(this);
	}

	NRRDLoader.prototype = Object.create(BaseLoader.prototype);
	NRRDLoader.prototype.constructor = NRRDLoader;

	NRRDLoader.prototype.load = function (url, options) {
	  // eslint-disable-line
	  return new Promise(resolve => {
	    this.require('NRRDLoader').then(() => {
	      var loader = new THREE.NRRDLoader();
	      loader.load(url, result => {
	        // eslint-disable-line
	        var loader = new THREE.NRRDLoader();
	        loader.load(url, volume => {
	          var obj = new THREE.Object3D(); // x plane

	          var sliceX = volume.extractSlice('x', Math.floor(volume.RASDimensions[0] / 2));
	          obj.add(sliceX.mesh); //y plane

	          var sliceY = volume.extractSlice('y', Math.floor(volume.RASDimensions[1] / 2));
	          obj.add(sliceY.mesh); //z plane

	          var sliceZ = volume.extractSlice('z', Math.floor(volume.RASDimensions[2] / 4));
	          obj.add(sliceZ.mesh);
	          resolve(obj);
	        });
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * PCDLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function PCDLoader() {
	  BaseLoader.call(this);
	}

	PCDLoader.prototype = Object.create(BaseLoader.prototype);
	PCDLoader.prototype.constructor = PCDLoader;

	PCDLoader.prototype.load = function (url, options) {
	  // eslint-disable-line
	  return new Promise(resolve => {
	    this.require('PCDLoader').then(() => {
	      var loader = new THREE.PCDLoader();
	      loader.load(url, mesh => {
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * PDBLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function PDBLoader() {
	  BaseLoader.call(this);
	}

	PDBLoader.prototype = Object.create(BaseLoader.prototype);
	PDBLoader.prototype.constructor = PDBLoader;

	PDBLoader.prototype.load = function (url, options) {
	  // eslint-disable-line
	  return new Promise(resolve => {
	    this.require('PDBLoader').then(() => {
	      var loader = new THREE.PDBLoader();
	      var offset = new THREE.Vector3();
	      loader.load(url, pdb => {
	        var geometryAtoms = pdb.geometryAtoms;
	        var geometryBonds = pdb.geometryBonds; // var json = pdb.json;

	        var root = new THREE.Group();
	        var boxGeometry = new THREE.BoxBufferGeometry(1, 1, 1);
	        var sphereGeometry = new THREE.IcosahedronBufferGeometry(1, 2);
	        geometryAtoms.computeBoundingBox();
	        geometryAtoms.boundingBox.getCenter(offset).negate();
	        geometryAtoms.translate(offset.x, offset.y, offset.z);
	        geometryBonds.translate(offset.x, offset.y, offset.z);
	        var positions = geometryAtoms.getAttribute('position');
	        var colors = geometryAtoms.getAttribute('color');
	        var position = new THREE.Vector3();
	        var color = new THREE.Color();
	        var i, object;

	        for (i = 0; i < positions.count; i++) {
	          position.x = positions.getX(i);
	          position.y = positions.getY(i);
	          position.z = positions.getZ(i);
	          color.r = colors.getX(i);
	          color.g = colors.getY(i);
	          color.b = colors.getZ(i);
	          var material = new THREE.MeshPhongMaterial({
	            color: color
	          });
	          object = new THREE.Mesh(sphereGeometry, material);
	          object.position.copy(position);
	          object.position.multiplyScalar(75);
	          object.scale.multiplyScalar(25);
	          root.add(object);
	        }

	        positions = geometryBonds.getAttribute('position');
	        var start = new THREE.Vector3();
	        var end = new THREE.Vector3();

	        for (i = 0; i < positions.count; i += 2) {
	          start.x = positions.getX(i);
	          start.y = positions.getY(i);
	          start.z = positions.getZ(i);
	          end.x = positions.getX(i + 1);
	          end.y = positions.getY(i + 1);
	          end.z = positions.getZ(i + 1);
	          start.multiplyScalar(75);
	          end.multiplyScalar(75);
	          object = new THREE.Mesh(boxGeometry, new THREE.MeshPhongMaterial(0xffffff));
	          object.position.copy(start);
	          object.position.lerp(end, 0.5);
	          object.scale.set(5, 5, start.distanceTo(end));
	          object.lookAt(end);
	          root.add(object);
	        }

	        resolve(root);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * PRWMLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function PRWMLoader() {
	  BaseLoader.call(this);
	}

	PRWMLoader.prototype = Object.create(BaseLoader.prototype);
	PRWMLoader.prototype.constructor = PRWMLoader;

	PRWMLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('PRWMLoader').then(() => {
	      var loader = new THREE.PRWMLoader();
	      loader.load(url, geometry => {
	        var material = new THREE.MeshPhongMaterial();
	        var mesh = new THREE.Mesh(geometry, material);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * SEA3DLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function SEA3DLoader() {
	  BaseLoader.call(this);
	}

	SEA3DLoader.prototype = Object.create(BaseLoader.prototype);
	SEA3DLoader.prototype.constructor = SEA3DLoader;

	SEA3DLoader.prototype.load = function (url, options) {
	  var obj = new THREE.Object3D();
	  return new Promise(resolve => {
	    this.require('SEA3D').then(() => {
	      var loader = new THREE.SEA3D({
	        autoPlay: true,
	        // Auto play animations
	        container: obj,
	        // Container to add models
	        progressive: true // Progressive download

	      });

	      loader.onComplete = function () {
	        resolve(obj);
	      };

	      loader.load(url);
	      Object.assign(obj.userData, {
	        animNames: ['Animation1'],
	        scripts: [{
	          id: null,
	          name: `${options.Name}${_t('Animation')}`,
	          type: 'javascript',
	          source: this.createScripts(options.Name),
	          uuid: THREE.Math.generateUUID()
	        }]
	      });
	    });
	  });
	};

	SEA3DLoader.prototype.createScripts = function (name) {
	  // eslint-disable-line
	  return `function update(clock, deltaTime) { \n    THREE.SEA3D.AnimationHandler.update(deltaTime); \n}`;
	};

	/**
	 * VRMLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function VRMLoader() {
	  BaseLoader.call(this);
	}

	VRMLoader.prototype = Object.create(BaseLoader.prototype);
	VRMLoader.prototype.constructor = VRMLoader;

	VRMLoader.prototype.load = function (url, options) {
	  // eslint-disable-line
	  return new Promise(resolve => {
	    this.require(['GLTFLoader', 'VRMLoader']).then(() => {
	      var loader = new THREE.VRMLoader();
	      loader.load(url, vrm => {
	        var material; // VRMLoader doesn't support VRM Unlit extension yet so
	        // converting all materials to MeshBasicMaterial here as workaround so far.

	        vrm.scene.traverse(function (object) {
	          if (object.material) {
	            if (Array.isArray(object.material)) {
	              for (var i = 0, il = object.material.length; i < il; i++) {
	                material = new THREE.MeshBasicMaterial();
	                THREE.Material.prototype.copy.call(material, object.material[i]);
	                material.color.copy(object.material[i].color);
	                material.map = object.material[i].map;
	                material.lights = false;
	                material.skinning = object.material[i].skinning;
	                material.morphTargets = object.material[i].morphTargets;
	                material.morphNormals = object.material[i].morphNormals;
	                object.material[i] = material;
	              }
	            } else {
	              material = new THREE.MeshBasicMaterial();
	              THREE.Material.prototype.copy.call(material, object.material);
	              material.color.copy(object.material.color);
	              material.map = object.material.map;
	              material.lights = false;
	              material.skinning = object.material.skinning;
	              material.morphTargets = object.material.morphTargets;
	              material.morphNormals = object.material.morphNormals;
	              object.material = material;
	            }
	          }
	        });
	        resolve(vrm.scene);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * VRMLLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function VRMLLoader() {
	  BaseLoader.call(this);
	}

	VRMLLoader.prototype = Object.create(BaseLoader.prototype);
	VRMLLoader.prototype.constructor = VRMLLoader;

	VRMLLoader.prototype.load = function (url, options) {
	  // eslint-disable-line
	  return new Promise(resolve => {
	    this.require(['chevrotain', 'VRMLLoader']).then(() => {
	      var loader = new THREE.VRMLLoader();
	      loader.load(url, obj => {
	        resolve(obj);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * XLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function XLoader() {
	  BaseLoader.call(this);
	}

	XLoader.prototype = Object.create(BaseLoader.prototype);
	XLoader.prototype.constructor = XLoader;

	XLoader.prototype.load = function (url, options) {
	  // eslint-disable-line
	  return new Promise(resolve => {
	    this.require('XLoader').then(() => {
	      var loader = new THREE.XLoader();
	      loader.load([url], object => {
	        var obj = new THREE.Object3D();

	        for (var i = 0; i < object.models.length; i++) {
	          var model = object.models[i];
	          obj.add(model);
	        }

	        resolve(obj);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * 模型工具类
	 */
	const MeshUtils = {
	  /**
	   * 遍历模型子元素，得到uuid列表
	   * @param {THREE.Object3D} children 模型的children数组
	   * @param {Array} list uuid数组
	   */
	  traverseUUID(children, list) {
	    for (let i = 0; i < children.length; i++) {
	      let child = children[i];
	      let list1 = [];

	      if (child.children && child.children.length > 0) {
	        this.traverseUUID(child.children, list1);
	      }

	      list.push({
	        uuid: child.uuid,
	        children: list1
	      });
	    }
	  },

	  /**
	   * 通过模型组件获取整个模型
	   * @param {*} obj 通过模型的一部分获取整个模型
	   * @returns {*} 整体模型
	   */
	  partToMesh(obj) {
	    let scene = app.editor.scene;

	    if (obj === scene || obj.userData && obj.userData.Server === true) {
	      // 场景或服务端模型
	      return obj;
	    } // 判断obj是否是模型的一部分


	    let model = obj;
	    let isPart = false;

	    while (model) {
	      if (model === scene) {
	        break;
	      }

	      if (model.userData && model.userData.Server === true) {
	        isPart = true;
	        break;
	      }

	      model = model.parent;
	    }

	    if (isPart) {
	      return model;
	    }

	    return obj;
	  }

	};

	const Loaders = {
	  '_3ds': _3DSLoader,
	  '_3mf': _3MFLoader,
	  'amf': AMFLoader,
	  'assimp': AssimpLoader,
	  'awd': AWDLoader,
	  'babylon': BabylonLoader,
	  'binary': BinaryLoader,
	  'bvh': BVHLoader,
	  'ctm': CTMLoader,
	  'dae': ColladaLoader,
	  'fbx': FBXLoader,
	  'glb': GLTFLoader,
	  'gltf': GLTFLoader,
	  'kmz': KMZLoader,
	  'md2': MD2Loader,
	  'json': ObjectLoader,
	  'obj': OBJLoader,
	  'ply': PLYLoader,
	  'stl': STLLoader,
	  'vtk': VTKLoader,
	  'lol': LOLLoader,
	  'pmd': MMDLoader,
	  'pmx': MMDLoader,
	  'js': JsonLoader,
	  'drc': DRACOLoader,
	  'gcode': GCodeLoader,
	  'nrrd': NRRDLoader,
	  'pcd': PCDLoader,
	  'pdb': PDBLoader,
	  'prwm': PRWMLoader,
	  'sea3d': SEA3DLoader,
	  'vrm': VRMLoader,
	  'vrml': VRMLLoader,
	  'x': XLoader
	};
	/**
	 * ModelLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function ModelLoader() {
	  BaseLoader.call(this);
	}

	ModelLoader.prototype = Object.create(BaseLoader.prototype);
	ModelLoader.prototype.constructor = ModelLoader;

	ModelLoader.prototype.load = function (url, options = {}, environment = {}) {
	  var type = options.Type;

	  if (type === undefined) {
	    console.warn(`ModelLoader: no type parameters, and cannot load.`);
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  return new Promise(resolve => {
	    var loader = Loaders[type];

	    if (loader === undefined) {
	      console.warn(`ModelLoader: no ${type} loader.`);
	      resolve(null);
	      return;
	    }

	    new loader(app).load(url, options, environment).then(obj => {
	      if (!obj || !obj.userData) {
	        resolve(null);
	        return;
	      } // bug: 由于模型可能自带错误的_children数据，导致载入场景模型显示不全。
	      // 所以，向场景添加模型时，清除掉_children属性。


	      if (environment.clearChildren) {
	        delete obj.userData._children;
	      } // 由于每次加载模型，uuid会变，所以要记录原始模型的uuid，而且只能记录一次。


	      if (obj.children && !obj.userData._children) {
	        obj.userData._children = []; // 原始模型的uuid层次

	        MeshUtils.traverseUUID(obj.children, obj.userData._children); // 记录最原始的模型，每个组件的uuid。
	      }

	      obj.userData.physics = obj.userData.physics || {
	        enabled: false,
	        type: 'rigidBody',
	        shape: 'btBoxShape',
	        mass: 1,
	        inertia: {
	          x: 0,
	          y: 0,
	          z: 0
	        }
	      };
	      resolve(obj);
	    });
	  });
	};

	/**
	 * ServerObject
	 * @author tengge / https://github.com/tengge1
	 */

	function ServerObject() {
	  BaseSerializer.call(this);
	}

	ServerObject.prototype = Object.create(BaseSerializer.prototype);
	ServerObject.prototype.constructor = ServerObject;

	ServerObject.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.userData = Object.assign({}, obj.userData);
	  delete json.userData.model;
	  delete json.userData.helper;
	  return json;
	};

	ServerObject.prototype.fromJSON = function (json, options, environment) {
	  let url = json.userData.Url;

	  if (url.indexOf(';') > -1) {
	    // 包含多个入口文件
	    url = url.split(';').map(n => options.server + n);
	  } else {
	    url = options.server + url;
	  } // 将server传递给MMDLoader，以便下载资源


	  environment.server = options.server;
	  const loader = new ModelLoader();
	  return new Promise(resolve => {
	    loader.load(url, json.userData, environment).then(obj => {
	      if (obj) {
	        Object3DSerializer.prototype.fromJSON.call(this, json, obj); // 还原原始模型的uuid

	        if (Array.isArray(json.userData._children)) {
	          this.revertUUID(obj.children, json.userData._children);
	        }

	        resolve(obj);
	      } else {
	        resolve(null);
	      }
	    });
	  });
	};
	/**
	 * 还原原始模型的uuid。
	 * @param {THREE.Object3D} children 部件
	 * @param {Array} list 原始的uuid列表
	 */


	ServerObject.prototype.revertUUID = function (children, list) {
	  for (let i = 0; i < children.length; i++) {
	    let child = children[i];

	    if (list[i]) {
	      child.uuid = list[i].uuid;
	    }

	    if (child.children && list[i] && list[i].children) {
	      this.revertUUID(child.children, list[i].children);
	    }
	  }
	};

	/**
	 * WebGLShadowMapSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function WebGLShadowMapSerializer() {
	  BaseSerializer.call(this);
	}

	WebGLShadowMapSerializer.prototype = Object.create(BaseSerializer.prototype);
	WebGLShadowMapSerializer.prototype.constructor = WebGLShadowMapSerializer;

	WebGLShadowMapSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.autoUpdate = obj.autoUpdate;
	  json.enabled = obj.enabled;
	  json.needsUpdate = obj.needsUpdate;
	  json.type = obj.type;
	  return json;
	};

	WebGLShadowMapSerializer.prototype.fromJSON = function (json, parent) {
	  if (parent === undefined) {
	    console.warn(`WebGLShadowMapSerializer: parent is empty.`);
	    return null;
	  }

	  var obj = parent;
	  obj.autoUpdate = json.autoUpdate;
	  obj.enabled = json.enabled;
	  obj.needsUpdate = true;
	  obj.type = json.type;
	  return obj;
	};

	/**
	 * WebGLRendererSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function WebGLRendererSerializer() {
	  BaseSerializer.call(this);
	}

	WebGLRendererSerializer.prototype = Object.create(BaseSerializer.prototype);
	WebGLRendererSerializer.prototype.constructor = WebGLRendererSerializer;

	WebGLRendererSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.antialias = true;

	  json.autoClear = obj.autoClear;
	  json.autoClearColor = obj.autoClearColor;
	  json.autoClearDepth = obj.autoClearDepth;
	  json.autoClearStencil = obj.autoClearStencil;
	  json.autoUpdateScene = obj.autoUpdateScene;
	  json.clippingPlanes = obj.clippingPlanes;
	  json.gammaFactor = obj.gammaFactor; // json.gammaInput = obj.gammaInput;
	  // json.gammaOutput = obj.gammaOutput;

	  json.localClippingEnabled = obj.localClippingEnabled;
	  json.physicallyCorrectLights = obj.physicallyCorrectLights;
	  json.shadowMap = new WebGLShadowMapSerializer().toJSON(obj.shadowMap);
	  json.sortObjects = obj.sortObjects;
	  json.toneMapping = obj.toneMapping;
	  json.toneMappingExposure = obj.toneMappingExposure;
	  json.toneMappingWhitePoint = obj.toneMappingWhitePoint;
	  return json;
	};

	WebGLRendererSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.WebGLRenderer({
	    antialias: json.antialias,alpha:true 
	  }) : parent;

	  obj.autoClear = json.autoClear;
	  obj.autoClearColor = json.autoClearColor;
	  obj.autoClearDepth = json.autoClearDepth;
	  obj.autoClearStencil = json.autoClearStencil;
	  obj.autoUpdateScene = json.autoUpdateScene;
	  obj.clippingPlanes = json.clippingPlanes;
	  obj.gammaFactor = json.gammaFactor; // obj.gammaInput = json.gammaInput;
	  // obj.gammaOutput = json.gammaOutput;

	  obj.localClippingEnabled = json.localClippingEnabled;
	  obj.physicallyCorrectLights = json.physicallyCorrectLights;
	  new WebGLShadowMapSerializer().fromJSON(json.shadowMap, obj.shadowMap);
	  obj.sortObjects = json.sortObjects;
	  obj.toneMapping = json.toneMapping;
	  obj.toneMappingExposure = json.toneMappingExposure;
	  obj.toneMappingWhitePoint = json.toneMappingWhitePoint;
	  return obj;
	};

	/**
	 * OptionsSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function OptionsSerializer() {
	  BaseSerializer.call(this);
	}

	OptionsSerializer.prototype = Object.create(BaseSerializer.prototype);
	OptionsSerializer.prototype.constructor = OptionsSerializer;

	OptionsSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  Object.assign(json, obj);
	  return json;
	};

	OptionsSerializer.prototype.fromJSON = function (json) {
	  var obj = {};
	  Object.keys(json).forEach(n => {
	    if (n === '_id' || n === 'metadata' || n === 'server') {
	      // 由于不同服务器的服务端不一样，所以不能反序列化server配置
	      return;
	    }

	    obj[n] = json[n];
	  });
	  return obj;
	};

	/**
	 * ScriptSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ScriptSerializer() {
	  BaseSerializer.call(this);
	}

	ScriptSerializer.prototype = Object.create(BaseSerializer.prototype);
	ScriptSerializer.prototype.constructor = ScriptSerializer;

	ScriptSerializer.prototype.toJSON = function (scripts) {
	  var list = [];
	  scripts.forEach(script => {
	    var json = BaseSerializer.prototype.toJSON.call(this);
	    Object.assign(json, {
	      id: script.id,
	      pid: script.pid,
	      name: script.name,
	      type: script.type,
	      source: script.source,
	      sort: script.sort,
	      uuid: script.uuid
	    });
	    list.push(json);
	  });
	  return list;
	};

	ScriptSerializer.prototype.fromJSON = function (jsons, parent) {
	  parent = parent || [];
	  jsons.forEach(json => {
	    parent.push({
	      id: json.id,
	      pid: json.pid,
	      name: json.name,
	      type: json.type,
	      source: json.source,
	      sort: json.sort,
	      uuid: json.uuid
	    });
	  });
	  return parent;
	};

	/**
	 * AnimationSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function AnimationSerializer() {
	  BaseSerializer.call(this);
	}

	AnimationSerializer.prototype = Object.create(BaseSerializer.prototype);
	AnimationSerializer.prototype.constructor = AnimationSerializer;

	AnimationSerializer.prototype.toJSON = function (list) {
	  var jsons = [];
	  list.forEach(n => {
	    var json = BaseSerializer.prototype.toJSON.call(this, n);
	    Object.assign(json, n);
	    jsons.push(json);
	  });
	  return jsons;
	};

	AnimationSerializer.prototype.fromJSON = function (jsons) {
	  var list = [];
	  jsons.forEach(n => {
	    var obj = Object.assign({}, n);
	    delete obj.metadata;
	    list.push(obj);
	  });
	  return list;
	};

	/**
	 * CameraSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CameraSerializer() {
	  BaseSerializer.call(this);
	}

	CameraSerializer.prototype = Object.create(BaseSerializer.prototype);
	CameraSerializer.prototype.constructor = CameraSerializer;

	CameraSerializer.prototype.filter = function (obj) {
	  if (obj instanceof THREE.Camera) {
	    return true;
	  } else if (obj.metadata && obj.metadata.generator === this.constructor.name) {
	    return true;
	  } else {
	    return false;
	  }
	};

	CameraSerializer.prototype.toJSON = function (obj) {
	  return Object3DSerializer.prototype.toJSON.call(this, obj);
	};

	CameraSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Camera() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * OrthographicCameraSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function OrthographicCameraSerializer() {
	  BaseSerializer.call(this);
	}

	OrthographicCameraSerializer.prototype = Object.create(BaseSerializer.prototype);
	OrthographicCameraSerializer.prototype.constructor = OrthographicCameraSerializer;

	OrthographicCameraSerializer.prototype.toJSON = function (obj) {
	  var json = CameraSerializer.prototype.toJSON.call(this, obj);
	  json.bottom = obj.bottom;
	  json.far = obj.far;
	  json.left = obj.left;
	  json.near = obj.near;
	  json.right = obj.right;
	  json.top = obj.top;
	  json.view = obj.view;
	  json.zoom = obj.zoom;
	  return json;
	};

	OrthographicCameraSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.OrthographicCamera() : parent;
	  CameraSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.bottom = json.bottom;
	  obj.far = json.far;
	  obj.left = json.left;
	  obj.near = json.near;
	  obj.right = json.right;
	  obj.top = json.top;
	  obj.view = json.view;
	  obj.zoom = json.zoom;
	  return obj;
	};

	/**
	 * PerspectiveCameraSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PerspectiveCameraSerializer() {
	  BaseSerializer.call(this);
	}

	PerspectiveCameraSerializer.prototype = Object.create(BaseSerializer.prototype);
	PerspectiveCameraSerializer.prototype.constructor = PerspectiveCameraSerializer;

	PerspectiveCameraSerializer.prototype.toJSON = function (obj) {
	  var json = CameraSerializer.prototype.toJSON.call(this, obj);
	  json.aspect = obj.aspect;
	  json.far = obj.far;
	  json.filmGauge = obj.filmGauge;
	  json.filmOffset = obj.filmOffset;
	  json.focus = obj.focus;
	  json.fov = obj.fov;
	  json.near = obj.near;
	  json.view = obj.view;
	  json.zoom = obj.zoom;
	  return json;
	};

	PerspectiveCameraSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.PerspectiveCamera() : parent;
	  CameraSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.aspect = json.aspect;
	  obj.far = json.far;
	  obj.filmGauge = json.filmGauge;
	  obj.filmOffset = json.filmOffset;
	  obj.focus = json.focus;
	  obj.fov = json.fov;
	  obj.near = json.near;
	  obj.view = json.view;
	  obj.zoom = json.zoom;
	  return obj;
	};

	var Serializers$3 = {
	  'OrthographicCamera': OrthographicCameraSerializer,
	  'PerspectiveCamera': PerspectiveCameraSerializer,
	  'Camera': CameraSerializer
	};
	/**
	 * CamerasSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CamerasSerializer() {
	  BaseSerializer.call(this);
	}

	CamerasSerializer.prototype = Object.create(BaseSerializer.prototype);
	CamerasSerializer.prototype.constructor = CamerasSerializer;

	CamerasSerializer.prototype.toJSON = function (obj) {
	  var serializer = Serializers$3[obj.constructor.name];

	  if (serializer === undefined) {
	    console.warn(`CamerasSerializer: No serializer with ${obj.constructor.name}.`);
	    return null;
	  }

	  return new serializer().toJSON(obj);
	};

	CamerasSerializer.prototype.fromJSON = function (json, parent) {
	  var generator = json.metadata.generator;
	  var serializer = Serializers$3[generator.replace('Serializer', '')];

	  if (serializer === undefined) {
	    console.warn(`CamerasSerializer: No deserializer with ${generator}.`);
	    return null;
	  }

	  return new serializer().fromJSON(json, parent);
	};

	/**
	 * WebGLRenderTargetSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function WebGLRenderTargetSerializer() {
	  BaseSerializer.call(this);
	}

	WebGLRenderTargetSerializer.prototype = Object.create(BaseSerializer.prototype);
	WebGLRenderTargetSerializer.prototype.constructor = WebGLRenderTargetSerializer;

	WebGLRenderTargetSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.depthBuffer = obj.depthBuffer;
	  json.depthTexture = !obj.depthTexture ? null : new TexturesSerializer().toJSON(obj.depthTexture);
	  json.height = obj.height;
	  json.scissor = obj.scissor;
	  json.scissorTest = obj.scissorTest;
	  json.stencilBuffer = obj.stencilBuffer;
	  json.texture = !obj.texture ? null : new TexturesSerializer().toJSON(obj.texture);
	  json.viewport = obj.viewport;
	  json.width = obj.width;
	  json.isWebGLRenderTarget = obj.isWebGLRenderTarget;
	  return json;
	};

	WebGLRenderTargetSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.WebGLRenderTarget(json.width, json.height) : parent;
	  obj.depthBuffer = json.depthBuffer;
	  obj.depthTexture = !json.depthTexture ? null : new TexturesSerializer().fromJSON(json.depthTexture);
	  obj.height = json.height;
	  obj.scissor.copy(json.scissor);
	  obj.scissorTest = json.scissorTest;
	  obj.stencilBuffer = json.stencilBuffer;
	  obj.texture = !json.texture ? null : new TexturesSerializer().fromJSON(json.texture);
	  obj.viewport.copy(json.viewport);
	  obj.width = json.width;
	  obj.isWebGLRenderTarget = json.isWebGLRenderTarget;
	  return obj;
	};

	/**
	 * LightShadowSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LightShadowSerializer() {
	  BaseSerializer.call(this);
	}

	LightShadowSerializer.prototype = Object.create(BaseSerializer.prototype);
	LightShadowSerializer.prototype.constructor = LightShadowSerializer;

	LightShadowSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.bias = obj.bias;
	  json.camera = new CamerasSerializer().toJSON(obj.camera);
	  json.map = !obj.map ? null : new WebGLRenderTargetSerializer().toJSON(obj.map);
	  json.mapSize = obj.mapSize;
	  json.radius = obj.radius;
	  return json;
	};

	LightShadowSerializer.prototype.fromJSON = function (json, parent) {
	  var camera = new CamerasSerializer().fromJSON(json.camera);
	  var obj = parent === undefined ? new THREE.LightShadow(camera) : parent;
	  obj.bias = json.bias;
	  obj.camera.copy(camera);
	  obj.mapSize.copy(json.mapSize);
	  obj.radius = json.radius;
	  return obj;
	};

	/**
	 * DirectionalLightShadowSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function DirectionalLightShadowSerializer() {
	  BaseSerializer.call(this);
	}

	DirectionalLightShadowSerializer.prototype = Object.create(BaseSerializer.prototype);
	DirectionalLightShadowSerializer.prototype.constructor = DirectionalLightShadowSerializer;

	DirectionalLightShadowSerializer.prototype.toJSON = function (obj) {
	  var json = LightShadowSerializer.prototype.toJSON.call(this, obj);
	  json.isDirectionalLightShadow = obj.isDirectionalLightShadow;
	  return json;
	};

	DirectionalLightShadowSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.DirectionalLightShadow() : parent;
	  LightShadowSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * SpotLightShadowSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SpotLightShadowSerializer() {
	  BaseSerializer.call(this);
	}

	SpotLightShadowSerializer.prototype = Object.create(BaseSerializer.prototype);
	SpotLightShadowSerializer.prototype.constructor = SpotLightShadowSerializer;

	SpotLightShadowSerializer.prototype.toJSON = function (obj) {
	  var json = LightShadowSerializer.prototype.toJSON.call(this, obj);
	  json.isSpotLightShadow = obj.isSpotLightShadow;
	  return json;
	};

	SpotLightShadowSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.SpotLightShadow() : parent;
	  LightShadowSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var Serializers$4 = {
	  'LightShadow': LightShadowSerializer,
	  'DirectionalLightShadow': DirectionalLightShadowSerializer,
	  'SpotLightShadow': SpotLightShadowSerializer
	};
	/**
	 * LightShadowsSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LightShadowsSerializer() {
	  BaseSerializer.call(this);
	}

	LightShadowsSerializer.prototype = Object.create(BaseSerializer.prototype);
	LightShadowsSerializer.prototype.constructor = LightShadowsSerializer;

	LightShadowsSerializer.prototype.toJSON = function (obj) {
	  var serializer = Serializers$4[obj.constructor.name];

	  if (serializer === undefined) {
	    console.warn(`LightShadowsSerializer: No serializer with  ${obj.constructor.name}.`);
	    return null;
	  }

	  return new serializer().toJSON(obj);
	};

	LightShadowsSerializer.prototype.fromJSON = function (json) {
	  var generator = json.metadata.generator;
	  var serializer = Serializers$4[generator.replace('Serializer', '')];

	  if (serializer === undefined) {
	    console.warn(`LightShadowsSerializer: No deserializer with ${generator}.`);
	    return null;
	  }

	  return new serializer().fromJSON(json);
	};

	/**
	 * LightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LightSerializer() {
	  BaseSerializer.call(this);
	}

	LightSerializer.prototype = Object.create(BaseSerializer.prototype);
	LightSerializer.prototype.constructor = LightSerializer;

	LightSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.color = obj.color;
	  json.intensity = obj.intensity;
	  json.isLight = obj.isLight;
	  json.shadow = !obj.shadow ? null : new LightShadowsSerializer().toJSON(obj.shadow);
	  return json;
	};

	LightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Light() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.color = new THREE.Color(json.color);
	  obj.intensity = json.intensity;
	  obj.isLight = json.isLight;

	  if (json.shadow) {
	    obj.shadow = new LightShadowsSerializer().fromJSON(json.shadow);
	  }

	  return obj;
	};

	/**
	 * AmbientLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function AmbientLightSerializer() {
	  BaseSerializer.call(this);
	}

	AmbientLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	AmbientLightSerializer.prototype.constructor = AmbientLightSerializer;

	AmbientLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.isAmbientLight = obj.isAmbientLight;
	  return json;
	};

	AmbientLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.AmbientLight(json.color, json.intensity) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isAmbientLight = json.isAmbientLight;
	  return obj;
	};

	/**
	 * DirectionalLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function DirectionalLightSerializer() {
	  BaseSerializer.call(this);
	}

	DirectionalLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	DirectionalLightSerializer.prototype.constructor = DirectionalLightSerializer;

	DirectionalLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.isDirectionalLight = obj.isDirectionalLight;
	  return json;
	};

	DirectionalLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.DirectionalLight(json.color, json.intensity) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isDirectionalLight = json.isDirectionalLight;
	  return obj;
	};

	/**
	 * HemisphereLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function HemisphereLightSerializer() {
	  BaseSerializer.call(this);
	}

	HemisphereLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	HemisphereLightSerializer.prototype.constructor = HemisphereLightSerializer;

	HemisphereLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.isHemisphereLight = obj.isHemisphereLight;
	  json.skyColor = obj.skyColor;
	  json.groundColor = obj.groundColor;
	  return json;
	};

	HemisphereLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.HemisphereLight(json.skyColor, json.groundColor, json.intensity) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isHemisphereLight = json.isHemisphereLight;
	  return obj;
	};

	/**
	 * PointLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PointLightSerializer() {
	  BaseSerializer.call(this);
	}

	PointLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	PointLightSerializer.prototype.constructor = PointLightSerializer;

	PointLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.isPointLight = obj.isPointLight;
	  json.distance = obj.distance;
	  json.decay = obj.decay;
	  return json;
	};

	PointLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.PointLight(json.color, json.intensity, json.distance, json.decay) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isPointLight = json.isPointLight;
	  return obj;
	};

	/**
	 * SpotLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SpotLightSerializer() {
	  BaseSerializer.call(this);
	}

	SpotLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	SpotLightSerializer.prototype.constructor = SpotLightSerializer;

	SpotLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.isSpotLight = obj.isSpotLight;
	  json.distance = obj.distance;
	  json.angle = obj.angle;
	  json.penumbra = obj.penumbra;
	  json.decay = obj.decay;
	  return json;
	};

	SpotLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.SpotLight(json.color, json.intensity, json.distance, json.angle, json.penumbra, json.decay) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isSpotLight = json.isSpotLight;
	  obj.distance = json.distance;
	  obj.angle = json.angle;
	  obj.penumbra = json.penumbra;
	  obj.decay = json.decay;
	  return obj;
	};

	/**
	 * RectAreaLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function RectAreaLightSerializer() {
	  BaseSerializer.call(this);
	}

	RectAreaLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	RectAreaLightSerializer.prototype.constructor = RectAreaLightSerializer;

	RectAreaLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.width = obj.width;
	  json.height = obj.height;
	  return json;
	};

	RectAreaLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.RectAreaLight(json.color, json.intensity, json.width, json.height) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isRectAreaLight = true;
	  return obj;
	};

	/**
	 * AudioSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function AudioSerializer() {
	  BaseSerializer.call(this);
	}

	AudioSerializer.prototype = Object.create(BaseSerializer.prototype);
	AudioSerializer.prototype.constructor = AudioSerializer;

	AudioSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.autoplay = obj.autoplay;
	  json.loop = obj.getLoop();
	  json.volume = obj.getVolume();
	  return json;
	};

	AudioSerializer.prototype.fromJSON = function (json, parent, audioListener) {
	  if (audioListener === undefined) {
	    audioListener = new THREE.AudioListener();
	  }

	  var obj = parent === undefined ? new THREE.Audio(audioListener) : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.autoplay = json.autoplay;
	  obj.setLoop(json.loop);
	  obj.setVolume(json.volume);
	  return obj;
	};

	/**
	 * AudioListenerSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function AudioListenerSerializer() {
	  BaseSerializer.call(this);
	}

	AudioListenerSerializer.prototype = Object.create(BaseSerializer.prototype);
	AudioListenerSerializer.prototype.constructor = AudioListenerSerializer;

	AudioListenerSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.masterVolume = obj.getMasterVolume();
	  return json;
	};

	AudioListenerSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.AudioListener() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.setMasterVolume(json.masterVolume);
	  return obj;
	};

	/**
	 * ReflectorSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ReflectorSerializer() {
	  BaseSerializer.call(this);
	}

	ReflectorSerializer.prototype = Object.create(BaseSerializer.prototype);
	ReflectorSerializer.prototype.constructor = ReflectorSerializer;

	ReflectorSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);

	  if (json.userData.mesh) {
	    json.userData.mesh = new MeshSerializer().toJSON(json.userData.mesh);
	  }

	  return json;
	};

	ReflectorSerializer.prototype.fromJSON = function (json) {
	  var geometry = new GeometriesSerializer().fromJSON(json.geometry);
	  var obj = new THREE.Reflector(geometry, {
	    color: json.userData.color,
	    textureWidth: parseInt(json.userData.size),
	    textureHeight: parseInt(json.userData.size),
	    clipBias: json.userData.clipBias,
	    recursion: json.userData.recursion ? 1 : 0
	  });
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);

	  if (obj.userData.mesh) {
	    obj.userData.mesh = new MeshSerializer().fromJSON(obj.userData.mesh);
	  }

	  return obj;
	};

	/**
	 * 火焰
	 * @param {THREE.Camera} camera 相机
	 * @param {Object} options 参数
	 */
	function Fire(camera, options = {}) {
	  THREE.Object3D.call(this);
	  VolumetricFire.texturePath = 'assets/textures/VolumetricFire/';
	  var width = options.width || 2;
	  var height = options.height || 4;
	  var depth = options.depth || 2;
	  var sliceSpacing = options.sliceSpacing || 0.5;
	  var fire = new VolumetricFire(width, height, depth, sliceSpacing, camera);
	  this.add(fire.mesh);
	  fire.mesh.name = _t('Fire');
	  this.name = _t('Fire');
	  this.position.y = 2;
	  Object.assign(this.userData, {
	    type: 'Fire',
	    fire: fire,
	    width: width,
	    height: height,
	    depth: depth,
	    sliceSpacing: sliceSpacing
	  });
	}

	Fire.prototype = Object.create(THREE.Object3D.prototype);
	Fire.prototype.constructor = Fire;

	/**
	 * FireSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function FireSerializer() {
	  BaseSerializer.call(this);
	}

	FireSerializer.prototype = Object.create(BaseSerializer.prototype);
	FireSerializer.prototype.constructor = FireSerializer;

	FireSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  delete json.userData.fire;
	  return json;
	};

	FireSerializer.prototype.fromJSON = function (json, parent, camera) {
	  // eslint-disable-line
	  var fire = new Fire(camera, {
	    width: json.userData.width,
	    height: json.userData.height,
	    depth: json.userData.depth,
	    sliceSpacing: json.userData.sliceSpacing
	  });
	  Object3DSerializer.prototype.fromJSON.call(this, json, fire);
	  fire.userData.fire.update(0);
	  return fire;
	};

	var vertexShader = "attribute float shift;\r\nuniform float time;\r\nuniform float size;\r\nuniform float lifetime;\r\nuniform float projection;\r\nvarying float progress;\r\n\r\nfloat cubicOut( float t ) {\r\n\r\n  float f = t - 1.0;\r\n  return f * f * f + 1.0;\r\n\r\n}\r\n\r\nvoid main () {\r\n\r\n  progress = fract( time * 2. / lifetime + shift );\r\n  float eased = cubicOut( progress );\r\n  vec3 pos = vec3( position.x * eased, position.y * eased, position.z );\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1. );\r\n  gl_PointSize = ( projection * size ) / gl_Position.w;\r\n\r\n}";

	var fragmentShader = "uniform sampler2D texture;\r\nvarying float progress;\r\n\r\nvoid main() {\r\n\r\n  vec3 color = vec3( 1. );\r\n  gl_FragColor = texture2D( texture, gl_PointCoord ) * vec4( color, .3 * ( 1. - progress ) );\r\n\r\n}";

	/**
	 * 烟
	 * @author yomotsu / http://yomotsu.net
	 * ported from http://webgl-fire.appspot.com/html/fire.html
	 *
	 * https://www.youtube.com/watch?v=jKRHmQmduDI
	 * https://graphics.ethz.ch/teaching/former/imagesynthesis_06/miniprojects/p3/
	 * https://www.iusb.edu/math-compsci/_prior-thesis/YVanzine_thesis.pdf
	 * @param {THREE.Camera} camera 相机
	 * @param {THREE.WebGLRenderer} renderer 渲染器
	 * @param {Object} options 选项
	 */

	function Smoke(camera, renderer, options = {}) {
	  var particleCount = options.particleCount || 32;
	  var size = options.size || 3;
	  var lifetime = options.lifetime || 10; // 几何体

	  var geometry = new THREE.BufferGeometry();
	  var position = new Float32Array(particleCount * 3);
	  var shift = new Float32Array(particleCount);

	  for (var i = 0; i < particleCount; i++) {
	    position[i * 3 + 0] = THREE.Math.randFloat(-0.5, 0.5);
	    position[i * 3 + 1] = 2.4;
	    position[i * 3 + 3] = THREE.Math.randFloat(-0.5, 0.5);
	    shift[i] = Math.random() * 1;
	  }

	  geometry.setAttribute('position', new THREE.BufferAttribute(position, 3));
	  geometry.setAttribute('shift', new THREE.BufferAttribute(shift, 1)); // 材质

	  var texture = new THREE.TextureLoader().load('assets/textures/VolumetricFire/smoke.png');
	  var uniforms = {
	    time: {
	      type: 'f',
	      value: 0
	    },
	    size: {
	      type: 'f',
	      value: size
	    },
	    texture: {
	      type: 't',
	      value: texture
	    },
	    lifetime: {
	      type: 'f',
	      value: lifetime
	    },
	    projection: {
	      type: 'f',
	      value: Math.abs(renderer.domElement.height / (2 * Math.tan(THREE.Math.degToRad(camera.fov))))
	    }
	  };
	  var material = new THREE.ShaderMaterial({
	    vertexShader: vertexShader,
	    fragmentShader: fragmentShader,
	    uniforms: uniforms,
	    blending: THREE.AdditiveBlending,
	    transparent: true,
	    depthWrite: false
	  });
	  THREE.Points.call(this, geometry, material);
	  this.sortParticles = true;
	  this.name = _t('Smoke');
	  Object.assign(this.userData, {
	    type: 'Smoke',
	    particleCount: particleCount,
	    size: size,
	    lifetime: lifetime
	  });
	}

	Smoke.prototype = Object.create(THREE.Points.prototype);
	Smoke.prototype.constructor = Smoke;

	Smoke.prototype.update = function (elapsed) {
	  this.material.uniforms.time.value = elapsed;
	};

	/**
	 * SmokeSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SmokeSerializer() {
	  BaseSerializer.call(this);
	}

	SmokeSerializer.prototype = Object.create(BaseSerializer.prototype);
	SmokeSerializer.prototype.constructor = SmokeSerializer;

	SmokeSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	SmokeSerializer.prototype.fromJSON = function (json, parent, camera, renderer) {
	  var obj = parent || new Smoke(camera, renderer, json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.update(0);
	  return obj;
	};

	/**
	 * 天空
	 * @param {Obejct} options 选项
	 */
	function Sky(options = {}) {
	  THREE.Object3D.call(this);
	  var turbidity = options.turbidity || 10; // 浑浊度

	  var rayleigh = options.rayleigh || 2; // 瑞利

	  var luminance = options.luminance || 1; // 亮度

	  var mieCoefficient = options.mieCoefficient || 0.005;
	  var mieDirectionalG = options.mieDirectionalG || 0.8;
	  var distance = 400000;
	  var sky = new THREE.Sky();
	  sky.scale.setScalar(450000);
	  this.add(sky);
	  var sunSphere = new THREE.Mesh(new THREE.SphereBufferGeometry(20000, 16, 8), new THREE.MeshBasicMaterial({
	    color: 0xffffff
	  }));
	  sunSphere.position.y = -700000;
	  sunSphere.visible = false;
	  this.add(sunSphere);
	  var uniforms = sky.material.uniforms;
	  uniforms.turbidity.value = turbidity;
	  uniforms.rayleigh.value = rayleigh;
	  uniforms.luminance.value = luminance;
	  uniforms.mieCoefficient.value = mieCoefficient;
	  uniforms.mieDirectionalG.value = mieDirectionalG;
	  var theta = Math.PI * (0.49 - 0.5);
	  var phi = 2 * Math.PI * (0.25 - 0.5);
	  sunSphere.position.x = distance * Math.cos(phi);
	  sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
	  sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);
	  sunSphere.visible = true;
	  uniforms.sunPosition.value.copy(sunSphere.position);
	  this.userData = {
	    type: 'Sky',
	    turbidity: turbidity,
	    rayleigh: rayleigh,
	    luminance: luminance,
	    mieCoefficient: mieCoefficient,
	    mieDirectionalG: mieDirectionalG
	  };
	}

	Sky.prototype = Object.create(THREE.Object3D.prototype);
	Sky.prototype.constructor = Sky;

	/**
	 * SkySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SkySerializer() {
	  BaseSerializer.call(this);
	}

	SkySerializer.prototype = Object.create(BaseSerializer.prototype);
	SkySerializer.prototype.constructor = SkySerializer;

	SkySerializer.prototype.toJSON = function (obj) {
	  return Object3DSerializer.prototype.toJSON.call(this, obj);
	};

	SkySerializer.prototype.fromJSON = function (json, parent, camera) {
	  // eslint-disable-line
	  var obj = new Sky(json);
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * 粒子发射器
	 * @param {SPE.Group} group 粒子组
	 * @param {SPE.Emitter} emitter 粒子发射器
	 */
	function ParticleEmitter(group, emitter) {
	  THREE.Object3D.call(this);
	  group = group || new SPE.Group({
	    texture: {
	      value: new THREE.TextureLoader().load('assets/textures/SPE/smokeparticle.png')
	    },
	    maxParticleCount: 2000
	  });
	  emitter = emitter || new SPE.Emitter({
	    maxAge: {
	      value: 2
	    },
	    position: {
	      value: new THREE.Vector3(0, 0, 0),
	      spread: new THREE.Vector3(0, 0, 0)
	    },
	    acceleration: {
	      value: new THREE.Vector3(0, -10, 0),
	      spread: new THREE.Vector3(10, 0, 10)
	    },
	    velocity: {
	      value: new THREE.Vector3(0, 25, 0),
	      spread: new THREE.Vector3(10, 7.5, 10)
	    },
	    color: {
	      value: [new THREE.Color('white'), new THREE.Color('red')]
	    },
	    size: {
	      value: 1
	    },
	    particleCount: 2000
	  });
	  group.addEmitter(emitter);
	  group.mesh.name = _t('Particle');
	  this.add(group.mesh);
	  this.name = _t('ParticleEmitter');
	  Object.assign(this.userData, {
	    type: 'ParticleEmitter',
	    group: group,
	    emitter: emitter
	  });
	}

	ParticleEmitter.prototype = Object.create(THREE.Object3D.prototype);
	ParticleEmitter.prototype.constructor = ParticleEmitter;

	/**
	 * ParticleEmitterSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ParticleEmitterSerializer() {
	  BaseSerializer.call(this);
	}

	ParticleEmitterSerializer.prototype = Object.create(BaseSerializer.prototype);
	ParticleEmitterSerializer.prototype.constructor = ParticleEmitterSerializer;

	ParticleEmitterSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.children.length = 0;
	  var group = json.userData.group;
	  var emitter = json.userData.emitter;
	  json.userData.group = {
	    texture: new TexturesSerializer().toJSON(group.texture),
	    maxParticleCount: group.maxParticleCount
	  };
	  json.userData.emitter = {
	    position: {
	      value: {
	        x: emitter.position.value.x,
	        y: emitter.position.value.y,
	        z: emitter.position.value.z
	      },
	      spread: {
	        x: emitter.position.spread.x,
	        y: emitter.position.spread.y,
	        z: emitter.position.spread.z
	      }
	    },
	    velocity: {
	      value: {
	        x: emitter.velocity.value.x,
	        y: emitter.velocity.value.y,
	        z: emitter.velocity.value.z
	      },
	      spread: {
	        x: emitter.velocity.spread.x,
	        y: emitter.velocity.spread.y,
	        z: emitter.velocity.spread.z
	      }
	    },
	    acceleration: {
	      value: {
	        x: emitter.acceleration.value.x,
	        y: emitter.acceleration.value.y,
	        z: emitter.acceleration.value.z
	      },
	      spread: {
	        x: emitter.acceleration.spread.x,
	        y: emitter.acceleration.spread.y,
	        z: emitter.acceleration.spread.z
	      }
	    },
	    color: {
	      value: [emitter.color.value[0].getHex(), emitter.color.value[1].getHex(), emitter.color.value[2].getHex(), emitter.color.value[3].getHex()]
	    },
	    size: {
	      value: emitter.size.value,
	      spread: emitter.size.spread
	    },
	    particleCount: emitter.particleCount,
	    maxAge: {
	      value: emitter.maxAge.value,
	      spread: emitter.maxAge.spread
	    }
	  };
	  return json;
	};

	ParticleEmitterSerializer.prototype.fromJSON = function (json, parent, server) {
	  var groupJson = json.userData.group;
	  var emitterJson = json.userData.emitter;
	  var group = new SPE.Group({
	    texture: {
	      value: new TexturesSerializer().fromJSON(groupJson.texture, undefined, server)
	    },
	    maxParticleCount: groupJson.maxParticleCount
	  });
	  var emitter = new SPE.Emitter({
	    maxAge: {
	      value: emitterJson.maxAge.value
	    },
	    position: {
	      value: new THREE.Vector3().copy(emitterJson.position.value),
	      spread: new THREE.Vector3().copy(emitterJson.position.spread)
	    },
	    acceleration: {
	      value: new THREE.Vector3().copy(emitterJson.acceleration.value),
	      spread: new THREE.Vector3().copy(emitterJson.acceleration.spread)
	    },
	    velocity: {
	      value: new THREE.Vector3().copy(emitterJson.velocity.value),
	      spread: new THREE.Vector3().copy(emitterJson.velocity.spread)
	    },
	    color: {
	      value: [new THREE.Color(emitterJson.color.value[0]), new THREE.Color(emitterJson.color.value[1]), new THREE.Color(emitterJson.color.value[2]), new THREE.Color(emitterJson.color.value[3])]
	    },
	    size: {
	      value: emitterJson.size.value.slice(),
	      spread: emitterJson.size.spread.slice()
	    },
	    particleCount: emitterJson.particleCount
	  });
	  var obj = new ParticleEmitter(group, emitter);
	  delete json.userData.group;
	  delete json.userData.emitter;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.userData.group.tick(0);
	  return obj;
	};

	/**
	 * 柏林地形
	 * @param {Number} width 地形宽度
	 * @param {Number} depth 地形深度
	 * @param {Number} widthSegments 宽度分段
	 * @param {Number} depthSegments 深度分段
	 * @param {Number} quality 地形质量
	 */
	function PerlinTerrain(width = 1000, depth = 1000, widthSegments = 256, depthSegments = 256, quality = 80) {
	  // 创建地形几何体
	  var geometry = new THREE.PlaneBufferGeometry(width, depth, widthSegments - 1, depthSegments - 1);
	  geometry.rotateX(-Math.PI / 2);
	  var vertices = geometry.attributes.position.array;
	  var data = this.generateHeight(widthSegments, depthSegments, quality);

	  for (var i = 0, l = vertices.length; i < l; i++) {
	    vertices[i * 3 + 1] = data[i]; // 给顶点数组y分量赋值（地面高度）
	  }

	  geometry.computeFaceNormals(); // 创建光照贴图

	  var texture = new THREE.CanvasTexture(this.generateTexture(data, widthSegments, depthSegments));
	  texture.wrapS = THREE.ClampToEdgeWrapping;
	  texture.wrapT = THREE.ClampToEdgeWrapping; // 创建网格

	  THREE.Mesh.call(this, geometry, new THREE.MeshLambertMaterial({
	    map: texture
	  }));
	  this.name = _t('Terrain');
	  this.position.y = -50;
	  Object.assign(this.userData, {
	    type: 'PerlinTerrain',
	    width: width,
	    depth: depth,
	    widthSegments: widthSegments,
	    depthSegments: depthSegments,
	    quality: quality
	  });
	}

	PerlinTerrain.prototype = Object.create(THREE.Mesh.prototype);
	PerlinTerrain.prototype.constructor = PerlinTerrain;
	/**
	 * 生成高程数据
	 * @param {Number} width 宽度
	 * @param {Number} height 高度
	 * @param {Number} quality 质量
	 * @returns {Uint8Array} 高程数据
	 */

	PerlinTerrain.prototype.generateHeight = function (width, height, quality) {
	  var data = new Uint8Array(width * height);
	  var perlin = new THREE.ImprovedNoise();

	  for (var i = 0; i < width; i++) {
	    for (var j = 0; j < height; j++) {
	      data[i * height + j] = Math.abs(perlin.noise(i / quality, j / quality, 0) * quality);
	    }
	  }

	  return data;
	};
	/**
	 * 将光照烘培到贴图上
	 * @param {Uint8Array} data 高程数据
	 * @param {Number} width 宽度
	 * @param {Number} height 高度
	 * @returns {HTMLCanvasElement} 光照贴图
	 */


	PerlinTerrain.prototype.generateTexture = function (data, width, height) {
	  // 创建ImageData
	  var canvas = document.createElement('canvas');
	  canvas.width = width;
	  canvas.height = height;
	  var context = canvas.getContext('2d');
	  context.fillStyle = '#000';
	  context.fillRect(0, 0, width, height);
	  var image = context.getImageData(0, 0, canvas.width, canvas.height);
	  var imageData = image.data; // 计算光照强度

	  var sun = new THREE.Vector3(1, 1, 1);
	  sun.normalize();
	  var vector3 = new THREE.Vector3(0, 0, 0);
	  var shade;

	  for (var i = 0, j = 0, l = imageData.length; i < l; i += 4, j++) {
	    // i-像素RGBA分量索引，j-高程数据索引
	    vector3.x = data[j - 2] - data[j + 2];
	    vector3.y = 2;
	    vector3.z = data[j - width * 2] - data[j + width * 2];
	    vector3.normalize();
	    shade = vector3.dot(sun);
	    imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
	    imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
	    imageData[i + 2] = shade * 96 * (0.5 + data[j] * 0.007);
	  } // 将光照强度写入canvas


	  context.putImageData(image, 0, 0);
	  return canvas;
	};

	/**
	 * PerlinTerrainSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PerlinTerrainSerializer() {
	  BaseSerializer.call(this);
	}

	PerlinTerrainSerializer.prototype = Object.create(BaseSerializer.prototype);
	PerlinTerrainSerializer.prototype.constructor = PerlinTerrainSerializer;

	PerlinTerrainSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	PerlinTerrainSerializer.prototype.fromJSON = function (json, parent) {
	  // eslint-disable-line
	  var terrain = new PerlinTerrain(json.userData.width, json.userData.depth, json.userData.widthSegments, json.userData.depthSegments, json.userData.quality);
	  Object3DSerializer.prototype.fromJSON.call(this, json, terrain);
	  return terrain;
	};

	var HeightmapFragmentShader = "#include <common>\r\nuniform vec2 mousePos;\r\nuniform float mouseSize;\r\nuniform float viscosityConstant;\r\n#define deltaTime ( 1.0 / 60.0 )\r\n#define GRAVITY_CONSTANT ( resolution.x * deltaTime * 3.0 )\r\nvoid main()\t{\r\n\tvec2 cellSize = 1.0 / resolution.xy;\r\n\tvec2 uv = gl_FragCoord.xy * cellSize;\r\n\t// heightmapValue.x == height\r\n\t// heightmapValue.y == velocity\r\n\t// heightmapValue.z, heightmapValue.w not used\r\n\tvec4 heightmapValue = texture2D( heightmap, uv );\r\n\t// Get neighbours\r\n\tvec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );\r\n\tvec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );\r\n\tvec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );\r\n\tvec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );\r\n\tfloat sump = north.x + south.x + east.x + west.x - 4.0 * heightmapValue.x;\r\n\tfloat accel = sump * GRAVITY_CONSTANT;\r\n\t// Dynamics\r\n\theightmapValue.y += accel;\r\n\theightmapValue.x += heightmapValue.y * deltaTime;\r\n\t// Viscosity\r\n\theightmapValue.x += sump * viscosityConstant;\r\n\t// Mouse influence\r\n\tfloat mousePhase = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( mousePos.x, - mousePos.y ) ) * PI / mouseSize, 0.0, PI );\r\n\theightmapValue.x += cos( mousePhase ) + 1.0;\r\n\tgl_FragColor = heightmapValue;\r\n}";

	var WaterVertexShader = "uniform sampler2D heightmap;\r\n#define PHONG\r\nvarying vec3 vViewPosition;\r\n#ifndef FLAT_SHADED\r\n\tvarying vec3 vNormal;\r\n#endif\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\tvec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\t// # include <beginnormal_vertex>\r\n\t// Compute normal from heightmap\r\n\tvec3 objectNormal = vec3(\r\n\t\t( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,\r\n\t\t( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,\r\n\t\t1.0 );\r\n\t//<beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n#ifndef FLAT_SHADED \r\n\tvNormal = normalize( transformedNormal );\r\n#endif\r\n\t//# include <begin_vertex>\r\n\tfloat heightValue = texture2D( heightmap, uv ).x;\r\n\tvec3 transformed = vec3( position.x, position.y, heightValue );\r\n\t//<begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\tvViewPosition = - mvPosition.xyz;\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <shadowmap_vertex>\r\n}";

	/**
	 * 水
	 * @param {THREE.WebGLRenderer} renderer 渲染器
	 */

	function Water(renderer) {
	  var BOUNDS = 512;
	  var WIDTH = 128;
	  var materialColor = 0x0040C0; // 创建几何体

	  var geometry = new THREE.PlaneBufferGeometry(BOUNDS, BOUNDS, WIDTH - 1, WIDTH - 1); // 创建材质

	  var material = new THREE.ShaderMaterial({
	    uniforms: THREE.UniformsUtils.merge([THREE.ShaderLib['phong'].uniforms, {
	      heightmap: {
	        value: null
	      }
	    }]),
	    vertexShader: WaterVertexShader,
	    fragmentShader: THREE.ShaderChunk['meshphong_frag']
	  });
	  material.lights = true; // 来自MeshPhongMaterial的属性

	  material.color = new THREE.Color(materialColor);
	  material.specular = new THREE.Color(0x111111);
	  material.shininess = 50; // 根据材质的值设置uniforms

	  material.uniforms.diffuse.value = material.color;
	  material.uniforms.specular.value = material.specular;
	  material.uniforms.shininess.value = Math.max(material.shininess, 1e-4);
	  material.uniforms.opacity.value = material.opacity; // 设置Defines

	  material.defines.WIDTH = WIDTH.toFixed(1);
	  material.defines.BOUNDS = BOUNDS.toFixed(1);
	  var waterUniforms = material.uniforms; // 创建网格

	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Water');
	  this.rotation.x = -Math.PI / 2;
	  this.matrixAutoUpdate = false;
	  this.updateMatrix();
	  var gpuCompute = new THREE.GPUComputationRenderer(WIDTH, WIDTH, renderer);
	  var heightmap0 = gpuCompute.createTexture();
	  this.fillTexture(heightmap0, WIDTH);
	  var heightmapVariable = gpuCompute.addVariable('heightmap', HeightmapFragmentShader, heightmap0);
	  gpuCompute.setVariableDependencies(heightmapVariable, [heightmapVariable]);
	  heightmapVariable.material.uniforms.mousePos = {
	    value: new THREE.Vector2(10000, 10000)
	  };
	  heightmapVariable.material.uniforms.mouseSize = {
	    value: 20.0
	  };
	  heightmapVariable.material.uniforms.viscosityConstant = {
	    value: 0
	  };
	  heightmapVariable.material.defines.BOUNDS = BOUNDS.toFixed(1);
	  var error = gpuCompute.init();

	  if (error !== null) {
	    console.error(error);
	  } // var smoothShader = gpuCompute.createShaderMaterial(SmoothFragmentShader, {
	  //     texture: {
	  //         value: null
	  //     }
	  // });


	  this.heightmapVariable = heightmapVariable;
	  this.gpuCompute = gpuCompute;
	  this.waterUniforms = waterUniforms;
	  Object.assign(this.userData, {
	    type: 'Water'
	  });
	}

	Water.prototype = Object.create(THREE.Mesh.prototype);
	Water.prototype.constructor = Water;

	Water.prototype.fillTexture = function (texture, WIDTH) {
	  var simplex = new THREE.SimplexNoise();
	  var waterMaxHeight = 30;

	  function noise(x, y) {
	    var multR = waterMaxHeight;
	    var mult = 0.025;
	    var r = 0;

	    for (var i = 0; i < 15; i++) {
	      r += multR * simplex.noise(x * mult, y * mult);
	      multR *= 0.53 + 0.025 * i;
	      mult *= 1.25;
	    }

	    return r;
	  }

	  var pixels = texture.image.data;
	  var p = 0;

	  for (var j = 0; j < WIDTH; j++) {
	    for (var i = 0; i < WIDTH; i++) {
	      var x = i * 128 / WIDTH;
	      var y = j * 128 / WIDTH;
	      pixels[p + 0] = noise(x, y);
	      pixels[p + 1] = 0;
	      pixels[p + 2] = 0;
	      pixels[p + 3] = 1;
	      p += 4;
	    }
	  }
	};

	Water.prototype.update = function () {
	  var heightmapVariable = this.heightmapVariable;
	  var gpuCompute = this.gpuCompute;
	  var waterUniforms = this.waterUniforms;
	  var uniforms = heightmapVariable.material.uniforms;
	  uniforms.mousePos.value.set(10000, 10000);
	  gpuCompute.compute();
	  waterUniforms.heightmap.value = gpuCompute.getCurrentRenderTarget(heightmapVariable).texture;
	};

	/**
	 * WaterSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function WaterSerializer() {
	  BaseSerializer.call(this);
	}

	WaterSerializer.prototype = Object.create(BaseSerializer.prototype);
	WaterSerializer.prototype.constructor = WaterSerializer;

	WaterSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	WaterSerializer.prototype.fromJSON = function (json, parent, renderer) {
	  var obj = new Water(renderer);
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.update();
	  return obj;
	};

	/*
	 * Cloth Simulation using a relaxed constraints solver
	 */
	// Suggested Readings
	// Advanced Character Physics by Thomas Jakobsen Character
	// http://freespace.virgin.net/hugo.elias/models/m_cloth.htm
	// http://en.wikipedia.org/wiki/Cloth_modeling
	// http://cg.alexandra.dk/tag/spring-mass-system/
	// Real-time Cloth Animation http://www.darwin3d.com/gamedev/articles/col0599.pdf
	var DAMPING = 0.03;
	var DRAG = 1 - DAMPING;
	var MASS = 0.1;
	var restDistance = 25;
	var xSegs = 10;
	var ySegs = 10;

	function plane(width, height) {
	  return function (u, v, optionalTarget) {
	    var result = optionalTarget || new THREE.Vector3();
	    var x = (u - 0.5) * width;
	    var y = (v + 0.5) * height;
	    var z = 0;
	    return result.set(x, y, z);
	  };
	}

	var clothFunction = plane(restDistance * xSegs, restDistance * ySegs);
	var GRAVITY = 981 * 1.4;
	var gravity = new THREE.Vector3(0, -GRAVITY, 0).multiplyScalar(MASS);
	var TIMESTEP = 18 / 1000;
	var TIMESTEP_SQ = TIMESTEP * TIMESTEP;

	var windForce = new THREE.Vector3(0, 0, 0);
	var tmpForce = new THREE.Vector3();
	var lastTime;

	function Particle(x, y, z, mass) {
	  this.position = clothFunction(x, y); // position

	  this.previous = clothFunction(x, y); // previous

	  this.original = clothFunction(x, y);
	  this.a = new THREE.Vector3(0, 0, 0); // acceleration

	  this.mass = mass;
	  this.invMass = 1 / mass;
	  this.tmp = new THREE.Vector3();
	  this.tmp2 = new THREE.Vector3();
	} // Force -> Acceleration


	Particle.prototype.addForce = function (force) {
	  this.a.add(this.tmp2.copy(force).multiplyScalar(this.invMass));
	}; // Performs Verlet integration


	Particle.prototype.integrate = function (timesq) {
	  var newPos = this.tmp.subVectors(this.position, this.previous);
	  newPos.multiplyScalar(DRAG).add(this.position);
	  newPos.add(this.a.multiplyScalar(timesq));
	  this.tmp = this.previous;
	  this.previous = this.position;
	  this.position = newPos;
	  this.a.set(0, 0, 0);
	};

	var diff = new THREE.Vector3();

	function satisfyConstraints(p1, p2, distance) {
	  diff.subVectors(p2.position, p1.position);
	  var currentDist = diff.length();
	  if (currentDist === 0) return; // prevents division by 0

	  var correction = diff.multiplyScalar(1 - distance / currentDist);
	  var correctionHalf = correction.multiplyScalar(0.5);
	  p1.position.add(correctionHalf);
	  p2.position.sub(correctionHalf);
	}
	/**
	 * 布料
	 */


	function Cloth() {
	  var pins = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	  var w = xSegs;
	  var h = ySegs;
	  this.w = w;
	  this.h = h;
	  var particles = [];
	  var constraints = [];
	  var u, v; // Create particles

	  for (v = 0; v <= h; v++) {
	    for (u = 0; u <= w; u++) {
	      particles.push(new Particle(u / w, v / h, 0, MASS));
	    }
	  } // Structural


	  for (v = 0; v < h; v++) {
	    for (u = 0; u < w; u++) {
	      constraints.push([particles[index(u, v)], particles[index(u, v + 1)], restDistance]);
	      constraints.push([particles[index(u, v)], particles[index(u + 1, v)], restDistance]);
	    }
	  }

	  for (u = w, v = 0; v < h; v++) {
	    constraints.push([particles[index(u, v)], particles[index(u, v + 1)], restDistance]);
	  }

	  for (v = h, u = 0; u < w; u++) {
	    constraints.push([particles[index(u, v)], particles[index(u + 1, v)], restDistance]);
	  }

	  this.particles = particles;
	  this.constraints = constraints;

	  function index(u, v) {
	    return u + v * (w + 1);
	  }

	  this.index = index; // 材质

	  var loader = new THREE.TextureLoader();
	  var clothTexture = loader.load('assets/textures/patterns/circuit_pattern.png');
	  clothTexture.anisotropy = 16;
	  var clothGeometry = new THREE.ParametricGeometry(clothFunction, w, h);
	  var clothMaterial = new THREE.MeshLambertMaterial({
	    map: clothTexture,
	    side: THREE.DoubleSide,
	    alphaTest: 0.5
	  });
	  THREE.Mesh.call(this, clothGeometry, clothMaterial);
	  this.scale.multiplyScalar(0.02);
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'Cloth'
	  });
	  this.pins = pins;
	  this.clothGeometry = clothGeometry;
	}

	Cloth.prototype = Object.create(THREE.Mesh.prototype);
	Cloth.prototype.constructor = Cloth;

	Cloth.prototype.update = function () {
	  var time = Date.now();
	  var windStrength = Math.cos(time / 7000) * 20 + 40;
	  windForce.set(Math.sin(time / 2000), Math.cos(time / 3000), Math.sin(time / 1000));
	  windForce.normalize();
	  windForce.multiplyScalar(windStrength);
	  this.simulate(time, this.clothGeometry, this.pins);
	  var p = this.particles;
	  var clothGeometry = this.clothGeometry;

	  for (var i = 0, il = p.length; i < il; i++) {
	    clothGeometry.vertices[i].copy(p[i].position);
	  }

	  clothGeometry.verticesNeedUpdate = true;
	  clothGeometry.computeFaceNormals();
	  clothGeometry.computeVertexNormals();
	};

	Cloth.prototype.simulate = function (time) {
	  if (!lastTime) {
	    lastTime = time;
	    return;
	  }

	  var i, il, particles, particle, constraints, constraint; // Aerodynamics forces

	  {
	    var face,
	        faces = this.clothGeometry.faces,
	        normal;
	    particles = this.particles;

	    for (i = 0, il = faces.length; i < il; i++) {
	      face = faces[i];
	      normal = face.normal;
	      tmpForce.copy(normal).normalize().multiplyScalar(normal.dot(windForce));
	      particles[face.a].addForce(tmpForce);
	      particles[face.b].addForce(tmpForce);
	      particles[face.c].addForce(tmpForce);
	    }
	  }

	  for (particles = this.particles, i = 0, il = particles.length; i < il; i++) {
	    particle = particles[i];
	    particle.addForce(gravity);
	    particle.integrate(TIMESTEP_SQ);
	  } // Start Constraints


	  constraints = this.constraints;
	  il = constraints.length;

	  for (i = 0; i < il; i++) {
	    constraint = constraints[i];
	    satisfyConstraints(constraint[0], constraint[1], constraint[2]);
	  } // Floor Constraints


	  for (particles = this.particles, i = 0, il = particles.length; i < il; i++) {
	    particle = particles[i];
	    var pos = particle.position;

	    if (pos.y < -250) {
	      pos.y = -250;
	    }
	  } // Pin Constraints


	  var pins = this.pins;

	  for (i = 0, il = pins.length; i < il; i++) {
	    var xy = pins[i];
	    var p = particles[xy];
	    p.position.copy(p.original);
	    p.previous.copy(p.original);
	  }
	};

	/**
	 * ClothSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ClothSerializer() {
	  BaseSerializer.call(this);
	}

	ClothSerializer.prototype = Object.create(BaseSerializer.prototype);
	ClothSerializer.prototype.constructor = ClothSerializer;

	ClothSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	ClothSerializer.prototype.fromJSON = function (json, parent, camera) {
	  // eslint-disable-line
	  var cloth = new Cloth();
	  Object3DSerializer.prototype.fromJSON.call(this, json, cloth);
	  return cloth;
	};

	var UnscaledTextVertexShader = "precision highp float;\r\n\r\nuniform float width;\r\nuniform float height;\r\nuniform float domWidth;\r\nuniform float domHeight;\r\n\r\nvarying vec2 vUv;\r\n \r\nvoid main() {\r\n    vUv = uv;\r\n    vec4 proj = projectionMatrix * modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\r\n    gl_Position = vec4(\r\n        proj.x / proj.w  + position.x * width / domWidth * 2.0,\r\n        proj.y / proj.w + position.y * height / domHeight * 2.0,\r\n        proj.z / proj.w,\r\n        1.0\r\n    );\r\n}";

	var UnscaledTextFragmentShader = "precision highp float;\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform float width;\r\nuniform float height;\r\n \r\nvarying vec2 vUv;\r\n \r\nvoid main() {\r\n    // 注意vUv一定要从画布整数坐标取颜色，否则会导致文字模糊问题。\r\n    vec2 _uv = vec2(\r\n        (floor(vUv.s * width) + 0.5) / width,\r\n        (floor(vUv.t * height) + 0.5) / height\r\n    );\r\n\r\n    gl_FragColor = texture2D( tDiffuse, _uv );\r\n\r\n    if (gl_FragColor.a == 0.0) {\r\n        discard;\r\n    }\r\n\r\n    if (_uv.s < 0.0 || _uv.s > 1.0 || _uv.t < 0.0 || _uv.t > 1.0) {\r\n        discard;\r\n    }\r\n}";

	/**
	 * 画布工具类
	 */
	const CanvasUtils = {
	  /**
	   * 扩大到2的整数倍
	   * @param {Number} num 数字
	   * @returns {Number} 数字
	   */
	  makePowerOfTwo: function (num) {
	    let result = 1;

	    while (result < num) {
	      result *= 2;
	    }

	    return result;
	  }
	};

	let ID$3 = -1;
	/**
	 * 不缩放文字
	 */

	class UnscaledText extends THREE.Mesh {
	  constructor(text = '', options) {
	    const canvas = document.createElement('canvas');
	    const domWidth = options.domWidth || 1422;
	    const domHeight = options.domHeight || 715;
	    let geometry = new THREE.PlaneBufferGeometry();
	    let material = new THREE.ShaderMaterial({
	      vertexShader: UnscaledTextVertexShader,
	      fragmentShader: UnscaledTextFragmentShader,
	      uniforms: {
	        tDiffuse: {
	          value: new THREE.CanvasTexture(canvas)
	        },
	        width: {
	          value: 1.0 // canvas width

	        },
	        height: {
	          value: 1.0 // canvas height

	        },
	        domWidth: {
	          value: domWidth // dom width

	        },
	        domHeight: {
	          value: domHeight // dom height

	        }
	      },
	      transparent: true
	    });
	    super(geometry, material);
	    this.userData.type = 'text';
	    this.setText(text);
	    app.on(`resize.${this.constructor.name}${ID$3--}`, this.onResize.bind(this));
	  }

	  setText(text) {
	    let fontSize = 16;
	    let padding = 4;
	    this.name = text;
	    this.userData.text = text; // 设置样式并计算文字宽度和高度

	    let map = this.material.uniforms.tDiffuse.value;
	    let canvas = map.image;
	    let context = canvas.getContext('2d');
	    context.font = `${fontSize}px "Microsoft YaHei"`;
	    const width = context.measureText(text).width;
	    const width2 = CanvasUtils.makePowerOfTwo(width + padding * 2);
	    const height2 = CanvasUtils.makePowerOfTwo(fontSize + padding * 2);
	    canvas.width = width2;
	    canvas.height = height2;
	    this.material.uniforms.width.value = width2;
	    this.material.uniforms.height.value = height2; // 设置样式并绘制文字

	    context = canvas.getContext('2d');
	    context.imageSmoothingQuality = 'high';
	    context.textBaseline = 'middle';
	    context.textAlign = 'center';
	    context.lineWidth = 2;
	    let halfWidth = width2 / 2;
	    let halfHeight = height2 / 2; // 画描边

	    context.font = `${fontSize}px "Microsoft YaHei"`;
	    context.strokeStyle = '#000';
	    context.strokeText(text, halfWidth, halfHeight); // 画文字

	    context.fillStyle = '#fff';
	    context.fillText(text, halfWidth, halfHeight); // 更新贴图

	    map.needsUpdate = true;
	  }

	  onResize() {
	    // TODO: 播放器中大小
	    const {
	      width,
	      height
	    } = app.editor.renderer.domElement;
	    this.material.uniforms.domWidth.value = width;
	    this.material.uniforms.domHeight.value = height;
	  }

	}

	/**
	 * UnscaledTextSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function UnscaledTextSerializer() {
	  BaseSerializer.call(this);
	}

	UnscaledTextSerializer.prototype = Object.create(BaseSerializer.prototype);
	UnscaledTextSerializer.prototype.constructor = UnscaledTextSerializer;

	UnscaledTextSerializer.prototype.toJSON = function (obj) {
	  return Object3DSerializer.prototype.toJSON.call(this, obj);
	};

	UnscaledTextSerializer.prototype.fromJSON = function (json, parent, options) {
	  var obj = new UnscaledText(json.userData.text, {
	    domWidth: options.domWidth,
	    domHeight: options.domHeight
	  });
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * 3D文字
	 */
	class ThreeDText extends THREE.Mesh {
	  constructor(text = '', options) {
	    const parameters = Object.assign({
	      // 默认参数
	      size: 16,
	      height: 4,
	      bevelEnabled: true,
	      bevelSize: 0.5,
	      bevelThickness: 0.5,
	      depth: 4
	    }, options, {
	      font: new THREE.Font(JSON.parse(options.font))
	    });
	    const geometry = new THREE.TextBufferGeometry(text, parameters);
	    const material = new THREE.MeshPhongMaterial({
	      color: options.color || '#ffffff'
	    });
	    super(geometry, material);
	    this.name = text;
	    this.userData = {
	      type: '3dtext',
	      text: text,
	      ...options
	    };
	  }

	}

	/**
	 * ThreeDTextSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ThreeDTextSerializer() {
	  BaseSerializer.call(this);
	}

	ThreeDTextSerializer.prototype = Object.create(BaseSerializer.prototype);
	ThreeDTextSerializer.prototype.constructor = ThreeDTextSerializer;

	ThreeDTextSerializer.prototype.toJSON = function (obj) {
	  return Object3DSerializer.prototype.toJSON.call(this, obj);
	};

	ThreeDTextSerializer.prototype.fromJSON = function (json, parent) {
	  // eslint-disable-line
	  var obj = new ThreeDText(json.userData.text, json.userData);
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var PointMarkerVertexShader = "precision highp float;\r\n\r\nuniform float width;\r\nuniform float height;\r\nuniform float domWidth;\r\nuniform float domHeight;\r\n\r\nvarying vec2 vUv;\r\n \r\nvoid main() {\r\n    vUv = uv;\r\n    vec4 proj = projectionMatrix * modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\r\n    gl_Position = vec4(\r\n        proj.x / proj.w  + position.x * width / domWidth * 2.0,\r\n        proj.y / proj.w + position.y * height / domHeight * 2.0,\r\n        proj.z / proj.w,\r\n        1.0\r\n    );\r\n}";

	var PointMarkerFragmentShader = "precision highp float;\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform float width;\r\nuniform float height;\r\n \r\nvarying vec2 vUv;\r\n \r\nvoid main() {\r\n    // 注意vUv一定要从画布整数坐标+0.5处取颜色，否则会导致文字模糊问题。\r\n    vec2 _uv = vec2(\r\n        (floor(vUv.s * width) + 0.5) / width,\r\n        (floor(vUv.t * height) + 0.5) / height\r\n    );\r\n\r\n    gl_FragColor = texture2D( tDiffuse, _uv );\r\n\r\n    if (gl_FragColor.a == 0.0) {\r\n        discard;\r\n    }\r\n\r\n    if (_uv.s < 0.0 || _uv.s > 1.0 || _uv.t < 0.0 || _uv.t > 1.0) {\r\n        discard;\r\n    }\r\n}";

	let ID$4 = -1;
	/**
	 * 点标注
	 */

	class PointMarker extends THREE.Mesh {
	  constructor(text = '', options = {}) {
	    const canvas = document.createElement('canvas');
	    const domWidth = options.domWidth || 1422;
	    const domHeight = options.domHeight || 715;
	    let geometry = new THREE.PlaneBufferGeometry();
	    let material = new THREE.ShaderMaterial({
	      vertexShader: PointMarkerVertexShader,
	      fragmentShader: PointMarkerFragmentShader,
	      uniforms: {
	        tDiffuse: {
	          value: new THREE.CanvasTexture(canvas)
	        },
	        width: {
	          value: 1.0 // canvas width

	        },
	        height: {
	          value: 1.0 // canvas height

	        },
	        domWidth: {
	          value: domWidth // dom width

	        },
	        domHeight: {
	          value: domHeight // dom height

	        }
	      },
	      transparent: true
	    });
	    super(geometry, material);
	    this.userData.type = 'pointMarker';
	    this.setText(text);
	    app.on(`resize.${this.constructor.name}${ID$4--}`, this.onResize.bind(this));
	  }

	  setText(text) {
	    let fontSize = 16;
	    let padding = 4;
	    let triangleWidth = 24;
	    let triangleHeight = 12;
	    this.name = text;
	    this.userData.text = text; // 设置样式并计算文字宽度和高度

	    let map = this.material.uniforms.tDiffuse.value;
	    let canvas = map.image;
	    let context = canvas.getContext('2d');
	    context.font = `${fontSize}px "Microsoft YaHei"`;
	    const width = context.measureText(text).width;
	    const width2 = CanvasUtils.makePowerOfTwo(Math.max(width, triangleWidth) + padding * 2);
	    const height2 = CanvasUtils.makePowerOfTwo(fontSize + triangleHeight + padding * 3);
	    canvas.width = width2;
	    canvas.height = height2;
	    this.material.uniforms.width.value = width2;
	    this.material.uniforms.height.value = height2; // 设置样式并绘制文字

	    context = canvas.getContext('2d');
	    context.imageSmoothingQuality = 'high';
	    context.textBaseline = 'hanging';
	    context.textAlign = 'center';
	    context.lineWidth = 2;
	    let halfWidth = width2 / 2; // 画描边

	    context.font = `${fontSize}px "Microsoft YaHei"`;
	    context.strokeStyle = '#000';
	    context.strokeText(text, halfWidth, padding); // 画文字

	    context.fillStyle = '#fff';
	    context.fillText(text, halfWidth, padding); // 画三角形

	    context.beginPath();
	    context.moveTo(halfWidth - triangleWidth / 2, fontSize + padding * 2);
	    context.lineTo(halfWidth + triangleWidth / 2, fontSize + padding * 2);
	    context.lineTo(halfWidth, fontSize + padding * 2 + triangleHeight);
	    context.closePath();
	    context.fillStyle = '#ff0';
	    context.fill(); // 更新贴图

	    map.needsUpdate = true;
	  }

	  onResize() {
	    // TODO: 在Player中的情况。
	    const {
	      width,
	      height
	    } = app.editor.renderer.domElement;
	    this.material.uniforms.domWidth.value = width;
	    this.material.uniforms.domHeight.value = height;
	  }

	}

	/**
	 * PointMarkerSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PointMarkerSerializer() {
	  BaseSerializer.call(this);
	}

	PointMarkerSerializer.prototype = Object.create(BaseSerializer.prototype);
	PointMarkerSerializer.prototype.constructor = PointMarkerSerializer;

	PointMarkerSerializer.prototype.toJSON = function (obj) {
	  return Object3DSerializer.prototype.toJSON.call(this, obj);
	};

	PointMarkerSerializer.prototype.fromJSON = function (json, parent, options) {
	  var obj = new PointMarker(json.userData.text, {
	    domWidth: options.domWidth,
	    domHeight: options.domHeight
	  });
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var ARC_SEGMENTS = 200;
	/**
	 * 线段
	 * @param {Object} options 参数
	 */

	function LineCurve(options = {}) {
	  var geometry = new THREE.BufferGeometry();
	  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(ARC_SEGMENTS * 3), 3));
	  var material = new THREE.LineBasicMaterial({
	    color: 0xff0000,
	    opacity: 0.35
	  });
	  THREE.Line.call(this, geometry, material);
	  this.name = _t('Line Curve');
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'LineCurve',
	    points: options.points || [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 10, 10)]
	  });
	  this.update();
	}

	LineCurve.prototype = Object.create(THREE.Line.prototype);
	LineCurve.prototype.constructor = LineCurve;

	LineCurve.prototype.update = function () {
	  var curve = new THREE.LineCurve3(this.userData.points[0], this.userData.points[1]);
	  var position = this.geometry.attributes.position;
	  var point = new THREE.Vector3();

	  for (var i = 0; i < ARC_SEGMENTS; i++) {
	    var t = i / (ARC_SEGMENTS - 1);
	    curve.getPoint(t, point);
	    position.setXYZ(i, point.x, point.y, point.z);
	  }

	  position.needsUpdate = true;
	};

	/**
	 * LineCurveSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LineCurveSerializer() {
	  BaseSerializer.call(this);
	}

	LineCurveSerializer.prototype = Object.create(BaseSerializer.prototype);
	LineCurveSerializer.prototype.constructor = LineCurveSerializer;

	LineCurveSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	LineCurveSerializer.prototype.fromJSON = function (json, parent) {
	  json.userData.points = json.userData.points.map(n => {
	    return new THREE.Vector3().copy(n);
	  });
	  var obj = parent || new LineCurve(json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var ARC_SEGMENTS$1 = 200;
	/**
	 * CatmullRom曲线
	 * @param {Object} options 参数
	 */

	function CatmullRomCurve(options = {}) {
	  var geometry = new THREE.BufferGeometry();
	  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(ARC_SEGMENTS$1 * 3), 3));
	  var material = new THREE.LineBasicMaterial({
	    color: 0xff0000,
	    opacity: 0.35
	  });
	  THREE.Line.call(this, geometry, material);
	  this.name = _t('CatmullRom Curve');
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'CatmullRomCurve',
	    points: options.points || [new THREE.Vector3(4, 8, 16), new THREE.Vector3(0, 12, -4), new THREE.Vector3(-16, 4, -8)],
	    closed: options.closed || false,
	    curveType: options.curveType || 'catmullrom',
	    // centripetal, chordal and catmullrom
	    tension: options.tension || 0.5
	  });
	  this.update();
	}

	CatmullRomCurve.prototype = Object.create(THREE.Line.prototype);
	CatmullRomCurve.prototype.constructor = CatmullRomCurve;

	CatmullRomCurve.prototype.update = function () {
	  var curve = new THREE.CatmullRomCurve3(this.userData.points, this.userData.closed, this.userData.curveType, this.userData.tension);
	  var position = this.geometry.attributes.position;
	  var point = new THREE.Vector3();

	  for (var i = 0; i < ARC_SEGMENTS$1; i++) {
	    var t = i / (ARC_SEGMENTS$1 - 1);
	    curve.getPoint(t, point);
	    position.setXYZ(i, point.x, point.y, point.z);
	  }

	  position.needsUpdate = true;
	};

	/**
	 * CatmullRomCurveSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CatmullRomCurveSerializer() {
	  BaseSerializer.call(this);
	}

	CatmullRomCurveSerializer.prototype = Object.create(BaseSerializer.prototype);
	CatmullRomCurveSerializer.prototype.constructor = CatmullRomCurveSerializer;

	CatmullRomCurveSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	CatmullRomCurveSerializer.prototype.fromJSON = function (json, parent) {
	  json.userData.points = json.userData.points.map(n => {
	    return new THREE.Vector3().copy(n);
	  });
	  var obj = parent || new CatmullRomCurve(json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var ARC_SEGMENTS$2 = 200;
	/**
	 * 二次贝塞尔曲线
	 * @param {Object} options 参数
	 */

	function QuadraticBezierCurve(options = {}) {
	  var geometry = new THREE.BufferGeometry();
	  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(ARC_SEGMENTS$2 * 3), 3));
	  var material = new THREE.LineBasicMaterial({
	    color: 0xff0000,
	    opacity: 0.35
	  });
	  THREE.Line.call(this, geometry, material);
	  this.name = _t('Quadratic Bezier Curve');
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'QuadraticBezierCurve',
	    points: options.points || [new THREE.Vector3(-10, 0, 0), new THREE.Vector3(20, 15, 0), new THREE.Vector3(10, 0, 0)]
	  });
	  this.update();
	}

	QuadraticBezierCurve.prototype = Object.create(THREE.Line.prototype);
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

	QuadraticBezierCurve.prototype.update = function () {
	  var curve = new THREE.QuadraticBezierCurve3(this.userData.points[0], this.userData.points[1], this.userData.points[2]);
	  var position = this.geometry.attributes.position;
	  var point = new THREE.Vector3();

	  for (var i = 0; i < ARC_SEGMENTS$2; i++) {
	    var t = i / (ARC_SEGMENTS$2 - 1);
	    curve.getPoint(t, point);
	    position.setXYZ(i, point.x, point.y, point.z);
	  }

	  position.needsUpdate = true;
	};

	/**
	 * QuadraticBezierCurveSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function QuadraticBezierCurveSerializer() {
	  BaseSerializer.call(this);
	}

	QuadraticBezierCurveSerializer.prototype = Object.create(BaseSerializer.prototype);
	QuadraticBezierCurveSerializer.prototype.constructor = QuadraticBezierCurveSerializer;

	QuadraticBezierCurveSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	QuadraticBezierCurveSerializer.prototype.fromJSON = function (json, parent) {
	  json.userData.points = json.userData.points.map(n => {
	    return new THREE.Vector3().copy(n);
	  });
	  var obj = parent || new QuadraticBezierCurve(json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var ARC_SEGMENTS$3 = 200;
	/**
	 * 三次贝塞尔曲线
	 * @param {Object} options 参数
	 */

	function CubicBezierCurve(options = {}) {
	  var geometry = new THREE.BufferGeometry();
	  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(ARC_SEGMENTS$3 * 3), 3));
	  var material = new THREE.LineBasicMaterial({
	    color: 0xff0000,
	    opacity: 0.35
	  });
	  THREE.Line.call(this, geometry, material);
	  this.name = _t('CubicBezier Curve');
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'CubicBezierCurve',
	    points: options.points || [new THREE.Vector3(-10, 0, 0), new THREE.Vector3(-5, 15, 0), new THREE.Vector3(20, 15, 0), new THREE.Vector3(10, 0, 0)]
	  });
	  this.update();
	}

	CubicBezierCurve.prototype = Object.create(THREE.Line.prototype);
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;

	CubicBezierCurve.prototype.update = function () {
	  var curve = new THREE.CubicBezierCurve3(this.userData.points[0], this.userData.points[1], this.userData.points[2], this.userData.points[3]);
	  var position = this.geometry.attributes.position;
	  var point = new THREE.Vector3();

	  for (var i = 0; i < ARC_SEGMENTS$3; i++) {
	    var t = i / (ARC_SEGMENTS$3 - 1);
	    curve.getPoint(t, point);
	    position.setXYZ(i, point.x, point.y, point.z);
	  }

	  position.needsUpdate = true;
	};

	/**
	 * CubicBezierCurveSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CubicBezierCurveSerializer() {
	  BaseSerializer.call(this);
	}

	CubicBezierCurveSerializer.prototype = Object.create(BaseSerializer.prototype);
	CubicBezierCurveSerializer.prototype.constructor = CubicBezierCurveSerializer;

	CubicBezierCurveSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	CubicBezierCurveSerializer.prototype.fromJSON = function (json, parent) {
	  json.userData.points = json.userData.points.map(n => {
	    return new THREE.Vector3().copy(n);
	  });
	  var obj = parent || new CubicBezierCurve(json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var ARC_SEGMENTS$4 = 200;
	/**
	 * 椭圆曲线
	 * @param {Object} options 参数
	 */

	function EllipseCurve(options = {}) {
	  var geometry = new THREE.BufferGeometry();
	  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(ARC_SEGMENTS$4 * 3), 3));
	  var material = new THREE.LineBasicMaterial({
	    color: 0xff0000,
	    opacity: 0.35
	  });
	  THREE.Line.call(this, geometry, material);
	  this.name = _t('Ellipse Curve');
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'EllipseCurve',
	    aX: options.aX || 0,
	    aY: options.aY || 0,
	    xRadius: options.xRadius || 10,
	    yRadius: options.yRadius || 5,
	    aStartAngle: options.aStartAngle || 0,
	    aEndAngle: options.aEndAngle || 2 * Math.PI,
	    aClockwise: options.aClockwise || false,
	    aRotation: options.aRotation || 0
	  });
	  this.update();
	}

	EllipseCurve.prototype = Object.create(THREE.Line.prototype);
	EllipseCurve.prototype.constructor = EllipseCurve;

	EllipseCurve.prototype.update = function () {
	  var curve = new THREE.EllipseCurve(this.userData.aX, this.userData.aY, this.userData.xRadius, this.userData.yRadius, this.userData.aStartAngle, this.userData.aEndAngle, this.userData.aClockwise, this.userData.aRotation);
	  var position = this.geometry.attributes.position;
	  var point = new THREE.Vector3();

	  for (var i = 0; i < ARC_SEGMENTS$4; i++) {
	    var t = i / (ARC_SEGMENTS$4 - 1);
	    curve.getPoint(t, point);
	    position.setXYZ(i, point.x, point.y, 0); // 椭圆曲线只能输出二维点
	  }

	  position.needsUpdate = true;
	};

	/**
	 * EllipseCurveSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function EllipseCurveSerializer() {
	  BaseSerializer.call(this);
	}

	EllipseCurveSerializer.prototype = Object.create(BaseSerializer.prototype);
	EllipseCurveSerializer.prototype.constructor = EllipseCurveSerializer;

	EllipseCurveSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	EllipseCurveSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent || new EllipseCurve(json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * GlobeSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function GlobeSerializer() {
	  BaseSerializer.call(this);
	}

	GlobeSerializer.prototype = Object.create(BaseSerializer.prototype);
	GlobeSerializer.prototype.constructor = GlobeSerializer;

	GlobeSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	GlobeSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Bone() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * VisualSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function VisualSerializer() {
	  BaseSerializer.call(this);
	}

	VisualSerializer.prototype = Object.create(BaseSerializer.prototype);
	VisualSerializer.prototype.constructor = VisualSerializer;

	VisualSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.data = obj.toJSON();
	  return json;
	};

	VisualSerializer.prototype.fromJSON = function (json) {
	  return json.data ? json.data : null;
	};

	/**
	 * 场景序列化/反序列化类
	 * @author tengge / https://github.com/tengge1
	 */

	function Converter() {
	  BaseSerializer.call(this);
	}

	Converter.prototype = Object.create(BaseSerializer.prototype);
	Converter.prototype.constructor = Converter;
	/**
	 * 将应用转为json
	 * @param {Object} obj 需要序列化的对象
	 * @param {Object} obj.options 配置信息
	 * @param {THREE.Camera} obj.camera 相机
	 * @param {THREE.WebGLRenderer} obj.renderer 渲染器 
	 * @param {Array} obj.scripts 脚本列表
	 * @param {Array} obj.animations 动画列表
	 * @param {Object} obj.visual 可视化数据
	 * @param {THREE.Scene} obj.scene 场景
	 * @param {String} obj.server 服务端地址
	 * @returns {Object} json数据
	 */

	Converter.prototype.toJSON = function (obj) {
	  let options = obj.options;
	  let camera = obj.camera;
	  let renderer = obj.renderer;
	  let scripts = obj.scripts;
	  let animations = obj.animations;
	  let visual = obj.visual;
	  let scene = obj.scene;
	  let list = []; // 选项

	  let configJson = new OptionsSerializer().toJSON(options);
	  list.push(configJson); // 相机

	  let cameraJson = new CamerasSerializer().toJSON(camera);
	  list.push(cameraJson); // 渲染器

	  let rendererJson = new WebGLRendererSerializer().toJSON(renderer);
	  list.push(rendererJson); // 脚本

	  let scriptsJson = new ScriptSerializer().toJSON(scripts);
	  scriptsJson.forEach(n => {
	    list.push(n);
	  }); // 动画

	  let animationsJson = new AnimationSerializer().toJSON(animations);
	  animationsJson.forEach(n => {
	    list.push(n);
	  }); // 音频监听器

	  let audioListener = camera.children.filter(n => n instanceof THREE.AudioListener)[0];

	  if (audioListener) {
	    let audioListenerJson = new AudioListenerSerializer().toJSON(audioListener);
	    list.push(audioListenerJson);
	  } // 可视化


	  if (visual) {
	    let visualJson = new VisualSerializer().toJSON(visual);
	    list.push(visualJson);
	  } // 将场景转为json


	  let children = []; // 将层级结构保存在场景中，以供场景加载时还原。

	  this.traverse(scene, children, list, options, false);
	  let sceneJson = list.filter(n => n.uuid === scene.uuid)[0];

	  if (sceneJson) {
	    sceneJson.userData.children = children;
	  } else {
	    console.warn(`Converter: no scene json with id ${scene.uuid}`);
	  }

	  return list;
	};
	/**
	 * 场景转json
	 * @param {THREE.Object3D} obj 三维物体
	 * @param {Object} children 子级结构
	 * @param {Array} list json列表
	 * @param {Object} options 配置信息
	 * @param {Boolean} isServerObject 是否是模型内部组件
	 */


	Converter.prototype.traverse = function (obj, children, list, options, isServerObject) {
	  let json = null;

	  if (obj.userData.Server === true) {
	    // 服务器对象
	    isServerObject = true;
	    json = new ServerObject().toJSON(obj);
	  } else if (obj.userData.type === 'Sky') {
	    json = new SkySerializer().toJSON(obj);
	  } else if (obj.userData.type === 'Fire') {
	    // 火焰
	    json = new FireSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'Smoke') {
	    // 烟
	    json = new SmokeSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'ParticleEmitter') {
	    // 粒子发射器
	    json = new ParticleEmitterSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'PerlinTerrain') {
	    // 柏林地形
	    json = new PerlinTerrainSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'Water') {
	    json = new WaterSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'Cloth') {
	    json = new ClothSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'LineCurve') {
	    json = new LineCurveSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'CatmullRomCurve') {
	    json = new CatmullRomCurveSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'QuadraticBezierCurve') {
	    json = new QuadraticBezierCurveSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'CubicBezierCurve') {
	    json = new CubicBezierCurveSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'EllipseCurve') {
	    json = new EllipseCurveSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'text') {
	    json = new UnscaledTextSerializer().toJSON(obj);
	  } else if (obj.userData.type === '3dtext') {
	    json = new ThreeDTextSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'pointMarker') {
	    json = new PointMarkerSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'Globe') {
	    json = new GlobeSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Scene) {
	    json = new SceneSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Group) {
	    json = new GroupSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Reflector) {
	    json = new ReflectorSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Mesh) {
	    // 设置了options.saveMaterial === false，不要保存模型内部材质。
	    json = new MeshSerializer().toJSON(obj, {
	      saveMaterial: options.saveMaterial === false && isServerObject ? false : true
	    });
	  } else if (obj instanceof THREE.Sprite) {
	    json = new SpriteSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.AmbientLight) {
	    json = new AmbientLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.DirectionalLight) {
	    json = new DirectionalLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.HemisphereLight) {
	    json = new HemisphereLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.PointLight) {
	    json = new PointLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.RectAreaLight) {
	    json = new RectAreaLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.SpotLight) {
	    json = new SpotLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Audio) {
	    json = new AudioSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Bone) {
	    json = new BoneSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Object3D) {
	    json = new Object3DSerializer().toJSON(obj);
	  }

	  if (json) {
	    list.push(json);
	  } else {
	    console.warn(`Converter: No ${obj.constructor.name} Serializer.`);
	  } // 1、服务器模型(ServerObject)，如果设置了不保存子组件，则不保存模型内部信息。


	  if (obj.userData.Server === true && options.saveChild === false) {
	    return;
	  } // 2、如果obj.userData.type不为空，则为内置类型，其子项不应该序列化。


	  if (obj.children && obj.userData.type === undefined) {
	    obj.children.forEach(n => {
	      let children1 = [];
	      children.push({
	        uuid: n.uuid,
	        children: children1
	      });
	      this.traverse(n, children1, list, options, isServerObject);
	    });
	  }
	};
	/**
	 * 场景反序列化
	 * @param {Array} jsons json对象（列表）
	 * @param {Object} options 配置选项
	 * @param {String} options.server 服务端地址，用于下载模型、纹理等资源
	 * @param {THREE.Camera} options.camera 旧相机
	 * @param {Number} options.domWidth 画布宽度
	 * @param {Number} options.domHeight 画布高度
	 * @returns {Object} json数据
	 */


	Converter.prototype.fromJson = function (jsons, options) {
	  let obj = {
	    options: null,
	    camera: null,
	    renderer: null,
	    scripts: null,
	    animations: [],
	    svg: {
	      html: ''
	    },
	    scene: null,
	    // 配置选项
	    oldCamera: options.camera,
	    server: options.server,
	    // 当前服务端选项，便于场景数据在不同服务端显示。
	    domWidth: options.domWidth || 1422,
	    domHeight: options.domHeight || 715
	  }; // 选项

	  let optionsJson = jsons.filter(n => n.metadata && n.metadata.generator === 'OptionsSerializer')[0];

	  if (optionsJson) {
	    obj.options = new OptionsSerializer().fromJSON(optionsJson);
	  } else {
	    console.warn(`Converter: No config info in the scene.`);
	  } // 相机


	  let cameraJson = jsons.filter(n => n.metadata && n.metadata.generator.indexOf('CameraSerializer') > -1)[0];

	  if (cameraJson) {
	    obj.camera = new CamerasSerializer().fromJSON(cameraJson);
	  } else {
	    console.warn(`Converter: No camera info in the scene.`);
	  } // 1、载入场景，传相机参数，则使用编辑器自带相机。
	  // 2、播放时，不传相机参数，使用新生成的相机。


	  if (!obj.oldCamera) {
	    obj.oldCamera = obj.camera;
	  } // 渲染器


	  let rendererJson = jsons.filter(n => n.metadata && n.metadata.generator.indexOf('WebGLRendererSerializer') > -1)[0];

	  if (rendererJson) {
	    obj.renderer = new WebGLRendererSerializer().fromJSON(rendererJson);
	    obj.renderer.setDrawingBufferSize(obj.domWidth, obj.domHeight, window.devicePixelRatio);
	  } else {
	    console.warn(`Converter: No renderer info in the scene.`);
	  } // 脚本


	  let scriptJsons = jsons.filter(n => n.metadata && n.metadata.generator === 'ScriptSerializer');

	  if (scriptJsons) {
	    obj.scripts = new ScriptSerializer().fromJSON(scriptJsons);
	  } // 动画


	  let animationJsons = jsons.filter(n => n.metadata && n.metadata.generator === 'AnimationSerializer');

	  if (animationJsons) {
	    obj.animations = new AnimationSerializer().fromJSON(animationJsons);
	  } // Visual


	  let visualJson = jsons.filter(n => n.metadata && n.metadata.generator === 'VisualSerializer')[0];

	  if (visualJson) {
	    obj.visual = new VisualSerializer().fromJSON(visualJson);
	  } // 音频监听器


	  let audioListenerJson = jsons.filter(n => n.metadata && n.metadata.generator === 'AudioListenerSerializer')[0];
	  let audioListener;

	  if (audioListenerJson) {
	    audioListener = new AudioListenerSerializer().fromJSON(audioListenerJson);
	  } else {
	    console.warn(`Converter: No AudioListener in the scene.`);
	    audioListener = new THREE.AudioListener();
	  }

	  obj.audioListener = audioListener;
	  obj.camera.add(audioListener); // 场景

	  return new Promise(resolve => {
	    this.parse(jsons, obj).then(scene => {
	      obj.scene = scene;
	      resolve(obj);
	    });
	  });
	};

	const NoDeserializeSerializers = ['OptionsSerializer', 'CamerasSerializer', 'PerspectiveCameraSerializer', 'OrthographicCameraSerializer', 'WebGLRendererSerializer', 'ScriptSerializer', 'AnimationSerializer', 'VisualSerializer', 'AudioListenerSerializer', 'SceneSerializer', 'GlobeSerializer'];
	/**
	 * json转场景
	 * @param {*} jsons 反序列化对象列表
	 * @param {*} options 配置信息
	 * @returns {Object} json数据
	 */

	Converter.prototype.parse = function (jsons, options) {
	  // TODO: 由于有的模型上带Scene，这样判断得到的Scene可能不太准确。
	  let sceneJson = jsons.filter(n => n.metadata && n.metadata.generator === 'SceneSerializer')[0];

	  if (sceneJson === undefined) {
	    console.warn(`Converter: No scene info in the scene.`);
	    return new Promise(resolve => {
	      resolve(new THREE.Scene());
	    });
	  }

	  let scene = new SceneSerializer().fromJSON(sceneJson, undefined, options.server);
	  let children = sceneJson.userData.children; // 将每个组件反序列化

	  let parts = [scene];
	  let serverParts = [];
	  let promises = jsons.map(n => {
	    const generator = n.metadata.generator;

	    if (generator === 'ServerObject') {
	      parts.push(new Object3DSerializer().fromJSON(n));
	      return new Promise(resolve => {
	        new ServerObject().fromJSON(n, options, options).then(obj => {
	          if (obj) {
	            if (options.options.saveChild === false) {
	              // 不保存模型内部组件
	              serverParts.push(obj);
	            } else {
	              // 保存模型内部组件
	              this.traverseServerObject(obj, serverParts);
	            }
	          } else {
	            console.warn(`Converter: ${n.uuid} loaded failed.`);
	          }

	          resolve();
	        });
	      });
	    } else if (NoDeserializeSerializers.indexOf(generator) > -1) ; else if (generator === 'GroupSerializer') {
	      parts.push(new GroupSerializer().fromJSON(n));
	    } else if (generator === 'ReflectorSerializer') {
	      parts.push(new ReflectorSerializer().fromJSON(n));
	    } else if (generator === 'MeshSerializer') {
	      parts.push(new MeshSerializer().fromJSON(n, undefined, options.server));
	    } else if (generator === 'SpriteSerializer') {
	      parts.push(new SpriteSerializer().fromJSON(n, undefined, options.server));
	    } else if (generator === 'AmbientLightSerializer') {
	      parts.push(new AmbientLightSerializer().fromJSON(n));
	    } else if (generator === 'DirectionalLightSerializer') {
	      parts.push(new DirectionalLightSerializer().fromJSON(n));
	    } else if (generator === 'HemisphereLightSerializer') {
	      parts.push(new HemisphereLightSerializer().fromJSON(n));
	    } else if (generator === 'PointLightSerializer') {
	      parts.push(new PointLightSerializer().fromJSON(n));
	    } else if (generator === 'RectAreaLightSerializer') {
	      parts.push(new RectAreaLightSerializer().fromJSON(n));
	    } else if (generator === 'SpotLightSerializer') {
	      parts.push(new SpotLightSerializer().fromJSON(n));
	    } else if (generator === 'AudioSerializer') {
	      parts.push(new AudioSerializer().fromJSON(n, undefined, options.audioListener));
	    } else if (generator === 'FireSerializer') {
	      parts.push(new FireSerializer().fromJSON(n, undefined, options.oldCamera));
	    } else if (generator === 'SmokeSerializer') {
	      parts.push(new SmokeSerializer().fromJSON(n, undefined, options.oldCamera, options.renderer));
	    } else if (generator === 'BoneSerializer') {
	      parts.push(new BoneSerializer().fromJSON(n));
	    } else if (generator === 'SkySerializer') {
	      parts.push(new SkySerializer().fromJSON(n));
	    } else if (generator === 'ParticleEmitterSerializer') {
	      parts.push(new ParticleEmitterSerializer().fromJSON(n, undefined, options.server));
	    } else if (generator === 'PerlinTerrainSerializer') {
	      parts.push(new PerlinTerrainSerializer().fromJSON(n));
	    } else if (generator === 'WaterSerializer') {
	      parts.push(new WaterSerializer().fromJSON(n, undefined, options.renderer));
	    } else if (generator === 'ClothSerializer') {
	      parts.push(new ClothSerializer().fromJSON(n));
	    } else if (generator === 'LineCurveSerializer') {
	      parts.push(new LineCurveSerializer().fromJSON(n));
	    } else if (generator === 'CatmullRomCurveSerializer') {
	      parts.push(new CatmullRomCurveSerializer().fromJSON(n));
	    } else if (generator === 'QuadraticBezierCurveSerializer') {
	      parts.push(new QuadraticBezierCurveSerializer().fromJSON(n));
	    } else if (generator === 'CubicBezierCurveSerializer') {
	      parts.push(new CubicBezierCurveSerializer().fromJSON(n));
	    } else if (generator === 'EllipseCurveSerializer') {
	      parts.push(new EllipseCurveSerializer().fromJSON(n));
	    } else if (generator === 'Object3DSerializer') {
	      parts.push(new Object3DSerializer().fromJSON(n));
	    } else if (generator === 'UnscaledTextSerializer') {
	      parts.push(new UnscaledTextSerializer().fromJSON(n, undefined, {
	        domWidth: options.domWidth,
	        domHeight: options.domHeight
	      }));
	    } else if (generator === 'ThreeDTextSerializer') {
	      parts.push(new ThreeDTextSerializer().fromJSON(n));
	    } else if (generator === 'PointMarkerSerializer') {
	      parts.push(new PointMarkerSerializer().fromJSON(n, undefined, {
	        domWidth: options.domWidth,
	        domHeight: options.domHeight
	      }));
	    } else {
	      console.warn(`Converter: No Deserializer with ${generator}.`);
	    }

	    return new Promise(resolve => {
	      resolve();
	    });
	  }); // 根据children重新还原场景结构

	  return new Promise(resolve => {
	    Promise.all(promises).then(() => {
	      this.parseScene(scene, children, parts, serverParts, options);
	      resolve(scene);
	    });
	  });
	};
	/**
	 * 新的组装场景方法
	 * @param {*} parent 父组件
	 * @param {*} children 子组件
	 * @param {*} parts 反序列化json得到的部件
	 * @param {*} serverParts 服务端模型分解出的组件
	 * @param {*} options 配置信息
	 * @description 由于只序列化了服务端模型的材质，所以优先采用服务端模型组件搭建场景，并用序列化的材质代替服务端材质。
	 */


	Converter.prototype.parseScene = function (parent, children, parts, serverParts, options) {
	  children.forEach(child => {
	    let obj = serverParts.filter(n => n.uuid === child.uuid)[0];
	    let isServerObject = false;

	    if (obj) {
	      // 服务端组件
	      isServerObject = true;

	      if (options.options.saveChild !== false) {
	        // 保存模型内部组件
	        let obj1 = parts.filter(n => n.uuid === child.uuid)[0];

	        if (obj1) {
	          // 还原修改过的名称、位置、旋转、缩放等信息。
	          obj.name = obj1.name;
	          obj.position.copy(obj1.position);
	          obj.rotation.copy(obj1.rotation);
	          obj.scale.copy(obj1.scale);

	          if (options.options.saveMaterial !== false) {
	            if (obj.material && obj1.material) {
	              // blob:http://
	              if (obj.material.map && obj.material.map.image && obj.material.map.image.src && obj.material.map.image.src.toString().startsWith('blob:http://')) ; else {
	                obj.material = obj1.material;
	              }
	            }
	          }
	        } else {
	          console.warn(`Converter: The components of ServerObject ${child.uuid} is not serialized.`);
	        }
	      }
	    } else {
	      obj = parts.filter(n => n.uuid === child.uuid)[0];
	    }

	    if (!obj) {
	      console.warn(`Converter: no element with uuid ${child.uuid}.`);
	      return;
	    }

	    parent.add(obj); // 1、对于服务端组件，只有保存内部组件选项不为false时，才保存模型内部选项。

	    if (isServerObject && options.options.saveChild !== false || !isServerObject) {
	      if (child.children.length > 0) {
	        this.parseScene(obj, child.children, parts, serverParts, options);
	      }
	    }
	  });
	};
	/**
	 * 将服务端模型分解为组件，并移除子组件
	 * @param {THREE.Object3D} obj Object3D对象
	 * @param {Array} list 列表
	 */


	Converter.prototype.traverseServerObject = function (obj, list) {
	  list.push(obj);

	  while (obj.children && obj.children.length) {
	    let child = obj.children[0];
	    obj.remove(child);
	    this.traverseServerObject(child, list);
	  }
	};

	/**
	 * 播放器下载事件
	 * @param {*} app 播放器
	 */

	function PlayerLoader(app) {
	  PlayerComponent.call(this, app);
	}

	PlayerLoader.prototype = Object.create(PlayerComponent.prototype);
	PlayerLoader.prototype.constructor = PlayerLoader;

	PlayerLoader.prototype.create = function (jsons, options) {
	  return new Converter().fromJson(jsons, {
	    server: app.options.server,
	    domWidth: options.domWidth,
	    domHeight: options.domHeight
	  }).then(obj => {
	    this.scene = obj.scene;
	    return new Promise(resolve => {
	      resolve(obj);
	    });
	  });
	};

	PlayerLoader.prototype.dispose = function () {
	  // TODO: 彻底清空下载的模型资源
	  this.scene = null;
	};

	/**
	 * 播放器事件
	 * @param {*} app 播放器
	 */

	function PlayerEvent(app) {
	  PlayerComponent.call(this, app);
	}

	PlayerEvent.prototype = Object.create(PlayerComponent.prototype);
	PlayerEvent.prototype.constructor = PlayerEvent;

	PlayerEvent.prototype.create = function (scene, camera, renderer, scripts) {
	  this.scene = scene;
	  this.camera = camera;
	  this.renderer = renderer;
	  this.scripts = scripts;
	  var dom = renderer.domElement;
	  this.events = Object.keys(scripts).map(uuid => {
	    var script = scripts[uuid]; // TODO: 存在安全风险。

	    return new Function('app', 'scene', 'camera', 'renderer', script.source + `
            var init = init || null;
            var start = start || null;
            var update = update || null;
            var stop = stop || null;
            var onClick = onClick || null;
            var onDblClick = onDblClick || null;
            var onKeyDown = onKeyDown || null;
            var onKeyUp = onKeyUp || null;
            var onMouseDown = onMouseDown || null;
            var onMouseMove = onMouseMove || null;
            var onMouseUp = onMouseUp || null;
            var onMouseWheel = onMouseWheel || null;
            var onResize = onResize || null;
            var preChapter = preChapter || null;
            var nextChapter = nextChapter || null;
            var preStep = preStep || null;
            var nextStep = nextStep || null;
            return { init, start, update, stop, onClick, onDblClick, onKeyDown, onKeyUp, onMouseDown, onMouseMove, onMouseUp, onMouseWheel, onResize,preChapter,nextChapter,preStep,nextStep };
            `).call(scene, this.app, scene, camera, renderer);
	  });
	  this.events.forEach(n => {
	    if (typeof n.onClick === 'function') {
	      dom.addEventListener('click', n.onClick.bind(this.scene));
	    }

	    if (typeof n.onDblClick === 'function') {
	      dom.addEventListener('dblclick', n.onDblClick.bind(this.scene));
	    }

	    if (typeof n.onKeyDown === 'function') {
	      dom.addEventListener('keydown', n.onKeyDown.bind(this.scene));
	    }

	    if (typeof n.onKeyUp === 'function') {
	      dom.addEventListener('keyup', n.onKeyUp.bind(this.scene));
	    }

	    if (typeof n.onMouseDown === 'function') {
	      dom.addEventListener('mousedown', n.onMouseDown.bind(this.scene));
	    }

	    if (typeof n.onMouseMove === 'function') {
	      dom.addEventListener('mousemove', n.onMouseMove.bind(this.scene));
	    }

	    if (typeof n.onMouseUp === 'function') {
	      dom.addEventListener('mouseup', n.onMouseUp.bind(this.scene));
	    }

	    if (typeof n.onMouseWheel === 'function') {
	      dom.addEventListener('mousewheel', n.onMouseWheel.bind(this.scene));
	    }

	    if (typeof n.onResize === 'function') {
	      window.addEventListener('resize', n.onResize.bind(this.scene));
	    }
	  });
	  return new Promise(resolve => {
	    resolve();
	  });
	};
	/**
	 * 场景载入前执行一次
	 */


	PlayerEvent.prototype.init = function () {
	  this.events.forEach(n => {
	    if (typeof n.init === 'function') {
	      n.init();
	    }
	  });
	};
	/**
	 * 场景载入后执行一次
	 */


	PlayerEvent.prototype.start = function () {
	  this.events.forEach(n => {
	    if (typeof n.start === 'function') {
	      n.start();
	    }
	  });
	};
	/**
	 * 运行期间每帧都要执行
	 * @param {THREE.Clock} clock 时钟
	 * @param {Number} deltaTime 间隔时间
	 */


	PlayerEvent.prototype.update = function (clock, deltaTime) {
	  this.events.forEach(n => {
	    if (typeof n.update === 'function') {
	      n.update(clock, deltaTime);
	    }
	  });
	};
	/**
	 * 程序结束运行后执行一次
	 */


	PlayerEvent.prototype.stop = function () {
	  this.events.forEach(n => {
	    if (typeof n.stop === 'function') {
	      n.stop();
	    }
	  });
	};
	/**
	 * 析构PlayerEvent
	 */


	PlayerEvent.prototype.dispose = function () {
	  var dom = this.renderer.domElement;
	  this.events.forEach(n => {
	    if (typeof n.onClick === 'function') {
	      dom.removeEventListener('click', n.onClick.bind(this.scene));
	    }

	    if (typeof n.onDblClick === 'function') {
	      dom.removeEventListener('dblclick', n.onDblClick.bind(this.scene));
	    }

	    if (typeof n.onKeyDown === 'function') {
	      dom.removeEventListener('keydown', n.onKeyDown.bind(this.scene));
	    }

	    if (typeof n.onKeyUp === 'function') {
	      dom.removeEventListener('keyup', n.onKeyUp.bind(this.scene));
	    }

	    if (typeof n.onMouseDown === 'function') {
	      dom.removeEventListener('mousedown', n.onMouseDown.bind(this.scene));
	    }

	    if (typeof n.onMouseMove === 'function') {
	      dom.removeEventListener('mousemove', n.onMouseMove.bind(this.scene));
	    }

	    if (typeof n.onMouseUp === 'function') {
	      dom.removeEventListener('mouseup', n.onMouseUp.bind(this.scene));
	    }

	    if (typeof n.onMouseWheel === 'function') {
	      dom.removeEventListener('mousewheel', n.onMouseWheel.bind(this.scene));
	    }

	    if (typeof n.onResize === 'function') {
	      window.removeEventListener('resize', n.onResize.bind(this.scene));
	    }
	  });
	  this.scene = null;
	  this.camera = null;
	  this.renderer = null;
	  this.scripts = null;
	  this.events.length = 0;
	};

	/**
	 * 播放器场景控制
	 * @param {*} app 播放器
	 */

	function PlayerControl(app) {
	  PlayerComponent.call(this, app);
	  this.packageManager = new PackageManager();
	  this.require = this.packageManager.require.bind(this.packageManager);
	  this.control = null;
	}

	PlayerControl.prototype = Object.create(PlayerComponent.prototype);
	PlayerControl.prototype.constructor = PlayerControl;

	PlayerControl.prototype.create = function (scene, camera, renderer) {
	  var type = camera.userData.control;
	  var promise = new Promise(resolve => {
	    resolve();
	  });

	  if (type === 'FirstPersonControls') {
	    // 第一视角控制器
	    promise = this.require('FirstPersonControls');
	  } else if (type === 'FlyControls') {
	    // 飞行控制器
	    promise = this.require('FlyControls');
	  } else if (type === 'OrbitControls') {
	    // 轨道控制器
	    promise = this.require('OrbitControls');
	  } else if (type === 'PointerLockControls') {
	    // 指针锁定控制器
	    promise = this.require('PointerLockControls');
	  } else if (type === 'TrackballControls') {
	    // 轨迹球控制器
	    promise = this.require('TrackballControls');
	  }

	  return promise.then(() => {
	    this._createControl(scene, camera, renderer);

	    return new Promise(resolve => {
	      resolve();
	    });
	  });
	};

	PlayerControl.prototype._createControl = function (scene, camera, renderer) {
	  var type = camera.userData.control;

	  if (type === 'FirstPersonControls') {
	    // 第一视角控制器
	    this.control = new THREE.FirstPersonControls(camera, renderer.domElement);

	    if (camera.userData.firstPersonOptions) {
	      Object.assign(this.control, camera.userData.firstPersonOptions);
	    }
	  } else if (type === 'FlyControls') {
	    // 飞行控制器
	    this.control = new THREE.FlyControls(camera, renderer.domElement);

	    if (camera.userData.flyOptions) {
	      Object.assign(this.control, camera.userData.flyOptions);
	    }
	  } else if (type === 'OrbitControls') {
	    // 轨道控制器
	    this.control = new THREE.OrbitControls(camera, renderer.domElement);

	    if (camera.userData.orbitOptions) {
	      Object.assign(this.control, camera.userData.orbitOptions);
	    }
	  } else if (type === 'PointerLockControls') {
	    // 指针锁定控制器
	    this.control = new THREE.PointerLockControls(camera, renderer.domElement);

	    if (camera.userData.pointerLockOptions) {
	      Object.assign(this.control, camera.userData.pointerLockOptions);

	      if (this.control.isLocked) {
	        this.control.lock();
	      } else {
	        this.control.unlock();
	      }
	    }
	  } else if (type === 'TrackballControls') {
	    // 轨迹球控制器
	    this.control = new THREE.TrackballControls(camera, renderer.domElement);

	    if (camera.userData.trackballOptions) {
	      Object.assign(this.control, camera.userData.trackballOptions);
	    }
	  }
	};

	PlayerControl.prototype.update = function (clock, deltaTime) {
	  if (this.control && this.control.update) {
	    this.control.update(deltaTime);
	  }
	};

	PlayerControl.prototype.dispose = function () {
	  if (this.control) {
	    this.control.dispose();
	    this.control = null;
	  }
	};

	/**
	 * 播放器音频
	 * @param {*} app 播放器
	 */

	function PlayerAudio(app) {
	  PlayerComponent.call(this, app);
	  this.audios = [];
	}

	PlayerAudio.prototype = Object.create(PlayerComponent.prototype);
	PlayerAudio.prototype.constructor = PlayerAudio;

	PlayerAudio.prototype.create = function (scene, camera, renderer) {
	  // eslint-disable-line
	  this.audios.length = 0;
	  scene.traverse(n => {
	    if (n instanceof THREE.Audio) {
	      this.audios.push(n);
	    }
	  });
	  var loader = new THREE.AudioLoader();
	  var promises = this.audios.map(n => {
	    return new Promise(resolve => {
	      loader.load(app.options.server + n.userData.Url, buffer => {
	        n.setBuffer(buffer);

	        if (n.userData.autoplay) {
	          n.autoplay = n.userData.autoplay;
	          n.play();
	        }

	        resolve();
	      }, undefined, () => {
	        console.warn(`PlayerLoader: ${n.userData.Url} loaded failed.`);
	        resolve();
	      });
	    });
	  });
	  return Promise.all(promises);
	};

	PlayerAudio.prototype.dispose = function () {
	  this.audios.forEach(n => {
	    if (n.isPlaying) {
	      n.stop();
	    }
	  });
	  this.audios.length = 0;
	};

	var ID$5 = -1;
	/**
	 * 基本渲染器
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseRenderer() {
	  this.id = `${this.constructor.name}${ID$5--}`;
	} // eslint-disable-next-line


	BaseRenderer.prototype.create = function (scenes, camera, renderer, selected) {
	  return new Promise(resolve => {
	    resolve();
	  });
	};

	BaseRenderer.prototype.render = function () {};

	BaseRenderer.prototype.dispose = function () {};

	/**
	 * 特效渲染器
	 */

	function EffectRenderer() {
	  BaseRenderer.call(this);
	  this.packageManager = new PackageManager();
	  this.require = this.packageManager.require.bind(this.packageManager);
	  this.ready = false;
	  this.effectNames = ['fxaa', 'smaa', 'ssaa', 'taa', 'sao', 'ssao', 'pixel', 'dotScreen', 'rgbShift', 'afterimage', 'halftone', 'bokeh', 'glitch'];
	}

	EffectRenderer.prototype = Object.create(BaseRenderer.prototype);
	EffectRenderer.prototype.constructor = EffectRenderer;
	/**
	 * 特效渲染器初始化，特效配置修改后需要重新调用该函数
	 * @param {*} scenes 场景数组，使用第一个场景的特效配置
	 * @param {*} camera 相机
	 * @param {*} renderer 渲染器
	 */

	EffectRenderer.prototype.create = async function (scenes, camera, renderer) {
	  if (!Array.isArray(scenes)) {
	    scenes = [scenes];
	  }

	  this.scenes = scenes;
	  this.camera = camera;
	  this.renderer = renderer;
	  var postProcessing = scenes[0].userData.postProcessing || {};
	  this.ready = false; // 快速近似抗锯齿

	  if (postProcessing.fxaa && postProcessing.fxaa.enabled) {
	    await this.require(['CopyShader', 'FXAAShader', 'EffectComposer', 'RenderPass', 'ShaderPass']);
	  } // 多重采样抗锯齿


	  if (postProcessing.smaa && postProcessing.smaa.enabled) {
	    await this.require(['CopyShader', 'SMAAShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'SMAAPass']);
	  } // 全屏抗锯齿


	  if (postProcessing.ssaa && postProcessing.ssaa.enabled) {
	    await this.require(['CopyShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'SSAARenderPass']);
	  } // 时间抗锯齿


	  if (postProcessing.taa && postProcessing.taa.enabled) {
	    await this.require(['CopyShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'SSAARenderPass', 'TAARenderPass']);
	  } // 可扩展环境光遮挡


	  if (postProcessing.sao && postProcessing.sao.enabled) {
	    await this.require(['CopyShader', 'SAOShader', 'DepthLimitedBlurShader', 'UnpackDepthRGBAShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'SAOPass']);
	  } // 屏幕空间环境光遮蔽


	  if (postProcessing.ssao && postProcessing.ssao.enabled) {
	    await this.require(['CopyShader', 'SSAOShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'SSAOPass']);
	  } // 像素特效


	  if (postProcessing.pixel && postProcessing.pixel.enabled) {
	    await this.require(['CopyShader', 'PixelShader', 'EffectComposer', 'RenderPass', 'ShaderPass']);
	  } // 点阵化


	  if (postProcessing.dotScreen && postProcessing.dotScreen.enabled) {
	    await this.require(['CopyShader', 'DotScreenShader', 'EffectComposer', 'RenderPass', 'ShaderPass']);
	  } // 颜色偏移


	  if (postProcessing.rgbShift && postProcessing.rgbShift.enabled) {
	    await this.require(['CopyShader', 'RGBShiftShader', 'EffectComposer', 'RenderPass', 'ShaderPass']);
	  } // 残影特效


	  if (postProcessing.afterimage && postProcessing.afterimage.enabled) {
	    await this.require(['CopyShader', 'AfterimageShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'AfterimagePass']);
	  } // 半色调特效


	  if (postProcessing.halftone && postProcessing.halftone.enabled) {
	    await this.require(['HalftoneShader', 'HalftonePass']);
	  } // 背景虚化特效


	  if (postProcessing.bokeh && postProcessing.bokeh.enabled) {
	    await this.require(['CopyShader', 'BokehShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'BokehPass']);
	  } // 毛刺特效


	  if (postProcessing.glitch && postProcessing.glitch.enabled) {
	    await this.require(['CopyShader', 'DigitalGlitch', 'EffectComposer', 'RenderPass', 'ShaderPass', 'GlitchPass']);
	  }

	  this._createPostProcessing(scenes, camera, renderer);

	  this.ready = true;
	};

	EffectRenderer.prototype._createPostProcessing = function (scenes, camera, renderer) {
	  let scene = scenes[0];
	  let postProcessing = scene.userData.postProcessing || {};

	  if (this.composer) {
	    this.dispose();
	  } // 判断是否需要启用特效渲染器


	  var keys = Object.keys(postProcessing);
	  var useEffect = false;
	  var i;

	  for (i = 0; i < keys.length; i++) {
	    var key = keys[i];

	    if (this.effectNames.indexOf(key) > -1 && postProcessing[key].enabled) {
	      // 需要特效
	      useEffect = true;
	      break;
	    }
	  }

	  if (!useEffect) {
	    return;
	  }

	  var effects = [],
	      effect;
	  var composer = new THREE.EffectComposer(renderer);
	  scenes.forEach((n, i) => {
	    effect = new THREE.RenderPass(n, camera);
	    effect.clear = i === 0;
	    composer.addPass(effect);
	    effects.push(effect);
	  }); // 快速近似抗锯齿

	  if (postProcessing.fxaa && postProcessing.fxaa.enabled) {
	    effect = new THREE.ShaderPass(THREE.FXAAShader);
	    effect.uniforms['resolution'].value.set(1 / renderer.domElement.width, 1 / renderer.domElement.height);
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 多重采样抗锯齿


	  if (postProcessing.smaa && postProcessing.smaa.enabled) {
	    effect = new THREE.SMAAPass(renderer.domElement.width * renderer.getPixelRatio(), renderer.domElement.height * renderer.getPixelRatio());
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 全屏抗锯齿


	  if (postProcessing.ssaa && postProcessing.ssaa.enabled) {
	    effect = new THREE.SSAARenderPass(scene, camera);
	    effect.unbiased = postProcessing.ssaa.unbiased;
	    effect.sampleLevel = postProcessing.ssaa.sampleLevel;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 时间抗锯齿


	  if (postProcessing.taa && postProcessing.taa.enabled) {
	    effect = new THREE.TAARenderPass(scene, camera);
	    effect.unbiased = postProcessing.taa.unbiased;
	    effect.sampleLevel = postProcessing.taa.sampleLevel;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 可扩展环境光遮挡


	  if (postProcessing.sao && postProcessing.sao.enabled) {
	    effect = new THREE.SAOPass(scene, camera, false, true);
	    effect.params.output = postProcessing.sao.output;
	    effect.params.saoBias = postProcessing.sao.saoBias;
	    effect.params.saoIntensity = postProcessing.sao.saoIntensity;
	    effect.params.saoScale = postProcessing.sao.saoScale;
	    effect.params.saoKernelRadius = postProcessing.sao.saoKernelRadius;
	    effect.params.saoMinResolution = postProcessing.sao.saoMinResolution;
	    effect.params.saoBlur = postProcessing.sao.saoBlur;
	    effect.params.saoBlurRadius = postProcessing.sao.saoBlurRadius;
	    effect.params.saoBlurStdDev = postProcessing.sao.saoBlurStdDev;
	    effect.params.saoBlurDepthCutoff = postProcessing.sao.saoBlurDepthCutoff;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 屏幕空间环境光遮蔽


	  if (postProcessing.ssao && postProcessing.ssao.enabled) {
	    effect = new THREE.SSAOPass(scene, camera, renderer.domElement.width, renderer.domElement.height);
	    effect.output = postProcessing.ssao.output;
	    effect.kernelRadius = postProcessing.ssao.kernelRadius;
	    effect.minDistance = postProcessing.ssao.minDistance;
	    effect.maxDistance = postProcessing.ssao.maxDistance;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 像素特效


	  if (postProcessing.pixel && postProcessing.pixel.enabled) {
	    effect = new THREE.ShaderPass(THREE.PixelShader);
	    effect.uniforms.resolution.value = new THREE.Vector2(renderer.domElement.width, renderer.domElement.height);
	    effect.uniforms.resolution.value.multiplyScalar(window.devicePixelRatio);
	    effect.uniforms.pixelSize.value = postProcessing.pixel.pixelSize;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 点阵化


	  if (postProcessing.dotScreen && postProcessing.dotScreen.enabled) {
	    effect = new THREE.ShaderPass(THREE.DotScreenShader);
	    effect.uniforms['scale'].value = postProcessing.dotScreen.scale;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 颜色偏移


	  if (postProcessing.rgbShift && postProcessing.rgbShift.enabled) {
	    effect = new THREE.ShaderPass(THREE.RGBShiftShader);
	    effect.uniforms['amount'].value = postProcessing.rgbShift.amount;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 残影特效


	  if (postProcessing.afterimage && postProcessing.afterimage.enabled) {
	    effect = new THREE.AfterimagePass();
	    effect.uniforms['damp'].value = postProcessing.afterimage.damp;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 半色调特效


	  if (postProcessing.halftone && postProcessing.halftone.enabled) {
	    effect = new THREE.HalftonePass(renderer.domElement.width, renderer.domElement.height, {
	      shape: postProcessing.halftone.shape,
	      radius: postProcessing.halftone.radius,
	      rotateR: postProcessing.halftone.rotateR * (Math.PI / 180),
	      rotateB: postProcessing.halftone.rotateB * (Math.PI / 180),
	      rotateG: postProcessing.halftone.rotateG * (Math.PI / 180),
	      scatter: postProcessing.halftone.scatter,
	      blending: postProcessing.halftone.blending,
	      blendingMode: postProcessing.halftone.blendingMode,
	      greyscale: postProcessing.halftone.greyscale
	    });
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 背景虚化特效


	  if (postProcessing.bokeh && postProcessing.bokeh.enabled) {
	    effect = new THREE.BokehPass(scene, camera, {
	      focus: postProcessing.bokeh.focus,
	      aperture: postProcessing.bokeh.aperture / 100000,
	      maxblur: postProcessing.bokeh.maxBlur,
	      width: renderer.domElement.width,
	      height: renderer.domElement.height
	    });
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 毛刺特效


	  if (postProcessing.glitch && postProcessing.glitch.enabled) {
	    effect = new THREE.GlitchPass();
	    effect.goWild = postProcessing.glitch.wild;
	    composer.addPass(effect);
	    effects.push(effect);
	  }

	  for (i = 0; i < effects.length; i++) {
	    if (i === effects.length - 1) {
	      effects[i].renderToScreen = true;
	    } else {
	      effects[i].renderToScreen = false;
	    }
	  }

	  this.composer = composer;
	};
	/**
	 * 渲染特效
	 */


	EffectRenderer.prototype.render = function () {
	  if (this.composer && this.ready) {
	    // 使用特效渲染器
	    this.composer.render();
	  } else {
	    // 未设置特效
	    this.scenes.forEach(n => {
	      this.renderer.render(n, this.camera);
	    });
	  }
	};

	EffectRenderer.prototype.dispose = function () {
	  if (this.composer) {
	    this.composer.reset();
	    this.composer.passes.length = 0;
	    this.composer = null;
	  }
	};

	/**
	 * 播放器渲染器
	 * @param {*} app 播放器
	 */

	function PlayerRenderer(app) {
	  PlayerComponent.call(this, app);
	}

	PlayerRenderer.prototype = Object.create(PlayerComponent.prototype);
	PlayerRenderer.prototype.constructor = PlayerRenderer;

	PlayerRenderer.prototype.create = function (scene, camera, renderer) {
	  this.renderer = new EffectRenderer();
	  return this.renderer.create(scene, camera, renderer);
	};

	PlayerRenderer.prototype.update = function (clock, deltaTime) {
	  // eslint-disable-line
	  this.renderer.render();
	};

	PlayerRenderer.prototype.dispose = function () {
	  this.renderer.dispose();
	  this.renderer = null;
	};

	/* eslint-disable */

	/*
	* Ease
	* Visit http://createjs.com/ for documentation, updates and examples.
	*
	* Copyright (c) 2010 gskinner.com, inc.
	*
	* Permission is hereby granted, free of charge, to any person
	* obtaining a copy of this software and associated documentation
	* files (the "Software"), to deal in the Software without
	* restriction, including without limitation the rights to use,
	* copy, modify, merge, publish, distribute, sublicense, and/or sell
	* copies of the Software, and to permit persons to whom the
	* Software is furnished to do so, subject to the following
	* conditions:
	*
	* The above copyright notice and this permission notice shall be
	* included in all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	* OTHER DEALINGS IN THE SOFTWARE.
	*/

	/**
	 * @module TweenJS
	 * @author tweenjs / https://www.createjs.com/tweenjs
	 * @link https://github.com/CreateJS/TweenJS/blob/master/src/tweenjs/Ease.js
	 */

	/**
	 * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param
	 * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.
	 *
	 * Most methods on Ease can be passed directly as easing functions:
	 *
	 *      createjs.Tween.get(target).to({x:100}, 500, createjs.Ease.linear);
	 *
	 * However, methods beginning with "get" will return an easing function based on parameter values:
	 *
	 *      createjs.Tween.get(target).to({y:200}, 500, createjs.Ease.getPowIn(2.2));
	 *
	 * Please see the <a href="http://www.createjs.com/Demos/TweenJS/Tween_SparkTable">spark table demo</a> for an
	 * overview of the different ease types on <a href="http://tweenjs.com">TweenJS.com</a>.
	 *
	 * <em>Equations derived from work by Robert Penner.</em>
	 * @class Ease
	 * @static
	 **/
	function Ease() {
	  throw "Ease cannot be instantiated.";
	} // static methods and properties

	/**
	 * @method linear
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.linear = function (t) {
	  return t;
	};
	/**
	 * Identical to linear.
	 * @method none
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.none = Ease.linear;
	/**
	 * Mimics the simple -100 to 100 easing in Adobe Flash/Animate.
	 * @method get
	 * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.
	 * @static
	 * @return {Function}
	 **/

	Ease.get = function (amount) {
	  if (amount < -1) {
	    amount = -1;
	  } else if (amount > 1) {
	    amount = 1;
	  }

	  return function (t) {
	    if (amount == 0) {
	      return t;
	    }

	    if (amount < 0) {
	      return t * (t * -amount + 1 + amount);
	    }

	    return t * ((2 - t) * amount + (1 - amount));
	  };
	};
	/**
	 * Configurable exponential ease.
	 * @method getPowIn
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/


	Ease.getPowIn = function (pow) {
	  return function (t) {
	    return Math.pow(t, pow);
	  };
	};
	/**
	 * Configurable exponential ease.
	 * @method getPowOut
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/


	Ease.getPowOut = function (pow) {
	  return function (t) {
	    return 1 - Math.pow(1 - t, pow);
	  };
	};
	/**
	 * Configurable exponential ease.
	 * @method getPowInOut
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/


	Ease.getPowInOut = function (pow) {
	  return function (t) {
	    if ((t *= 2) < 1) return 0.5 * Math.pow(t, pow);
	    return 1 - 0.5 * Math.abs(Math.pow(2 - t, pow));
	  };
	};
	/**
	 * @method quadIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.quadIn = Ease.getPowIn(2);
	/**
	 * @method quadOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quadOut = Ease.getPowOut(2);
	/**
	 * @method quadInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quadInOut = Ease.getPowInOut(2);
	/**
	 * @method cubicIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.cubicIn = Ease.getPowIn(3);
	/**
	 * @method cubicOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.cubicOut = Ease.getPowOut(3);
	/**
	 * @method cubicInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.cubicInOut = Ease.getPowInOut(3);
	/**
	 * @method quartIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quartIn = Ease.getPowIn(4);
	/**
	 * @method quartOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quartOut = Ease.getPowOut(4);
	/**
	 * @method quartInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quartInOut = Ease.getPowInOut(4);
	/**
	 * @method quintIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quintIn = Ease.getPowIn(5);
	/**
	 * @method quintOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quintOut = Ease.getPowOut(5);
	/**
	 * @method quintInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quintInOut = Ease.getPowInOut(5);
	/**
	 * @method sineIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.sineIn = function (t) {
	  return 1 - Math.cos(t * Math.PI / 2);
	};
	/**
	 * @method sineOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.sineOut = function (t) {
	  return Math.sin(t * Math.PI / 2);
	};
	/**
	 * @method sineInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.sineInOut = function (t) {
	  return -0.5 * (Math.cos(Math.PI * t) - 1);
	};
	/**
	 * Configurable "back in" ease.
	 * @method getBackIn
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/


	Ease.getBackIn = function (amount) {
	  return function (t) {
	    return t * t * ((amount + 1) * t - amount);
	  };
	};
	/**
	 * @method backIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.backIn = Ease.getBackIn(1.7);
	/**
	 * Configurable "back out" ease.
	 * @method getBackOut
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/

	Ease.getBackOut = function (amount) {
	  return function (t) {
	    return --t * t * ((amount + 1) * t + amount) + 1;
	  };
	};
	/**
	 * @method backOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.backOut = Ease.getBackOut(1.7);
	/**
	 * Configurable "back in out" ease.
	 * @method getBackInOut
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/

	Ease.getBackInOut = function (amount) {
	  amount *= 1.525;
	  return function (t) {
	    if ((t *= 2) < 1) return 0.5 * (t * t * ((amount + 1) * t - amount));
	    return 0.5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
	  };
	};
	/**
	 * @method backInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.backInOut = Ease.getBackInOut(1.7);
	/**
	 * @method circIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.circIn = function (t) {
	  return -(Math.sqrt(1 - t * t) - 1);
	};
	/**
	 * @method circOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.circOut = function (t) {
	  return Math.sqrt(1 - --t * t);
	};
	/**
	 * @method circInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.circInOut = function (t) {
	  if ((t *= 2) < 1) return -0.5 * (Math.sqrt(1 - t * t) - 1);
	  return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
	};
	/**
	 * @method bounceIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.bounceIn = function (t) {
	  return 1 - Ease.bounceOut(1 - t);
	};
	/**
	 * @method bounceOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.bounceOut = function (t) {
	  if (t < 1 / 2.75) {
	    return 7.5625 * t * t;
	  } else if (t < 2 / 2.75) {
	    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
	  } else if (t < 2.5 / 2.75) {
	    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
	  } else {
	    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
	  }
	};
	/**
	 * @method bounceInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.bounceInOut = function (t) {
	  if (t < 0.5) return Ease.bounceIn(t * 2) * .5;
	  return Ease.bounceOut(t * 2 - 1) * 0.5 + 0.5;
	};
	/**
	 * Configurable elastic ease.
	 * @method getElasticIn
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/


	Ease.getElasticIn = function (amplitude, period) {
	  var pi2 = Math.PI * 2;
	  return function (t) {
	    if (t == 0 || t == 1) return t;
	    var s = period / pi2 * Math.asin(1 / amplitude);
	    return -(amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));
	  };
	};
	/**
	 * @method elasticIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.elasticIn = Ease.getElasticIn(1, 0.3);
	/**
	 * Configurable elastic ease.
	 * @method getElasticOut
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/

	Ease.getElasticOut = function (amplitude, period) {
	  var pi2 = Math.PI * 2;
	  return function (t) {
	    if (t == 0 || t == 1) return t;
	    var s = period / pi2 * Math.asin(1 / amplitude);
	    return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1;
	  };
	};
	/**
	 * @method elasticOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.elasticOut = Ease.getElasticOut(1, 0.3);
	/**
	 * Configurable elastic ease.
	 * @method getElasticInOut
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/

	Ease.getElasticInOut = function (amplitude, period) {
	  var pi2 = Math.PI * 2;
	  return function (t) {
	    var s = period / pi2 * Math.asin(1 / amplitude);
	    if ((t *= 2) < 1) return -0.5 * (amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));
	    return amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * 0.5 + 1;
	  };
	};
	/**
	 * @method elasticInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.elasticInOut = Ease.getElasticInOut(1, 0.3 * 1.5);

	/**
	 * 补间动画控制器
	 * @param {*} app 播放器
	 */

	function TweenAnimator(app) {
	  PlayerComponent.call(this, app);
	}

	TweenAnimator.prototype = Object.create(PlayerComponent.prototype);
	TweenAnimator.prototype.constructor = TweenAnimator;

	TweenAnimator.prototype.create = function (scene, camera, renderer, animations) {
	  this.scene = scene;
	  this.animations = animations;
	  return new Promise(resolve => {
	    resolve();
	  });
	};

	TweenAnimator.prototype.update = function (clock, deltaTime, time) {
	  this.animations.forEach(n => {
	    n.animations.forEach(m => {
	      this.tweenObject(m, time);
	    });
	  });
	};

	TweenAnimator.prototype.tweenObject = function (animation, time) {
	  // 条件判断
	  if (animation.type !== 'Tween' || time < animation.beginTime || time > animation.endTime || !animation.target) {
	    return;
	  } // 获取对象


	  var target = this.scene.getObjectByProperty('uuid', animation.target);

	  if (!target) {
	    console.warn(`Player: There is no object that uuid equals to ${animation.target}.`);
	    return;
	  } // 获取插值函数


	  var data = animation.data;
	  var ease = Ease[data.ease];

	  if (!ease) {
	    console.warn(`Player: There is no ease function named ${data.ease}.`);
	    return;
	  }

	  var result = ease((time - animation.beginTime) / (animation.endTime - animation.beginTime));
	  var positionX = data.beginPositionX + (data.endPositionX - data.beginPositionX) * result;
	  var positionY = data.beginPositionY + (data.endPositionY - data.beginPositionY) * result;
	  var positionZ = data.beginPositionZ + (data.endPositionZ - data.beginPositionZ) * result;
	  var rotationX = data.beginRotationX + (data.endRotationX - data.beginRotationX) * result;
	  var rotationY = data.beginRotationY + (data.endRotationY - data.beginRotationY) * result;
	  var rotationZ = data.beginRotationZ + (data.endRotationZ - data.beginRotationZ) * result;
	  var scaleX = data.beginScaleX + (data.endScaleX - data.beginScaleX) * result;
	  var scaleY = data.beginScaleY + (data.endScaleY - data.beginScaleY) * result;
	  var scaleZ = data.beginScaleZ + (data.endScaleZ - data.beginScaleZ) * result;
	  target.position.x = positionX;
	  target.position.y = positionY;
	  target.position.z = positionZ;
	  target.rotation.x = rotationX;
	  target.rotation.y = rotationY;
	  target.rotation.z = rotationZ;
	  target.scale.x = scaleX;
	  target.scale.y = scaleY;
	  target.scale.z = scaleZ;
	};

	TweenAnimator.prototype.dispose = function () {
	  this.scene = null;
	  this.animations = null;
	};

	/**
	 * MMD动画控制器
	 * @param {*} app 播放器
	 */

	function MMDAnimator(app) {
	  PlayerComponent.call(this, app);
	  this.time = 0.0; // 当前动画播放时间

	  this.delayTime = 160 * 1 / 30; // 动画比音频提前执行时间
	}

	MMDAnimator.prototype = Object.create(PlayerComponent.prototype);
	MMDAnimator.prototype.constructor = MMDAnimator;

	MMDAnimator.prototype.create = function (scene, camera) {
	  var mmds = [];
	  scene.traverse(mesh => {
	    if (mesh.userData.Type === 'pmd' || mesh.userData.Type === 'pmx') {
	      mmds.push(mesh);
	    }
	  });

	  if (mmds.length === 0) {
	    return;
	  }

	  if (this.helper === undefined) {
	    this.helper = new THREE.MMDAnimationHelper();
	  }

	  var helper = this.helper;
	  mmds.forEach(mesh => {
	    let animation = mesh._animation;
	    let cameraAnimation = mesh._cameraAnimation;
	    let audio = mesh._audio;

	    if (animation) {
	      helper.add(mesh, {
	        animation: animation,
	        physics: true
	      });
	    } else {
	      helper.add(mesh, {
	        physics: true
	      });
	    }

	    if (cameraAnimation) {
	      helper.add(camera, {
	        animation: cameraAnimation
	      });
	    }

	    if (audio) {
	      var audioParams = {
	        delayTime: this.delayTime
	      };
	      helper.add(audio, audioParams);
	    }
	  });
	  this.time = 0.0;
	  return new Promise(resolve => {
	    resolve();
	  });
	};

	MMDAnimator.prototype.update = function (clock, deltaTime) {
	  if (!this.helper) {
	    return;
	  } // if (this.helper.audio) { // 如果有音频，使用音频时间比较准确
	  //     var currentTime = this.helper.audio.context.currentTime - this.helper.audio.startTime;
	  //     if (currentTime < this.delayTime) {
	  //         this.time += deltaTime;
	  //     } else {
	  //         var time = this.delayTime + currentTime;
	  //         deltaTime = time - this.time;
	  //         this.time = time;
	  //     }
	  // }


	  this.helper.update(deltaTime);
	};

	MMDAnimator.prototype.dispose = function () {
	  if (!this.helper) {
	    return;
	  }

	  var helper = this.helper;
	  helper.meshes.forEach(n => {
	    helper.remove(n);
	  });

	  if (helper.camera) {
	    helper.remove(helper.camera);
	  }

	  if (helper.audio) {
	    if (helper.audio.isPlaying) {
	      helper.audio.stop();
	    }

	    helper.remove(helper.audio);
	  }

	  delete this.helper;
	};

	/**
	 * 粒子动画控制器
	 * @param {*} app 播放器
	 */

	function ParticleAnimator(app) {
	  PlayerComponent.call(this, app);
	}

	ParticleAnimator.prototype = Object.create(PlayerComponent.prototype);
	ParticleAnimator.prototype.constructor = ParticleAnimator;

	ParticleAnimator.prototype.create = function (scene, camera, renderer) {
	  // eslint-disable-line
	  this.scene = scene;
	  return new Promise(resolve => {
	    resolve();
	  });
	};

	ParticleAnimator.prototype.update = function (clock, deltaTime, time) {
	  // eslint-disable-line
	  var elapsed = clock.elapsedTime;
	  this.scene.children.forEach(n => {
	    if (n.userData.type === 'Fire') {
	      n.userData.fire.update(elapsed);
	    } else if (n.userData.type === 'Smoke') {
	      n.update(elapsed);
	    } else if (n.userData.type === 'Water') {
	      n.update();
	    } else if (n.userData.type === 'ParticleEmitter') {
	      n.userData.group.tick(deltaTime);
	    } else if (n.userData.type === 'Cloth') {
	      n.update();
	    }
	  });
	};

	ParticleAnimator.prototype.dispose = function () {
	  this.scene = null;
	};

	/**
	 * 播放器动画
	 * @param {*} app 播放器
	 */

	function PlayerAnimation(app) {
	  PlayerComponent.call(this, app);
	  this.maxTime = 0; // 最大动画时间（单位：秒）

	  this.currentTime = 0; // 当前动画时间（单位：秒）

	  this.animations = null;
	  this.animators = [new TweenAnimator(app), new MMDAnimator(app), new ParticleAnimator(app)];
	}

	PlayerAnimation.prototype = Object.create(PlayerComponent.prototype);
	PlayerAnimation.prototype.constructor = PlayerAnimation;

	PlayerAnimation.prototype.create = function (scene, camera, renderer, animations) {
	  this.maxTime = 0;
	  this.currentTime = 0;
	  this.scene = scene;
	  this.camera = camera;
	  this.renderer = renderer;
	  this.animations = animations;
	  this.maxTime = this.calculateMaxTime();
	  var promises = this.animators.map(n => {
	    return n.create(scene, camera, renderer, animations);
	  });
	  return Promise.all(promises);
	};

	PlayerAnimation.prototype.calculateMaxTime = function () {
	  var maxTime = 0;
	  this.animations.forEach(n => {
	    n.animations.forEach(m => {
	      if (m.endTime > maxTime) {
	        maxTime = m.endTime;
	      }
	    });
	  });
	  return maxTime;
	};

	PlayerAnimation.prototype.update = function (clock, deltaTime) {
	  if (this.maxTime > 0) {
	    this.currentTime = clock.elapsedTime % this.maxTime;
	  }

	  this.animators.forEach(n => {
	    n.update(clock, deltaTime, this.currentTime);
	  });
	};

	PlayerAnimation.prototype.dispose = function () {
	  this.maxTime = 0;
	  this.currentTime = 0;
	  this.scene = null;
	  this.camera = null;
	  this.renderer = null;
	  this.animations = null;
	  this.animators.forEach(n => {
	    n.dispose();
	  });
	};

	/**
	 * 按z键扔球事件
	 * @param {*} app 播放器
	 * @param {*} world 物理世界
	 * @param {*} rigidBodies 刚体
	 */

	function ThrowBallEvent(app, world, rigidBodies) {
	  PlayerComponent.call(this, app);
	  this.world = world;
	  this.rigidBodies = rigidBodies;
	}

	ThrowBallEvent.prototype = Object.create(PlayerComponent.prototype);
	ThrowBallEvent.prototype.constructor = ThrowBallEvent;

	ThrowBallEvent.prototype.create = function (scene, camera, renderer) {
	  this.scene = scene;
	  this.camera = camera;
	  this.renderer = renderer;
	  this.renderer.domElement.addEventListener('click', this.throwBall.bind(this));
	};

	ThrowBallEvent.prototype.dispose = function () {
	  // TODO: 不判断有时报错，不知道为什么。
	  if (this.renderer) {
	    this.renderer.domElement.removeEventListener('click', this.throwBall);
	  }

	  this.scene = null;
	  this.camera = null;
	  this.renderer = null;
	};

	ThrowBallEvent.prototype.throwBall = function (event) {
	  if (!app.options.enableThrowBall) {
	    return;
	  }

	  var mouse = new THREE.Vector2();
	  var raycaster = new THREE.Raycaster();
	  var camera = this.camera;
	  var width = this.renderer.domElement.width;
	  var height = this.renderer.domElement.height;
	  mouse.set(event.offsetX / width * 2 - 1, -(event.offsetY / height) * 2 + 1);
	  raycaster.setFromCamera(mouse, camera); // Creates a ball and throws it

	  var ballMass = 3;
	  var ballRadius = 0.4;
	  var ballMaterial = new THREE.MeshPhongMaterial({
	    color: 0x202020
	  });
	  var ball = new THREE.Mesh(new THREE.SphereBufferGeometry(ballRadius, 14, 10), ballMaterial);
	  ball.castShadow = true;
	  ball.receiveShadow = true;
	  this.scene.add(ball);
	  var ballShape = new Ammo.btSphereShape(ballRadius);
	  var pos = new THREE.Vector3();
	  pos.copy(raycaster.ray.direction);
	  pos.add(raycaster.ray.origin);
	  var quat = new THREE.Quaternion();
	  quat.set(0, 0, 0, 1);
	  var body = this.createRigidBody(ball, ballShape, ballMass, pos, quat);
	  pos.copy(raycaster.ray.direction);
	  pos.multiplyScalar(20);
	  body.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));
	  body.setFriction(0.5);
	  ball.userData.physics = {
	    body: body
	  };
	  this.world.addRigidBody(body);
	  this.rigidBodies.push(ball);
	};

	ThrowBallEvent.prototype.createRigidBody = function (threeObject, physicsShape, mass, pos, quat) {
	  threeObject.position.copy(pos);
	  threeObject.quaternion.copy(quat);
	  var transform = new Ammo.btTransform();
	  transform.setIdentity();
	  transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
	  transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
	  var motionState = new Ammo.btDefaultMotionState(transform);
	  var localInertia = new Ammo.btVector3(0, 0, 0);
	  physicsShape.calculateLocalInertia(mass, localInertia);
	  var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
	  var body = new Ammo.btRigidBody(rbInfo);

	  if (mass > 0) {
	    body.setActivationState(4);
	  }

	  return body;
	};

	/**
	 * 播放器物理
	 * @param {*} app 播放器
	 */

	function PlayerPhysics(app) {
	  PlayerComponent.call(this, app);
	}

	PlayerPhysics.prototype = Object.create(PlayerComponent.prototype);
	PlayerPhysics.prototype.constructor = PlayerPhysics;

	PlayerPhysics.prototype.create = function (scene, camera, renderer) {
	  if (!this.app.options.enablePhysics) {
	    return;
	  }

	  var usePhysics = false;
	  this.scene = scene;
	  this.scene.traverse(n => {
	    if (n.userData && n.userData.physics && n.userData.physics.enabled) {
	      usePhysics = true;
	    }
	  }); // 未使用物理

	  if (!usePhysics) {
	    return new Promise(resolve => {
	      resolve();
	    });
	  }

	  this.initPhysicsWorld();
	  this.initScene(scene, camera, renderer);
	};

	PlayerPhysics.prototype.initPhysicsWorld = function () {
	  // 各种参数
	  var gravityConstant = -9.8; // 重力常数

	  this.margin = 0.05; // 两个物体之间最小间距
	  // 物理环境配置

	  var collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration(); // 软体刚体碰撞配置

	  var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration); // 碰撞调度器

	  var broadphase = new Ammo.btDbvtBroadphase(); // dbvt粗测

	  var solver = new Ammo.btSequentialImpulseConstraintSolver(); // 顺序脉冲约束求解器

	  var softBodySolver = new Ammo.btDefaultSoftBodySolver(); // 默认软体求解器

	  this.world = new Ammo.btSoftRigidDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
	  var gravity = new Ammo.btVector3(0, gravityConstant, 0);
	  this.world.setGravity(gravity);
	  this.world.getWorldInfo().set_m_gravity(gravity);
	  this.transformAux1 = new Ammo.btTransform();
	  this.rigidBodies = [];
	  this.softBodies = [];
	  this.softBodyHelpers = new Ammo.btSoftBodyHelpers();
	  this.events = [new ThrowBallEvent(app, this.world, this.rigidBodies)]; // api函数
	  // TODO: 很难受的实现

	  Object.assign(this.app, {
	    addPhysicsObject: this.addPhysicsObject.bind(this)
	  });
	};

	PlayerPhysics.prototype.initScene = function (scene, camera, renderer) {
	  let body;
	  this.scene.traverse(n => {
	    if (n.userData && n.userData.physics && n.userData.physics.enabled) {
	      if (n.userData.physics.type === 'rigidBody') {
	        body = this.createRigidBody(n);

	        if (body) {
	          n.userData.physics.body = body;
	          this.world.addRigidBody(body);

	          if (n.userData.physics.mass > 0) {
	            this.rigidBodies.push(n);
	            body.setActivationState(4);
	          }
	        }
	      } else if (n.userData.physics.type === 'softVolume') {
	        body = this.createSoftVolume(n);

	        if (body) {
	          n.userData.physics.body = body;
	          this.world.addSoftBody(body, 1, -1);
	          this.softBodies.push(n);

	          if (n.userData.physics.mass > 0) {
	            body.setActivationState(4);
	          }
	        }
	      } else {
	        console.warn(`PlayerPhysics: unknown physics type ${n.userData.physics.type}.`);
	      }
	    }
	  });
	  this.events.forEach(n => {
	    n.create(scene, camera, renderer);
	  });
	};

	PlayerPhysics.prototype.update = function (clock, deltaTime) {
	  if (!this.app.options.enablePhysics || !this.world) {
	    return;
	  }

	  this.world.stepSimulation(deltaTime, 10); // 更新柔软体

	  var softBodies = this.softBodies;
	  let i, il;

	  for (i = 0, il = softBodies.length; i < il; i++) {
	    var volume = softBodies[i];
	    var geometry = volume.geometry;
	    var body = volume.userData.physics.body;
	    var volumePositions = geometry.attributes.position.array;
	    var volumeNormals = geometry.attributes.normal.array;
	    var association = geometry.ammoIndexAssociation;
	    var numVerts = association.length;
	    var nodes = body.get_m_nodes();

	    for (var j = 0; j < numVerts; j++) {
	      var node = nodes.at(j);
	      var nodePos = node.get_m_x();
	      var x = nodePos.x();
	      var y = nodePos.y();
	      var z = nodePos.z();
	      var nodeNormal = node.get_m_n();
	      var nx = nodeNormal.x();
	      var ny = nodeNormal.y();
	      var nz = nodeNormal.z();
	      var assocVertex = association[j];

	      for (var k = 0, kl = assocVertex.length; k < kl; k++) {
	        var indexVertex = assocVertex[k];
	        volumePositions[indexVertex] = x;
	        volumeNormals[indexVertex] = nx;
	        indexVertex++;
	        volumePositions[indexVertex] = y;
	        volumeNormals[indexVertex] = ny;
	        indexVertex++;
	        volumePositions[indexVertex] = z;
	        volumeNormals[indexVertex] = nz;
	      }
	    }

	    geometry.attributes.position.needsUpdate = true;
	    geometry.attributes.normal.needsUpdate = true;
	  } // 更新刚体


	  var rigidBodies = this.rigidBodies;

	  for (i = 0, il = rigidBodies.length; i < il; i++) {
	    var objThree = rigidBodies[i];
	    var objPhys = objThree.userData.physics.body;

	    if (!objPhys) {
	      continue;
	    }

	    var ms = objPhys.getMotionState();

	    if (ms) {
	      ms.getWorldTransform(this.transformAux1);
	      var p = this.transformAux1.getOrigin();
	      var q = this.transformAux1.getRotation();
	      objThree.position.set(p.x(), p.y(), p.z());
	      objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
	    }
	  }

	  this.events.forEach(n => {
	    n.update(clock, deltaTime);
	  });
	};

	PlayerPhysics.prototype.dispose = function () {
	  if (!this.app.options.enablePhysics) {
	    return;
	  }

	  this.events && this.events.forEach(n => {
	    n.dispose();
	  });

	  if (this.rigidBodies) {
	    this.rigidBodies.forEach(n => {
	      var body = n.userData.physics.body;
	      this.world.removeRigidBody(body);
	    });
	    this.rigidBodies.length = 0;
	  }

	  if (this.softBodies) {
	    this.softBodies.forEach(n => {
	      var body = n.userData.physics.body;
	      this.world.removeRigidBody(body);
	    });
	    this.softBodies.length = 0;
	  }

	  this.scene.traverse(n => {
	    if (n.userData && n.userData.physics) {
	      n.userData.physics.body = null;
	    }
	  });
	  this.scene = null;
	}; // ------------------------------------ 创建刚体 ------------------------------------


	PlayerPhysics.prototype.createRigidBody = function (obj) {
	  var position = obj.position;
	  var quaternion = obj.quaternion;
	  var physics = obj.userData.physics;
	  var shape = physics.shape;
	  var mass = physics.mass;
	  var inertia = physics.inertia; // 形状

	  var physicsShape = null;
	  var geometry = null;

	  if (shape === 'btBoxShape') {
	    geometry = obj.geometry;
	    geometry.computeBoundingBox();
	    var box = geometry.boundingBox;
	    var x = box.max.x - box.min.x;
	    var y = box.max.y - box.min.y;
	    var z = box.max.z - box.min.z;
	    var center = new THREE.Vector3();
	    box.getCenter(center);
	    position = position.clone();
	    position.add(center);
	    physicsShape = new Ammo.btBoxShape(new Ammo.btVector3(x * 0.5, y * 0.5, z * 0.5));
	  } else if (shape === 'btSphereShape') {
	    geometry = obj.geometry;
	    geometry.computeBoundingSphere();
	    var sphere = geometry.boundingSphere;
	    physicsShape = new Ammo.btSphereShape(sphere.radius);
	  } else {
	    console.warn(`PlayerPhysics: cannot create shape ${shape}.`);
	    return null;
	  }

	  physicsShape.setMargin(0.05); // 位移

	  var transform = new Ammo.btTransform();
	  transform.setIdentity();
	  transform.setOrigin(new Ammo.btVector3(position.x, position.y, position.z));
	  transform.setRotation(new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));
	  var defaultState = new Ammo.btDefaultMotionState(transform);
	  var localInertia = new Ammo.btVector3(inertia.x, inertia.y, inertia.z);
	  physicsShape.calculateLocalInertia(mass, localInertia);
	  var info = new Ammo.btRigidBodyConstructionInfo(mass, defaultState, physicsShape, localInertia);
	  return new Ammo.btRigidBody(info);
	}; // --------------------------------- 创建柔软体 ---------------------------------------------


	PlayerPhysics.prototype.createSoftVolume = function (obj) {
	  var geometry = obj.geometry;
	  var mass = obj.userData.physics.mass;
	  var pressure = obj.userData.physics.pressure;
	  this.processGeometry(geometry);
	  var volume = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
	    color: 0xFFFFFF
	  }));
	  volume.castShadow = true;
	  volume.receiveShadow = true;
	  volume.frustumCulled = false; // Volume physic object

	  var body = this.softBodyHelpers.CreateFromTriMesh(this.world.getWorldInfo(), geometry.ammoVertices, geometry.ammoIndices, geometry.ammoIndices.length / 3, true);
	  var sbConfig = body.get_m_cfg();
	  sbConfig.set_viterations(40); // 设置迭代次数

	  sbConfig.set_piterations(40); // Soft-soft and soft-rigid碰撞

	  sbConfig.set_collisions(0x11); // 摩擦力(Friction)

	  sbConfig.set_kDF(0.1); // 减震(Damping)

	  sbConfig.set_kDP(0.01); // 压力(Pressure)

	  sbConfig.set_kPR(pressure); // 刚性(Stiffness)

	  body.get_m_materials().at(0).set_m_kLST(0.9);
	  body.get_m_materials().at(0).set_m_kAST(0.9);
	  body.setTotalMass(mass, false);
	  Ammo.castObject(body, Ammo.btCollisionObject).getCollisionShape().setMargin(0.05);
	  return body;
	};

	PlayerPhysics.prototype.processGeometry = function (bufGeometry) {
	  // Obtain a Geometry
	  var geometry = new THREE.Geometry().fromBufferGeometry(bufGeometry); // Merge the vertices so the triangle soup is converted to indexed triangles

	  geometry.mergeVertices(); // Convert again to BufferGeometry, indexed

	  var indexedBufferGeom = this.createIndexedBufferGeometryFromGeometry(geometry); // Create index arrays mapping the indexed vertices to bufGeometry vertices

	  this.mapIndices(bufGeometry, indexedBufferGeom);
	};

	PlayerPhysics.prototype.createIndexedBufferGeometryFromGeometry = function (geometry) {
	  var numVertices = geometry.vertices.length;
	  var numFaces = geometry.faces.length;
	  var bufferGeom = new THREE.BufferGeometry();
	  var vertices = new Float32Array(numVertices * 3);
	  var indices = new (numFaces * 3 > 65535 ? Uint32Array : Uint16Array)(numFaces * 3);
	  let i, i3;

	  for (i = 0; i < numVertices; i++) {
	    var p = geometry.vertices[i];
	    i3 = i * 3;
	    vertices[i3] = p.x;
	    vertices[i3 + 1] = p.y;
	    vertices[i3 + 2] = p.z;
	  }

	  for (i = 0; i < numFaces; i++) {
	    var f = geometry.faces[i];
	    i3 = i * 3;
	    indices[i3] = f.a;
	    indices[i3 + 1] = f.b;
	    indices[i3 + 2] = f.c;
	  }

	  bufferGeom.setIndex(new THREE.BufferAttribute(indices, 1));
	  bufferGeom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
	  return bufferGeom;
	};

	PlayerPhysics.prototype.mapIndices = function (bufGeometry, indexedBufferGeom) {
	  // Creates ammoVertices, ammoIndices and ammoIndexAssociation in bufGeometry
	  var vertices = bufGeometry.attributes.position.array;
	  var idxVertices = indexedBufferGeom.attributes.position.array;
	  var indices = indexedBufferGeom.index.array;
	  var numIdxVertices = idxVertices.length / 3;
	  var numVertices = vertices.length / 3;
	  bufGeometry.ammoVertices = idxVertices;
	  bufGeometry.ammoIndices = indices;
	  bufGeometry.ammoIndexAssociation = [];

	  for (var i = 0; i < numIdxVertices; i++) {
	    var association = [];
	    bufGeometry.ammoIndexAssociation.push(association);
	    var i3 = i * 3;

	    for (var j = 0; j < numVertices; j++) {
	      var j3 = j * 3;

	      if (this.isEqual(idxVertices[i3], idxVertices[i3 + 1], idxVertices[i3 + 2], vertices[j3], vertices[j3 + 1], vertices[j3 + 2])) {
	        association.push(j3);
	      }
	    }
	  }
	};

	PlayerPhysics.prototype.isEqual = function (x1, y1, z1, x2, y2, z2) {
	  var delta = 0.000001;
	  return Math.abs(x2 - x1) < delta && Math.abs(y2 - y1) < delta && Math.abs(z2 - z1) < delta;
	}; // --------------------------------- API函数 ------------------------------------------------

	/**
	 * 添加一个物理物体
	 * @param {*} obj 物体
	 */


	PlayerPhysics.prototype.addPhysicsObject = function (obj) {
	  this.scene.add(obj);
	  let body = null;

	  if (obj.userData && obj.userData.physics && obj.userData.physics.enabled) {
	    if (obj.userData.physics.type === 'rigidBody') {
	      body = this.createRigidBody(obj);

	      if (body) {
	        obj.userData.physics.body = body;
	        this.world.addRigidBody(body);

	        if (obj.userData.physics.mass > 0) {
	          this.rigidBodies.push(obj);
	          body.setActivationState(4);
	        }
	      }
	    } else if (obj.userData.physics.type === 'softVolume') {
	      body = this.createSoftVolume(obj);

	      if (body) {
	        obj.userData.physics.body = body;
	        this.world.addSoftBody(body);
	        this.softBodies.push(obj);
	      }
	    }
	  }
	};

	/**
	 * CSS工具类
	 */
	var CssUtils = {
	  /**
	   * 序列化滤镜
	   * @param {Object} filters 滤镜对象
	   * @returns {String} CSS数据
	   */
	  serializeFilter: function (filters) {
	    var _filters = Object.assign({}, {
	      hueRotate: filters.hueRotate || 0,
	      saturate: filters.saturate === undefined ? 1 : filters.saturate,
	      brightness: filters.brightness === undefined ? 1 : filters.brightness,
	      blur: filters.blur || 0,
	      contrast: filters.contrast === undefined ? 1 : filters.contrast,
	      grayscale: filters.grayscale || 0,
	      invert: filters.invert || 0,
	      sepia: filters.sepia || 0
	    });

	    return `hue-rotate(${_filters.hueRotate}deg) saturate(${_filters.saturate}) brightness(${_filters.brightness}) ` + `blur(${_filters.blur}px) contrast(${_filters.contrast}) grayscale(${_filters.grayscale}) invert(${_filters.invert}) sepia(${_filters.sepia})`;
	  },

	  /**
	   * 反序列化滤镜
	   * @param {String} str css滤镜字符串
	   * @returns {Object} 滤镜对象
	   */
	  parseFilter: function (str) {
	    var list = str.split(' ');
	    var filters = {
	      hueRotate: 0,
	      saturate: 1,
	      brightness: 1,
	      blur: 0,
	      contrast: 1,
	      grayscale: 0,
	      invert: 0,
	      sepia: 0
	    };
	    list.forEach(n => {
	      if (n.startsWith('hue-rotate')) {
	        // 色调
	        filters.hueRotate = parseFloat(n.substring(11, n.length - 4));
	      } else if (n.startsWith('saturate')) {
	        // 饱和度
	        filters.saturate = parseFloat(n.substring(9, n.length - 1));
	      } else if (n.startsWith('brightness')) {
	        // 亮度
	        filters.brightness = parseFloat(n.substring(11, n.length - 1));
	      } else if (n.startsWith('blur')) {
	        // 模糊
	        filters.blur = parseFloat(n.substring(5, n.length - 3));
	      } else if (n.startsWith('contrast')) {
	        // 对比度
	        filters.contrast = parseFloat(n.substring(9, n.length - 1));
	      } else if (n.startsWith('grayscale')) {
	        filters.grayscale = parseFloat(n.substring(10, n.length - 1));
	      } else if (n.startsWith('invert')) {
	        // 颜色反转
	        filters.invert = parseFloat(n.substring(7, n.length - 1));
	      } else if (n.startsWith('sepia')) {
	        // 复古
	        filters.sepia = parseFloat(n.substring(6, n.length - 1));
	      }
	    });
	    return filters;
	  }
	};

	// import Visualization from '../visual/Visualization';

	/**
	 * 播放器
	 * @author mrdoob / http://mrdoob.com/
	 * @author tengge / https://github.com/tengge1
	 * @param {HTMLElement} container 容器
	 * @param {Object} options 配置信息
	 * @param {String} options.server 服务器信息，例如：http://localhost:2000
	 * @param {Boolean} options.enableThrowBall 是否允许扔小球进行物理测试
	 * @param {Boolean} options.showStats 是否显示性能控件
	 */

	function Player(container = document.body, options = {}) {
	  this.container = container;
	  this.options = options;
	  this.options.server = this.options.server || window.origin;
	  this.options.enablePhysics = false; // 这个配置在场景里

	  this.options.enableThrowBall = false;
	  this.options.showStats = this.options.showStats || false;
	  this.dispatch = new dispatch('init', 'resize');
	  this.call = this.dispatch.call.bind(this.dispatch);
	  this.on = this.dispatch.on.bind(this.dispatch); // 性能控件

	  if (this.options.showStats) {
	    this.stats = new Stats();
	    Object.assign(this.stats.dom.style, {
	      position: 'absolute',
	      left: '8px',
	      top: '8px',
	      zIndex: 'initial'
	    });
	    container.appendChild(this.stats.dom);
	  }

	  window.addEventListener('resize', this.onResize.bind(this));
	  var observer = new MutationObserver(this.onResize.bind(this));
	  observer.observe(this.container, {
	    attributes: true,
	    characterData: false,
	    childList: false
	  });
	  this.scene = null;
	  this.camera = null;
	  this.renderer = null;
	  this.gis = null;
	  this.package = new PackageManager();
	  this.require = this.package.require.bind(this.package);
	  this.loader = new PlayerLoader(this);
	  this.event = new PlayerEvent(this);
	  this.control = new PlayerControl(this);
	  this.audio = new PlayerAudio(this);
	  this.playerRenderer = new PlayerRenderer(this);
	  this.animation = new PlayerAnimation(this);
	  this.physics = new PlayerPhysics(this);
	  this.isPlaying = false;
	  this.clock = new THREE.Clock(false); // 保证播放器在不加载语言包的情况下正常运行

	  if (!window._t) {
	    window._t = function (data) {
	      return data;
	    };
	  }
	}
	/**
	 * 启动播放器
	 * @param {String} sceneData 场景数据
	 */


	Player.prototype.start = function (sceneData) {
	  if (typeof sceneData !== 'string') {
	    app.toast(_t('Scene data of string type is needed.'));
	    return;
	  }

	  var jsons;

	  try {
	    jsons = JSON.parse(sceneData);
	  } catch (e) {
	    app.toast(_t('Cannot deserialize scene data.'), 'error');
	    return;
	  }

	  if (this.isPlaying) {
	    return;
	  }

	  this.isPlaying = true;
	  this.container.style.display = 'block';
	  this.loader.create(jsons, {
	    domWidth: this.container.clientWidth,
	    domHeight: this.container.clientHeight
	  }).then(obj => {
	    this.initPlayer(obj);
	    this.dispatch.call('init', this);
	    var promise1 = this.event.create(this.scene, this.camera, this.renderer, obj.scripts);
	    var promise2 = this.control.create(this.scene, this.camera, this.renderer);
	    var promise3 = this.audio.create(this.scene, this.camera, this.renderer);
	    var promise4 = this.playerRenderer.create(this.scene, this.camera, this.renderer);
	    var promise5 = this.animation.create(this.scene, this.camera, this.renderer, obj.animations);
	    var promise6 = this.physics.create(this.scene, this.camera, this.renderer);
	    Promise.all([promise1, promise2, promise3, promise4, promise5, promise6]).then(() => {
	      this.event.init();
	      this.clock.start();
	      this.event.start();
	      requestAnimationFrame(this.animate.bind(this));
	    });
	  });
	};
	/**
	 * 停止播放器
	 */


	Player.prototype.stop = function () {
	  if (!this.isPlaying) {
	    return;
	  }

	  this.isPlaying = false;
	  this.event.stop();
	  this.loader.dispose();
	  this.event.dispose();
	  this.control.dispose();
	  this.audio.dispose();
	  this.animation.dispose();
	  this.physics.dispose(); // if (this.gis) {
	  //     this.gis.dispose();
	  //     this.gis = null;
	  // }

	  this.playerRenderer.dispose();
	  this.container.removeChild(this.renderer.domElement);
	  this.container.style.display = 'none';
	  this.scene.children.length = 0;
	  this.scene = null;
	  this.camera = null;
	  this.renderer = null;
	  this.clock.stop();
	};
	/**
	 * 初始化播放器
	 * @param {*} obj 场景数据
	 */


	Player.prototype.initPlayer = function (obj) {
	  var container = this.container; // options

	  this.options.enablePhysics = obj.options.enablePhysics; // camera

	  this.camera = obj.camera;

	  if (!this.camera) {
	    console.warn(`Player: Three is no camera in the scene.`);
	    this.camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
	  } // renderer


	  this.renderer = obj.renderer || new THREE.WebGLRenderer({
	    antialias: true,alpha:true 
	  });
	  this.renderer.setSize(container.clientWidth, container.clientHeight);
	  container.appendChild(this.renderer.domElement);
	  this.camera.aspect = this.renderer.domElement.width / this.renderer.domElement.height;
	  this.camera.updateProjectionMatrix();
	  var listener = obj.audioListener || new THREE.AudioListener();
	  this.camera.add(listener);
	  this.renderer.domElement.style.filter = CssUtils.serializeFilter(obj.options); // scene

	  this.scene = obj.scene || new THREE.Scene(); // if (obj.options.sceneType === 'GIS') {
	  //     this.gis = new Globe(this.camera, this.renderer, Object.assign({}, obj.options, {
	  //         useCameraPosition: true
	  //     }));
	  // }
	  // 可视化
	  // if (obj.visual) {
	  //     this.visual.fromJSON(obj.visual);
	  // } else {
	  //     this.visual.clear();
	  // }
	  // this.visual.render(this.svg);
	};

	Player.prototype.animate = function () {
	  if (!this.isPlaying) {
	    return;
	  }

	  if (this.stats) {
	    this.stats.begin();
	  }

	  this.clock._getDelta(); // see: ../polyfills.js


	  var deltaTime = this.clock.getDelta();
	  this.event.update(this.clock, deltaTime);
	  this.control.update(this.clock, deltaTime);
	  this.playerRenderer.update(this.clock, deltaTime);
	  this.animation.update(this.clock, deltaTime);
	  this.physics.update(this.clock, deltaTime); // if (this.gis) {
	  //     this.gis.update();
	  // }

	  if (this.stats) {
	    this.stats.end();
	  }

	  requestAnimationFrame(this.animate.bind(this));
	};

	Player.prototype.resize = function () {
	  if (!this.camera || !this.renderer) {
	    return;
	  }

	  var width = this.container.clientWidth;
	  var height = this.container.clientHeight;
	  var camera = this.camera;
	  var renderer = this.renderer;
	  camera.aspect = width / height;
	  camera.updateProjectionMatrix();
	  renderer.domElement;
	  renderer.setSize(width, height);
	};

	Player.prototype.onResize = function () {
	  this.resize();
	};

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	/**
	 * 画布
	 * @author tengge / https://github.com/tengge1
	 */

	class Canvas extends React.Component {
	  constructor(props) {
	    super(props);
	    this.dom = React.createRef();
	  }

	  render() {
	    const {
	      className,
	      style,
	      ...others
	    } = this.props;
	    return /*#__PURE__*/React.createElement("canvas", _extends({
	      className: bind('Canvas', className),
	      style: style,
	      ref: this.dom
	    }, others));
	  }

	}

	Canvas.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object
	};
	Canvas.defaultProps = {
	  className: null,
	  style: null
	};

	/**
	 * 折叠面板
	 * @author tengge / https://github.com/tengge1
	 */
	class Accordion extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 很多按钮
	 * @author tengge / https://github.com/tengge1
	 */
	class Buttons extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 列
	 * @author tengge / https://github.com/tengge1
	 */
	class Column extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 内容
	 * @author tengge / https://github.com/tengge1
	 */
	class Content extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 一项
	 * @author tengge / https://github.com/tengge1
	 */
	class Item extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 菜单
	 * @author tengge / https://github.com/tengge1
	 */
	class Menu extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 行
	 * @author tengge / https://github.com/tengge1
	 */
	class Row extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 很多行
	 * @author tengge / https://github.com/tengge1
	 */
	class Rows extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 按钮
	 * @author tengge / https://github.com/tengge1
	 */

	class Button extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      color,
	      disabled,
	      show
	    } = this.props;
	    return /*#__PURE__*/React.createElement("button", {
	      className: bind('Button', color, disabled && 'disabled', !show && 'hidden', className),
	      style: style,
	      disabled: disabled,
	      onClick: this.handleClick
	    }, children);
	  }

	  handleClick(event) {
	    const {
	      name,
	      disabled,
	      onClick
	    } = this.props;
	    !disabled && onClick && onClick(name, event);
	  }

	}

	Button.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  children: propTypes.node,
	  color: propTypes.oneOf(['primary', 'success', 'warn', 'danger']),
	  disabled: propTypes.bool,
	  show: propTypes.bool,
	  onClick: propTypes.func
	};
	Button.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  children: null,
	  color: null,
	  disabled: false,
	  show: true,
	  onClick: null
	};

	/**
	 * 复选框
	 * @author tengge / https://github.com/tengge1
	 */

	class CheckBox extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      checked,
	      disabled
	    } = this.props;
	    return /*#__PURE__*/React.createElement("input", {
	      type: 'checkbox',
	      className: bind('CheckBox', checked && 'checked', disabled && 'disabled', className),
	      style: style,
	      checked: checked,
	      disabled: disabled,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(event) {
	    const {
	      name,
	      onChange
	    } = this.props;
	    onChange && onChange(event.target.checked, name, event);
	  }

	}

	CheckBox.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  checked: propTypes.bool,
	  disabled: propTypes.bool,
	  onChange: propTypes.func
	};
	CheckBox.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  checked: false,
	  disabled: false,
	  onChange: null
	};

	/**
	 * 表单
	 * @author tengge / https://github.com/tengge1
	 */

	class Form extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleSubmit = this.handleSubmit.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      direction
	    } = this.props;
	    return /*#__PURE__*/React.createElement("form", {
	      className: bind('Form', direction, className),
	      style: style,
	      onSubmit: this.handleSubmit
	    }, children);
	  }

	  handleSubmit() {
	    const {
	      onSubmit
	    } = this.props;
	    event.preventDefault();
	    onSubmit && onSubmit();
	  }

	}

	Form.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  direction: propTypes.oneOf(['horizontal', 'vertical']),
	  onSubmit: propTypes.func
	};
	Form.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  direction: 'horizontal',
	  onSubmit: null
	};

	/**
	 * 表单项
	 * @author tengge / https://github.com/tengge1
	 */

	class FormControl extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      hidden
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('FormControl', className, hidden && 'hidden'),
	      style: style
	    }, children);
	  }

	}

	FormControl.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  hidden: propTypes.bool
	};
	FormControl.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  hidden: false
	};

	/**
	 * 图标按钮
	 * @author tengge / https://github.com/tengge1
	 */

	class IconButton extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      icon,
	      title,
	      show,
	      selected,
	      disabled
	    } = this.props;
	    return /*#__PURE__*/React.createElement("button", {
	      className: bind('IconButton', selected && 'selected', !show && 'hidden', disabled && 'disabled', className),
	      style: style,
	      title: title,
	      onClick: this.handleClick
	    }, /*#__PURE__*/React.createElement("i", {
	      className: bind('iconfont', icon && 'icon-' + icon)
	    }));
	  }

	  handleClick(event) {
	    const {
	      name,
	      disabled,
	      onClick
	    } = this.props;
	    !disabled && onClick && onClick(name, event);
	  }

	}

	IconButton.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  icon: propTypes.string,
	  name: propTypes.string,
	  title: propTypes.string,
	  show: propTypes.bool,
	  selected: propTypes.bool,
	  disabled: propTypes.bool,
	  onClick: propTypes.func
	};
	IconButton.defaultProps = {
	  className: null,
	  style: null,
	  icon: null,
	  name: null,
	  title: null,
	  show: true,
	  selected: false,
	  disabled: false,
	  onClick: null
	};

	/**
	 * 带下拉菜单的图标按钮
	 * @author tengge / https://github.com/tengge1
	 */

	class IconMenuButton extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      icon,
	      title,
	      show,
	      selected
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('IconMenuButton', selected && 'selected', !show && 'hidden', className),
	      style: style
	    }, /*#__PURE__*/React.createElement("button", {
	      className: 'button',
	      title: title,
	      onClick: this.handleClick
	    }, /*#__PURE__*/React.createElement("i", {
	      className: bind('iconfont', icon && 'icon-' + icon)
	    })), /*#__PURE__*/React.createElement("div", {
	      className: 'menu'
	    }, children));
	  }

	  handleClick(event) {
	    const {
	      name,
	      onClick
	    } = this.props;
	    onClick && onClick(name, event);
	  }

	}

	IconMenuButton.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  icon: propTypes.string,
	  name: propTypes.string,
	  title: propTypes.string,
	  show: propTypes.bool,
	  selected: propTypes.bool,
	  onClick: propTypes.func
	};
	IconMenuButton.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  icon: null,
	  name: null,
	  title: null,
	  show: true,
	  selected: false,
	  onClick: null
	};

	/**
	 * 图片按钮
	 * @author tengge / https://github.com/tengge1
	 */

	class ImageButton extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      src,
	      title,
	      selected
	    } = this.props;
	    return /*#__PURE__*/React.createElement("button", {
	      className: bind('ImageButton', selected && 'selected', className),
	      style: style,
	      title: title,
	      onClick: this.handleClick
	    }, /*#__PURE__*/React.createElement("img", {
	      src: src
	    }));
	  }

	  handleClick(event) {
	    const {
	      name,
	      onClick
	    } = this.props;
	    onClick && onClick(name, event);
	  }

	}

	ImageButton.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  src: propTypes.string,
	  name: propTypes.string,
	  title: propTypes.string,
	  selected: propTypes.bool,
	  onClick: propTypes.func
	};
	ImageButton.defaultProps = {
	  className: null,
	  style: null,
	  src: null,
	  name: null,
	  title: null,
	  selected: false,
	  onClick: null
	};

	/**
	 * 输入框
	 * @author tengge / https://github.com/tengge1
	 */

	class Input extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleFocus = this.handleFocus.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handleInput = this.handleInput.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      type,
	      value,
	      min,
	      max,
	      step,
	      show,
	      disabled,
	      accept
	    } = this.props;
	    let val = value === undefined || value === null ? '' : value;
	    return /*#__PURE__*/React.createElement("input", {
	      className: bind('Input', !show && 'hidden', className),
	      style: style,
	      type: type,
	      value: val,
	      min: min,
	      max: max,
	      step: step,
	      disabled: disabled,
	      accept: accept,
	      autoComplete: 'off',
	      onFocus: this.handleFocus,
	      onChange: this.handleChange,
	      onInput: this.handleInput
	    });
	  }

	  handleFocus(event) {
	    const {
	      onFocus
	    } = this.props;
	    onFocus && onFocus(event);
	  }

	  handleChange(event) {
	    const {
	      name,
	      type,
	      onChange
	    } = this.props;
	    const value = event.target.value;

	    if (type === 'number') {
	      if (value.trim() !== '') {
	        const precision = this.props.precision;

	        if (precision === 0) {
	          onChange && onChange(parseInt(value), name, event);
	        } else {
	          onChange && onChange(parseInt(parseFloat(value) * 10 ** precision) / 10 ** precision, name, event);
	        }
	      } else {
	        onChange && onChange(null, name, event);
	      }
	    } else {
	      onChange && onChange(value, name, event);
	    }
	  }

	  handleInput(event) {
	    const {
	      name,
	      type,
	      onInput
	    } = this.props;
	    const value = event.target.value;

	    if (type === 'number') {
	      if (value.trim() !== '') {
	        onInput && onInput(parseFloat(value), name, event);
	      } else {
	        onInput && onInput(null, name, event);
	      }
	    } else {
	      onInput && onInput(value, name, event);
	    }
	  }

	}

	Input.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  type: propTypes.oneOf(['text', 'number', 'color', 'password', 'file']),
	  value: propTypes.oneOfType([propTypes.string, propTypes.number]),
	  min: propTypes.number,
	  max: propTypes.number,
	  step: propTypes.number,
	  precision: propTypes.number,
	  disabled: propTypes.bool,
	  accept: propTypes.string,
	  show: propTypes.bool,
	  onFocus: propTypes.func,
	  onChange: propTypes.func,
	  onInput: propTypes.func
	};
	Input.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  type: 'text',
	  value: '',
	  min: null,
	  max: null,
	  step: null,
	  precision: 3,
	  disabled: false,
	  accept: null,
	  show: true,
	  onFocus: null,
	  onChange: null,
	  onInput: null
	};

	/**
	 * 标签
	 * @author tengge / https://github.com/tengge1
	 */

	class Label extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      id
	    } = this.props;
	    return /*#__PURE__*/React.createElement("label", {
	      className: bind('Label', className),
	      style: style,
	      id: id
	    }, children);
	  }

	}

	Label.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  id: propTypes.string
	};
	Label.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  id: null
	};

	/**
	 * 链接按钮
	 * @author tengge / https://github.com/tengge1
	 */

	class LinkButton extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      disabled
	    } = this.props;
	    return /*#__PURE__*/React.createElement("a", {
	      className: bind('LinkButton', disabled && 'disabled', className),
	      style: style,
	      href: 'javascript:;',
	      disabled: disabled,
	      onClick: this.handleClick
	    }, children);
	  }

	  handleClick(event) {
	    const {
	      disabled,
	      onClick
	    } = this.props;
	    !disabled && onClick && onClick(this.props.name, event);
	  }

	}

	LinkButton.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  children: propTypes.node,
	  disabled: propTypes.bool,
	  onClick: propTypes.func
	};
	LinkButton.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  children: null,
	  disabled: false,
	  onClick: null
	};

	/**
	 * 单选框
	 * @author tengge / https://github.com/tengge1
	 */

	class Radio extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      checked,
	      disabled
	    } = this.props;
	    return /*#__PURE__*/React.createElement("input", {
	      type: 'radio',
	      className: bind('Radio', checked && 'checked', disabled && 'disabled', className),
	      style: style,
	      checked: checked,
	      disabled: disabled,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(event) {
	    const {
	      name,
	      onChange
	    } = this.props;
	    onChange && onChange(event.target.checked, name, event);
	  }

	}

	Radio.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  checked: propTypes.bool,
	  disabled: propTypes.bool,
	  onChange: propTypes.func
	};
	Radio.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  checked: false,
	  disabled: false,
	  onChange: null
	};

	/**
	 * 搜索框
	 * @author tengge / https://github.com/tengge1
	 */

	class SearchField extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      value: props.value,
	      categories: [],
	      filterShow: false
	    };
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handleInput = this.handleInput.bind(this);
	    this.handleReset = this.handleReset.bind(this);
	    this.handleShowFilter = this.handleShowFilter.bind(this);
	    this.handleHideFilter = this.handleHideFilter.bind(this);
	    this.handleCheckBoxChange = this.handleCheckBoxChange.bind(this);
	    this.stopPropagation = this.stopPropagation.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      data,
	      placeholder,
	      showAddButton,
	      showFilterButton
	    } = this.props;
	    const {
	      value,
	      categories,
	      filterShow
	    } = this.state;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('SearchField', className),
	      onClick: this.stopPropagation
	    }, showAddButton && /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'add',
	      onClick: this.handleAdd
	    }), /*#__PURE__*/React.createElement("input", {
	      className: 'input',
	      style: style,
	      placeholder: placeholder,
	      value: value,
	      onChange: this.handleChange,
	      onInput: this.handleInput,
	      onKeyDown: this.handleKeyDown
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'close',
	      onClick: this.handleReset
	    }), showFilterButton && /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'filter',
	      className: bind(filterShow && 'selected'),
	      onClick: this.handleShowFilter
	    }), showFilterButton && /*#__PURE__*/React.createElement("div", {
	      className: bind('category', !filterShow && 'hidden')
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'item',
	      key: ''
	    }, /*#__PURE__*/React.createElement(CheckBox, {
	      name: '',
	      checked: categories.indexOf('') > -1,
	      onChange: this.handleCheckBoxChange
	    }), /*#__PURE__*/React.createElement("label", {
	      className: 'title'
	    }, _t('No Type'))), data.map(n => {
	      return /*#__PURE__*/React.createElement("div", {
	        className: 'item',
	        key: n.ID
	      }, /*#__PURE__*/React.createElement(CheckBox, {
	        name: n.ID,
	        checked: categories.indexOf(n.ID) > -1,
	        onChange: this.handleCheckBoxChange
	      }), /*#__PURE__*/React.createElement("label", {
	        className: 'title'
	      }, n.Name));
	    })));
	  }

	  componentDidMount() {
	    document.addEventListener(`click`, this.handleHideFilter);
	  }

	  handleAdd(event) {
	    const {
	      onAdd
	    } = this.props;
	    onAdd && onAdd(event);
	  }

	  handleChange(event) {
	    const {
	      onChange
	    } = this.props;
	    event.stopPropagation();
	    const value = event.target.value;
	    this.setState({
	      value
	    });
	    onChange && onChange(value, this.state.categories, event);
	  }

	  handleInput(event) {
	    const {
	      onInput
	    } = this.props;
	    event.stopPropagation();
	    const value = event.target.value;
	    this.setState({
	      value
	    });
	    onInput && onInput(value, this.state.categories, event);
	  }

	  handleReset(event) {
	    const {
	      onInput,
	      onChange
	    } = this.props;
	    const value = '';
	    this.setState({
	      value
	    });
	    onInput && onInput(value, this.state.categories, event);
	    onChange && onChange(value, this.state.categories, event);
	  }

	  handleShowFilter() {
	    this.setState({
	      filterShow: !this.state.filterShow
	    });
	  }

	  handleHideFilter() {
	    this.setState({
	      filterShow: false
	    });
	  }

	  handleCheckBoxChange(checked, name, event) {
	    const {
	      onInput,
	      onChange
	    } = this.props;
	    let categories = this.state.categories;
	    let index = categories.indexOf(name);

	    if (checked && index === -1) {
	      categories.push(name);
	    } else if (!checked && index > -1) {
	      categories.splice(index, 1);
	    } else {
	      console.warn(`SearchField: handleCheckBoxChange error.`);
	      return;
	    }

	    const value = this.state.value;
	    this.setState({
	      categories
	    }, () => {
	      onInput && onInput(value, categories, event);
	      onChange && onChange(value, categories, event);
	    });
	  }

	  stopPropagation(event) {
	    event.nativeEvent.stopImmediatePropagation();
	  }

	}

	SearchField.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  value: propTypes.string,
	  data: propTypes.array,
	  placeholder: propTypes.string,
	  showAddButton: propTypes.bool,
	  showFilterButton: propTypes.bool,
	  onAdd: propTypes.func,
	  onChange: propTypes.func,
	  onInput: propTypes.func
	};
	SearchField.defaultProps = {
	  className: null,
	  style: null,
	  value: '',
	  data: [],
	  placeholder: 'Enter a keyword',
	  showAddButton: false,
	  showFilterButton: false,
	  onAdd: null,
	  onChange: null,
	  onInput: null
	};

	/**
	 * 输入框
	 * @author tengge / https://github.com/tengge1
	 */

	class Select extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      options,
	      value,
	      disabled
	    } = this.props;
	    return /*#__PURE__*/React.createElement("select", {
	      className: bind('Select', className),
	      style: style,
	      value: value,
	      disabled: disabled,
	      onChange: this.handleChange
	    }, options && Object.keys(options).map(n => {
	      return /*#__PURE__*/React.createElement("option", {
	        value: n,
	        key: n
	      }, options[n]);
	    }));
	  }

	  handleChange(event) {
	    const {
	      onChange
	    } = this.props;
	    const selectedIndex = event.target.selectedIndex;

	    if (selectedIndex === -1) {
	      onChange && onChange(null, event);
	      return;
	    }

	    const value = event.target.options[selectedIndex].value; // 注意：options的key一定是字符串，所以value也一定是字符串

	    onChange && onChange(value, this.props.name, event);
	  }

	}

	Select.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  options: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.oneOfType([propTypes.string, propTypes.number]),
	  disabled: propTypes.bool,
	  onChange: propTypes.func
	};
	Select.defaultProps = {
	  className: null,
	  style: null,
	  options: null,
	  name: null,
	  value: null,
	  disabled: false,
	  onChange: null
	};

	/**
	 * 文本域
	 * @author tengge / https://github.com/tengge1
	 */

	class TextArea extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this);
	    this.handleInput = this.handleInput.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      value
	    } = this.props;
	    return /*#__PURE__*/React.createElement("textarea", {
	      className: bind('TextArea', className),
	      style: style,
	      value: value,
	      onChange: this.handleChange,
	      onInput: this.handleInput
	    });
	  }

	  handleChange(event) {
	    const {
	      onChange
	    } = this.props;
	    onChange && onChange(event.target.value, this.props.name, event);
	  }

	  handleInput(event) {
	    const {
	      onInput
	    } = this.props;
	    onInput && onInput(event.target.value, this.props.name, event);
	  }

	}

	TextArea.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.string,
	  onChange: propTypes.func,
	  onInput: propTypes.func
	};
	TextArea.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: '',
	  onChange: null,
	  onInput: null
	};

	/**
	 * 开关
	 * @author tengge / https://github.com/tengge1
	 */

	class Toggle extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      checked,
	      disabled
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('Toggle', checked && 'checked', disabled && 'disabled', className),
	      style: style,
	      onClick: disabled ? null : this.handleChange
	    });
	  }

	  handleChange(event) {
	    const {
	      onChange
	    } = this.props;
	    var checked = event.target.classList.contains('checked');
	    onChange && onChange(!checked, this.props.name, event);
	  }

	}

	Toggle.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  checked: propTypes.bool,
	  disabled: propTypes.bool,
	  onChange: propTypes.func
	};
	Toggle.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  checked: false,
	  disabled: false,
	  onChange: null
	};

	/**
	 * 图标
	 * @author tengge / https://github.com/tengge1
	 */

	class Icon extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value,
	      icon,
	      title
	    } = this.props;
	    return /*#__PURE__*/React.createElement("i", {
	      className: bind('Icon', 'iconfont', icon && 'icon-' + icon, className),
	      style: style,
	      name: name,
	      value: value,
	      title: title,
	      onClick: this.handleClick
	    });
	  }

	  handleClick(event) {
	    const {
	      onClick
	    } = this.props;
	    const name = event.target.getAttribute('name');
	    onClick && onClick(name, event);
	  }

	}

	Icon.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.string,
	  icon: propTypes.string,
	  title: propTypes.string,
	  onClick: propTypes.func
	};
	Icon.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: null,
	  icon: null,
	  title: null,
	  onClick: null
	};

	/**
	 * 图片
	 * @author tengge / https://github.com/tengge1
	 */

	class Image$1 extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleError = this.handleError.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      src,
	      title
	    } = this.props;
	    return /*#__PURE__*/React.createElement("img", {
	      className: bind('Image', className),
	      style: style,
	      src: src,
	      title: title,
	      onError: this.handleError
	    });
	  }

	  handleError(event) {
	    let target = event.target;
	    let parent = target.parentNode;
	    parent.removeChild(target);
	    let img = document.createElement('div');
	    img.className = 'no-img';
	    let icon = document.createElement('i');
	    icon.className = 'Icon iconfont icon-scenes';
	    img.appendChild(icon);
	    let title = parent.children[0];
	    parent.insertBefore(img, title);
	  }

	}

	Image$1.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  src: propTypes.string,
	  title: propTypes.string
	};
	Image$1.defaultProps = {
	  className: null,
	  style: null,
	  src: null,
	  title: null
	};

	/**
	 * 图片列表
	 * @author tengge / https://github.com/tengge1
	 */

	class ImageList extends React.Component {
	  constructor(props) {
	    super(props);
	    const {
	      onClick,
	      onEdit,
	      onDelete
	    } = props;
	    this.state = {
	      pageSize: 10,
	      pageNum: 0
	    };
	    this.handleFirstPage = this.handleFirstPage.bind(this);
	    this.handleLastPage = this.handleLastPage.bind(this);
	    this.handlePreviousPage = this.handlePreviousPage.bind(this);
	    this.handleNextPage = this.handleNextPage.bind(this);
	    this.handleClick = this.handleClick.bind(this, onClick);
	    this.handleEdit = this.handleEdit.bind(this, onEdit);
	    this.handleDelete = this.handleDelete.bind(this, onDelete);
	    this.handleError = this.handleError.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      data,
	      showEditButton,
	      showDeleteButton
	    } = this.props;
	    const {
	      pageSize,
	      pageNum
	    } = this.state;
	    const totalPage = this.getTotalPage();
	    const current = data.filter((n, i) => {
	      return i >= pageSize * pageNum && i < pageSize * (pageNum + 1);
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('ImageList', className),
	      style: style
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'content'
	    }, current.map(n => {
	      return /*#__PURE__*/React.createElement("div", {
	        className: 'item',
	        name: n.id,
	        key: n.id,
	        onClick: this.handleClick
	      }, n.src ? /*#__PURE__*/React.createElement("img", {
	        className: 'img',
	        src: n.src,
	        onError: this.handleError
	      }) : /*#__PURE__*/React.createElement("div", {
	        className: 'no-img'
	      }, /*#__PURE__*/React.createElement(Icon, {
	        icon: n.icon
	      })), /*#__PURE__*/React.createElement("div", {
	        className: 'title'
	      }, n.title), n.cornerText && /*#__PURE__*/React.createElement("div", {
	        className: 'cornerText'
	      }, n.cornerText), showEditButton && n.showEditButton !== false && /*#__PURE__*/React.createElement(IconButton, {
	        className: 'edit',
	        icon: 'edit',
	        name: n.id,
	        onClick: this.handleEdit
	      }), showDeleteButton && n.showDeleteButton !== false && /*#__PURE__*/React.createElement(IconButton, {
	        className: 'delete',
	        icon: 'delete',
	        name: n.id,
	        onClick: this.handleDelete
	      }));
	    })), /*#__PURE__*/React.createElement("div", {
	      className: 'page'
	    }, /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'backward',
	      title: _t('First Page'),
	      onClick: this.handleFirstPage
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'left-triangle2',
	      title: _t('Previous Page'),
	      onClick: this.handlePreviousPage
	    }), /*#__PURE__*/React.createElement(Input, {
	      className: 'current',
	      value: (pageNum + 1).toString(),
	      title: _t('Current Page'),
	      disabled: true
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'right-triangle2',
	      title: _t('Next Page'),
	      onClick: this.handleNextPage
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'forward',
	      title: _t('Last Page'),
	      onClick: this.handleLastPage
	    }), /*#__PURE__*/React.createElement("div", {
	      className: 'info'
	    }, _t('Total {{totalPage}} Pages', {
	      totalPage: totalPage
	    }))));
	  }

	  handleFirstPage() {
	    this.setState({
	      pageNum: 0
	    });
	  }

	  handleLastPage() {
	    const totalPage = this.getTotalPage();
	    this.setState({
	      pageNum: totalPage < 1 ? 0 : totalPage - 1
	    });
	  }

	  handleNextPage() {
	    this.setState(state => {
	      const totalPage = this.getTotalPage();
	      return {
	        pageNum: state.pageNum < totalPage - 1 ? state.pageNum + 1 : totalPage - 1
	      };
	    });
	  }

	  handlePreviousPage() {
	    this.setState(state => {
	      return {
	        pageNum: state.pageNum > 0 ? state.pageNum - 1 : 0
	      };
	    });
	  }

	  handleClick(onClick, event) {
	    event.stopPropagation();
	    const id = event.target.getAttribute('name');
	    const data = this.props.data.filter(n => n.id === id)[0];
	    onClick && onClick(data, event);
	  }

	  handleEdit(onEdit, name, event) {
	    event.stopPropagation();
	    const data = this.props.data.filter(n => n.id === name)[0];
	    onEdit && onEdit(data, event);
	  }

	  handleDelete(onDelete, name, event) {
	    event.stopPropagation();
	    const data = this.props.data.filter(n => n.id === name)[0];
	    onDelete && onDelete(data, event);
	  }

	  handleError(event) {
	    let target = event.target;
	    let parent = target.parentNode;
	    parent.removeChild(target);
	    let img = document.createElement('div');
	    img.className = 'no-img';
	    let icon = document.createElement('i');
	    icon.className = 'Icon iconfont icon-scenes';
	    img.appendChild(icon);
	    let title = parent.children[0];
	    parent.insertBefore(img, title);
	  }

	  getTotalPage() {
	    const total = this.props.data.length;
	    const pageSize = this.state.pageSize;
	    return total % pageSize === 0 ? total / pageSize : parseInt(total / pageSize) + 1;
	  }

	}

	ImageList.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  data: propTypes.array,
	  showEditButton: propTypes.bool,
	  showDeleteButton: propTypes.bool,
	  onClick: propTypes.func,
	  onEdit: propTypes.func,
	  onDelete: propTypes.func
	};
	ImageList.defaultProps = {
	  className: null,
	  style: null,
	  data: [],
	  showEditButton: true,
	  showDeleteButton: true,
	  onClick: null,
	  onEdit: null,
	  onDelete: null
	};

	/**
	 * 图片选取控件
	 * @author tengge / https://github.com/tengge1
	 */

	class ImageSelector extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      value,
	      noImageText
	    } = this.props;

	    if (value) {
	      return /*#__PURE__*/React.createElement("img", {
	        className: bind('ImageSelector', className),
	        style: style,
	        src: value,
	        onClick: this.handleSelect
	      });
	    } else {
	      return /*#__PURE__*/React.createElement("div", {
	        className: bind('ImageSelector', 'empty', className),
	        style: style,
	        onClick: this.handleSelect
	      }, noImageText);
	    }
	  }

	  componentDidMount() {
	    var input = document.createElement('input');
	    input.type = 'file';
	    input.style.display = 'none';
	    input.addEventListener('change', this.handleChange);
	    document.body.appendChild(input);
	    this.input = input;
	  }

	  componentWillUnmount() {
	    var input = this.input;
	    input.removeEventListener('change', this.handleChange);
	    document.body.removeChild(input);
	    this.input = null;
	  }

	  handleSelect() {
	    this.input.click();
	  }

	  handleChange(event) {
	    const {
	      name,
	      onChange
	    } = this.props;
	    onChange && onChange(name, event.target.files[0], event);
	  }

	}

	ImageSelector.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.any,
	  noImageText: propTypes.string,
	  onChange: propTypes.func
	};
	ImageSelector.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: null,
	  noImageText: 'No Image',
	  onChange: null
	};

	/**
	 * 图片上传控件
	 * @author tengge / https://github.com/tengge1
	 */

	class ImageUploader extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      url,
	      server,
	      noImageText
	    } = this.props;

	    if (url && url !== 'null') {
	      return /*#__PURE__*/React.createElement("img", {
	        className: bind('ImageUploader', className),
	        style: style,
	        src: server + url,
	        onClick: this.handleSelect
	      });
	    } else {
	      return /*#__PURE__*/React.createElement("div", {
	        className: bind('ImageUploader', 'empty', className),
	        onClick: this.handleSelect
	      }, noImageText);
	    }
	  }

	  componentDidMount() {
	    var input = document.createElement('input');
	    input.type = 'file';
	    input.style.display = 'none';
	    input.addEventListener('change', this.handleChange);
	    document.body.appendChild(input);
	    this.input = input;
	  }

	  componentWillUnmount() {
	    var input = this.input;
	    input.removeEventListener('change', this.handleChange);
	    document.body.removeChild(input);
	    this.input = null;
	  }

	  handleSelect() {
	    this.input.click();
	  }

	  handleChange(event) {
	    const {
	      onChange
	    } = this.props;
	    onChange && onChange(event.target.files[0], event);
	  }

	}

	ImageUploader.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  url: propTypes.string,
	  server: propTypes.string,
	  noImageText: propTypes.string,
	  onChange: propTypes.func
	};
	ImageUploader.defaultProps = {
	  className: null,
	  style: null,
	  url: null,
	  server: '',
	  noImageText: 'No Image',
	  onChange: null
	};

	/**
	 * 绝对定位布局
	 * @author tengge / https://github.com/tengge1
	 */

	class AbsoluteLayout extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      left,
	      top,
	      ...others
	    } = this.props;
	    const position = {
	      left: left || 0,
	      top: top || 0
	    };
	    return /*#__PURE__*/React.createElement("div", _extends({
	      className: bind('AbsoluteLayout', className),
	      style: style ? Object.assign({}, style, position) : position
	    }, others), children);
	  }

	}

	AbsoluteLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  left: propTypes.string,
	  top: propTypes.string
	};
	AbsoluteLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  left: '0',
	  top: '0'
	};

	/**
	 * 单个折叠面板
	 * @private
	 * @author tengge / https://github.com/tengge1
	 */

	class AccordionPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      maximized: props.maximized
	    };
	    this.handleClick = this.handleClick.bind(this, props.onClick, props.index, props.name);
	    this.handleMaximize = this.handleMaximize.bind(this, props.onMaximize);
	  }

	  handleClick(onClick, index, name, event) {
	    onClick && onClick(index, name, event);
	  }

	  handleMaximize(onMaximize, event) {
	    this.setState(state => ({
	      maximized: !state.maximized
	    }));
	    onMaximize && onMaximize(event);
	  }

	  render() {
	    const {
	      title,
	      className,
	      style,
	      children,
	      show,
	      total,
	      collpased,
	      maximizable
	    } = this.props;
	    const maximizeControl = maximizable && /*#__PURE__*/React.createElement("div", {
	      className: 'control',
	      onClick: this.handleMaximize
	    }, this.state.maximized ? /*#__PURE__*/React.createElement("i", {
	      className: 'iconfont icon-minimize'
	    }) : /*#__PURE__*/React.createElement("i", {
	      className: 'iconfont icon-maximize'
	    }));

	    const _style = collpased ? style : Object.assign({}, style, {
	      height: `calc(100% - ${26 * (total - 1)}px`
	    });

	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('AccordionPanel', this.state.maximized && 'maximized', collpased && 'collpased', !show && 'hidden', className),
	      style: _style
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'header',
	      onClick: this.handleClick
	    }, /*#__PURE__*/React.createElement("span", {
	      className: "title"
	    }, title), /*#__PURE__*/React.createElement("div", {
	      className: "controls"
	    }, maximizeControl)), /*#__PURE__*/React.createElement("div", {
	      className: 'body'
	    }, children));
	  }

	}

	AccordionPanel.propTypes = {
	  name: propTypes.string,
	  title: propTypes.string,
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  show: propTypes.bool,
	  total: propTypes.number,
	  index: propTypes.number,
	  collpased: propTypes.bool,
	  maximizable: propTypes.bool,
	  maximized: propTypes.bool,
	  onMaximize: propTypes.bool,
	  onClick: propTypes.func
	};
	AccordionPanel.defaultProps = {
	  name: null,
	  title: null,
	  className: null,
	  style: null,
	  children: null,
	  show: true,
	  total: 1,
	  index: 0,
	  collpased: true,
	  maximizable: false,
	  maximized: false,
	  onMaximize: null,
	  onClick: null
	};

	/**
	 * 折叠布局
	 * @author tengge / https://github.com/tengge1
	 */

	class AccordionLayout extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      activeIndex: props.activeIndex
	    };
	    this.handleClick = this.handleClick.bind(this);
	  }

	  handleClick(index, name, event) {
	    const {
	      onActive
	    } = this.props;
	    onActive && onActive(index, name, event);
	    this.setState({
	      activeIndex: index
	    });
	  }

	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    const content = (Array.isArray(children) ? children : [children]).filter(n => n);
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('AccordionLayout', className),
	      style: style
	    }, content.map((n, i) => {
	      return /*#__PURE__*/React.createElement(AccordionPanel, {
	        name: n.props.name,
	        title: n.props.title,
	        show: n.props.show,
	        total: content.length,
	        index: i,
	        collpased: i !== this.state.activeIndex,
	        maximizable: n.props.maximizable,
	        onClick: this.handleClick,
	        key: i
	      }, n.props.children);
	    }));
	  }

	}

	AccordionLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  activeIndex: propTypes.number,
	  onActive: propTypes.func
	};
	AccordionLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  activeIndex: 0,
	  onActive: null
	};

	/**
	 * 边框布局
	 * @author tengge / https://github.com/tengge1
	 */

	class BorderLayout extends React.Component {
	  constructor(props) {
	    super(props);
	    const children = this.props.children;
	    const north = children && children.filter(n => n && n.props.region === 'north')[0];
	    const south = children && children.filter(n => n && n.props.region === 'south')[0];
	    const west = children && children.filter(n => n && n.props.region === 'west')[0];
	    const east = children && children.filter(n => n && n.props.region === 'east')[0];
	    const northSplit = north && north.props.split || false;
	    const southSplit = south && south.props.split || false;
	    const westSplit = west && west.props.split || false;
	    const eastSplit = east && east.props.split || false;
	    const northCollapsed = north && north.props.collapsed || false;
	    const southCollapsed = south && south.props.collapsed || false;
	    const westCollapsed = west && west.props.collapsed || false;
	    const eastCollapsed = east && east.props.collapsed || false;
	    const onNorthToggle = north && north.props.onToggle || null;
	    const onSouthToggle = south && south.props.onToggle || null;
	    const onWestToggle = west && west.props.onToggle || null;
	    const onEastToggle = east && east.props.onToggle || null;
	    this.northRef = React.createRef();
	    this.southRef = React.createRef();
	    this.westRef = React.createRef();
	    this.eastRef = React.createRef();
	    this.state = {
	      northSplit,
	      southSplit,
	      westSplit,
	      eastSplit,
	      northCollapsed,
	      southCollapsed,
	      westCollapsed,
	      eastCollapsed
	    };
	    this.handleNorthClick = this.handleNorthClick.bind(this, onNorthToggle);
	    this.handleSouthClick = this.handleSouthClick.bind(this, onSouthToggle);
	    this.handleWestClick = this.handleWestClick.bind(this, onWestToggle);
	    this.handleEastClick = this.handleEastClick.bind(this, onEastToggle);
	    this.handleTransitionEnd = this.handleTransitionEnd.bind(this, onNorthToggle, onSouthToggle, onWestToggle, onEastToggle);
	  }

	  handleNorthClick() {
	    if (!this.state.northSplit) {
	      return;
	    }

	    this.setState(state => {
	      const collapsed = !state.northCollapsed;
	      const dom = this.northRef.current;
	      const height = dom.clientHeight;

	      if (collapsed) {
	        dom.style.marginTop = `-${height - 8}px`;
	      } else {
	        dom.style.marginTop = null;
	      }

	      return {
	        northCollapsed: collapsed
	      };
	    });
	  }

	  handleSouthClick() {
	    if (!this.state.southSplit) {
	      return;
	    }

	    this.setState(state => {
	      const collapsed = !state.southCollapsed;
	      const dom = this.southRef.current;
	      const height = dom.clientHeight;

	      if (collapsed) {
	        dom.style.marginBottom = `-${height - 8}px`;
	      } else {
	        dom.style.marginBottom = null;
	      }

	      return {
	        southCollapsed: collapsed
	      };
	    });
	  }

	  handleWestClick() {
	    if (!this.state.westSplit) {
	      return;
	    }

	    const dom = this.westRef.current;
	    this.setState(state => {
	      const collapsed = !state.westCollapsed;
	      const width = dom.clientWidth;

	      if (collapsed) {
	        dom.style.marginLeft = `-${width - 8}px`;
	      } else {
	        dom.style.marginLeft = null;
	      }

	      return {
	        westCollapsed: collapsed
	      };
	    });
	  }

	  handleEastClick() {
	    if (!this.state.eastSplit) {
	      return;
	    }

	    this.setState(state => {
	      const collapsed = !state.eastCollapsed;
	      const dom = this.eastRef.current;
	      const width = dom.clientWidth;

	      if (collapsed) {
	        dom.style.marginRight = `-${width - 8}px`;
	      } else {
	        dom.style.marginRight = null;
	      }

	      return {
	        eastCollapsed: collapsed
	      };
	    });
	  }

	  handleTransitionEnd(onNorthToggle, onSouthToggle, onWestToggle, onEastToggle, event) {
	    const region = event.target.getAttribute('region');

	    switch (region) {
	      case 'north':
	        onNorthToggle && onNorthToggle(!this.state.northCollapsed);
	        break;

	      case 'south':
	        onSouthToggle && onSouthToggle(!this.state.southCollapsed);
	        break;

	      case 'west':
	        onWestToggle && onWestToggle(!this.state.westCollapsed);
	        break;

	      case 'east':
	        onEastToggle && onEastToggle(!this.state.eastCollapsed);
	        break;
	    }
	  }

	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    let north = [],
	        south = [],
	        west = [],
	        east = [],
	        center = [],
	        others = [];
	    children && children.forEach(n => {
	      if (!n) {
	        return;
	      }

	      switch (n.props.region) {
	        case 'north':
	          north.push(n);
	          break;

	        case 'south':
	          south.push(n);
	          break;

	        case 'west':
	          west.push(n);
	          break;

	        case 'east':
	          east.push(n);
	          break;

	        case 'center':
	          center.push(n);
	          break;

	        default:
	          others.push(n);
	          break;
	      }
	    });

	    if (center.length === 0) {
	      console.warn(`BorderLayout: center region is not defined.`);
	    } // north region


	    const northRegion = north.length > 0 && /*#__PURE__*/React.createElement("div", {
	      className: bind('north', this.state.northSplit && 'split', this.state.northCollapsed && 'collapsed', north.every(n => n.props.show === false) && 'hidden'),
	      region: 'north',
	      onTransitionEnd: this.handleTransitionEnd,
	      ref: this.northRef
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'content'
	    }, north), this.state.northSplit && /*#__PURE__*/React.createElement("div", {
	      className: 'control'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'button',
	      onClick: this.handleNorthClick
	    }))); // south region

	    const southRegion = south.length > 0 && /*#__PURE__*/React.createElement("div", {
	      className: bind('south', this.state.northSplit && 'split', this.state.southCollapsed && 'collapsed', south.every(n => n.props.show === false) && 'hidden'),
	      region: 'south',
	      onTransitionEnd: this.handleTransitionEnd,
	      ref: this.southRef
	    }, this.state.southSplit && /*#__PURE__*/React.createElement("div", {
	      className: 'control'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'button',
	      onClick: this.handleSouthClick
	    })), /*#__PURE__*/React.createElement("div", {
	      className: 'content'
	    }, south)); // west region

	    const westRegion = west.length > 0 && /*#__PURE__*/React.createElement("div", {
	      className: bind('west', this.state.westSplit && 'split', this.state.westCollapsed && 'collapsed', west.every(n => n.props.show === false) && 'hidden'),
	      region: 'west',
	      onTransitionEnd: this.handleTransitionEnd,
	      ref: this.westRef
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'content'
	    }, west), this.state.westSplit && /*#__PURE__*/React.createElement("div", {
	      className: 'control'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'button',
	      onClick: this.handleWestClick
	    }))); // east region

	    const eastRegion = east.length > 0 && /*#__PURE__*/React.createElement("div", {
	      className: bind('east', this.state.eastSplit && 'split', this.state.eastCollapsed && 'collapsed', east.every(n => n.props.show === false) && 'hidden'),
	      region: 'east',
	      onTransitionEnd: this.handleTransitionEnd,
	      ref: this.eastRef
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'control'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'button',
	      onClick: this.handleEastClick
	    })), /*#__PURE__*/React.createElement("div", {
	      className: 'content'
	    }, east)); // center region

	    const centerRegion = center.length > 0 && /*#__PURE__*/React.createElement("div", {
	      className: 'center'
	    }, center);
	    const otherRegion = others.length > 0 && others;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('BorderLayout', className),
	      style: style
	    }, northRegion, /*#__PURE__*/React.createElement("div", {
	      className: 'middle'
	    }, westRegion, centerRegion, eastRegion), southRegion, otherRegion);
	  }

	}

	BorderLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	BorderLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 水平布局
	 * @author tengge / https://github.com/tengge1
	 */

	class HBoxLayout extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", _extends({
	      className: bind('HBoxLayout', className),
	      style: style
	    }, others), children);
	  }

	}

	HBoxLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	HBoxLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 选项卡布局
	 * @author tengge / https://github.com/tengge1
	 */

	class TabLayout extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onActiveTabChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      activeTabIndex
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('TabLayout', className),
	      style: style
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'tabs'
	    }, React.Children.map(children, (n, i) => {
	      return /*#__PURE__*/React.createElement("div", {
	        className: bind('tab', i === activeTabIndex ? 'selected' : null),
	        key: i,
	        tbindex: i,
	        onClick: this.handleClick
	      }, n.props.title);
	    })), /*#__PURE__*/React.createElement("div", {
	      className: 'contents'
	    }, React.Children.map(children, (n, i) => {
	      return /*#__PURE__*/React.createElement("div", {
	        className: bind('content', i === activeTabIndex ? 'show' : null),
	        key: i
	      }, n);
	    })));
	  }

	  handleClick(onActiveTabChange, event) {
	    const index = event.target.getAttribute('tbindex');
	    onActiveTabChange && onActiveTabChange(parseInt(index), event.target, event);
	  }

	}

	TabLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  activeTabIndex: propTypes.number,
	  onActiveTabChange: propTypes.func
	};
	TabLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  activeTabIndex: 0,
	  onActiveTabChange: null
	};

	/**
	 * 竖直布局
	 * @author tengge / https://github.com/tengge1
	 */

	class VBoxLayout extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", _extends({
	      className: bind('VBoxLayout', className),
	      style: style
	    }, others), children);
	  }

	}

	VBoxLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	VBoxLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 上下文菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class ContextMenu extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    return /*#__PURE__*/React.createElement("ul", {
	      className: bind('ContextMenu', className),
	      style: style
	    }, children);
	  }

	}

	ContextMenu.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	ContextMenu.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 菜单栏
	 * @author tengge / https://github.com/tengge1
	 */

	class MenuBar extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return /*#__PURE__*/React.createElement("ul", _extends({
	      className: bind('MenuBar', className),
	      style: style
	    }, others), children);
	  }

	}

	MenuBar.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	MenuBar.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 菜单栏填充
	 * @author tengge / https://github.com/tengge1
	 */

	class MenuBarFiller extends React.Component {
	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    return /*#__PURE__*/React.createElement("li", {
	      className: bind('MenuItem', 'MenuBarFiller', className),
	      style: style
	    });
	  }

	}

	MenuBarFiller.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object
	};
	MenuBarFiller.defaultProps = {
	  className: null,
	  style: null
	};

	/**
	 * 菜单项
	 * @author tengge / https://github.com/tengge1
	 */

	class MenuItem extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	  }

	  render() {
	    const {
	      title,
	      className,
	      style,
	      children,
	      show,
	      checked,
	      selected,
	      disabled
	    } = this.props;
	    const subMenu = React.Children.count(children) ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
	      className: 'suffix'
	    }, /*#__PURE__*/React.createElement("i", {
	      className: 'iconfont icon-right-triangle'
	    })), /*#__PURE__*/React.createElement("div", {
	      className: 'sub'
	    }, /*#__PURE__*/React.createElement("ul", {
	      className: 'wrap'
	    }, children))) : null;
	    return /*#__PURE__*/React.createElement("li", {
	      className: bind('MenuItem', checked !== undefined && 'checked', selected !== undefined && 'selected', disabled && 'disabled', !show && 'hidden', className),
	      style: style,
	      onClick: this.handleClick
	    }, (checked !== undefined || selected !== undefined) && /*#__PURE__*/React.createElement("div", {
	      className: bind('prefix', (checked || selected) && 'on')
	    }), /*#__PURE__*/React.createElement("span", null, title), subMenu);
	  }

	  handleClick(onClick, event) {
	    event.stopPropagation();

	    if (!event.target.classList.contains('disabled')) {
	      onClick && onClick(this.props.name, event);
	    }
	  }

	}

	MenuItem.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  name: propTypes.string,
	  title: propTypes.string,
	  show: propTypes.bool,
	  checked: propTypes.bool,
	  selected: propTypes.bool,
	  disabled: propTypes.bool,
	  onClick: propTypes.func
	};
	MenuItem.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  name: null,
	  title: null,
	  show: true,
	  checked: undefined,
	  selected: undefined,
	  disabled: false,
	  onClick: null
	};

	/**
	 * 菜单项分隔符
	 * @author tengge / https://github.com/tengge1
	 */

	class MenuItemSeparator extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      direction,
	      show
	    } = this.props;
	    return /*#__PURE__*/React.createElement("li", {
	      className: bind('MenuItemSeparator', direction && direction, !show && 'hidden', className),
	      style: style
	    }, /*#__PURE__*/React.createElement("div", {
	      className: "separator"
	    }));
	  }

	}

	MenuItemSeparator.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  direction: propTypes.oneOf(['horizontal', 'vertical']),
	  show: propTypes.bool
	};
	MenuItemSeparator.defaultProps = {
	  className: null,
	  style: null,
	  direction: 'vertical',
	  show: true
	};

	/**
	 * 菜单选项卡
	 * @author tengge / https://github.com/tengge1
	 */

	class MenuTab extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      selected,
	      show,
	      disabled
	    } = this.props;
	    return /*#__PURE__*/React.createElement("li", {
	      className: bind('MenuTab', selected && 'selected', disabled && 'disabled', !show && 'hidden', className),
	      style: style,
	      onClick: this.handleClick
	    }, children);
	  }

	  handleClick(onClick, event) {
	    event.stopPropagation();

	    if (!event.target.classList.contains('disabled')) {
	      onClick && onClick(this.props.name, event);
	    }
	  }

	}

	MenuTab.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  name: propTypes.string,
	  selected: propTypes.bool,
	  show: propTypes.bool,
	  disabled: propTypes.bool,
	  onClick: propTypes.func
	};
	MenuTab.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  name: null,
	  selected: false,
	  show: true,
	  disabled: false,
	  onClick: null
	};

	/**
	 * 面板
	 * @author tengge / https://github.com/tengge1
	 */

	class Panel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      collapsed: props.collapsed,
	      maximized: props.maximized,
	      closed: props.closed
	    };
	    this.handleCollapse = this.handleCollapse.bind(this, props.onCollapse);
	    this.handleMaximize = this.handleMaximize.bind(this, props.onMaximize);
	    this.handleClose = this.handleClose.bind(this, props.onClose);
	  }

	  handleCollapse(onCollapse, event) {
	    this.setState(state => ({
	      collapsed: !state.collapsed
	    }));
	    onCollapse && onCollapse(event);
	  }

	  handleMaximize(onMaximize, event) {
	    this.setState(state => ({
	      maximized: !state.maximized
	    }));
	    onMaximize && onMaximize(event);
	  }

	  handleClose(onClose, event) {
	    this.setState(state => ({
	      closed: !state.closed
	    }));
	    onClose && onClose(event);
	  }

	  render() {
	    const {
	      title,
	      className,
	      style,
	      children,
	      show,
	      header,
	      collapsible,
	      maximizable,
	      closable
	    } = this.props;
	    const collapseControl = collapsible && /*#__PURE__*/React.createElement("div", {
	      className: 'control',
	      onClick: this.handleCollapse
	    }, this.state.collapsed ? /*#__PURE__*/React.createElement("i", {
	      className: 'iconfont icon-down-arrow'
	    }) : /*#__PURE__*/React.createElement("i", {
	      className: 'iconfont icon-up-arrow'
	    }));
	    const maximizeControl = maximizable && /*#__PURE__*/React.createElement("div", {
	      className: 'control',
	      onClick: this.handleMaximize
	    }, this.state.maximized ? /*#__PURE__*/React.createElement("i", {
	      className: 'iconfont icon-minimize'
	    }) : /*#__PURE__*/React.createElement("i", {
	      className: 'iconfont icon-maximize'
	    }));
	    const closeControl = closable && /*#__PURE__*/React.createElement("div", {
	      className: 'control',
	      onClick: this.handleClose
	    }, /*#__PURE__*/React.createElement("i", {
	      className: 'iconfont icon-close-thin'
	    }));
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('Panel', this.state.maximized && 'maximized', this.state.collapsed && 'collapsed', this.state.closed && 'hidden', !show && 'hidden', className),
	      style: style
	    }, /*#__PURE__*/React.createElement("div", {
	      className: bind('header', header ? null : 'hidden')
	    }, /*#__PURE__*/React.createElement("span", {
	      className: "title"
	    }, title), /*#__PURE__*/React.createElement("div", {
	      className: "controls"
	    }, collapseControl, maximizeControl, closeControl)), /*#__PURE__*/React.createElement("div", {
	      className: 'body'
	    }, children));
	  }

	}

	Panel.propTypes = {
	  title: propTypes.string,
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  show: propTypes.bool,
	  header: propTypes.bool,
	  collapsible: propTypes.bool,
	  collapsed: propTypes.bool,
	  onCollapse: propTypes.func,
	  maximizable: propTypes.bool,
	  maximized: propTypes.bool,
	  onMaximize: propTypes.bool,
	  closable: propTypes.bool,
	  closed: propTypes.bool,
	  onClose: propTypes.func
	};
	Panel.defaultProps = {
	  title: null,
	  className: null,
	  style: null,
	  children: null,
	  show: true,
	  header: true,
	  collapsible: false,
	  collapsed: false,
	  onCollapse: null,
	  maximizable: false,
	  maximized: false,
	  onMaximize: null,
	  closable: false,
	  closed: false,
	  onClose: null
	};

	/**
	 * 加载动画
	 * @author tengge / https://github.com/tengge1
	 */

	class LoadMask extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    const {
	      className,
	      style,
	      show,
	      text
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('LoadMask', className, !show && 'hidden'),
	      style: style
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'box'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'msg'
	    }, text)));
	  }

	}

	LoadMask.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool,
	  text: propTypes.string
	};
	LoadMask.defaultProps = {
	  className: null,
	  style: null,
	  show: true,
	  text: 'Waiting...'
	};

	/**
	 * 属性表
	 * @author tengge / https://github.com/tengge1
	 */

	class PropertyGrid extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('PropertyGrid', className),
	      style: style
	    }, children);
	  }

	}

	PropertyGrid.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	PropertyGrid.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 属性组
	 * @author tengge / https://github.com/tengge1
	 */

	class PropertyGroup extends React.Component {
	  constructor(props) {
	    super(props);
	    this.contentRef = React.createRef();
	    this.handleExpand = this.handleExpand.bind(this, props.onExpand);
	  }

	  render() {
	    const {
	      style,
	      children,
	      title,
	      show,
	      expanded
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('PropertyGroup', !show && 'hidden'),
	      style: style
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'head',
	      expanded: expanded ? 'true' : 'false',
	      onClick: this.handleExpand
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'icon'
	    }, /*#__PURE__*/React.createElement("i", {
	      className: expanded ? 'icon-expand' : 'icon-collapse'
	    })), /*#__PURE__*/React.createElement("div", {
	      className: 'title'
	    }, title)), /*#__PURE__*/React.createElement("div", {
	      className: bind('content', !expanded && 'collapsed'),
	      ref: this.contentRef
	    }, React.Children.map(children, (n, i) => {
	      if (n.props.show === false) {
	        return null;
	      }

	      let typeName = n.type.name;

	      if (typeName.indexOf('$') > -1) {
	        typeName = typeName.split('$')[0];
	      }

	      return /*#__PURE__*/React.createElement("div", {
	        className: bind('property', typeName),
	        key: i
	      }, /*#__PURE__*/React.createElement("div", {
	        className: 'label'
	      }, n.props.label), /*#__PURE__*/React.createElement("div", {
	        className: 'field'
	      }, n));
	    })));
	  }

	  componentDidUpdate() {
	    let content = this.contentRef.current;
	    let height = 0;

	    for (let i = 0; i < content.children.length; i++) {
	      let child = content.children[i];
	      height += child.offsetHeight; // offsetHeight包含下边框
	    }

	    content.style.height = `${height}px`;
	  }

	  handleExpand(onExpand, event) {
	    const expanded = event.target.getAttribute('expanded') === 'true';
	    onExpand && onExpand(!expanded, event);
	  }

	}

	PropertyGroup.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  title: propTypes.string,
	  show: propTypes.bool,
	  expanded: propTypes.bool,
	  onExpand: propTypes.func
	};
	PropertyGroup.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  title: 'Group',
	  show: true,
	  expanded: true,
	  onExpand: null
	};

	/**
	 * 展示属性
	 * @author tengge / https://github.com/tengge1
	 */

	class DisplayProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	  }

	  render() {
	    const {
	      className,
	      style,
	      value,
	      btnShow,
	      btnText
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('wrap', className),
	      style: style
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'label'
	    }, value), btnShow && /*#__PURE__*/React.createElement(Button, {
	      className: 'button',
	      onClick: this.handleClick
	    }, btnText));
	  }

	  handleClick(onClick, name, event) {
	    onClick && onClick(this.props.name, event);
	  }

	}

	DisplayProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.string,
	  btnShow: propTypes.bool,
	  btnText: propTypes.string,
	  onClick: propTypes.func
	};
	DisplayProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: 'name',
	  value: '',
	  btnShow: false,
	  btnText: 'Button',
	  onClick: null
	};

	/**
	 * 文本属性
	 * @author tengge / https://github.com/tengge1
	 */

	class TextProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value
	    } = this.props;
	    return /*#__PURE__*/React.createElement(Input, {
	      className: bind('input', className),
	      style: style,
	      name: name,
	      value: value,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    onChange && onChange(value, name, event);
	  }

	}

	TextProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.string,
	  onChange: propTypes.func
	};
	TextProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: '',
	  onChange: null
	};

	/**
	 * 复选框属性
	 * @author tengge / https://github.com/tengge1
	 */

	class CheckBoxProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value
	    } = this.props;
	    return /*#__PURE__*/React.createElement(CheckBox, {
	      className: bind('checkbox', className),
	      style: style,
	      name: name,
	      checked: value,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    onChange && onChange(value, name, event);
	  }

	}

	CheckBoxProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.bool,
	  onChange: propTypes.func
	};
	CheckBoxProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: false,
	  onChange: null
	};

	/**
	 * 数字属性
	 * @author tengge / https://github.com/tengge1
	 */

	class NumberProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value,
	      min,
	      max,
	      step
	    } = this.props;
	    return /*#__PURE__*/React.createElement(Input, {
	      className: bind('input', className),
	      style: style,
	      name: name,
	      type: 'number',
	      value: value,
	      min: min,
	      max: max,
	      step: step,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    onChange && onChange(value, name, event);
	  }

	}

	NumberProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.number,
	  min: propTypes.number,
	  max: propTypes.number,
	  step: propTypes.number,
	  onChange: propTypes.func
	};
	NumberProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: 0,
	  min: null,
	  max: null,
	  step: null,
	  onChange: null
	};

	/**
	 * 按钮属性
	 * @author tengge / https://github.com/tengge1
	 */

	class ButtonProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      text
	    } = this.props;
	    return /*#__PURE__*/React.createElement(Button, {
	      className: bind('button', className),
	      style: style,
	      onClick: this.handleChange
	    }, text);
	  }

	  handleChange(onChange, name, value, event) {
	    onChange && onChange(name, value, event);
	  }

	}

	ButtonProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  text: propTypes.string,
	  onChange: propTypes.func
	};
	ButtonProperty.defaultProps = {
	  className: null,
	  style: null,
	  text: 'Button',
	  onChange: null
	};

	/**
	 * 颜色属性
	 * @author tengge / https://github.com/tengge1
	 */

	class ColorProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value
	    } = this.props;
	    return /*#__PURE__*/React.createElement(Input, {
	      className: bind('input', className),
	      style: style,
	      name: name,
	      type: 'color',
	      value: value,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    onChange && onChange(value, name, event);
	  }

	}

	ColorProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.string,
	  onChange: propTypes.func
	};
	ColorProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: '',
	  onChange: null
	};

	/**
	 * 文本属性
	 * @author tengge / https://github.com/tengge1
	 */

	class SelectProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      options,
	      name,
	      value,
	      disabled
	    } = this.props;
	    return /*#__PURE__*/React.createElement(Select, {
	      className: bind('select', className),
	      style: style,
	      options: options,
	      name: name,
	      value: value,
	      disabled: disabled,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    onChange && onChange(value, name, event);
	  }

	}

	SelectProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  options: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.oneOfType([propTypes.string, propTypes.number]),
	  disabled: propTypes.bool,
	  onChange: propTypes.func
	};
	SelectProperty.defaultProps = {
	  className: null,
	  style: null,
	  options: {},
	  name: null,
	  value: null,
	  disabled: false,
	  onChange: null
	};

	/**
	 * 整数属性
	 * @author tengge / https://github.com/tengge1
	 */

	class IntegerProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value,
	      min,
	      max
	    } = this.props;
	    return /*#__PURE__*/React.createElement(Input, {
	      className: bind('input', className),
	      style: style,
	      name: name,
	      type: 'number',
	      value: value,
	      min: min,
	      max: max,
	      step: 1,
	      precision: 0,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    if (value === null) {
	      onChange && onChange(value, name, event);
	    } else {
	      onChange && onChange(parseInt(value), name, event);
	    }
	  }

	}

	IntegerProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.number,
	  min: propTypes.number,
	  max: propTypes.number,
	  onChange: propTypes.func
	};
	IntegerProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: 0,
	  min: null,
	  max: null,
	  onChange: null
	};

	/**
	 * 按钮组属性
	 * @author tengge / https://github.com/tengge1
	 */

	class ButtonsProperty extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('buttons', className),
	      style: style
	    }, children);
	  }

	}

	ButtonsProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	ButtonsProperty.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 纹理属性
	 * @author tengge / https://github.com/tengge1
	 */

	class TextureProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.canvasRef = React.createRef();
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleEnable = this.handleEnable.bind(this, props.onChange);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      value,
	      showScale,
	      scale
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('texture', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(CheckBox, {
	      checked: value !== null,
	      onChange: this.handleEnable
	    }), /*#__PURE__*/React.createElement("canvas", {
	      title: value ? value.sourceFile : '',
	      ref: this.canvasRef,
	      onClick: this.handleSelect
	    }), /*#__PURE__*/React.createElement(Input, {
	      type: 'number',
	      value: scale,
	      show: showScale
	    }));
	  }

	  componentDidMount() {
	    this.componentDidUpdate();
	  }

	  componentDidUpdate() {
	    let texture = this.props.value;
	    const canvas = this.canvasRef.current;
	    const context = canvas.getContext('2d');

	    if (texture !== null) {
	      let image = texture.image;

	      if (Array.isArray(image)) {
	        image = image[0];
	      }

	      if (image !== undefined && image.width > 0) {
	        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
	      } else {
	        context.clearRect(0, 0, canvas.width, canvas.height);
	      }
	    } else if (context !== null) {
	      context.clearRect(0, 0, canvas.width, canvas.height);
	    }
	  }

	  handleSelect() {
	    app.toast(_t('Please click the image in the MapPanel.'));
	    app.on(`selectMap.TextureProperty`, this.handleChange);
	  }

	  handleEnable(onChange, enabled, name, event) {
	    const value = this.props.value;

	    if (enabled && value === null) {
	      this.input.value = null;
	      this.input.click();
	      return;
	    }

	    if (enabled) {
	      onChange && onChange(value, this.props.name, event);
	    } else {
	      onChange && onChange(null, this.props.name, event);
	    }
	  }

	  handleChange(onChange, data) {
	    app.on(`selectMap.TextureProperty`, null);
	    const name = data.Name;
	    const type = data.Type;
	    const url = data.Url;

	    if (type === 'targa') {
	      const loader = new THREE.TGALoader();
	      loader.load(url, obj => {
	        let texture = new THREE.CanvasTexture(obj, THREE.UVMapping);
	        texture.sourceFile = name;
	        onChange && onChange(texture, this.props.name, data);
	      });
	    } else if (type === 'video') {
	      let video = document.createElement('video');
	      video.setAttribute('src', data.Url);
	      video.setAttribute('autoplay', 'autoplay');
	      video.setAttribute('loop', 'loop');
	      video.setAttribute('crossorigin', 'anonymous');
	      let texture = new THREE.VideoTexture(video);
	      texture.minFilter = THREE.LinearFilter;
	      texture.magFilter = THREE.LinearFilter;
	      texture.format = THREE.RGBFormat;
	      onChange && onChange(texture, this.props.name, data);
	    } else if (type === 'cube') {
	      const loader = new THREE.CubeTextureLoader();
	      loader.load(url.split(';'), obj => {
	        obj.sourceFile = name;
	        obj.format = url.endsWith('jpg') || url.endsWith('jpeg') ? THREE.RGBFormat : THREE.RGBAFormat;
	        obj.needsUpdate = true;
	        onChange && onChange(obj, this.props.name, data);
	      });
	    } else {
	      const loader = new THREE.TextureLoader();
	      loader.load(url, obj => {
	        obj.sourceFile = name;
	        obj.format = url.endsWith('jpg') || url.endsWith('jpeg') ? THREE.RGBFormat : THREE.RGBAFormat;
	        obj.needsUpdate = true;
	        onChange && onChange(obj, this.props.name, data);
	      });
	    }
	  }

	}

	TextureProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: (props, propName, componentName) => {
	    const value = props.value;

	    if (value === null) {
	      return;
	    }

	    if (!(value instanceof THREE.Texture)) {
	      return new TypeError(`Invalid prop \`${propName}\` of type \`${typeof value}\` supplied to \`${componentName}\`, expected \`THREE.Texture\`.`);
	    }
	  },
	  showScale: propTypes.bool,
	  scale: propTypes.number,
	  onChange: propTypes.func
	};
	TextureProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: null,
	  showScale: false,
	  scale: 1.0,
	  onChange: null
	};

	/**
	 * SVG
	 * @author tengge / https://github.com/tengge1
	 */

	class SVG extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      ...others
	    } = this.props;
	    return /*#__PURE__*/React.createElement("svg", _extends({
	      className: bind('SVG', className),
	      style: style
	    }, others));
	  }

	}

	SVG.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object
	};
	SVG.defaultProps = {
	  className: null,
	  style: null
	};

	/**
	 * 工具栏分割线
	 * @author tengge / https://github.com/tengge1
	 */

	class ToolbarSeparator extends React.Component {
	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('ToolbarSeparator', className),
	      style: style
	    }, /*#__PURE__*/React.createElement("div", {
	      className: "separator"
	    }));
	  }

	}

	ToolbarSeparator.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object
	};
	ToolbarSeparator.defaultProps = {
	  className: null,
	  style: null
	};

	/**
	 * 工具栏填充
	 * @author tengge / https://github.com/tengge1
	 */

	class ToolbarFiller extends React.Component {
	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('ToolbarFiller', className),
	      style: style
	    });
	  }

	}

	ToolbarFiller.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object
	};
	ToolbarFiller.defaultProps = {
	  className: null,
	  style: null
	};

	/**
	 * 数据表格
	 * @author tengge / https://github.com/tengge1
	 */

	class DataGrid extends React.Component {
	  constructor(props) {
	    super(props);
	    this.pageSize = {
	      10: '10',
	      20: '20',
	      50: '50',
	      100: '100'
	    };
	    this.handleClick = this.handleClick.bind(this, props.onSelect);
	    this.handleSelectAll = this.handleSelectAll.bind(this);
	    this.handleChangePageSize = this.handleChangePageSize.bind(this, props.onChangePageSize);
	    this.handleFirstPage = this.handleFirstPage.bind(this, props.onFirstPage);
	    this.handlePreviousPage = this.handlePreviousPage.bind(this, props.onPreviousPage);
	    this.handleNextPage = this.handleNextPage.bind(this, props.onNextPage);
	    this.handleLastPage = this.handleLastPage.bind(this, props.onLastPage);
	    this.handleRefresh = this.handleRefresh.bind(this, props.onRefresh);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      pages,
	      data,
	      keyField,
	      pageSize,
	      pageNum,
	      total,
	      selected,
	      mask
	    } = this.props;
	    const totalPage = total % pageSize === 0 ? total / pageSize : parseInt(total / pageSize) + 1; // 计算列宽：
	    // 数字列(type: number)、复选框列(type: checkbox)：60px。
	    // 其他列：提供的按提供的数值(px)。
	    // 表格列

	    const columns = React.Children.map(children, n => {
	      return n.props;
	    }); // 表格头

	    const head = /*#__PURE__*/React.createElement("table", {
	      className: 'head'
	    }, /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement("tr", null, columns.map(col => {
	      if (col.type === 'number') {
	        return /*#__PURE__*/React.createElement("th", {
	          className: 'number',
	          width: 60,
	          name: 'number',
	          key: 'number'
	        }, '#');
	      } else if (col.type === 'checkbox') {
	        const selectAll = data.length > 0 && data.every(n => n[col.field] === true);
	        return /*#__PURE__*/React.createElement("th", {
	          className: 'checkbox',
	          width: 60,
	          name: 'checkbox',
	          key: 'checkbox'
	        }, /*#__PURE__*/React.createElement(CheckBox, {
	          name: col.field,
	          checked: selectAll,
	          onChange: this.handleSelectAll
	        }));
	      } else {
	        return /*#__PURE__*/React.createElement("th", {
	          width: col.width,
	          name: col.field,
	          key: col.field
	        }, col.title);
	      }
	    })))); // 表格体

	    const body = /*#__PURE__*/React.createElement("table", {
	      className: 'body'
	    }, /*#__PURE__*/React.createElement("tbody", null, data.map((row, i) => {
	      return /*#__PURE__*/React.createElement("tr", {
	        className: selected === row[keyField] ? 'selected' : null,
	        "data-id": row[keyField],
	        key: row[keyField],
	        onClick: this.handleClick
	      }, columns.map(col => {
	        if (col.type === 'number') {
	          const value = pageSize * (pageNum - 1) + i + 1;
	          return /*#__PURE__*/React.createElement("td", {
	            className: 'number',
	            width: 60,
	            align: 'center',
	            key: 'number'
	          }, value);
	        } else if (col.type === 'checkbox') {
	          const value = row[col.field] === true;
	          return /*#__PURE__*/React.createElement("td", {
	            className: col.type,
	            width: 60,
	            align: 'center',
	            key: 'number'
	          }, /*#__PURE__*/React.createElement(CheckBox, {
	            checked: value
	          }));
	        } else {
	          const value = col.renderer ? col.renderer(row[col.field], row) : row[col.field];

	          if (col.danger) {
	            return /*#__PURE__*/React.createElement("td", {
	              width: col.width,
	              align: col.align,
	              key: col.field,
	              dangerouslySetInnerHTML: {
	                __html: value
	              }
	            });
	          } else {
	            return /*#__PURE__*/React.createElement("td", {
	              width: col.width,
	              align: col.align,
	              key: col.field
	            }, value);
	          }
	        }
	      }));
	    })));
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('DataGrid', pages && 'pages', className),
	      style: style
	    }, head, /*#__PURE__*/React.createElement("div", {
	      className: 'wrap'
	    }, body), pages && /*#__PURE__*/React.createElement("div", {
	      className: 'page'
	    }, /*#__PURE__*/React.createElement(Select, {
	      className: 'pageSize',
	      name: 'pageSize',
	      options: this.pageSize,
	      value: pageSize.toString(),
	      onChange: this.handleChangePageSize
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, {
	      className: 'line'
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'backward',
	      title: _t('First Page'),
	      onClick: this.handleFirstPage
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'left-triangle2',
	      title: _t('Previous Page'),
	      onClick: this.handlePreviousPage
	    }), /*#__PURE__*/React.createElement(Input, {
	      className: 'current',
	      value: pageNum,
	      title: _t('Current Page')
	    }), /*#__PURE__*/React.createElement("span", {
	      className: 'slash'
	    }, " / "), /*#__PURE__*/React.createElement(Label, {
	      className: 'totalPage'
	    }, totalPage), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'right-triangle2',
	      title: _t('Next Page'),
	      onClick: this.handleNextPage
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'forward',
	      title: _t('Last Page'),
	      onClick: this.handleLastPage
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, {
	      className: 'line'
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'refresh',
	      title: _t('Refresh'),
	      onClick: this.handleRefresh
	    }), /*#__PURE__*/React.createElement(ToolbarFiller, null), /*#__PURE__*/React.createElement("div", {
	      className: 'info'
	    }, _t('{{pageSize}} per page, total {{total}} records.', {
	      pageSize,
	      total
	    }))), /*#__PURE__*/React.createElement(LoadMask, {
	      text: _t('Loading...'),
	      show: mask
	    }));
	  }

	  handleClick(onSelect, event) {
	    const keyField = this.props.keyField;
	    const id = event.currentTarget.getAttribute('data-id');
	    const record = this.props.data.filter(n => n[keyField] === id)[0];
	    onSelect && onSelect(record);
	  }

	  handleSelectAll(value, name, event) {
	    const {
	      onSelectAll
	    } = this.props;
	    onSelectAll && onSelectAll(value, name, event);
	  }

	  handleChangePageSize(onChangePageSize, value, event) {
	    const pageSize = parseInt(value);
	    onChangePageSize && onChangePageSize(pageSize, event);
	  }

	  handleFirstPage(onFirstPage, event) {
	    onFirstPage && onFirstPage(event);
	  }

	  handlePreviousPage(onPreviousPage, event) {
	    onPreviousPage && onPreviousPage(event);
	  }

	  handleNextPage(onNextPage, event) {
	    onNextPage && onNextPage(event);
	  }

	  handleLastPage(onLastPage, event) {
	    onLastPage && onLastPage(event);
	  }

	  handleRefresh(onRefresh, event) {
	    onRefresh && onRefresh(event);
	  }

	}

	DataGrid.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: (props, propName, componentName) => {
	    const children = props[propName];
	    Array.isArray(children) && children.forEach(n => {
	      if (n.type !== Column) {
	        return new TypeError(`Invalid prop \`${propName}\` of type \`${n.type.name}\` supplied to \`${componentName}\`, expected \`Column\`.`);
	      }
	    });
	  },
	  pages: propTypes.bool,
	  data: propTypes.array,
	  keyField: propTypes.string,
	  pageSize: propTypes.number,
	  pageNum: propTypes.number,
	  total: propTypes.number,
	  selected: propTypes.string,
	  mask: propTypes.bool,
	  onSelect: propTypes.func,
	  onSelectAll: propTypes.func,
	  onChangePageSize: propTypes.func,
	  onFirstPage: propTypes.func,
	  onPreviousPage: propTypes.func,
	  onNextPage: propTypes.func,
	  onLastPage: propTypes.func,
	  onRefresh: propTypes.func
	};
	DataGrid.defaultProps = {
	  className: null,
	  style: null,
	  children: [],
	  pages: false,
	  data: [],
	  keyField: 'id',
	  pageSize: 20,
	  pageNum: 1,
	  total: 0,
	  selected: null,
	  mask: false,
	  onSelect: null,
	  onSelectAll: null,
	  onChangePageSize: null,
	  onFirstPage: null,
	  onPreviousPage: null,
	  onNextPage: null,
	  onLastPage: null,
	  onRefresh: null
	};

	/**
	 * 表格
	 * @author tengge / https://github.com/tengge1
	 */

	class Table extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return /*#__PURE__*/React.createElement("table", _extends({
	      className: bind('Table', className),
	      style: style
	    }, others), children);
	  }

	}

	Table.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	Table.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 表格内容
	 * @author tengge / https://github.com/tengge1
	 */

	class TableBody extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return /*#__PURE__*/React.createElement("tbody", _extends({
	      className: bind('TableBody', className),
	      style: style
	    }, others), children);
	  }

	}

	TableBody.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	TableBody.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 表格单元格
	 * @author tengge / https://github.com/tengge1
	 */

	class TableCell extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return /*#__PURE__*/React.createElement("td", _extends({
	      className: bind('TableCell', className),
	      style: style
	    }, others), children);
	  }

	}

	TableCell.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	TableCell.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 表格头部
	 * @author tengge / https://github.com/tengge1
	 */

	class TableHead extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return /*#__PURE__*/React.createElement("thead", _extends({
	      className: bind('TableHead', className),
	      style: style
	    }, others), children);
	  }

	}

	TableHead.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	TableHead.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 表格行
	 * @author tengge / https://github.com/tengge1
	 */

	class TableRow extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return /*#__PURE__*/React.createElement("tr", _extends({
	      className: bind('TableRow', className),
	      style: style
	    }, others), children);
	  }

	}

	TableRow.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	TableRow.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 工具栏
	 * @author tengge / https://github.com/tengge1
	 */

	class Toolbar extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      direction
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('Toolbar', direction, className),
	      style: style
	    }, children);
	  }

	}

	Toolbar.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  direction: propTypes.oneOf(['horizontal', 'vertical']),
	  children: propTypes.node
	};
	Toolbar.defaultProps = {
	  className: null,
	  style: null,
	  direction: 'horizontal',
	  children: null
	};

	/**
	 * 时间轴
	 * @author tengge / https://github.com/tengge1
	 */

	class Timeline extends React.Component {
	  constructor(props) {
	    super(props);
	    this.duration = 120; // 持续时长(秒)

	    this.scale = 30; // 尺寸，1秒=30像素

	    this.time = 0; // 当前时间

	    this.speed = 16; // 当前速度

	    this.canvasRef = React.createRef();
	    this.layersRef = React.createRef();
	    this.leftRef = React.createRef();
	    this.rightRef = React.createRef();
	    this.sliderRef = React.createRef();
	    this.handleAddLayer = this.handleAddLayer.bind(this, props.onAddLayer);
	    this.handleEditLayer = this.handleEditLayer.bind(this, props.onEditLayer);
	    this.handleDeleteLayer = this.handleDeleteLayer.bind(this, props.onDeleteLayer);
	    this.commitDeleteLayer = this.commitDeleteLayer.bind(this);
	    this.handleSelectedLayerChange = this.handleSelectedLayerChange.bind(this, props.onSelectedLayerChange);
	    this.handleBackward = this.handleBackward.bind(this);
	    this.handlePlay = this.handlePlay.bind(this);
	    this.handlePause = this.handlePause.bind(this);
	    this.handleForward = this.handleForward.bind(this);
	    this.handleStop = this.handleStop.bind(this);
	    this.handleClick = this.handleClick.bind(this, props.onClickAnimation);
	    this.handleDoubleClick = this.handleDoubleClick.bind(this, props.onAddAnimation);
	    this.handleRightScroll = this.handleRightScroll.bind(this);
	    this.handleDragStart = this.handleDragStart.bind(this);
	    this.handleDragEnd = this.handleDragEnd.bind(this);
	    this.handleDragEnter = this.handleDragEnter.bind(this);
	    this.handleDragOver = this.handleDragOver.bind(this);
	    this.handleDragLeave = this.handleDragLeave.bind(this);
	    this.handleDrop = this.handleDrop.bind(this, props.onDropAnimation);
	  }

	  render() {
	    const {
	      className,
	      style,
	      animations,
	      selectedLayer,
	      selected
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('Timeline', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(Toolbar, {
	      className: bind('controls', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'add',
	      title: _t('Add Layer'),
	      onClick: this.handleAddLayer
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'edit',
	      title: _t('Edit Layer'),
	      onClick: this.handleEditLayer
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'delete',
	      title: _t('Delete Layer'),
	      onClick: this.handleDeleteLayer
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'backward',
	      title: _t('Slower'),
	      onClick: this.handleBackward
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'play',
	      title: _t('Play'),
	      onClick: this.handlePlay
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'pause',
	      title: _t('Pause'),
	      onClick: this.handlePause
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'forward',
	      title: _t('Faster'),
	      onClick: this.handleForward
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'stop',
	      title: _t('Stop'),
	      onClick: this.handleStop
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(Label, {
	      className: 'time'
	    }, this.parseTime(this.time)), /*#__PURE__*/React.createElement(Label, {
	      className: 'speed'
	    }, this.parseSpeed(this.speed)), /*#__PURE__*/React.createElement(ToolbarFiller, null), /*#__PURE__*/React.createElement(Label, null, _t('Illustrate: Double-click the area below the timeline to add an animation.'))), /*#__PURE__*/React.createElement("div", {
	      className: "box"
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'timeline'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: "mask"
	    }), /*#__PURE__*/React.createElement("canvas", {
	      ref: this.canvasRef
	    })), /*#__PURE__*/React.createElement("div", {
	      className: 'layers'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'left',
	      ref: this.leftRef
	    }, animations.map(layer => {
	      return /*#__PURE__*/React.createElement("div", {
	        className: 'info',
	        key: layer.uuid
	      }, /*#__PURE__*/React.createElement(CheckBox, {
	        name: layer.uuid,
	        checked: selectedLayer === layer.uuid,
	        onChange: this.handleSelectedLayerChange
	      }), /*#__PURE__*/React.createElement(Label, null, layer.layerName));
	    })), /*#__PURE__*/React.createElement("div", {
	      className: 'right',
	      ref: this.rightRef,
	      onScroll: this.handleRightScroll
	    }, animations.map(layer => {
	      return /*#__PURE__*/React.createElement("div", {
	        className: 'layer',
	        droppable: 'true',
	        "data-type": 'layer',
	        "data-id": layer.uuid,
	        onDoubleClick: this.handleDoubleClick,
	        onDragEnter: this.handleDragEnter,
	        onDragOver: this.handleDragOver,
	        onDragLeave: this.handleDragLeave,
	        onDrop: this.handleDrop,
	        key: layer.uuid
	      }, layer.animations.map(animation => {
	        return /*#__PURE__*/React.createElement("div", {
	          className: bind('animation', selected === animation.uuid && 'selected'),
	          title: animation.name,
	          draggable: 'true',
	          droppable: 'false',
	          "data-type": 'animation',
	          "data-id": animation.uuid,
	          "data-pid": layer.uuid,
	          style: {
	            left: animation.beginTime * this.scale + 'px',
	            width: (animation.endTime - animation.beginTime) * this.scale + 'px'
	          },
	          onClick: this.handleClick,
	          onDragStart: this.handleDragStart,
	          onDragEnd: this.handleDragEnd,
	          key: animation.uuid
	        }, animation.name);
	      }));
	    })), /*#__PURE__*/React.createElement("div", {
	      className: "slider",
	      ref: this.sliderRef
	    }))));
	  }

	  componentDidMount() {
	    this.renderTimeline();
	  }

	  renderTimeline() {
	    const {
	      duration,
	      scale
	    } = this;
	    const width = duration * scale; // 画布宽度

	    const scale5 = scale / 5; // 0.2秒像素数

	    const margin = 0; // 时间轴前后间距

	    const canvas = this.canvasRef.current;
	    canvas.style.width = width + margin * 2 + 'px';
	    canvas.width = canvas.clientWidth;
	    canvas.height = 32;
	    const context = canvas.getContext('2d'); // 时间轴背景

	    context.fillStyle = '#fafafa';
	    context.fillRect(0, 0, canvas.width, canvas.height); // 时间轴刻度

	    context.strokeStyle = '#555';
	    context.beginPath();

	    for (let i = margin; i <= width + margin; i += scale) {
	      // 绘制每一秒
	      for (let j = 0; j < 5; j++) {
	        // 绘制每个小格
	        if (j === 0) {
	          // 长刻度
	          context.moveTo(i + scale5 * j, 22);
	          context.lineTo(i + scale5 * j, 30);
	        } else {
	          // 短刻度
	          context.moveTo(i + scale5 * j, 26);
	          context.lineTo(i + scale5 * j, 30);
	        }
	      }
	    }

	    context.stroke(); // 时间轴文字

	    context.font = '12px Arial';
	    context.fillStyle = '#888';

	    for (let i = 0; i <= duration; i += 2) {
	      // 对于每两秒
	      let minute = Math.floor(i / 60);
	      let second = Math.floor(i % 60);
	      let text = (minute > 0 ? minute + ':' : '') + ('0' + second).slice(-2);

	      if (i === 0) {
	        context.textAlign = 'left';
	      } else if (i === duration) {
	        context.textAlign = 'right';
	      } else {
	        context.textAlign = 'center';
	      }

	      context.fillText(text, margin + i * scale, 16);
	    }
	  }

	  handleAddLayer(onAddLayer, event) {
	    onAddLayer && onAddLayer(event);
	  }

	  handleEditLayer(onEditLayer, event) {
	    const {
	      selectedLayer
	    } = this.props;
	    onEditLayer && onEditLayer(selectedLayer, event);
	  }

	  handleDeleteLayer(onDeleteLayer, event) {
	    const {
	      selectedLayer
	    } = this.props;
	    onDeleteLayer && onDeleteLayer(selectedLayer, event);
	  }

	  commitDeleteLayer() {}

	  handleSelectedLayerChange(onSelectedLayerChange, value, name, event) {
	    onSelectedLayerChange && onSelectedLayerChange(value ? name : null, event);
	  }

	  handleBackward(event) {}

	  handlePlay(event) {}

	  handlePause(event) {}

	  handleForward(event) {}

	  handleStop(event) {}

	  handleClick(onClickAnimation, event) {
	    const type = event.target.getAttribute('data-type');

	    if (type !== 'animation') {
	      return;
	    }

	    const pid = event.target.getAttribute('data-pid');
	    const id = event.target.getAttribute('data-id');
	    onClickAnimation && onClickAnimation(id, pid, event);
	  }

	  handleDoubleClick(onAddAnimation, event) {
	    const type = event.target.getAttribute('data-type');

	    if (type !== 'layer') {
	      return;
	    }

	    const layerID = event.target.getAttribute('data-id');
	    const beginTime = event.nativeEvent.offsetX / this.scale;
	    const endTime = beginTime + 2;
	    onAddAnimation && onAddAnimation(layerID, beginTime, endTime, event);
	  }

	  handleRightScroll(scroll) {
	    let left = this.leftRef.current;
	    let canvas = this.canvasRef.current;
	    left.scrollTop = event.target.scrollTop;
	    canvas.style.left = `${100 - event.target.scrollLeft}px`;
	  }

	  handleDragStart(event) {
	    const type = event.target.getAttribute('data-type');

	    if (type !== 'animation') {
	      return;
	    }

	    const id = event.target.getAttribute('data-id');
	    const pid = event.target.getAttribute('data-pid');
	    event.nativeEvent.dataTransfer.setData('id', id);
	    event.nativeEvent.dataTransfer.setData('pid', pid);
	    event.nativeEvent.dataTransfer.setData('offsetX', event.nativeEvent.offsetX);
	  }

	  handleDragEnd(event) {
	    event.nativeEvent.dataTransfer.clearData();
	  }

	  handleDragEnter(event) {
	    event.preventDefault();
	  }

	  handleDragOver(event) {
	    event.preventDefault();
	  }

	  handleDragLeave(event) {
	    event.preventDefault();
	  }

	  handleDrop(onDropAnimation, event) {
	    const type = event.target.getAttribute('data-type');

	    if (type !== 'layer') {
	      return;
	    }

	    const id = event.nativeEvent.dataTransfer.getData('id');
	    const oldLayerID = event.nativeEvent.dataTransfer.getData('pid');
	    const offsetX = event.nativeEvent.dataTransfer.getData('offsetX');
	    const newLayerID = event.target.getAttribute('data-id');
	    const beginTime = (event.nativeEvent.offsetX - offsetX) / this.scale;
	    onDropAnimation && onDropAnimation(id, oldLayerID, newLayerID, beginTime, event);
	  }

	  parseTime(time) {
	    let minute = `0${parseInt(time / 60)}`;
	    let second = `0${parseInt(time % 60)}`;
	    return `${minute.substr(minute.length - 2, 2)}:${second.substr(second.length - 2, 2)}`;
	  }

	  parseSpeed(speed) {
	    return speed;
	  }

	}

	Timeline.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  animations: propTypes.array,
	  selectedLayer: propTypes.string,
	  selected: propTypes.string,
	  onAddLayer: propTypes.func,
	  onEditLayer: propTypes.func,
	  onDeleteLayer: propTypes.func,
	  onSelectedLayerChange: propTypes.func,
	  onAddAnimation: propTypes.func,
	  onDropAnimation: propTypes.func,
	  onClickAnimation: propTypes.func
	};
	Timeline.defaultProps = {
	  className: null,
	  style: null,
	  animations: [],
	  selectedLayer: null,
	  selected: null,
	  onAddLayer: null,
	  onEditLayer: null,
	  onDeleteLayer: null,
	  onSelectedLayerChange: null,
	  onAddAnimation: null,
	  onDropAnimation: null,
	  onClickAnimation: null
	};

	/**
	 * 树
	 * @author tengge / https://github.com/tengge1
	 */

	class Tree extends React.Component {
	  constructor(props) {
	    super(props);
	    this.treeRef = React.createRef();
	    const {
	      onExpand,
	      onSelect,
	      onCheck,
	      onDoubleClick,
	      onDrop
	    } = this.props;
	    this.handleExpandNode = this.handleExpandNode.bind(this, onExpand);
	    this.handleClick = this.handleClick.bind(this, onSelect);
	    this.handleCheck = this.handleCheck.bind(this, onCheck);
	    this.handleDoubleClick = this.handleDoubleClick.bind(this, onDoubleClick);
	    this.handleClickIcon = this.handleClickIcon.bind(this, props.onClickIcon);
	    this.handleDrag = this.handleDrag.bind(this);
	    this.handleDragStart = this.handleDragStart.bind(this);
	    this.handleDragOver = this.handleDragOver.bind(this);
	    this.handleDragLeave = this.handleDragLeave.bind(this);
	    this.handleDrop = this.handleDrop.bind(this, onDrop);
	  }

	  render() {
	    const {
	      className,
	      style,
	      data,
	      mask
	    } = this.props; // 创建节点

	    let list = [];
	    Array.isArray(data) && data.forEach(n => {
	      list.push(this.createNode(n));
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: 'TreeWrap'
	    }, /*#__PURE__*/React.createElement("ul", {
	      className: bind('Tree', className),
	      style: style,
	      ref: this.treeRef
	    }, list), /*#__PURE__*/React.createElement(LoadMask, {
	      text: _t('Loading...'),
	      show: mask
	    }));
	  }

	  createNode(data) {
	    // TODO: leaf应该根据数据上的left属性判断，而不是children。
	    const leaf = (!data.children || data.children.length === 0) && data.leaf !== false;
	    const children = data.children && data.children.length > 0 ? /*#__PURE__*/React.createElement("ul", {
	      className: bind('sub', data.expanded ? null : 'collpase')
	    }, data.children.map(n => {
	      return this.createNode(n);
	    })) : null;
	    let checkbox = null;

	    if (data.checked === true || data.checked === false) {
	      checkbox = /*#__PURE__*/React.createElement(CheckBox, {
	        name: data.value,
	        checked: data.checked,
	        onChange: this.handleCheck
	      });
	    }

	    return /*#__PURE__*/React.createElement("li", {
	      className: bind('node', this.props.selected === data.value && 'selected'),
	      value: data.value,
	      key: data.value,
	      onClick: this.handleClick,
	      onDoubleClick: this.handleDoubleClick,
	      draggable: 'true',
	      droppable: 'true',
	      onDrag: this.handleDrag,
	      onDragStart: this.handleDragStart,
	      onDragOver: this.handleDragOver,
	      onDragLeave: this.handleDragLeave,
	      onDrop: this.handleDrop
	    }, /*#__PURE__*/React.createElement("i", {
	      className: bind('expand', leaf ? null : data.expanded ? 'minus' : 'plus'),
	      value: data.value,
	      onClick: this.handleExpandNode
	    }), checkbox, /*#__PURE__*/React.createElement("i", {
	      className: bind('type', leaf ? 'leaf' : data.expanded ? 'open' : 'close')
	    }), /*#__PURE__*/React.createElement("a", {
	      href: 'javascript:;'
	    }, data.text), data.icons && data.icons.map(n => {
	      return /*#__PURE__*/React.createElement(Icon, {
	        className: 'control',
	        name: n.name,
	        value: data.value,
	        icon: n.icon,
	        title: n.title,
	        key: n.name,
	        onClick: this.handleClickIcon
	      });
	    }), leaf ? null : children);
	  } // 暂时屏蔽树节点动画，有bug。
	  // componentDidUpdate() {
	  //     let tree = this.treeRef.current;
	  //     // 将每棵子树设置高度，以便显示动画
	  //     this.handleSetTreeHeight(tree);
	  // }
	  // handleSetTreeHeight(node) {
	  //     if (node.children.length === 0) {
	  //         return;
	  //     }
	  //     let height = 0;
	  //     for (let i = 0; i < node.children.length; i++) {
	  //         let child = node.children[i];
	  //         height += child.offsetHeight;
	  //         this.handleSetTreeHeight(child);
	  //     }
	  //     if (node.classList.contains('sub')) { // 子树
	  //         node.style.height = `${height}px`;
	  //     }
	  // }

	  /**
	   * 将某个节点滚动到视野范围内
	   * @param {*} value 节点的值
	   */


	  scrollToView(value) {
	    let root = this.treeRef.current;

	    if (!root) {
	      return;
	    }

	    let node = this.findNode(value, root);

	    if (!node) {
	      return;
	    }

	    const treeHeight = root.clientHeight;
	    const treeTop = root.scrollTop;
	    const nodeHeight = node.clientHeight;
	    const offsetTop = node.offsetTop;
	    const minScrollTop = offsetTop + nodeHeight - treeHeight;
	    const maxScrollTop = offsetTop;

	    if (treeTop >= minScrollTop && treeTop <= maxScrollTop) {
	      // 不需要滚动
	      return;
	    } else if (treeTop < minScrollTop) {
	      root.scrollTop = minScrollTop;
	    } else if (treeTop > maxScrollTop) {
	      root.scrollTop = maxScrollTop;
	    }
	  }

	  findNode(value, node) {
	    const _value = node.getAttribute('value');

	    if (value === _value) {
	      return node;
	    }

	    for (let child of node.children) {
	      const _node = this.findNode(value, child);

	      if (_node) {
	        return _node;
	      }
	    }
	  }

	  handleExpandNode(onExpand, event) {
	    event.stopPropagation();
	    const value = event.target.getAttribute('value');
	    onExpand && onExpand(value, event);
	  }

	  handleClick(onSelect, event) {
	    event.stopPropagation();
	    let value = event.target.getAttribute('value');

	    if (value) {
	      onSelect && onSelect(value, event);
	    }
	  }

	  handleCheck(onCheck, value, name, event) {
	    event.stopPropagation();
	    onCheck && onCheck(value, name, event);
	  }

	  handleDoubleClick(onDoubleClick, event) {
	    const value = event.target.getAttribute('value');

	    if (value) {
	      onDoubleClick && onDoubleClick(value, event);
	    }
	  }

	  handleClickIcon(onClickIcon, name, event) {
	    const value = event.target.getAttribute('value');
	    event.stopPropagation();
	    onClickIcon && onClickIcon(value, name, event);
	  } // --------------------- 拖拽事件 ---------------------------


	  handleDrag(event) {
	    event.stopPropagation();
	    this.currentDrag = event.currentTarget;
	  }

	  handleDragStart(event) {
	    event.stopPropagation();
	    event.dataTransfer.setData('text', 'foo');
	  }

	  handleDragOver(event) {
	    event.preventDefault();
	    event.stopPropagation();
	    let target = event.currentTarget;

	    if (target === this.currentDrag) {
	      return;
	    }

	    let area = event.nativeEvent.offsetY / target.clientHeight;

	    if (area < 0.25) {
	      target.classList.add('dragTop');
	    } else if (area > 0.75) {
	      target.classList.add('dragBottom');
	    } else {
	      target.classList.add('drag');
	    }
	  }

	  handleDragLeave(event) {
	    event.preventDefault();
	    event.stopPropagation();
	    let target = event.currentTarget;

	    if (target === this.currentDrag) {
	      return;
	    }

	    target.classList.remove('dragTop');
	    target.classList.remove('dragBottom');
	    target.classList.remove('drag');
	  }

	  handleDrop(onDrop, event) {
	    event.preventDefault();
	    event.stopPropagation();
	    let target = event.currentTarget;

	    if (target === this.currentDrag) {
	      return;
	    }

	    target.classList.remove('dragTop');
	    target.classList.remove('dragBottom');
	    target.classList.remove('drag');

	    if (typeof onDrop === 'function') {
	      const area = event.nativeEvent.offsetY / target.clientHeight;
	      const currentValue = this.currentDrag.getAttribute('value');

	      if (area < 0.25) {
	        // 放在当前元素前面
	        onDrop(currentValue, // 拖动要素
	        target.parentNode.parentNode.getAttribute('value'), // 新位置父级
	        target.getAttribute('value') // 新位置索引
	        ); // 拖动, 父级, 索引
	      } else if (area > 0.75) {
	        // 放在当前元素后面
	        onDrop(currentValue, target.parentNode.parentNode.getAttribute('value'), !target.nextSibling ? null : target.nextSibling.getAttribute('value') // target.nextSibling为null，说明是最后一个位置
	        );
	      } else {
	        // 成为该元素子级
	        onDrop(currentValue, target.getAttribute('value'), null);
	      }
	    }
	  }

	}

	Tree.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  data: propTypes.array,
	  mask: propTypes.bool,
	  selected: propTypes.string,
	  onExpand: propTypes.func,
	  onSelect: propTypes.func,
	  onCheck: propTypes.func,
	  onDoubleClick: propTypes.func,
	  onClickIcon: propTypes.func,
	  onDrop: propTypes.func
	};
	Tree.defaultProps = {
	  className: null,
	  style: null,
	  data: [],
	  mask: false,
	  selected: null,
	  onExpand: null,
	  onSelect: null,
	  onCheck: null,
	  onDoubleClick: null,
	  onClickIcon: null,
	  onDrop: null
	};

	/**
	 * 窗口
	 */

	class Window extends React.Component {
	  constructor(props) {
	    super(props);
	    this.dom = React.createRef();
	    this.isDown = false;
	    this.offsetX = 0;
	    this.offsetY = 0;
	    this.handleMouseDown = this.handleMouseDown.bind(this);
	    this.handleMouseMove = this.handleMouseMove.bind(this);
	    this.handleMouseUp = this.handleMouseUp.bind(this);
	    this.handleClose = this.handleClose.bind(this, props.onClose);
	  }

	  render() {
	    const {
	      className,
	      style,
	      title,
	      children,
	      hidden,
	      mask
	    } = this.props;
	    let _children = null;

	    if (children && Array.isArray(children)) {
	      _children = children;
	    } else if (children) {
	      _children = [children];
	    }

	    const content = _children.filter(n => {
	      return n.type === Content;
	    })[0];

	    const buttons = _children.filter(n => {
	      return n.type === Buttons;
	    })[0];

	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('WindowMask', mask && 'mask', hidden && 'hidden')
	    }, /*#__PURE__*/React.createElement("div", {
	      className: bind('Window', className),
	      style: style,
	      ref: this.dom
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'wrap'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'title',
	      onMouseDown: this.handleMouseDown
	    }, /*#__PURE__*/React.createElement("span", null, title), /*#__PURE__*/React.createElement("div", {
	      className: 'controls'
	    }, /*#__PURE__*/React.createElement("i", {
	      className: 'iconfont icon-close icon',
	      onClick: this.handleClose
	    }))), /*#__PURE__*/React.createElement("div", {
	      className: 'content'
	    }, content && content.props.children), buttons && /*#__PURE__*/React.createElement("div", {
	      className: 'buttons'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'button-wrap'
	    }, buttons && buttons.props.children)))));
	  }

	  handleMouseDown(event) {
	    this.isDown = true;
	    var dom = this.dom.current;
	    var left = dom.style.left === '' ? 0 : parseInt(dom.style.left.replace('px', ''));
	    var top = dom.style.top === '' ? 0 : parseInt(dom.style.top.replace('px', ''));
	    this.offsetX = event.clientX - left;
	    this.offsetY = event.clientY - top;
	  }

	  handleMouseMove(event) {
	    if (!this.isDown) {
	      return;
	    }

	    var dx = event.clientX - this.offsetX;
	    var dy = event.clientY - this.offsetY;
	    var dom = this.dom.current;
	    dom.style.left = `${dx}px`;
	    dom.style.top = `${dy}px`;
	  }

	  handleMouseUp() {
	    this.isDown = false;
	    this.offsetX = 0;
	    this.offsetY = 0;
	  }

	  handleClose(onClose, event) {
	    onClose && onClose(event);
	  }

	  componentDidMount() {
	    document.body.addEventListener('mousemove', this.handleMouseMove);
	    document.body.addEventListener('mouseup', this.handleMouseUp);
	  }

	  componentWillUnmount() {
	    document.body.removeEventListener('mousemove', this.handleMouseMove);
	    document.body.removeEventListener('mouseup', this.handleMouseUp);
	  }

	}

	Window.show = function () {};

	Window.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  title: propTypes.string,
	  children: propTypes.node,
	  hidden: propTypes.bool,
	  mask: propTypes.bool,
	  onClose: propTypes.func
	};
	Window.defaultProps = {
	  className: null,
	  style: null,
	  title: 'Window',
	  children: null,
	  hidden: false,
	  mask: true,
	  onClose: null
	};

	/**
	 * 提示框
	 */

	class Alert extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleOK = this.handleOK.bind(this, props.onOK);
	    this.handleClose = this.handleClose.bind(this, props.onClose);
	  }

	  render() {
	    const {
	      className,
	      style,
	      title,
	      children,
	      hidden,
	      mask,
	      okText
	    } = this.props;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: bind('Alert', className),
	      style: style,
	      title: title,
	      hidden: hidden,
	      mask: mask,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, children), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleOK
	    }, okText)));
	  }

	  handleOK(onOK, event) {
	    onOK && onOK(event);
	  }

	  handleClose(onClose, event) {
	    onClose && onClose(event);
	  }

	}

	Alert.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  title: propTypes.string,
	  children: propTypes.node,
	  hidden: propTypes.bool,
	  mask: propTypes.bool,
	  okText: propTypes.string,
	  onOK: propTypes.func,
	  onClose: propTypes.func
	};
	Alert.defaultProps = {
	  className: null,
	  style: null,
	  title: 'Message',
	  children: null,
	  hidden: false,
	  mask: false,
	  okText: 'OK',
	  onOK: null,
	  onClose: null
	};

	/**
	 * 询问框
	 */

	class Confirm extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleOK = this.handleOK.bind(this, props.onOK);
	    this.handleCancel = this.handleCancel.bind(this, props.onCancel);
	    this.handleClose = this.handleClose.bind(this, props.onClose);
	  }

	  render() {
	    const {
	      className,
	      style,
	      title,
	      children,
	      hidden,
	      mask,
	      okText,
	      cancelText
	    } = this.props;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: bind('Confirm', className),
	      style: style,
	      title: title,
	      hidden: hidden,
	      mask: mask,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, children), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleOK
	    }, okText), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleCancel
	    }, cancelText)));
	  }

	  handleOK(onOK, event) {
	    onOK && onOK(event);
	  }

	  handleCancel(onCancel, event) {
	    onCancel && onCancel(event);
	  }

	  handleClose(onClose, event) {
	    onClose && onClose(event);
	  }

	}

	Confirm.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  title: propTypes.string,
	  children: propTypes.node,
	  hidden: propTypes.bool,
	  mask: propTypes.bool,
	  okText: propTypes.string,
	  cancelText: propTypes.string,
	  onOK: propTypes.func,
	  onCancel: propTypes.func,
	  onClose: propTypes.func
	};
	Confirm.defaultProps = {
	  className: null,
	  style: null,
	  title: 'Confirm',
	  children: null,
	  hidden: false,
	  mask: false,
	  okText: 'OK',
	  cancelText: 'Cancel',
	  onOK: null,
	  onCancel: null,
	  onClose: null
	};

	/**
	 * 提示窗
	 */

	class Message extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      type
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('Message', type, className),
	      style: style
	    }, /*#__PURE__*/React.createElement("i", {
	      className: bind('iconfont', `icon-${type}`)
	    }), /*#__PURE__*/React.createElement("p", {
	      className: 'content'
	    }, children));
	  }

	}

	Message.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  type: propTypes.oneOf(['info', 'success', 'warn', 'error'])
	};
	Message.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  type: 'info'
	};

	/**
	 * 图片查看器
	 */

	class Photo extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	    this.handleClickImage = this.handleClickImage.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      url
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('PhotoMark', className),
	      style: style,
	      onClick: this.handleClick
	    }, /*#__PURE__*/React.createElement("img", {
	      src: url,
	      onClick: this.handleClickImage
	    }));
	  }

	  handleClick(onClick, event) {
	    onClick && onClick(event);
	  }

	  handleClickImage(event) {
	    event.stopPropagation();
	  }

	}

	Photo.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  url: propTypes.string,
	  onClick: propTypes.func
	};
	Photo.defaultProps = {
	  className: null,
	  style: null,
	  url: null,
	  onClick: null
	};

	/**
	 * 弹窗输入框
	 */

	class Prompt extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      value: props.value
	    };
	    this.handleOK = this.handleOK.bind(this, props.onOK);
	    this.handleClose = this.handleClose.bind(this, props.onClose);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      title,
	      content,
	      hidden,
	      mask,
	      okText
	    } = this.props;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: bind('Prompt', className),
	      style: style,
	      title: title,
	      hidden: hidden,
	      mask: mask,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, content, /*#__PURE__*/React.createElement(Input, {
	      value: this.state.value,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleOK
	    }, okText)));
	  }

	  handleOK(onOK, event) {
	    onOK && onOK(this.state.value, event);
	  }

	  handleClose(onClose, event) {
	    onClose && onClose(event);
	  }

	  handleChange(value) {
	    this.setState({
	      value
	    });
	  }

	}

	Prompt.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  title: propTypes.string,
	  content: propTypes.node,
	  value: propTypes.string,
	  hidden: propTypes.bool,
	  mask: propTypes.bool,
	  okText: propTypes.string,
	  onOK: propTypes.func,
	  onClose: propTypes.func
	};
	Prompt.defaultProps = {
	  className: null,
	  style: null,
	  title: 'Prompt',
	  content: null,
	  value: '',
	  hidden: false,
	  mask: false,
	  okText: 'OK',
	  onOK: null,
	  onClose: null
	};

	/**
	 * 提示窗
	 */

	class Toast extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: 'ToastMark'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: bind('Toast', className),
	      style: style
	    }, children));
	  }

	}

	Toast.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	Toast.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 视频查看器
	 */

	class Video extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	    this.handleClickImage = this.handleClickVideo.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      url
	    } = this.props;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('VideoMark', className),
	      style: style,
	      onClick: this.handleClick
	    }, /*#__PURE__*/React.createElement("video", {
	      src: url,
	      autoPlay: 'autoplay',
	      controls: 'controls',
	      onClick: this.handleClickVideo
	    }));
	  }

	  handleClick(onClick, event) {
	    onClick && onClick(event);
	  }

	  handleClickVideo(event) {
	    event.stopPropagation();
	  }

	}

	Video.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  url: propTypes.string,
	  onClick: propTypes.func
	};
	Video.defaultProps = {
	  className: null,
	  style: null,
	  url: null,
	  onClick: null
	};

	/**
	 * 语言加载器
	 * @author tengge / https://github.com/tengge1
	 */

	class LanguageLoader {
	  constructor() {
	    window.i18next = i18next;
	    window._t = i18next.t.bind(i18next);
	  }

	  load() {
	    let lang = window.localStorage.getItem('lang');

	    if (!lang) {
	      let language = window.navigator.language.toLocaleLowerCase();

	      if (language === 'zh-cn') {
	        lang = 'zh-CN';
	      } else {
	        lang = 'en-US';
	      }

	      window.localStorage.setItem('lang', lang);
	    }

	    return new Promise(resolve => {
	      i18next.use(Backend).init({
	        lng: lang,
	        debug: false,
	        whitelist: ['en-US', 'zh-CN', 'zh-TW', 'ja-JP', 'ko-KR', 'ru-RU', 'fr-FR'],
	        backend: {
	          // for all available options read the backend's repository readme file
	          loadPath: 'locales/{{lng}}.json'
	        },
	        // allow keys to be phrases having `:`, `.`
	        nsSeparator: false,
	        keySeparator: false,
	        // do not load a fallback
	        fallbackLng: false
	      }, err => {
	        if (err) {
	          console.warn(err);
	        }

	        resolve();
	      });
	    });
	  }

	}

	/**
	 * 存储类
	 */
	class Storage {
	  constructor() {
	    // 向本地存储写入默认配置，并提供快捷访问方法
	    const defaultConfigs = {
	      debug: false,
	      // 调试模式
	      autoSave: false,
	      // 自动保存
	      // 视图相关
	      assetsPanelShow: true,
	      sidebarShow: true,
	      toolbarShow: true,
	      timelinePanelShow: true,
	      statusBarShow: true,
	      // 帮助器
	      showStats: true,
	      // 性能监视器
	      showGrid: true,
	      // 网格
	      showViewHelper: true,
	      // 视角帮助器
	      showCamera: false,
	      showPointLight: true,
	      showDirectionalLight: true,
	      showSpotLight: true,
	      showHemisphereLight: true,
	      showRectAreaLight: true,
	      showSkeleton: false,
	      // 选中效果
	      selectMode: 'whole',
	      // whole: 选择整体；part: 选择部分。
	      selectedColor: '#ff6600',
	      // unity3d: #ff6600
	      selectedThickness: 4,
	      // 高亮效果
	      hoverEnabled: false,
	      // 高亮效果
	      hoveredColor: '#ffff00',
	      // 编辑模式
	      addMode: 'center',
	      // 添加模式：center: 添加到场景中心；click: 点击场景添加。
	      controlMode: 'EditorControls' // 控制器模式：EditorControls: 编辑器控制器；FreeControls: 自由控制器。

	    };

	    let configs = this._getConfigs();

	    Object.entries(defaultConfigs).forEach(n => {
	      if (configs[n[0]] === undefined) {
	        configs[n[0]] = n[1];
	      }

	      Object.defineProperty(this, n[0], {
	        get: () => {
	          return this.get(n[0]);
	        },
	        set: value => {
	          return this.set(n[0], value);
	        }
	      });
	    });

	    this._setConfigs(configs);
	  }
	  /**
	   * 获取本地存储键值
	   * @param {String} key 键
	   * @returns {Object} 值，不存储返回undefined
	   */


	  get(key) {
	    let configs = this._getConfigs();

	    return configs[key];
	  }
	  /**
	   * 设置本地存储
	   * @param {String} key 键
	   * @param {String} value 值
	   */


	  set(key, value) {
	    let configs = this._getConfigs();

	    configs[key] = value;

	    this._setConfigs(configs);

	    if (app.call) {
	      app.call(`storageChanged`, this, key, value);
	    } else {
	      console.warn(`Storage: EventDispatcher has not been created.`);
	    }
	  }

	  setConfigs(configs) {
	    if (typeof configs !== 'object') {
	      console.warn(`Storage: configs should be an object.`);
	      return;
	    }

	    let _configs = this._getConfigs();

	    Object.keys(configs).forEach(n => {
	      _configs[n] = configs[n];
	    });

	    this._setConfigs(_configs);
	  }

	  remove(key) {
	    let configs = this._getConfigs();

	    delete configs[key];

	    this._setConfigs(configs);
	  }

	  clear() {
	    window.localStorage.removeItem('configs');
	  }

	  _getConfigs() {
	    let configs = window.localStorage.getItem('configs');

	    if (!configs) {
	      configs = '{}';
	    }

	    return JSON.parse(configs);
	  }

	  _setConfigs(configs) {
	    window.localStorage.setItem('configs', JSON.stringify(configs));
	  }

	}

	/**
	 * 服务端功能
	 * @author tengge / https://github.com/tengge1
	 */
	class Server {
	  constructor(server) {
	    this.origin = server;
	    this.enableAuthority = false; // 是否开启权限

	    this.initialized = false; // 系统是否初始化

	    this.isLogin = false; // 是否登录

	    this.username = ''; // 登录用户名

	    this.name = ''; // 登录姓名

	    this.roleName = ''; // 角色名称

	    this.deptName = ''; // 机构名称

	    this.authorities = []; // 权限列表

	    this.isAdmin = false; // 是否是管理员

	    this.enableRemoteEdit = false;
	    this.webSocketServerPort = 5000;
	  }

	  load() {
	    return new Promise(resolve => {
	      fetch(`${this.origin}/api/Config/Get`).then(response => {
	        response.json().then(obj => {
	          if (obj.Code !== 200) {
	            app.toast(_t(obj.Msg), 'warn');
	            return;
	          }

	          this.enableAuthority = obj.Data.EnableAuthority;
	          this.initialized = obj.Data.Initialized;
	          this.isLogin = obj.Data.IsLogin;
	          this.username = obj.Data.Username;
	          this.name = obj.Data.Name;
	          this.roleName = obj.Data.RoleName;
	          this.deptName = obj.Data.DeptName;
	          this.authorities = obj.Data.OperatingAuthorities;
	          this.isAdmin = this.roleName === 'Administrator';
	          this.enableRemoteEdit = obj.Data.EnableRemoteEdit;
	          this.webSocketServerPort = obj.Data.WebSocketServerPort;
	          resolve();
	        }).catch(e => {
	          console.warn(e);
	          app.toast(_t('Server configuration acquisition failed.'), 'error');
	          resolve();
	        });
	      }).catch(e => {
	        console.warn(e);
	        app.toast(_t('Server configuration acquisition failed.'), 'error');
	        resolve();
	      });
	    });
	  }

	  login(username, password) {
	    return new Promise(resolve => {
	      fetch(`${this.origin}/api/Login/Login`, {
	        method: 'POST',
	        headers: {
	          'Content-Type': 'application/x-www-form-urlencoded'
	        },
	        body: `Username=${username}&Password=${password}`
	      }).then(response => {
	        response.json().then(obj => {
	          if (obj.Code !== 200) {
	            app.toast(_t(obj.Msg), 'warn');
	            resolve(false);
	            return;
	          }

	          this.isLogin = true;
	          this.username = obj.Data.Username;
	          this.name = obj.Data.Name; // TODO: 登录后返回所有信息
	          // this.roleName = ''; // 角色名称
	          // this.deptName = ''; // 机构名称
	          // this.authorities = []; // 权限列表
	          // this.authorities = obj.Data.OperatingAuthorities;
	          // this.isAdmin = false; // 是否是管理员

	          app.call('login', this);
	          resolve(true);
	        });
	      });
	    });
	  }

	  logout() {
	    return new Promise(resolve => {
	      fetch(`${this.origin}/api/Login/Logout`, {
	        method: 'POST'
	      }).then(response => {
	        response.json().then(obj => {
	          if (obj.Code !== 200) {
	            app.toast(_t(obj.Msg), 'warn');
	            resolve(false);
	            return;
	          }

	          this.isLogin = false;
	          this.username = '';
	          this.name = '';
	          app.call('logout', this);
	          resolve(true);
	        });
	      });
	    });
	  }

	}

	/**
	 * 自定义事件列表
	 * @author tengge / https://github.com/tengge1
	 */
	var EventList = [// dom事件
	'click', // 点击
	'contextmenu', // 右键
	'dblclick', // 双击
	'keydown', // 按下键盘按键
	'keyup', // 抬起键盘按键
	'mousedown', // 按下鼠标按键
	'mousemove', // 鼠标移动
	'mouseup', // 抬起鼠标按键
	'mousewheel', // 鼠标滚轮
	'resize', // 窗口大小改变
	'dragover', // 拖动到某元素上
	'drop', // 放置到某元素上
	// app事件
	'appStart', // 应用程序开始前调用
	'appStarted', // 应用程序开始后调用
	'appStop', // 程序开始结束前调用
	'appStoped', // 程序结束后调用
	'showMask', // 是否显示加载器
	'login', // 登录成功
	'logout', // 注销成功
	'message', // 接收到一个WebSocket消息，格式：{ type: 'Message Type', ... }
	'send', // 通过WebSocket向服务端发送消息，格式：{ type: 'Message Type', ... }
	'queryLoadAutoSceneScene', // 提示是否加载自动保存的场景
	// 配置
	'optionChange', // 某个配置发生变化
	'optionsChanged', // 配置改变事件（参数：无）
	'storageChanged', // 存储改变事件（参数：key, value）
	// 工具栏事件
	'changeMode', // 改变模式（select, translate, rotate, scale, delete）
	'changeView', // 改变视图（perspective, front, side, top）
	'viewChanged', // 视图已经改变
	// 编辑工具栏
	'undo', 'redo', 'clearHistory', 'copy', 'clone', 'delete', // editor事件
	'sceneSaved', // 场景保存成功
	'select', // 选中事件
	'clear', // 清空场景
	'load', // 加载场景，(url, name, id)
	'loadSceneList', // 加载场景，(list, name, id)
	'log', // 日志事件
	'editScript', // 编辑脚本事件 uuid, name, type, source
	'editorCleared', // 编辑器已经清空事件
	'snapChanged', // 对齐单元格事件
	'spaceChanged', // 空间坐标系改变事件
	'sceneGraphChanged', // 场景内容改变事件
	'cameraChanged', // 相机改变事件
	'rendererChanged', // 渲染器改变
	'geometryChanged', // 几何体改变事件
	'objectSelected', // 物体选中改变
	'objectFocused', // 物体交点改变事件
	'objectAdded', // 添加物体事件
	'objectChanged', // 物体改变事件
	'objectRemoved', // 物体移除事件
	'addText', // 添加文字
	'removeText', // 移除文字
	'scriptChanged', // 脚本改变事件
	'historyChanged', // 历史改变事件
	'refreshScriptEditor', // 刷新脚本编辑器事件
	'sceneLoaded', // 场景载入
	'postProcessingChanged', // 后期处理设置改变
	'currentMaterialChange', // 当前材质改变
	// 场景编辑区
	'transformControlsChange', // 变形控件改变
	'transformControlsMouseDown', // 变形控件按下鼠标键
	'transformControlsMouseUp', // 变形控件抬起鼠标键
	'raycast', // 光线投射（不碰到模型也会触发）
	'intersect', // 碰撞到模型（只有碰撞到模型才会触发）
	'gpuPick', // 使用GPU选取到某个模型，参数：{ object: 碰撞到的物体，没碰到为null, point: 碰撞到物体坐标点，没碰到与y=0平面碰撞, distance: 相机到碰撞点距离，没碰到为0 }
	'beforeRender', // 渲染前执行
	'afterRender', // 渲染后执行
	'animate', // 进行动画
	// 侧边栏
	'animationSelected', // 动画选中事件
	'animationChanged', // 动画发生改变事件
	'resetAnimation', // 重制动画时间轴
	'startAnimation', // 开始播放动画
	'animationTime', // 时间轴发送当前动画时间
	// 底部面板事件
	'selectBottomPanel', // 点击选择某个面板
	'showBottomPanel', // 显示某个底部面板以后
	'selectModel', // 选择模型
	'selectMap', // 选择贴图
	'selectMaterial', // 选择材质
	'selectAudio', // 选择音频
	'selectAnimation', // 选择动画
	'selectParticle', // 选择粒子
	// 状态栏事件
	'enableThrowBall' // 是否允许扔小球
	];

	var ID$6 = -1;
	/**
	 * 事件基类
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseEvent() {
	  this.id = `${this.constructor.name}${ID$6--}`;
	}

	BaseEvent.prototype.start = function () {};

	BaseEvent.prototype.stop = function () {};

	/**
	 * 渲染事件
	 * @author tengge / https://github.com/tengge1
	 */

	function RenderEvent() {
	  BaseEvent.call(this);
	  this.clock = new THREE.Clock();
	  this.running = true;
	  this.render = this.render.bind(this);
	  this.createRenderer = this.createRenderer.bind(this);
	  this.onViewChanged = this.onViewChanged.bind(this);
	}

	RenderEvent.prototype = Object.create(BaseEvent.prototype);
	RenderEvent.prototype.constructor = RenderEvent;

	RenderEvent.prototype.start = function () {
	  this.running = true;
	  app.on(`appStarted.${this.id}`, this.render);
	  app.on(`viewChanged.${this.id}`, this.onViewChanged);
	};

	RenderEvent.prototype.stop = function () {
	  this.running = false;
	  app.on(`appStarted.${this.id}`, null);
	  app.on(`viewChanged.${this.id}`, null);
	};

	RenderEvent.prototype.render = function () {
	  if (app.options.sceneType === 'GIS') {
	    return;
	  }

	  const {
	    scene,
	    sceneHelpers
	  } = app.editor;

	  this.clock._getDelta(); // see: ../polyfills.js


	  const deltaTime = this.clock.getDelta();
	  app.call('animate', this, this.clock, deltaTime);
	  app.stats.begin();
	  scene.updateMatrixWorld();
	  sceneHelpers.updateMatrixWorld();
	  app.editor.renderer.clear();
	  app.call('beforeRender', this, this.clock, deltaTime);

	  if (this.renderer === undefined) {
	    this.createRenderer().then(() => {
	      this.render();
	    });
	    app.on(`sceneLoaded.${this.id}`, this.createRenderer);
	    app.on(`postProcessingChanged.${this.id}`, this.createRenderer);
	    return;
	  } else {
	    this.renderer.render();
	  }

	  app.call('afterRender', this, this.clock, deltaTime);
	  app.stats.end();

	  if (this.running) {
	    requestAnimationFrame(this.render);
	  }
	};

	RenderEvent.prototype.createRenderer = function () {
	  const {
	    scene,
	    sceneHelpers,
	    camera,
	    renderer
	  } = app.editor;
	  this.renderer = new EffectRenderer();
	  return this.renderer.create([scene, sceneHelpers], app.editor.view === 'perspective' ? camera : app.editor.orthCamera, renderer);
	};

	RenderEvent.prototype.onViewChanged = function () {
	  this.createRenderer();
	};

	/**
	 * 窗口大小改变事件
	 * @author tengge / https://github.com/tengge1
	 */

	function ResizeEvent() {
	  BaseEvent.call(this);
	}

	ResizeEvent.prototype = Object.create(BaseEvent.prototype);
	ResizeEvent.prototype.constructor = ResizeEvent;

	ResizeEvent.prototype.start = function () {
	  app.on(`resize.${this.id}`, this.onResize.bind(this));
	};

	ResizeEvent.prototype.stop = function () {
	  app.on(`resize.${this.id}`, null);
	};

	ResizeEvent.prototype.onResize = function () {
	  let {
	    editor,
	    viewport
	  } = app;
	  let {
	    DEFAULT_CAMERA,
	    camera,
	    orthCamera,
	    renderer
	  } = editor;
	  const width = viewport.clientWidth;
	  const height = viewport.clientHeight;

	  if (this.width === undefined || this.height === undefined) {
	    this.width = width;
	    this.height = height;
	  }

	  DEFAULT_CAMERA.aspect = width / height;
	  DEFAULT_CAMERA.updateProjectionMatrix();
	  camera.aspect = width / height;
	  camera.updateProjectionMatrix();

	  if (width !== this.width) {
	    let dwidth = (orthCamera.right - orthCamera.left) * (width / this.width - 1);
	    orthCamera.left -= dwidth / 2;
	    orthCamera.right += dwidth / 2;
	    this.width = width;
	  }

	  if (height !== this.height) {
	    let dheight = (orthCamera.top - orthCamera.bottom) * (height / this.height - 1);
	    orthCamera.top += dheight / 2;
	    orthCamera.bottom -= dheight / 2;
	    this.height = height;
	  }

	  orthCamera.updateProjectionMatrix();
	  renderer.setSize(width, height);
	};

	/**
	 * 滤镜事件
	 * @author tengge / https://github.com/tengge1
	 */

	function FilterEvent() {
	  BaseEvent.call(this);
	}

	FilterEvent.prototype = Object.create(BaseEvent.prototype);
	FilterEvent.prototype.constructor = FilterEvent;

	FilterEvent.prototype.start = function () {
	  app.on(`editorCleared.${this.id}`, this.onEditorCleared.bind(this));
	  app.on(`optionsChanged.${this.id}`, this.onOptionsChanged.bind(this));
	};

	FilterEvent.prototype.stop = function () {
	  app.on(`editorCleared.${this.id}`, null);
	  app.on(`optionsChanged.${this.id}`, null);
	};

	FilterEvent.prototype.onEditorCleared = function () {
	  app.editor.renderer.domElement.style.filter = '';
	};

	FilterEvent.prototype.onOptionsChanged = function () {
	  app.editor.renderer.domElement.style.filter = CssUtils.serializeFilter(app.options);
	};

	/**
	 * 正交相机控制器
	 * @author tengge / https://github.com/tengge1
	 * @param {THREE.OrthographicCamera} camera 正交相机
	 * @param {HTMLElement} domElement DOM
	 */
	function OrthographicCameraControls(camera, domElement) {
	  this.camera = camera;
	  this.domElement = domElement;
	  this.enabled = false;
	  this.isDown = false;
	  this.offsetXY = new THREE.Vector2();
	  this.onMouseDown = this.onMouseDown.bind(this);
	  this.onMouseMove = this.onMouseMove.bind(this);
	  this.onMouseUp = this.onMouseUp.bind(this);
	  this.onMouseWheel = this.onMouseWheel.bind(this);
	}

	OrthographicCameraControls.prototype.enable = function () {
	  if (this.enabled) {
	    return;
	  }

	  this.enabled = true;
	  this.domElement.addEventListener('mousedown', this.onMouseDown);
	  this.domElement.addEventListener('mousemove', this.onMouseMove);
	  this.domElement.addEventListener('mouseup', this.onMouseUp);
	  this.domElement.addEventListener('mousewheel', this.onMouseWheel);
	};

	OrthographicCameraControls.prototype.disable = function () {
	  if (!this.enabled) {
	    return;
	  }

	  this.enabled = false;
	  this.domElement.removeEventListener('mousedown', this.onMouseDown);
	  this.domElement.removeEventListener('mousemove', this.onMouseMove);
	  this.domElement.removeEventListener('mouseup', this.onMouseUp);
	  this.domElement.removeEventListener('mousewheel', this.onMouseWheel);
	};

	OrthographicCameraControls.prototype.onMouseDown = function (event) {
	  this.isDown = true;
	  this.offsetXY.set(event.offsetX, event.offsetY);
	};

	OrthographicCameraControls.prototype.onMouseMove = function (event) {
	  if (!this.isDown) {
	    return;
	  } // let camera = this.camera;


	  let width = this.domElement.clientWidth;
	  let height = this.domElement.clientHeight;
	  let dx = (event.offsetX - this.offsetXY.x) * (this.camera.right - this.camera.left) / width;
	  let dy = (event.offsetY - this.offsetXY.y) * (this.camera.top - this.camera.bottom) / height;
	  this.camera.left -= dx;
	  this.camera.right -= dx;
	  this.camera.top += dy;
	  this.camera.bottom += dy;
	  this.camera.updateProjectionMatrix();
	  this.offsetXY.set(event.offsetX, event.offsetY);
	};

	OrthographicCameraControls.prototype.onMouseUp = function () {
	  this.isDown = false;
	};

	OrthographicCameraControls.prototype.onMouseWheel = function (event) {
	  const delta = -event.wheelDelta / 1000;
	  let camera = this.camera;
	  let width = this.domElement.clientWidth;
	  let height = this.domElement.clientHeight;
	  let pointerX = camera.left + (camera.right - camera.left) * event.offsetX / width;
	  let pointerY = camera.top - (camera.top - camera.bottom) * event.offsetY / height;
	  camera.left = camera.left - Math.abs(pointerX - camera.left) * delta;
	  camera.right = camera.right + Math.abs(camera.right - pointerX) * delta;
	  camera.top = camera.top + Math.abs(camera.top - pointerY) * delta;
	  camera.bottom = camera.bottom - Math.abs(pointerY - camera.bottom) * delta;
	  camera.updateProjectionMatrix();
	};

	/**
	 * 视图事件
	 * @author tengge / https://github.com/tengge1
	 */

	function ViewEvent() {
	  BaseEvent.call(this);
	  this.changeView = this.changeView.bind(this);
	}

	ViewEvent.prototype = Object.create(BaseEvent.prototype);
	ViewEvent.prototype.constructor = ViewEvent;

	ViewEvent.prototype.start = function () {
	  app.on(`changeView.${this.id}`, this.changeView);
	};

	ViewEvent.prototype.stop = function () {
	  app.on(`changeView.${this.id}`, null);
	};

	ViewEvent.prototype.changeView = function (view) {
	  if (view === app.editor.view) {
	    return;
	  }

	  app.editor.view = view;

	  if (this.controls === undefined) {
	    this.controls = new OrthographicCameraControls(app.editor.orthCamera, app.editor.renderer.domElement);
	  }

	  if (view === 'perspective') {
	    app.editor.controls.enable();
	    app.editor.showViewHelper = true;
	    this.controls.disable();
	    app.call(`viewChanged`, this, view);
	    return;
	  }

	  let camera = app.editor.orthCamera; // 使用透视相机离原点最远距离设置正交相机

	  let distance = Math.max(app.editor.camera.position.x, app.editor.camera.position.y, app.editor.camera.position.z);

	  switch (view) {
	    case 'front':
	      camera.position.set(distance, 0, 0);
	      camera.lookAt(new THREE.Vector3());
	      break;

	    case 'side':
	      camera.position.set(0, 0, distance);
	      camera.lookAt(new THREE.Vector3());
	      break;

	    case 'top':
	      camera.position.set(0, distance, 0);
	      camera.lookAt(new THREE.Vector3());
	      break;
	  }

	  app.editor.select(null);
	  app.editor.controls.disable();
	  app.editor.showViewHelper = false;
	  this.controls.enable();
	  app.call(`viewChanged`, this, view);
	};

	var PickVertexShader = "void main() {\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}";

	var PickFragmentShader = "uniform vec3 pickColor;\r\n\r\nvoid main() {\r\n    gl_FragColor = vec4(pickColor, 1.0);\r\n}";

	var DepthVertexShader = "precision highp float;\r\n\r\nuniform float far;\r\n\r\nvarying float depth;\r\n\r\nvoid main() {\r\n    // 参考：https://stackoverflow.com/questions/6408851/draw-the-depth-value-in-opengl-using-shaders\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    depth = gl_Position.z / far;\r\n}";

	var DepthFragmentShader = "precision highp float;\r\n\r\nvarying float depth;\r\n\r\nvoid main() {\r\n    // 参考：https://gamedev.stackexchange.com/questions/93055/getting-the-real-fragment-depth-in-glsl\r\n    // 不能直接输出gl_FragCoord.z /  gl_FragCoord.w的原因是：\r\n    // 由于far=10000，gl_FragCoord.z /  gl_FragCoord.w（屏幕坐标系中的深度）非常接近1.0，几乎不变；\r\n    // 而gl_FragCoord.z是相机坐标系中的深度，线性变化的。\r\n\r\n    float hex = abs(depth) * 16777215.0; // 0xffffff\r\n\r\n    float r = floor(hex / 65535.0);\r\n    float g = floor((hex - r * 65535.0) / 255.0);\r\n    float b = floor(hex - r * 65535.0 - g * 255.0);\r\n    float a = sign(depth) >= 0.0 ? 1.0 : 0.0; // depth大于等于0，为1.0；小于0，为0.0。\r\n\r\n    gl_FragColor = vec4(r / 255.0, g / 255.0, b / 255.0, a);\r\n}";

	let maxHexColor = 1;
	/**
	 * 使用GPU选取物体和计算鼠标世界坐标
	 * @author tengge / https://github.com/tengge1
	 */

	function GPUPickEvent() {
	  BaseEvent.call(this);
	  this.isIn = false;
	  this.offsetX = 0;
	  this.offsetY = 0;
	  this.waitTime = 10; // 10毫秒检测一次，提升性能

	  this.oldTime = 0;
	  this.selectMode = 'whole';
	  this.onMouseMove = this.onMouseMove.bind(this);
	  this.onAfterRender = this.onAfterRender.bind(this);
	  this.onResize = this.onResize.bind(this);
	  this.onStorageChanged = this.onStorageChanged.bind(this);
	}

	GPUPickEvent.prototype = Object.create(BaseEvent.prototype);
	GPUPickEvent.prototype.constructor = GPUPickEvent;

	GPUPickEvent.prototype.start = function () {
	  app.on(`mousemove.${this.id}`, this.onMouseMove);
	  app.on(`afterRender.${this.id}`, this.onAfterRender);
	  app.on(`resize.${this.id}`, this.onResize);
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged);
	  this.selectMode = app.storage.selectMode;
	};

	GPUPickEvent.prototype.stop = function () {
	  app.on(`mousemove.${this.id}`, null);
	  app.on(`afterRender.${this.id}`, null);
	  app.on(`resize.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	  this.selectMode = 'whole';
	};

	GPUPickEvent.prototype.onMouseMove = function (event) {
	  if (event.target !== app.editor.renderer.domElement) {
	    // 鼠标不在画布上
	    this.isIn = false;
	    app.call(`gpuPick`, this, {
	      object: null,
	      point: null,
	      distance: 0
	    });
	    return;
	  }

	  this.isIn = true;
	  this.offsetX = event.offsetX;
	  this.offsetY = event.offsetY;
	};
	/**
	 * 由于需要较高性能，所以尽量不要拆分函数。
	 */


	GPUPickEvent.prototype.onAfterRender = function () {
	  if (!this.isIn || app.editor.gpuPickNum === 0) {
	    return;
	  } // 间隔一段时间执行一次，提高性能


	  let now = new Date().getTime();

	  if (now - this.oldTime < this.waitTime) {
	    return;
	  }

	  this.oldTime = now;
	  let {
	    scene,
	    renderer
	  } = app.editor;
	  const camera = app.editor.view === 'perspective' ? app.editor.camera : app.editor.orthCamera;
	  const {
	    width,
	    height
	  } = renderer.domElement;

	  if (this.init === undefined) {
	    this.init = true;
	    this.depthMaterial = new THREE.ShaderMaterial({
	      vertexShader: DepthVertexShader,
	      fragmentShader: DepthFragmentShader,
	      uniforms: {
	        far: {
	          value: camera.far
	        }
	      }
	    });
	    this.renderTarget = new THREE.WebGLRenderTarget(width, height);
	    this.pixel = new Uint8Array(4);
	    this.nearPosition = new THREE.Vector3(); // 鼠标屏幕位置在near处的相机坐标系中的坐标

	    this.farPosition = new THREE.Vector3(); // 鼠标屏幕位置在far处的相机坐标系中的坐标

	    this.world = new THREE.Vector3(); // 通过插值计算世界坐标

	    this.line = new THREE.Line3(this.nearPosition, this.farPosition);
	    this.plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), new THREE.Vector3());
	  } // 记录旧属性


	  const oldBackground = scene.background;
	  const oldOverrideMaterial = scene.overrideMaterial;
	  const oldRenderTarget = renderer.getRenderTarget(); // ---------------------------- 1. 使用GPU判断选中的物体 -----------------------------------

	  scene.background = null; // 有背景图，可能导致提取的颜色不准

	  scene.overrideMaterial = null;
	  renderer.setRenderTarget(this.renderTarget); // 更换选取材质

	  scene.traverseVisible(n => {
	    if (!(n instanceof THREE.Mesh)) {
	      return;
	    }

	    n.oldMaterial = n.material;

	    if (n.pickMaterial) {
	      n.material = n.pickMaterial;
	      return;
	    }

	    let material = new THREE.ShaderMaterial({
	      vertexShader: PickVertexShader,
	      fragmentShader: PickFragmentShader,
	      uniforms: {
	        pickColor: {
	          value: new THREE.Color(maxHexColor)
	        }
	      }
	    });
	    n.pickColor = maxHexColor;
	    maxHexColor++;
	    n.material = n.pickMaterial = material;
	  }); // 绘制并读取像素

	  renderer.clear(); // 一定要清缓冲区，renderer没开启自动清空缓冲区

	  renderer.render(scene, camera);
	  renderer.readRenderTargetPixels(this.renderTarget, this.offsetX, height - this.offsetY, 1, 1, this.pixel); // 还原原来材质，并获取选中物体

	  const currentColor = this.pixel[0] * 0xffff + this.pixel[1] * 0xff + this.pixel[2];
	  let selected = null;
	  scene.traverseVisible(n => {
	    if (!(n instanceof THREE.Mesh)) {
	      return;
	    }

	    if (n.pickMaterial && n.pickColor === currentColor) {
	      selected = n;
	    }

	    if (n.oldMaterial) {
	      n.material = n.oldMaterial;
	      delete n.oldMaterial;
	    }
	  }); // ------------------------- 2. 使用GPU反算世界坐标 ----------------------------------

	  scene.overrideMaterial = this.depthMaterial; // 注意：this.material为undifined，写在这也不会报错，不要写错了。

	  renderer.clear();
	  renderer.render(scene, camera);
	  renderer.readRenderTargetPixels(this.renderTarget, this.offsetX, height - this.offsetY, 1, 1, this.pixel);
	  let cameraDepth = 0;
	  const deviceX = this.offsetX / width * 2 - 1;
	  const deviceY = -this.offsetY / height * 2 + 1; // TODO: nearPosition和farPosition命名反了

	  this.nearPosition.set(deviceX, deviceY, 1); // 屏幕坐标系：(0, 0, 1)

	  this.nearPosition.applyMatrix4(camera.projectionMatrixInverse); // 相机坐标系：(0, 0, -far)

	  this.farPosition.set(deviceX, deviceY, -1); // 屏幕坐标系：(0, 0, -1)

	  this.farPosition.applyMatrix4(camera.projectionMatrixInverse); // 相机坐标系：(0, 0, -near)

	  if (this.pixel[2] !== 0 || this.pixel[1] !== 0 || this.pixel[0] !== 0) {
	    // 鼠标位置存在物体
	    let hex = (this.pixel[0] * 65535 + this.pixel[1] * 255 + this.pixel[2]) / 0xffffff;

	    if (this.pixel[3] === 0) {
	      hex = -hex;
	    }

	    cameraDepth = -hex * camera.far; // 相机坐标系中鼠标所在点的深度（注意：相机坐标系中的深度值为负值）

	    const t = (cameraDepth - this.nearPosition.z) / (this.farPosition.z - this.nearPosition.z);
	    this.world.set(this.nearPosition.x + (this.farPosition.x - this.nearPosition.x) * t, this.nearPosition.y + (this.farPosition.y - this.nearPosition.y) * t, cameraDepth);
	    this.world.applyMatrix4(camera.matrixWorld);
	  } else {
	    // 鼠标位置不存在物体，则与y=0的平面的交点
	    this.nearPosition.applyMatrix4(camera.matrixWorld); // 世界坐标系近点

	    this.farPosition.applyMatrix4(camera.matrixWorld); // 世界坐标系远点

	    this.line.set(this.nearPosition, this.farPosition);
	    this.plane.intersectLine(this.line, this.world);
	  } // 还原原来的属性


	  scene.background = oldBackground;
	  scene.overrideMaterial = oldOverrideMaterial;
	  renderer.setRenderTarget(oldRenderTarget); // ------------------------------- 3. 输出碰撞结果 --------------------------------------------

	  if (selected && this.selectMode === 'whole') {
	    // 选择整体
	    selected = MeshUtils.partToMesh(selected);
	  }

	  app.call(`gpuPick`, this, {
	    object: selected,
	    // 碰撞到的物体，没碰到为null
	    point: this.world,
	    // 碰撞点坐标，没碰到物体与y=0平面碰撞
	    distance: cameraDepth // 相机到碰撞点距离

	  });
	};

	GPUPickEvent.prototype.onResize = function () {
	  if (!this.renderTarget) {
	    return;
	  }

	  const {
	    width,
	    height
	  } = app.editor.renderer.domElement;
	  this.renderTarget.setSize(width, height);
	};

	GPUPickEvent.prototype.onStorageChanged = function (name, value) {
	  if (name === 'selectMode') {
	    this.selectMode = value;
	  }
	};

	/**
	 * WebSocket事件
	 * @author tengge / https://github.com/tengge1
	 */

	class WebSocketEvent extends BaseEvent {
	  constructor() {
	    super();
	    this.reconnectTime = 5000; // 重新连接时间

	    this.handleSend = this.handleSend.bind(this);
	    this.onOpen = this.onOpen.bind(this);
	    this.onMessage = this.onMessage.bind(this);
	    this.onError = this.onError.bind(this);
	    this.onClose = this.onClose.bind(this);
	  }

	  start() {
	    if (!app.server.enableRemoteEdit) {
	      return;
	    }

	    let url = `ws://${new URL(app.options.server).hostname}:${app.server.webSocketServerPort}/RemoteEdit`;

	    try {
	      this.socket = new WebSocket(url);
	    } catch (e) {
	      console.warn(e);
	    }

	    app.on(`send.${this.id}`, this.handleSend);
	    this.socket.addEventListener('open', this.onOpen);
	    this.socket.addEventListener('message', this.onMessage);
	    this.socket.addEventListener('error', this.onError);
	    this.socket.addEventListener('close', this.onClose);
	  }

	  stop() {
	    if (!this.socket) {
	      return;
	    }

	    app.on(`send.${this.id}`, null);
	    this.socket.removeEventListener('open', this.onOpen);
	    this.socket.removeEventListener('message', this.onMessage);
	    this.socket.removeEventListener('error', this.onError);
	    this.socket.removeEventListener('close', this.onClose);
	  }

	  reconnect() {
	    this.stop();
	    this.start();
	  }
	  /**
	   * 通过WebSocket向服务端发送消息
	   * @param {Object} obj 数据
	   * @param {String} obj.type 消息类型
	   */


	  handleSend(obj) {
	    if (!this.socket) {
	      return;
	    }

	    if (this.socket.readyState !== this.socket.OPEN) {
	      this.reconnect();
	      return;
	    }

	    this.socket.send(JSON.stringify(obj));
	  }

	  onOpen() {
	    console.log('WebSocket open successfully.');
	  }

	  onMessage(event) {
	    console.log('WebSocket message received.', event.data);
	  }

	  onError(event) {
	    console.warn('WebSocket Error:', event);
	    setTimeout(() => {
	      this.reconnect();
	    }, this.reconnectTime);
	  }

	  onClose() {
	    console.log('WebSocket closed.');
	    setTimeout(() => {
	      this.reconnect();
	    }, this.reconnectTime);
	  }

	}

	/**
	 * 脚本改变事件
	 * @author tengge / https://github.com/tengge1
	 */

	class ScriptChangedEvent extends BaseEvent {
	  constructor() {
	    super();
	    this.handleChange = this.handleChange.bind(this);
	  }

	  start() {
	    app.on(`scriptChanged.${this.id}`, this.handleChange);
	  }

	  stop() {
	    app.on(`scriptChanged.${this.id}`, null);
	  }

	  handleChange() {
	    app.call('send', this, {
	      type: 'changeScript',
	      scripts: app.editor.scripts
	    });
	  }

	}

	/**
	 * 时间工具
	 * @author tengge / https://github.com/tengge1
	 */
	const TimeUtils = {
	  getDateTime: function (format = 'yyyyMMddHHmmss') {
	    let date = new Date();
	    let year = date.getFullYear();
	    let month = `00${date.getMonth() + 1}`;
	    let day = `00${date.getDate()}`;
	    let hour = `00${date.getHours()}`;
	    let minute = `00${date.getMinutes()}`;
	    let second = `00${date.getSeconds()}`;
	    month = month.substr(month.length - 2, 2);
	    day = day.substr(day.length - 2, 2);
	    hour = hour.substr(hour.length - 2, 2);
	    minute = minute.substr(minute.length - 2, 2);
	    second = second.substr(second.length - 2, 2);
	    return format.replace('yyyy', year).replace('MM', month).replace('dd', day).replace('HH', hour).replace('mm', minute).replace('ss', second);
	  }
	};

	/**
	 * 自动保存事件
	 * @author tengge / https://github.com/tengge1
	 */

	class AutoSaveEvent extends BaseEvent {
	  constructor() {
	    super();
	    this.autoSave = true;
	    this.autoSaveTime = 10000; // 自动保存时间

	    this.saveProcess = null;
	    this.queryLoad = false; // 是否正在询问加载自动保存场景

	    this.handleSave = this.handleSave.bind(this);
	    this.handleLoad = this.handleLoad.bind(this);
	    this.handleStorageChange = this.handleStorageChange.bind(this);
	  }

	  start() {
	    this.autoSave = app.storage.autoSave;
	    app.on(`storageChanged.${this.id}`, this.handleStorageChange);
	    app.on(`queryLoadAutoSceneScene.${this.id}`, this.handleLoad);

	    if (this.autoSave) {
	      this.saveProcess = setTimeout(this.handleSave, this.autoSaveTime);
	    }
	  }

	  stop() {
	    app.on(`storageChanged.${this.id}`, null);
	  }

	  handleSave() {
	    if (this.saveProcess) {
	      clearTimeout(this.saveProcess);
	    } // 正在询问是否加载自动保存的场景，避免自动保存功能将原来的场景覆盖。


	    if (this.queryLoad) {
	      if (this.autoSave) {
	        this.saveProcess = setTimeout(this.handleSave, this.autoSaveTime);
	      }

	      return;
	    }

	    const editor = app.editor;
	    const obj = new Converter().toJSON({
	      options: app.options,
	      camera: editor.camera,
	      renderer: editor.renderer,
	      scripts: editor.scripts,
	      animations: editor.animations,
	      scene: editor.scene,
	      visual: editor.visual
	    });
	    const now = TimeUtils.getDateTime('yyyy-MM-dd HH:mm:ss');
	    window.localStorage.setItem('autoSaveData', JSON.stringify(obj));
	    window.localStorage.setItem('autoSaveTime', now);
	    window.localStorage.setItem('autoSaveSceneID', app.editor.sceneID);
	    window.localStorage.setItem('autoSaveSceneName', app.editor.sceneName);
	    console.log(`${now}, scene auto saved.`);

	    if (this.autoSave) {
	      this.saveProcess = setTimeout(this.handleSave, this.autoSaveTime);
	    }
	  }

	  handleLoad() {
	    const autoSaveTime = window.localStorage.getItem('autoSaveTime');
	    const autoSaveData = window.localStorage.getItem('autoSaveData');
	    const autoSaveSceneID = window.localStorage.getItem('autoSaveSceneID');
	    const autoSaveSceneName = window.localStorage.getItem('autoSaveSceneName');

	    if (!autoSaveData) {
	      return;
	    }

	    this.queryLoad = true;
	    app.confirm({
	      title: _t('Load Scene'),
	      content: _t('An auto-save scene was detected. Load?') + ` (${autoSaveTime})`,
	      cancelText: _t('Clear'),
	      onOK: () => {
	        this.queryLoad = false;
	        this.commitLoadScene(autoSaveData, autoSaveSceneName, autoSaveSceneID);
	      },
	      onCancel: () => {
	        window.localStorage.removeItem('autoSaveTime');
	        window.localStorage.removeItem('autoSaveData');
	        window.localStorage.removeItem('autoSaveSceneID');
	        window.localStorage.removeItem('autoSaveSceneName');
	        app.toast(_t('Auto-save scene is cleared.'));
	        this.queryLoad = false;
	      }
	    });
	  }

	  commitLoadScene(data, name, id) {
	    var obj = JSON.parse(data);

	    if (obj) {
	      app.call(`loadSceneList`, this, obj, name, id);
	    }
	  }

	  handleStorageChange(name, value) {
	    if (name !== 'autoSave') {
	      return;
	    }

	    this.autoSave = value;

	    if (this.autoSave) {
	      if (this.saveProcess) {
	        clearTimeout(this.saveProcess);
	      }

	      this.saveProcess = setTimeout(this.handleSave, this.autoSaveTime);
	    }
	  }

	}

	/**
	 * 命令基类
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {*} editorRef pointer to main editor object used to initialize each command object with a reference to the editor
	 * @constructor
	 */
	function Command(editorRef) {
	  this.id = -1;
	  this.inMemory = false;
	  this.updatable = false;
	  this.type = '';
	  this.name = '';

	  if (editorRef !== undefined) {
	    Command.editor = editorRef;
	  }

	  this.editor = Command.editor;
	}

	Command.prototype.toJSON = function () {
	  var output = {};
	  output.type = this.type;
	  output.id = this.id;
	  output.name = this.name;
	  return output;
	};

	Command.prototype.fromJSON = function (json) {
	  this.inMemory = true;
	  this.type = json.type;
	  this.id = json.id;
	  this.name = json.name;
	};

	/**
	 * 设置位置命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 物体
	 * @param {THREE.Vector3} newPosition 新位置
	 * @param {THREE.Vector3} optionalOldPosition 可选旧位置
	 * @constructor
	 */

	function SetPositionCommand(object, newPosition, optionalOldPosition) {
	  Command.call(this);
	  this.type = 'SetPositionCommand';
	  this.name = _t('Set Position');
	  this.updatable = true;
	  this.object = object;

	  if (object !== undefined && newPosition !== undefined) {
	    this.oldPosition = object.position.clone();
	    this.newPosition = newPosition.clone();
	  }

	  if (optionalOldPosition !== undefined) {
	    this.oldPosition = optionalOldPosition.clone();
	  }
	}

	SetPositionCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetPositionCommand.prototype, {
	  constructor: SetPositionCommand,
	  execute: function () {
	    this.object.position.copy(this.newPosition);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  undo: function () {
	    this.object.position.copy(this.oldPosition);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  update: function (command) {
	    this.newPosition.copy(command.newPosition);
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.oldPosition = this.oldPosition.toArray();
	    output.newPosition = this.newPosition.toArray();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldPosition = new THREE.Vector3().fromArray(json.oldPosition);
	    this.newPosition = new THREE.Vector3().fromArray(json.newPosition);
	  }
	});

	/**
	 * 设置旋转命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 物体
	 * @param {THREE.Euler} newRotation 新欧拉角
	 * @param {THREE.Euler} optionalOldRotation 可选旧欧拉角
	 * @constructor
	 */

	function SetRotationCommand(object, newRotation, optionalOldRotation) {
	  Command.call(this);
	  this.type = 'SetRotationCommand';
	  this.name = _t('Set Rotation');
	  this.updatable = true;
	  this.object = object;

	  if (object !== undefined && newRotation !== undefined) {
	    this.oldRotation = object.rotation.clone();
	    this.newRotation = newRotation.clone();
	  }

	  if (optionalOldRotation !== undefined) {
	    this.oldRotation = optionalOldRotation.clone();
	  }
	}

	SetRotationCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetRotationCommand.prototype, {
	  constructor: SetRotationCommand,
	  execute: function () {
	    this.object.rotation.copy(this.newRotation);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  undo: function () {
	    this.object.rotation.copy(this.oldRotation);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  update: function (command) {
	    this.newRotation.copy(command.newRotation);
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.oldRotation = this.oldRotation.toArray();
	    output.newRotation = this.newRotation.toArray();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldRotation = new THREE.Euler().fromArray(json.oldRotation);
	    this.newRotation = new THREE.Euler().fromArray(json.newRotation);
	  }
	});

	/**
	 * 设置缩放命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 物体
	 * @param {THREE.Vector3} newScale 新缩放
	 * @param {THREE.Vector3} optionalOldScale 可选旧缩放
	 * @constructor
	 */

	function SetScaleCommand(object, newScale, optionalOldScale) {
	  Command.call(this);
	  this.type = 'SetScaleCommand';
	  this.name = _t('Set Scale');
	  this.updatable = true;
	  this.object = object;

	  if (object !== undefined && newScale !== undefined) {
	    this.oldScale = object.scale.clone();
	    this.newScale = newScale.clone();
	  }

	  if (optionalOldScale !== undefined) {
	    this.oldScale = optionalOldScale.clone();
	  }
	}

	SetScaleCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetScaleCommand.prototype, {
	  constructor: SetScaleCommand,
	  execute: function () {
	    this.object.scale.copy(this.newScale);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  undo: function () {
	    this.object.scale.copy(this.oldScale);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  update: function (command) {
	    this.newScale.copy(command.newScale);
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.oldScale = this.oldScale.toArray();
	    output.newScale = this.newScale.toArray();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldScale = new THREE.Vector3().fromArray(json.oldScale);
	    this.newScale = new THREE.Vector3().fromArray(json.newScale);
	  }
	});

	/**
	 * 平移旋转缩放控件事件
	 * @author tengge / https://github.com/tengge1
	 */

	function TransformControlsEvent() {
	  BaseEvent.call(this);
	  this.mode = 'translate';
	  this.objectPosition = null;
	  this.objectRotation = null;
	  this.objectScale = null;
	}

	TransformControlsEvent.prototype = Object.create(BaseEvent.prototype);
	TransformControlsEvent.prototype.constructor = TransformControlsEvent;

	TransformControlsEvent.prototype.start = function () {
	  app.on(`appStarted.${this.id}`, this.onAppStarted.bind(this));
	};

	TransformControlsEvent.prototype.onAppStarted = function () {
	  let transformControls = app.editor.transformControls;
	  transformControls.addEventListener('mouseDown', this.onMouseDown.bind(this));
	  transformControls.addEventListener('mouseUp', this.onMouseUp.bind(this));
	  app.on('objectSelected.' + this.id, this.onObjectSelected.bind(this));
	  app.on('changeMode.' + this.id, this.onChangeMode.bind(this));
	  app.on('snapChanged.' + this.id, this.onSnapChanged.bind(this));
	  app.on('spaceChanged.' + this.id, this.onSpaceChanged.bind(this));
	};
	/**
	 * 点击鼠标，记录选中物体当前平移、旋转和缩放值
	 */


	TransformControlsEvent.prototype.onMouseDown = function () {
	  if (app.editor.view !== 'perspective') {
	    return;
	  }

	  if (['translate', 'rotate', 'scale'].indexOf(this.mode) === -1) {
	    return;
	  }

	  var object = app.editor.transformControls.object;
	  this.objectPosition = object.position.clone();
	  this.objectRotation = object.rotation.clone();
	  this.objectScale = object.scale.clone();
	  app.editor.controls.disable();
	};
	/**
	 * 抬起鼠标，更新选中物体的平移、旋转和缩放值
	 */


	TransformControlsEvent.prototype.onMouseUp = function () {
	  if (app.editor.view !== 'perspective') {
	    return;
	  }

	  if (['translate', 'rotate', 'scale'].indexOf(this.mode) === -1) {
	    return;
	  }

	  var editor = app.editor;
	  var transformControls = editor.transformControls;
	  var object = transformControls.object;

	  if (object === null) {
	    return;
	  }

	  switch (transformControls.getMode()) {
	    case 'translate':
	      if (!this.objectPosition.equals(object.position)) {
	        editor.execute(new SetPositionCommand(object, object.position, this.objectPosition));
	      }

	      break;

	    case 'rotate':
	      if (!this.objectRotation.equals(object.rotation)) {
	        editor.execute(new SetRotationCommand(object, object.rotation, this.objectRotation));
	      }

	      break;

	    case 'scale':
	      if (!this.objectScale.equals(object.scale)) {
	        editor.execute(new SetScaleCommand(object, object.scale, this.objectScale));
	      }

	      break;
	  }

	  app.editor.controls.enable();
	};
	/**
	 * 物体已经选中
	 * @param {*} object 选中的物体
	 */


	TransformControlsEvent.prototype.onObjectSelected = function (object) {
	  app.editor.transformControls.detach();

	  if (['translate', 'rotate', 'scale'].indexOf(this.mode) === -1) {
	    return;
	  }

	  if (!object || object === app.editor.scene || object === app.editor.camera) {
	    return;
	  }

	  app.editor.transformControls.attach(object);
	};
	/**
	 * 切换平移、旋转、缩放模式
	 * @param {*} mode 模式
	 */


	TransformControlsEvent.prototype.onChangeMode = function (mode) {
	  this.mode = mode;
	  var transformControls = app.editor.transformControls;

	  if (mode === 'translate' || mode === 'rotate' || mode === 'scale') {
	    // 设置模式在选中物体上
	    transformControls.setMode(mode);
	    var object = app.editor.selected;

	    if (object !== null) {
	      transformControls.attach(object);
	    }
	  } else {
	    // 取消对选中物体平移、旋转、缩放
	    transformControls.detach();
	  }
	};
	/**
	 * 设置平移移动的大小
	 * @param {*} dist 参数
	 */


	TransformControlsEvent.prototype.onSnapChanged = function (dist) {
	  app.editor.transformControls.setTranslationSnap(dist);
	};
	/**
	 * 设置世界坐标系还是物体坐标系
	 * @param {*} space 参数
	 */


	TransformControlsEvent.prototype.onSpaceChanged = function (space) {
	  app.editor.transformControls.setSpace(space);
	};

	/**
	 * 物体事件
	 * @author tengge / https://github.com/tengge1
	 */

	function ObjectEvent() {
	  BaseEvent.call(this);
	  this.box = new THREE.Box3();
	}

	ObjectEvent.prototype = Object.create(BaseEvent.prototype);
	ObjectEvent.prototype.constructor = ObjectEvent;

	ObjectEvent.prototype.start = function () {
	  app.on('objectAdded.' + this.id, this.onObjectAdded.bind(this));
	  app.on('objectChanged.' + this.id, this.onObjectChanged.bind(this));
	  app.on('objectRemoved.' + this.id, this.onObjectRemoved.bind(this));
	  app.on('objectFocused.' + this.id, this.onObjectFocused.bind(this));
	};

	ObjectEvent.prototype.stop = function () {
	  app.on('objectAdded.' + this.id, null);
	  app.on('objectChanged.' + this.id, null);
	  app.on('objectRemoved.' + this.id, null);
	  app.on('objectFocused.' + this.id, null);
	};

	ObjectEvent.prototype.onObjectAdded = function (object) {
	  var objects = app.editor.objects;
	  object.traverse(function (child) {
	    objects.push(child);
	  });
	};

	ObjectEvent.prototype.onObjectChanged = function (object) {
	  if (object instanceof THREE.PerspectiveCamera) {
	    object.updateProjectionMatrix();
	  }
	};

	ObjectEvent.prototype.onObjectRemoved = function (object) {
	  var objects = app.editor.objects;
	  object.traverse(function (child) {
	    objects.splice(objects.indexOf(child), 1);
	  });
	};

	ObjectEvent.prototype.onObjectFocused = function (object) {
	  app.editor.controls.focus(object);
	};

	/**
	 * 光线投射事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 应用程序
	 */

	function RaycastEvent(app) {
	  BaseEvent.call(this, app);
	  this.mouse = new THREE.Vector2();
	  this.raycaster = new THREE.Raycaster();
	}

	RaycastEvent.prototype = Object.create(BaseEvent.prototype);
	RaycastEvent.prototype.constructor = RaycastEvent;

	RaycastEvent.prototype.start = function () {
	  app.on(`mousedown.${this.id}`, this.onMouseDown.bind(this));
	  app.on(`mouseup.${this.id}`, this.onMouseUp.bind(this));
	};

	RaycastEvent.prototype.stop = function () {
	  app.on(`mousedown.${this.id}`, null);
	  app.on(`mouseup.${this.id}`, null);
	};

	RaycastEvent.prototype.onMouseDown = function (event) {
	  if (event.target !== app.editor.renderer.domElement) {
	    return;
	  }

	  this.isDown = true;
	  this.x = event.offsetX;
	  this.y = event.offsetY;
	};

	RaycastEvent.prototype.onMouseUp = function (event) {
	  if (event.target !== app.editor.renderer.domElement) {
	    return;
	  }

	  if (!this.isDown || this.x !== event.offsetX || this.y !== event.offsetY) {
	    return;
	  }

	  let domElement = app.editor.renderer.domElement;
	  this.mouse.x = event.offsetX / domElement.clientWidth * 2 - 1;
	  this.mouse.y = -event.offsetY / domElement.clientHeight * 2 + 1;
	  this.raycaster.setFromCamera(this.mouse, app.editor.view === 'perspective' ? app.editor.camera : app.editor.orthCamera);
	  let intersects = this.raycaster.intersectObjects(app.editor.scene.children, true);

	  if (intersects.length > 0) {
	    app.call('raycast', this, intersects[0], event);
	    app.call('intersect', this, intersects[0], event, intersects);
	  } else {
	    // 没有碰撞到任何物体，则跟y=0的平面碰撞
	    let plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), new THREE.Vector3());
	    let target = new THREE.Vector3();
	    this.raycaster.ray.intersectPlane(plane, target);
	    app.call('raycast', this, {
	      point: target,
	      distance: this.raycaster.ray.distanceSqToPoint(target),
	      object: null
	    }, event);
	  }
	};

	/**
	 * 选取事件
	 * @author tengge / https://github.com/tengge1
	 */

	function PickEvent() {
	  BaseEvent.call(this);
	  this.raycaster = new THREE.Raycaster();
	  this.mouse = new THREE.Vector2();
	  this.onDownPosition = new THREE.Vector2();
	  this.onUpPosition = new THREE.Vector2();
	  this.onAppStarted = this.onAppStarted.bind(this);
	  this.onMouseDown = this.onMouseDown.bind(this);
	  this.onMouseUp = this.onMouseUp.bind(this);
	}

	PickEvent.prototype = Object.create(BaseEvent.prototype);
	PickEvent.prototype.constructor = PickEvent;

	PickEvent.prototype.start = function () {
	  app.on(`appStarted.${this.id}`, this.onAppStarted);
	};

	PickEvent.prototype.onAppStarted = function () {
	  app.viewport.addEventListener('mousedown', this.onMouseDown, false);
	};

	PickEvent.prototype.onMouseDown = function (event) {
	  if (event.button !== 0) {
	    // 只允许左键选中
	    return;
	  } // 1、这样处理选中的原因是避免把拖动误认为点击
	  // 2、不能使用preventDefault，因为div无法获得焦点，无法响应keydown事件。
	  // event.preventDefault();


	  let array = this.getMousePosition(app.viewport, event.clientX, event.clientY);
	  this.onDownPosition.fromArray(array);
	  document.addEventListener('mouseup', this.onMouseUp, false);
	};

	PickEvent.prototype.onMouseUp = function (event) {
	  let array = this.getMousePosition(app.viewport, event.clientX, event.clientY);
	  this.onUpPosition.fromArray(array);
	  this.handleClick();
	  document.removeEventListener('mouseup', this.onMouseUp, false);
	};

	PickEvent.prototype.getIntersects = function (point, objects) {
	  this.mouse.set(point.x * 2 - 1, -(point.y * 2) + 1);
	  this.raycaster.setFromCamera(this.mouse, app.editor.view === 'perspective' ? app.editor.camera : app.editor.orthCamera);
	  return this.raycaster.intersectObjects(objects);
	};

	PickEvent.prototype.getMousePosition = function (dom, x, y) {
	  let rect = dom.getBoundingClientRect();
	  return [(x - rect.left) / rect.width, (y - rect.top) / rect.height];
	};

	PickEvent.prototype.handleClick = function () {
	  let editor = app.editor;
	  let objects = editor.objects;
	  const selectMode = app.storage.selectMode;

	  if (this.onDownPosition.distanceTo(this.onUpPosition) === 0) {
	    let intersects = this.getIntersects(this.onUpPosition, objects);

	    if (intersects.length > 0) {
	      let object = intersects[0].object;

	      if (object.userData.object !== undefined) {
	        // helper
	        // TODO: userData上有object时，无法复制模型。
	        editor.select(object.userData.object);
	      } else if (selectMode === 'whole') {
	        // 选择整体
	        editor.select(MeshUtils.partToMesh(object));
	      } else if (selectMode === 'part') {
	        // 选择部分
	        editor.select(object);
	      }
	    } else {
	      editor.select(null);
	    } // objects in sceneHelpers


	    let sceneHelpers = app.editor.sceneHelpers;
	    intersects = this.getIntersects(this.onUpPosition, sceneHelpers.children);

	    if (intersects.length > 0) {
	      if (!(intersects[0].object instanceof THREE.GridHelper)) {
	        // 禁止选中网格
	        editor.select(intersects[0].object);
	      }
	    }
	  }
	};

	/**
	 * 加载场景事件
	 * @author tengge / https://github.com/tengge1
	 */

	function LoadSceneEvent() {
	  BaseEvent.call(this);
	}

	LoadSceneEvent.prototype = Object.create(BaseEvent.prototype);
	LoadSceneEvent.prototype.constructor = LoadSceneEvent;

	LoadSceneEvent.prototype.start = function () {
	  app.on(`load.${this.id}`, this.onLoad.bind(this));
	  app.on(`loadSceneList.${this.id}`, this.onLoadSceneList.bind(this));
	};

	LoadSceneEvent.prototype.stop = function () {
	  app.on(`load.${this.id}`, null);
	  app.on(`loadSceneObj.${this.id}`, null);
	};

	LoadSceneEvent.prototype.onLoad = function (url, name, id) {
	  // id: MongoDB _id
	  if (!name || name.trim() === '') {
	    name = _t('No Name');
	  } // 新增场景id为null，不需要创建；否则导致保存示例场景报错。
	  // if (!id) {
	  //     id = THREE.Math.generateUUID();
	  // }


	  app.editor.clear(false);
	  document.title = name;
	  app.mask(_t('Loading...'));
	  fetch(url).then(response => {
	    response.json().then(obj => {
	      if (obj.Code !== 200) {
	        app.toast(_t(obj.Msg), 'warn');
	        return;
	      }

	      this.onLoadSceneList(obj.Data, name, id);
	    });
	  });
	};

	LoadSceneEvent.prototype.onLoadSceneList = function (list, name, id) {
	  app.mask(_t('Loading...'));
	  new Converter().fromJson(list, {
	    server: app.options.server,
	    camera: app.editor.camera,
	    domWidth: app.editor.renderer.domElement.width,
	    domHeight: app.editor.renderer.domElement.height
	  }).then(obj => {
	    this.onLoadScene(obj);
	    app.editor.sceneID = id || 0;
	    app.editor.sceneName = name || _t('No Name');
	    document.title = app.editor.sceneName;

	    if (obj.options) {
	      app.call('optionsChanged', this); // if (obj.options.sceneType === 'GIS') {
	      //     if (app.editor.gis) {
	      //         app.editor.gis.stop();
	      //     }
	      //     app.editor.gis = new GISScene(app, {
	      //         useCameraPosition: true
	      //     });
	      //     app.editor.gis.start();
	      // }
	    }

	    if (obj.scripts) {
	      app.call('scriptChanged', this);
	    }

	    if (obj.scene) {
	      app.call('sceneGraphChanged', this);
	    }

	    app.unmask();
	  });
	};

	LoadSceneEvent.prototype.onLoadScene = function (obj) {
	  if (obj.options) {
	    Object.assign(app.options, obj.options);
	  }

	  if (obj.camera) {
	    app.editor.camera.remove(app.editor.audioListener);
	    app.editor.camera.copy(obj.camera);
	    let audioListener = app.editor.camera.children.filter(n => n instanceof THREE.AudioListener)[0];

	    if (audioListener) {
	      app.editor.audioListener = audioListener;
	    }
	  }

	  if (obj.renderer) {
	    var viewport = app.viewport;
	    var oldRenderer = app.editor.renderer;
	    viewport.removeChild(oldRenderer.domElement);
	    viewport.appendChild(obj.renderer.domElement);
	    app.editor.renderer = obj.renderer;
	    app.editor.renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
	    app.call('resize', this);
	  }

	  if (obj.scripts) {
	    Object.assign(app.editor.scripts, obj.scripts);
	  }

	  if (obj.animations) {
	    Object.assign(app.editor.animations, obj.animations);
	  } else {
	    app.editor.animations = [{
	      id: null,
	      uuid: THREE.Math.generateUUID(),
	      layer: 0,
	      layerName: _t('AnimLayer1'),
	      animations: []
	    }, {
	      id: null,
	      uuid: THREE.Math.generateUUID(),
	      layer: 1,
	      layerName: _t('AnimLayer2'),
	      animations: []
	    }, {
	      id: null,
	      uuid: THREE.Math.generateUUID(),
	      layer: 2,
	      layerName: _t('AnimLayer3'),
	      animations: []
	    }];
	  }

	  if (obj.scene) {
	    app.editor.setScene(obj.scene);
	  }

	  app.editor.camera.updateProjectionMatrix();

	  if (obj.options.selected) {
	    var selected = app.editor.objectByUuid(obj.options.selected);

	    if (selected) {
	      app.editor.select(selected);
	    }
	  } // 可视化
	  // if (obj.visual) {
	  //     app.editor.visual.fromJSON(obj.visual);
	  // } else {
	  // app.editor.visual.clear();
	  // }
	  // app.editor.visual.render(app.editor.svg);


	  app.call('sceneLoaded', this);
	  app.call('animationChanged', this);
	};

	/**
	 * 下雨
	 */
	class Rain extends THREE.Object3D {
	  constructor() {
	    super();
	    this.createPointClouds('assets/textures/particles/raindrop-3.png');
	  }

	  createPointClouds(url) {
	    let geometry = new THREE.Geometry();
	    let range = 40;

	    for (let i = 0; i < 1500; i++) {
	      let particle = new THREE.Vector3(Math.random() * range - range / 2, Math.random() * range * 1.5, Math.random() * range - range / 2);
	      particle.velocityY = 0.1 + Math.random() / 5;
	      particle.velocityX = (Math.random() - 0.5) / 3;
	      geometry.vertices.push(particle);
	    }

	    let material = new THREE.PointsMaterial({
	      size: 3,
	      transparent: true,
	      opacity: 0.6,
	      map: new THREE.TextureLoader().load(url),
	      blending: THREE.AdditiveBlending,
	      sizeAttenuation: true,
	      color: 0xffffff
	    });
	    let points = new THREE.Points(geometry, material);
	    points.sortParticles = true;
	    this.add(points);
	  }

	  update() {
	    this.children.forEach(n => {
	      n.geometry.vertices.forEach(v => {
	        v.y = v.y - v.velocityY;
	        v.x = v.x - v.velocityX;

	        if (v.y <= 0) {
	          v.y = 60;
	        }

	        if (v.x <= -20 || v.x >= 20) {
	          v.velocityX = v.velocityX * -1;
	        }
	      });
	      n.geometry.verticesNeedUpdate = true;
	    });
	  }

	}

	/**
	 * 下雪
	 */
	class Snow extends THREE.Object3D {
	  constructor() {
	    super();
	    this.createPointClouds('assets/textures/particles/snowflake1.png');
	    this.createPointClouds('assets/textures/particles/snowflake2.png');
	    this.createPointClouds('assets/textures/particles/snowflake3.png');
	    this.createPointClouds('assets/textures/particles/snowflake5.png');
	  }

	  createPointClouds(url) {
	    let geometry = new THREE.Geometry();
	    let range = 40;

	    for (let i = 0; i < 50; i++) {
	      let particle = new THREE.Vector3(Math.random() * range - range / 2, Math.random() * range * 1.5, Math.random() * range - range / 2);
	      particle.velocityY = 0.1 + Math.random() / 5;
	      particle.velocityX = (Math.random() - 0.5) / 3;
	      particle.velocityZ = (Math.random() - 0.5) / 3;
	      geometry.vertices.push(particle);
	    }

	    let color = new THREE.Color(0xffffff);
	    let hsl = {
	      h: 0,
	      s: 0,
	      l: 0
	    };
	    color.getHSL(hsl);
	    color.setHSL(hsl.h, hsl.s, Math.random() * hsl.l);
	    let material = new THREE.PointsMaterial({
	      size: 10,
	      transparent: true,
	      opacity: 0.6,
	      map: new THREE.TextureLoader().load(url),
	      blending: THREE.AdditiveBlending,
	      depthWrite: false,
	      sizeAttenuation: true,
	      color: color
	    });
	    let points = new THREE.Points(geometry, material);
	    points.sortParticles = true;
	    this.add(points);
	  }

	  update() {
	    this.children.forEach(child => {
	      let vertices = child.geometry.vertices;
	      vertices.forEach(v => {
	        v.y = v.y - v.velocityY;
	        v.x = v.x - v.velocityX;
	        v.z = v.z - v.velocityZ;
	        if (v.y <= 0) v.y = 60;
	        if (v.x <= -20 || v.x >= 20) v.velocityX = v.velocityX * -1;
	        if (v.z <= -20 || v.z >= 20) v.velocityZ = v.velocityZ * -1;
	      });
	      child.geometry.verticesNeedUpdate = true;
	    });
	  }

	}

	/**
	 * 视图事件
	 * @author tengge / https://github.com/tengge1
	 */

	function WeatherEvent() {
	  BaseEvent.call(this);
	  this.weather = '';
	  this.object = null;
	  this.onOptionChange = this.onOptionChange.bind(this);
	  this.onAfterRender = this.onAfterRender.bind(this);
	}

	WeatherEvent.prototype = Object.create(BaseEvent.prototype);
	WeatherEvent.prototype.constructor = WeatherEvent;

	WeatherEvent.prototype.start = function () {
	  app.on(`optionChange.${this.id}`, this.onOptionChange);
	  app.on(`afterRender.${this.id}`, this.onAfterRender);
	};

	WeatherEvent.prototype.stop = function () {
	  app.on(`optionChange.${this.id}`, null);
	};

	WeatherEvent.prototype.onOptionChange = function (name, value) {
	  if (name !== 'weather') {
	    return;
	  }

	  this.weather = value;

	  if (this.object) {
	    app.editor.sceneHelpers.remove(this.object);
	    this.object = null;
	  }

	  if (this.weather === 'rain') {
	    if (this.rain === undefined) {
	      this.rain = new Rain();
	    }

	    this.object = this.rain;
	    app.editor.sceneHelpers.add(this.rain);
	  }

	  if (this.weather === 'snow') {
	    if (this.snow === undefined) {
	      this.snow = new Snow();
	    }

	    this.object = this.snow;
	    app.editor.sceneHelpers.add(this.snow);
	  }
	};

	WeatherEvent.prototype.onAfterRender = function () {
	  if (this.object) {
	    this.object.update();
	  }
	};

	/**
	 * 物理事件
	 */

	function PhysicsEngine() {
	  BaseEvent.call(this);
	  this.enabled = false;
	  this.init = false;
	  this.rigidBodies = [];
	  this.softBodies = [];
	  this.onOptionChange = this.onOptionChange.bind(this);
	  this.updatePhysicsWorld = this.updatePhysicsWorld.bind(this);
	}

	PhysicsEngine.prototype = Object.create(BaseEvent.prototype);
	PhysicsEngine.prototype.constructor = PhysicsEngine;

	PhysicsEngine.prototype.start = function () {
	  app.on(`optionChange.${this.id}`, this.onOptionChange);
	  app.on(`afterRender.${this.id}`, this.updatePhysicsWorld);
	};

	PhysicsEngine.prototype.stop = function () {
	  app.on(`optionChange.${this.id}`, null);
	  app.on(`afterRender.${this.id}`, null);
	};

	PhysicsEngine.prototype.onOptionChange = function (name, value) {
	  if (name !== 'enablePhysics') {
	    return;
	  }

	  if (value) {
	    this.enablePhysics();
	  } else {
	    this.disablePhysics();
	  }
	};

	PhysicsEngine.prototype.enablePhysics = function () {
	  this.enabled = true;

	  if (!this.init) {
	    this.init = true;
	    this.initPhysicsWorld();
	    this.clock = new THREE.Clock(false);
	  }

	  this.createScene();
	  this.clock.start();
	};

	PhysicsEngine.prototype.disablePhysics = function () {
	  this.enabled = false;

	  if (!this.world) {
	    return;
	  }

	  this.clock.stop();
	  this.rigidBodies.forEach(n => {
	    this.world.removeRigidBody(n._physicsBody);
	  });
	  this.rigidBodies.length = 0;
	  app.editor.scene.traverse(n => {
	    if (n._physicsBody) {
	      n._physicsBody = null;
	    }
	  });
	  this.scene = null;
	};

	PhysicsEngine.prototype.initPhysicsWorld = function () {
	  // 各种参数
	  let gravityConstant = -9.8; // 重力常数

	  this.margin = 0.05; // 两个物体之间最小间距
	  // 物理环境配置

	  let collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration(); // 软体刚体碰撞配置

	  let dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration); // 碰撞调度器

	  let broadphase = new Ammo.btDbvtBroadphase(); // dbvt粗测

	  let solver = new Ammo.btSequentialImpulseConstraintSolver(); // 顺序脉冲约束求解器

	  let softBodySolver = new Ammo.btDefaultSoftBodySolver(); // 默认软体求解器

	  this.world = new Ammo.btSoftRigidDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
	  let gravity = new Ammo.btVector3(0, gravityConstant, 0);
	  this.world.setGravity(gravity);
	  this.world.getWorldInfo().set_m_gravity(gravity);
	  this.transformAux1 = new Ammo.btTransform();
	};

	PhysicsEngine.prototype.createScene = function () {
	  app.editor.scene.traverse(n => {
	    if (!n.userData.physics || !n.userData.physics.enabled) {
	      return;
	    }

	    if (n.userData.physics.type !== 'rigidBody') {
	      // 仅对刚体提供支持
	      console.warn(`PhysicsEngine: unknown physics type ${n.userData.physics.type}.`);
	      return;
	    }

	    let body = this.createRigidBody(n);
	    n._physicsBody = body;
	    this.world.addRigidBody(body);

	    if (n.userData.physics.mass > 0) {
	      this.rigidBodies.push(n);
	      body.setActivationState(4);
	    }
	  });
	};

	PhysicsEngine.prototype.updatePhysicsWorld = function () {
	  if (!this.enabled) {
	    return;
	  }

	  let deltaTime = this.clock.getDelta();
	  this.world.stepSimulation(deltaTime, 10);

	  for (let i = 0, l = this.rigidBodies.length; i < l; i++) {
	    let obj = this.rigidBodies[i];

	    if (!obj._physicsBody) {
	      continue;
	    }

	    let state = obj._physicsBody.getMotionState();

	    if (state) {
	      state.getWorldTransform(this.transformAux1);
	      let p = this.transformAux1.getOrigin();
	      let q = this.transformAux1.getRotation();
	      obj.position.set(p.x(), p.y(), p.z());
	      obj.quaternion.set(q.x(), q.y(), q.z(), q.w());
	    }
	  }
	};

	PhysicsEngine.prototype.createRigidBody = function (obj) {
	  let position = obj.position;
	  let quaternion = obj.quaternion; // let scale = obj.scale;

	  let physics = obj.userData.physics;
	  let shape = physics.shape;
	  let mass = physics.mass;
	  let inertia = physics.inertia; // 形状

	  let geometry = null;
	  let physicsShape = null;

	  if (shape === 'btBoxShape') {
	    geometry = obj.geometry;
	    geometry.computeBoundingBox();
	    let box = geometry.boundingBox;
	    let x = box.max.x - box.min.x;
	    let y = box.max.y - box.min.y;
	    let z = box.max.z - box.min.z;
	    let center = new THREE.Vector3();
	    box.getCenter(center);
	    position = position.clone();
	    position.add(center);
	    physicsShape = new Ammo.btBoxShape(new Ammo.btVector3(x * 0.5, y * 0.5, z * 0.5));
	  } else if (shape === 'btSphereShape') {
	    geometry = obj.geometry;
	    geometry.computeBoundingSphere();
	    let sphere = geometry.boundingSphere;
	    physicsShape = new Ammo.btSphereShape(sphere.radius);
	  } else {
	    console.warn(`PlayerPhysics: cannot create shape ${shape}.`);
	    return null;
	  }

	  physicsShape.setMargin(0.05); // 位移

	  let transform = new Ammo.btTransform();
	  transform.setIdentity();
	  transform.setOrigin(new Ammo.btVector3(position.x, position.y, position.z));
	  transform.setRotation(new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));
	  let defaultState = new Ammo.btDefaultMotionState(transform);
	  let localInertia = new Ammo.btVector3(inertia.x, inertia.y, inertia.z);
	  physicsShape.calculateLocalInertia(mass, localInertia);
	  let info = new Ammo.btRigidBodyConstructionInfo(mass, defaultState, physicsShape, localInertia);
	  return new Ammo.btRigidBody(info);
	};

	// import DraggableEvent from './visual/DraggableEvent';

	/**
	 * 事件执行器
	 * @author tengge / https://github.com/tengge1
	 */

	function EventDispatcher() {
	  this.dispatch = dispatch.apply(dispatch, EventList);
	  this.addDomEventListener();
	  this.events = [// 核心事件
	  new RenderEvent(), new ResizeEvent(), new FilterEvent(), new ViewEvent(), new GPUPickEvent(), new WebSocketEvent(), new ScriptChangedEvent(), new AutoSaveEvent(), // viewport中的事件
	  new TransformControlsEvent(), new ObjectEvent(), new RaycastEvent(), new PickEvent(), new LoadSceneEvent(), new WeatherEvent(), // 物理引擎
	  new PhysicsEngine() // // 可视化
	  // new DraggableEvent()
	  ];
	}

	EventDispatcher.prototype = Object.create(BaseEvent.prototype);
	EventDispatcher.prototype.constructor = EventDispatcher;
	/**
	 * 启动
	 */

	EventDispatcher.prototype.start = function () {
	  this.events.forEach(n => {
	    n.start();
	  });
	};
	/**
	 * 停止
	 */


	EventDispatcher.prototype.stop = function () {
	  this.events.forEach(n => {
	    n.stop();
	  });
	};
	/**
	 * 执行事件
	 * @param {*} eventName 事件名称
	 * @param {*} _this this指针
	 * @param {*} others 其他参数
	 */


	EventDispatcher.prototype.call = function (eventName, _this, ...others) {
	  this.dispatch.call(eventName, _this, ...others);
	};
	/**
	 * 监听事件
	 * @param {*} eventName 事件名称
	 * @param {*} callback 回调函数
	 */


	EventDispatcher.prototype.on = function (eventName, callback) {
	  this.dispatch.on(eventName, callback);
	};
	/**
	 * 监听dom事件
	 */


	EventDispatcher.prototype.addDomEventListener = function () {
	  var container = app.container;
	  container.addEventListener('click', event => {
	    this.dispatch.call('click', this, event);
	  });
	  container.addEventListener('contextmenu', event => {
	    this.dispatch.call('contextmenu', this, event);
	    event.preventDefault();
	    return false;
	  });
	  container.addEventListener('dblclick', event => {
	    this.dispatch.call('dblclick', this, event);
	  });
	  document.addEventListener('keydown', event => {
	    this.dispatch.call('keydown', this, event);
	  });
	  document.addEventListener('keyup', event => {
	    this.dispatch.call('keyup', this, event);
	  });
	  container.addEventListener('mousedown', event => {
	    this.dispatch.call('mousedown', this, event);
	  });
	  container.addEventListener('mousemove', event => {
	    this.dispatch.call('mousemove', this, event);
	  });
	  container.addEventListener('mouseup', event => {
	    this.dispatch.call('mouseup', this, event);
	  });
	  container.addEventListener('mousewheel', event => {
	    this.dispatch.call('mousewheel', this, event);
	  });
	  window.addEventListener('resize', event => {
	    this.dispatch.call('resize', this, event);
	  }, false);
	  document.addEventListener('dragover', event => {
	    this.dispatch.call('dragover', this, event);
	  }, false);
	  document.addEventListener('drop', event => {
	    this.dispatch.call('drop', this, event);
	  }, false);
	};

	/**
	 * 载入页面
	 * @author tengge / https://github.com/tengge1
	 */

	class Loader extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(LoadMask, {
	      text: _t('Waiting...')
	    });
	  }

	}

	/**
	 * 获取MIME-Type后缀名
	 * @param {String} mimeType MIME-Type
	 * @returns {String} 文件名后缀
	 */
	function getExtension(mimeType) {
	  switch (mimeType) {
	    case 'image/jpeg':
	      return 'jpg';

	    case 'image/png':
	      return 'png';

	    case 'image/gif':
	      return 'gif';

	    case 'image/bmp':
	      return 'bmp';

	    default:
	      console.error(`MIMETypeUtils: unknown MIME-Type: ${mimeType}`);
	      return 'unknown';
	  }
	}
	/**
	 * 获取MIME-Type类型
	 * @param {String} extension 文件名后缀
	 * @returns {String} MIME-Type
	 */


	function getMIMEType(extension) {
	  extension = extension.trimLeft('.');

	  switch (extension.toLowerCase()) {
	    case 'jpg':
	    case 'jpeg':
	      return 'image/jpeg';

	    case 'png':
	      return 'image/png';

	    case 'gif':
	      return 'image/gif';

	    case 'bmp':
	      return 'image/bmp';

	    default:
	      console.warn(`MIMETypeUtils: unknown extension ${extension}.`);
	      return 'application/octet-stream';
	  }
	}
	/**
	 * MIME-Type工具类
	 */


	const MIMETypeUtils = {
	  getExtension: getExtension,
	  getMIMEType: getMIMEType
	};

	/**
	 * ajax
	 * @author tengge / https://github.com/tengge1
	 * @param {Object} params 参数
	 */

	function ajax$1(params) {
	  const url = params.url || '';
	  const method = params.method || 'GET';
	  const data = params.data || null;
	  const callback = params.callback || null;
	  const xhr = new XMLHttpRequest();
	  xhr.open(method, url, true);

	  xhr.onreadystatechange = function () {
	    if (xhr.readyState === 4) {
	      var data = xhr.responseText;
	      typeof callback === 'function' && callback(data);
	    }
	  };

	  if (data === null) {
	    // 不需要POST数据
	    xhr.send(null);
	    return;
	  } // 判断是发送表单还是上传文件
	  // 由于API Controller只能序列化Content-Type为`application/x-www-form-urlencoded`的数据，所以发送表单和上传文件只能二选一。
	  // 否则报错："No MediaTypeFormatter is available to read an object of type 'EditTextureModel' from content with media type 'multipart/form-data'.


	  var hasFile = false,
	      name;

	  for (name in data) {
	    if (data[name] instanceof Blob) {
	      hasFile = true;
	      break;
	    }
	  }

	  if (hasFile) {
	    // 上传文件
	    var formData = new FormData();

	    for (name in data) {
	      if (data[name] instanceof File) {
	        formData.append(name, data[name]);
	      } else if (data[name] instanceof Blob) {
	        formData.append(name, data[name], `${data[name].name}.${MIMETypeUtils.getExtension(data[name].type)}`);
	      }
	    }

	    xhr.send(formData);
	  } else {
	    // 发送表单
	    var bodies = [];

	    for (name in data) {
	      bodies.push(name + '=' + encodeURIComponent(data[name]));
	    }

	    var body = bodies.join('&');

	    if (body.length) {
	      xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
	    }

	    xhr.send(body);
	  }
	}
	/**
	 * get请求
	 * @param {String} url 地址
	 * @param {Function} callback 回调函数
	 */


	function get$2(url, callback) {
	  ajax$1({
	    url: url,
	    callback: callback
	  });
	}
	/**
	 * get请求并解析json数据
	 * @param {String} url URL地址
	 * @param {Function} callback 回调函数
	 */


	function getJson(url, callback) {
	  ajax$1({
	    url: url,
	    callback: function (data) {
	      typeof callback === 'function' && callback(JSON.parse(data));
	    }
	  });
	}
	/**
	 * post请求
	 * @param {String} url 地址
	 * @param {Object} data 数据
	 * @param {Function} callback 回调函数
	 */


	function post(url, data, callback) {
	  const _data = typeof data === 'function' ? null : data;

	  const _callback = typeof data === 'function' ? data : callback;

	  ajax$1({
	    url: url,
	    method: 'POST',
	    data: _data,
	    callback: _callback
	  });
	}
	/**
	 * Ajax
	 */


	const Ajax = {
	  ajax: ajax$1,
	  get: get$2,
	  getJson: getJson,
	  post: post
	};

	var link = document.createElement('a');
	link.style.display = 'none';
	document.body.appendChild(link); // Firefox workaround, see #6594

	var NUMBER_PRECISION = 6;
	/**
	 * 将浮点数转为JSON时，截取数字
	 * @param {String} key 键
	 * @param {Number} value 值
	 * @returns {Number} 截取后的数字 
	 */

	function parseNumber(key, value) {
	  return typeof value === 'number' ? parseFloat(value.toFixed(NUMBER_PRECISION)) : value;
	}
	/**
	 * 将数字凑成2的指数次幂
	 * @author mrdoob / http://mrdoob.com/
	 * @author tengge / https://github.com/tengge1
	 * @param {*} num 数字
	 * @returns {Number} 二的幂
	 */


	function makePowOfTwo(num) {
	  var result = 1;

	  while (result < num) {
	    result = result * 2;
	  }

	  return result;
	}

	function save(blob, filename) {
	  link.href = URL.createObjectURL(blob);
	  link.download = filename || 'data.json';
	  link.click(); // URL.revokeObjectURL( url ); breaks Firefox...
	}
	/**
	 * 下载字符串文件
	 * @param {*} text 字符串
	 * @param {*} filename 下载文件名称
	 */


	function saveString(text, filename) {
	  save(new Blob([text], {
	    type: 'text/plain'
	  }), filename);
	}

	const StringUtils = {
	  parseNumber: parseNumber,
	  makePowOfTwo: makePowOfTwo,
	  save: save,
	  saveString: saveString
	};

	/**
	 * 保存场景窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class SaveSceneWindow extends React.Component {
	  constructor(props) {
	    super(props);

	    if (app.options.saveChild === undefined) {
	      app.options.saveChild = true;
	    }

	    if (app.options.saveMaterial === undefined) {
	      app.options.saveMaterial = true;
	    }

	    this.state = {
	      sceneName: app.editor.sceneName || _t('New Scene'),
	      saveChild: app.options.saveChild,
	      saveMaterial: app.options.saveMaterial
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleSave = this.handleSave.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      sceneName,
	      saveChild,
	      saveMaterial
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'SaveSceneWindow',
	      title: _t('Save Scene'),
	      style: {
	        width: '400px',
	        height: '320px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Name')), /*#__PURE__*/React.createElement(Input, {
	      name: 'sceneName',
	      value: sceneName,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Save Child')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'saveChild',
	      checked: saveChild,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Save Material')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'saveMaterial',
	      checked: saveMaterial,
	      onChange: this.handleChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  handleChange(value, name) {
	    if (name === 'saveChild' || name === 'saveMaterial') {
	      app.options[name] = value;
	    }

	    this.setState({
	      [name]: value
	    });
	  }

	  handleSave() {
	    var editor = app.editor;
	    const {
	      sceneName
	    } = this.state;
	    app.mask(_t('Waiting...'));
	    var obj = new Converter().toJSON({
	      options: app.options,
	      camera: editor.camera,
	      renderer: editor.renderer,
	      scripts: editor.scripts,
	      animations: editor.animations,
	      scene: editor.scene,
	      visual: editor.visual
	    });
	    Ajax.post(`${app.options.server}/api/Scene/Save`, {
	      Name: sceneName,
	      Data: JSON.stringify(obj)
	    }, result => {
	      var obj = JSON.parse(result);

	      if (obj.Code === 200) {
	        editor.sceneID = obj.ID;
	        editor.sceneName = sceneName;
	        document.title = sceneName;
	      }

	      app.call(`sceneSaved`, this);
	      app.unmask();
	      this.handleClose();
	      app.toast(_t(obj.Msg), 'success');
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	let ID$7 = -1;
	/**
	 * 场景模板基类
	 */

	class BaseSceneTemplate {
	  constructor() {
	    this.id = `${this.constructor.name}${ID$7--}`;
	  }
	  /**
	   * 用于子类初始化场景
	   */


	  create() {}
	  /**
	   * 清空场景
	   */


	  clear() {
	    const editor = app.editor;
	    editor.history.clear();
	    editor.camera.copy(editor.DEFAULT_CAMERA);

	    if (editor.audioListener && editor.camera.children.findIndex(o => o instanceof THREE.AudioListener) === -1) {
	      editor.camera.add(editor.audioListener);
	    }

	    if (editor.scene.background instanceof THREE.Texture) {
	      editor.scene.background = new THREE.Color(0xaaaaaa);
	    } else if (editor.scene.background instanceof THREE.Color) {
	      editor.scene.background.setHex(0xaaaaaa);
	    }

	    editor.scene.fog = null;
	    editor.deselect(); // 移除场景物体

	    let objects = editor.scene.children;

	    while (objects.length > 0) {
	      editor.removeObject(objects[0]);
	    }

	    editor.scripts.length = 0;
	    editor.animations.length = 0; // 场景信息

	    editor.sceneID = null;
	    editor.sceneName = null;
	    app.options.sceneType = 'Empty';
	    document.title = _t('No Name');
	    app.editor.camera.userData.control = 'OrbitControls';
	  }

	}

	/**
	 * 空场景模板
	 */

	class EmptySceneTemplate extends BaseSceneTemplate {
	  create() {
	    const editor = app.editor; // 添加场景物体

	    const amlight = new THREE.AmbientLight(0xffffff, 0.24);
	    amlight.name = _t('Ambient');
	    editor.addObject(amlight);
	    const dirlight = new THREE.DirectionalLight(0xffffff, 0.56);
	    dirlight.name = _t('Directional');
	    dirlight.castShadow = true;
	    dirlight.position.set(5, 10, 7.5);
	    dirlight.shadow.radius = 0;
	    dirlight.shadow.mapSize.x = 2048;
	    dirlight.shadow.mapSize.y = 2048;
	    dirlight.shadow.camera.left = -20;
	    dirlight.shadow.camera.right = 20;
	    dirlight.shadow.camera.top = 20;
	    dirlight.shadow.camera.bottom = -20;
	    dirlight.shadow.camera.near = 0.1;
	    dirlight.shadow.camera.far = 500;
	    editor.addObject(dirlight); // 添加场景动画

	    editor.animations = [{
	      id: null,
	      uuid: THREE.Math.generateUUID(),
	      layer: 0,
	      layerName: _t('AnimLayer1'),
	      animations: []
	    }, {
	      id: null,
	      uuid: THREE.Math.generateUUID(),
	      layer: 1,
	      layerName: _t('AnimLayer2'),
	      animations: []
	    }, {
	      id: null,
	      uuid: THREE.Math.generateUUID(),
	      layer: 2,
	      layerName: _t('AnimLayer3'),
	      animations: []
	    }];
	  }

	}

	/**
	 * @exports AbstractError
	 */

	/**
	 * Constructs an error with a specified name and message.
	 * @alias AbstractError
	 * @constructor
	 * @abstract
	 * @classdesc Provides an abstract base class for error classes. This class is not meant to be instantiated
	 * directly but used only by subclasses.
	 * @param {String} name The error's name.
	 * @param {String} message The message.
	 */
	function AbstractError(name, message) {
	  this.name = name;
	  this.message = message;
	}
	/**
	 * Returns the message and stack trace associated with this error.
	 * @returns {String} The message and stack trace associated with this error.
	 */


	AbstractError.prototype.toString = function () {
	  var str = this.name + ': ' + this.message;

	  if (this.stack) {
	    str += '\n' + this.stack.toString();
	  }

	  return str;
	};

	/**
	 * Logs selected message types to the console.
	 * @exports Logger
	 */
	var Logger$1 = {
	  /**
	   * Log no messages.
	   * @constant
	   */
	  LEVEL_NONE: 0,

	  /**
	   * Log messages marked as severe.
	   * @constant
	   */
	  LEVEL_SEVERE: 1,

	  /**
	   * Log messages marked as warnings and messages marked as severe.
	   * @constant
	   */
	  LEVEL_WARNING: 2,

	  /**
	   * Log messages marked as information, messages marked as warnings and messages marked as severe.
	   * @constant
	   */
	  LEVEL_INFO: 3,

	  /**
	   * Set the logging level used by subsequent invocations of the logger.
	   * @param {Number} level The logging level, one of Logger.LEVEL_NONE, Logger.LEVEL_SEVERE, Logger.LEVEL_WARNING,
	   * or Logger.LEVEL_INFO.
	   */
	  setLoggingLevel: function (level) {
	    loggingLevel = level;
	  },

	  /**
	   * Indicates the current logging level.
	   * @returns {Number} The current logging level.
	   */
	  getLoggingLevel: function () {
	    return loggingLevel;
	  },

	  /**
	   * Logs a specified message at a specified level.
	   * @param {Number} level The logging level of the message. If the current logging level allows this message to be
	   * logged it is written to the console.
	   * @param {String} message The message to log. Nothing is logged if the message is null or undefined.
	   */
	  log: function (level, message) {
	    if (message && level > 0 && level <= loggingLevel) {
	      if (level === Logger$1.LEVEL_SEVERE) {
	        console.error(message);
	      } else if (level === Logger$1.LEVEL_WARNING) {
	        console.warn(message);
	      } else if (level === Logger$1.LEVEL_INFO) {
	        console.info(message);
	      } else {
	        console.log(message);
	      }
	    }
	  },
	  // Intentionally not documented.
	  makeMessage: function (className, functionName, message) {
	    var msg = this.messageTable[message] ? this.messageTable[message] : message;
	    return className + "." + functionName + ": " + msg;
	  },
	  // Intentionally not documented.
	  logMessage: function (level, className, functionName, message) {
	    var msg = this.makeMessage(className, functionName, message);
	    this.log(level, msg);
	    return msg;
	  },
	  // Intentionally not documented.
	  messageTable: {
	    // KEEP THIS TABLE IN ALPHABETICAL ORDER
	    abstractInvocation: "The function called is abstract and must be overridden in a subclass.",
	    indexOutOfRange: "The specified index is out of range.",
	    invalidColumn: "The specified column is out of range.",
	    invalidHeight: "The specified height is zero or negative.",
	    invalidWidth: "The specified width is zero or negative.",
	    invalidRow: "The specified row is out of range.",
	    invalidSize: "The specified size is zero or negative.",
	    missingAltitudeMode: "The specified altitude mode is null or undefined.",
	    missingArrayBuffer: "The specified array buffer is null or undefined",
	    missingAttributeName: "The specified DBase attribute file name is null or undefined.",
	    missingArray: "The specified array is null, undefined or of insufficient length.",
	    missingBoundaries: "The specified boundaries array is null or undefined.",
	    missingBuffer: "The specified buffer descriptor is null or undefined.",
	    missingColor: "The specified color is null or undefined.",
	    missingConfig: "The specified config is null or undefined.",
	    missingDc: "The specified draw context is null or undefined.",
	    missingDomElement: "The specified DOM element is null or undefined.",
	    missingEntry: "The specified entry is null or undefined.",
	    missingFont: "The specified font is null or undefined.",
	    missingFrustum: "The specified frustum is null or undefined.",
	    missingFunction: "The specified function is null or undefined.",
	    missingGlContext: "The specified WebGL rendering context is null or undefined.",
	    missingGlobe: "The specified globe is null or undefined.",
	    missingId: "The specified id is null or undefined.",
	    missingImage: "The specified image is null or undefined.",
	    missingImageFormat: "The specified image format is null or undefined.",
	    missingIndices: "The specified indices array is null or undefined.",
	    missingKey: "The specified key is null or undefined.",
	    missingLevel: "The specified level is null or undefined.",
	    missingLine: "The specified line is null or undefined.",
	    missingList: "The specified list is null or undefined.",
	    missingListener: "The specified listener is null or undefined",
	    missingLocation: "The specified location is null or undefined.",
	    missingMatrix: "The specified matrix is null or undefined.",
	    missingOffset: "The specified offset is null or undefined.",
	    missingPath: "The specified path is null or undefined.",
	    missingPlacename: "The specified place name is null or undefined.",
	    missingPlane: "The specified plane is null or undefined.",
	    missingPoint: "The specified point is null or undefined.",
	    missingPoints: "The specified points array is null or undefined.",
	    missingPosition: "The specified position is null or undefined.",
	    missingPositions: "The specified positions array is null or undefined.",
	    missingProgram: "The specified program is null or undefined.",
	    missingProjection: "The specified projection is null or undefined.",
	    missingRectangle: "The specified rectangle is null or undefined.",
	    missingRenderable: "The specified renderable is null or undefined.",
	    missingResolution: "The specified resolution is null, undefined, or zero.",
	    missingResource: "The specified resource is null or undefined.",
	    missingResult: "The specified result variable is null or undefined.",
	    missingResults: "The specified results array is null or undefined.",
	    missingSector: "The specified sector is null or undefined.",
	    missingShapeType: "The specified shape type is null or undefined.",
	    missingSize: "The specified size is null or undefined.",
	    missingText: "The specified text is null or undefined.",
	    missingTexture: "The specified texture is null or undefined.",
	    missingTile: "The specified tile is null or undefined.",
	    missingType: "The specified type is null or undefined.",
	    missingUrl: "The specified URL is null or undefined",
	    missingVector: "The specified vector is null or undefined.",
	    missingVertex: "The specified vertex is null or undefined.",
	    missingViewport: "The specified viewport is null or undefined.",
	    missingWebCoverageService: "The specified WebCoverageService is null or undefined.",
	    missingWorldWindow: "The specified WorldWindow is null or undefined.",
	    notYetImplemented: "This function is not yet implemented",
	    unsupportedVersion: "The specified version is not supported.",
	    webglNotSupported: "The browser does not support WebGL, or WebGL is disabled."
	  }
	};
	var loggingLevel = 1; // log severe messages by default

	/**
	 * @exports Color
	 */
	/**
	 * Constructs a color from red, green, blue and alpha values.
	 * @alias Color
	 * @constructor
	 * @classdesc Represents a red, green, blue, alpha, color.
	 * @param {Number} red The red component, a number between 0 and 1.
	 * @param {Number} green The green component, a number between 0 and 1.
	 * @param {Number} blue The blue component, a number between 0 and 1.
	 * @param {Number} alpha The alpha component, a number between 0 and 1.
	 */

	function Color(red, green, blue, alpha) {
	  /**
	   * This color's red component, a number between 0 and 1.
	   * @type {Number}
	   */
	  this.red = red;
	  /**
	   * This color's green component, a number between 0 and 1.
	   * @type {Number}
	   */

	  this.green = green;
	  /**
	   * This color's blue component, a number between 0 and 1.
	   * @type {Number}
	   */

	  this.blue = blue;
	  /**
	   * This color's alpha component, a number between 0 and 1.
	   * @type {Number}
	   */

	  this.alpha = alpha;
	}
	/**
	 * The color white.
	 * @type {Color}
	 * @constant
	 */


	Color.WHITE = new Color(1, 1, 1, 1);
	/**
	 * The color black.
	 * @type {Color}
	 * @constant
	 */

	Color.BLACK = new Color(0, 0, 0, 1);
	/**
	 * The color red.
	 * @type {Color}
	 * @constant
	 */

	Color.RED = new Color(1, 0, 0, 1);
	/**
	 * The color green.
	 * @type {Color}
	 * @constant
	 */

	Color.GREEN = new Color(0, 1, 0, 1);
	/**
	 * The color blue.
	 * @type {Color}
	 * @constant
	 */

	Color.BLUE = new Color(0, 0, 1, 1);
	/**
	 * The color cyan.
	 * @type {Color}
	 * @constant
	 */

	Color.CYAN = new Color(0, 1, 1, 1);
	/**
	 * The color yellow.
	 * @type {Color}
	 * @constant
	 */

	Color.YELLOW = new Color(1, 1, 0, 1);
	/**
	 * The color magenta.
	 * @type {Color}
	 * @constant
	 */

	Color.MAGENTA = new Color(1, 0, 1, 1);
	/**
	 * A light gray (75% white).
	 * @type {Color}
	 */

	Color.LIGHT_GRAY = new Color(0.75, 0.75, 0.75, 1);
	/**
	 * A medium gray (50% white).
	 * @type {Color}
	 */

	Color.MEDIUM_GRAY = new Color(0.5, 0.5, 0.5, 1);
	/**
	 * A dark gray (25% white).
	 * @type {Color}
	 */

	Color.DARK_GRAY = new Color(0.25, 0.25, 0.25, 1);
	/**
	 * A transparent color.
	 * @type {Color}
	 */

	Color.TRANSPARENT = new Color(0, 0, 0, 0);
	/**
	 * Assigns the components of this color.
	 * @param {Number} red The red component, a number between 0 and 1.
	 * @param {Number} green The green component, a number between 0 and 1.
	 * @param {Number} blue The blue component, a number between 0 and 1.
	 * @param {Number} alpha The alpha component, a number between 0 and 1.
	 * @returns {Color} This color with the specified components assigned.
	 */

	Color.prototype.set = function (red, green, blue, alpha) {
	  this.red = red;
	  this.green = green;
	  this.blue = blue;
	  this.alpha = alpha;
	  return this;
	};
	/**
	 * Copies the components of a specified color to this color.
	 * @param {Color} color The color to copy.
	 * @returns {Color} This color set to the red, green, blue and alpha values of the specified color.
	 * @throws {ArgumentError} If the specified color is null or undefined.
	 */


	Color.prototype.copy = function (color) {
	  if (!color) {
	    throw new ArgumentError(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Color", "copy", "missingColor"));
	  }

	  this.red = color.red;
	  this.green = color.green;
	  this.blue = color.blue;
	  this.alpha = color.alpha;
	  return this;
	};
	/**
	 * Create a copy of this color.
	 * @returns {Color} A new instance containing the color components of this color.
	 */


	Color.prototype.clone = function () {
	  return new Color(this.red, this.green, this.blue, this.alpha);
	};
	/**
	 * Returns this color's components premultiplied by this color's alpha component.
	 * @param {Float32Array} array A pre-allocated array in which to return the color components.
	 * @returns {Float32Array} This colors premultiplied components as an array, in the order RGBA.
	 */


	Color.prototype.premultipliedComponents = function (array) {
	  var a = this.alpha;
	  array[0] = this.red * a;
	  array[1] = this.green * a;
	  array[2] = this.blue * a;
	  array[3] = a;
	  return array;
	};
	/**
	 * Construct a color from an array of color components expressed as byte values.
	 * @param {Uint8Array} bytes A four-element array containing the red, green, blue and alpha color
	 * components each in the range [0, 255];
	 * @returns {Color} The constructed color.
	 */


	Color.colorFromByteArray = function (bytes) {
	  return new Color(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
	};
	/**
	 * Construct a color from specified color components expressed as byte values.
	 * @param {number} redByte The red component in the range [0, 255].
	 * @param {number} greenByte The green component in the range [0, 255].
	 * @param {number} blueByte The blue component in the range [0, 255].
	 * @param {number} alphaByte The alpha component in the range [0, 255].
	 * @returns {Color} The constructed color.
	 */


	Color.colorFromBytes = function (redByte, greenByte, blueByte, alphaByte) {
	  return new Color(redByte / 255, greenByte / 255, blueByte / 255, alphaByte / 255);
	};

	Color.colorFromHex = function (color) {
	  var red = parseInt(color.substring(0, 2), 16);
	  var green = parseInt(color.substring(2, 4), 16);
	  var blue = parseInt(color.substring(4, 6), 16);
	  var alpha = parseInt(color.substring(6, 8), 16);
	  return Color.colorFromBytes(red, green, blue, alpha);
	};

	Color.colorFromKmlHex = function (color) {
	  var alpha = parseInt(color.substring(0, 2), 16);
	  var blue = parseInt(color.substring(2, 4), 16);
	  var green = parseInt(color.substring(4, 6), 16);
	  var red = parseInt(color.substring(6, 8), 16);
	  return Color.colorFromBytes(red, green, blue, alpha);
	};
	/**
	 * Computes and sets this color to the next higher RBG color. If the color overflows, this color is set to
	 * (1 / 255, 0, 0, *), where * indicates the current alpha value.
	 * @returns {Color} This color, set to the next possible color.
	 */


	Color.prototype.nextColor = function () {
	  var rb = Math.round(this.red * 255),
	      gb = Math.round(this.green * 255),
	      bb = Math.round(this.blue * 255);

	  if (rb < 255) {
	    this.red = (rb + 1) / 255;
	  } else if (gb < 255) {
	    this.red = 0;
	    this.green = (gb + 1) / 255;
	  } else if (bb < 255) {
	    this.red = 0;
	    this.green = 0;
	    this.blue = (bb + 1) / 255;
	  } else {
	    this.red = 1 / 255;
	    this.green = 0;
	    this.blue = 0;
	  }

	  return this;
	};
	/**
	 * Indicates whether this color is equal to a specified color after converting the floating-point component
	 * values of each color to byte values.
	 * @param {Color} color The color to test,
	 * @returns {Boolean} true if the colors are equal, otherwise false.
	 */


	Color.prototype.equals = function (color) {
	  var rbA = Math.round(this.red * 255),
	      gbA = Math.round(this.green * 255),
	      bbA = Math.round(this.blue * 255),
	      abA = Math.round(this.alpha * 255),
	      rbB = Math.round(color.red * 255),
	      gbB = Math.round(color.green * 255),
	      bbB = Math.round(color.blue * 255),
	      abB = Math.round(color.alpha * 255);
	  return rbA === rbB && gbA === gbB && bbA === bbB && abA === abB;
	};
	/**
	 * Indicates whether this color is equal to another color expressed as an array of bytes.
	 * @param {Uint8Array} bytes The red, green, blue and alpha color components.
	 * @returns {Boolean} true if the colors are equal, otherwise false.
	 */


	Color.prototype.equalsBytes = function (bytes) {
	  var rb = Math.round(this.red * 255),
	      gb = Math.round(this.green * 255),
	      bb = Math.round(this.blue * 255),
	      ab = Math.round(this.alpha * 255);
	  return rb === bytes[0] && gb === bytes[1] && bb === bytes[2] && ab === bytes[3];
	};
	/**
	 * Returns a string representation of this color, indicating the byte values corresponding to this color's
	 * floating-point component values.
	 * @returns {String}
	 */


	Color.prototype.toByteString = function () {
	  var rb = Math.round(this.red * 255),
	      gb = Math.round(this.green * 255),
	      bb = Math.round(this.blue * 255),
	      ab = Math.round(this.alpha * 255);
	  return "(" + rb + "," + gb + "," + bb + "," + ab + ")";
	};
	/**
	 * Create a hex color string that CSS can use. Optionally, inhibit capturing alpha,
	 * because some uses reject a four-component color specification.
	 * @param {Boolean} isUsingAlpha Enable the use of an alpha component.
	 * @returns {string} A color string suitable for CSS.
	 * @deprecated since version 0.10.0, use toCssColorString for valid CSS color strings
	 */


	Color.prototype.toHexString = function (isUsingAlpha) {
	  // Use Math.ceil() to get 0.75 to map to 0xc0. This is important if the display is dithering.
	  var redHex = Math.ceil(this.red * 255).toString(16),
	      greenHex = Math.ceil(this.green * 255).toString(16),
	      blueHex = Math.ceil(this.blue * 255).toString(16),
	      alphaHex = Math.ceil(this.alpha * 255).toString(16);
	  var result = "#";
	  result += redHex.length < 2 ? '0' + redHex : redHex;
	  result += greenHex.length < 2 ? '0' + greenHex : greenHex;
	  result += blueHex.length < 2 ? '0' + blueHex : blueHex;

	  if (isUsingAlpha) {
	    result += alphaHex.length < 2 ? '0' + alphaHex : alphaHex;
	  }

	  return result;
	};
	/**
	 * Create a rgba color string that conforms to CSS Color Module Level 3 specification.
	 * @returns {string} A color string suitable for CSS.
	 */


	Color.prototype.toCssColorString = function () {
	  var red = Math.round(this.red * 255),
	      green = Math.round(this.green * 255),
	      blue = Math.round(this.blue * 255); // Per the CSS Color Module Level 3 specification, alpha is expressed as floating point value between 0 - 1

	  return 'rgba(' + red + ', ' + green + ', ' + blue + ', ' + this.alpha + ')';
	};

	/**
	 * @exports ArgumentError
	 */
	/**
	 * Constructs an argument error with a specified message.
	 * @alias ArgumentError
	 * @constructor
	 * @classdesc Represents an error associated with invalid function arguments.
	 * @augments AbstractError
	 * @param {String} message The message.
	 */

	function ArgumentError$1(message) {
	  AbstractError.call(this, "ArgumentError", message);
	  var stack;

	  try {
	    //noinspection ExceptionCaughtLocallyJS
	    throw new Error();
	  } catch (e) {
	    stack = e.stack;
	  }

	  this.stack = stack;
	}

	ArgumentError$1.prototype = Object.create(AbstractError.prototype);

	/**
	 * @exports Font
	 */
	/**
	 * Construct a font descriptor. See the individual attribute descriptions below for possible parameter values.
	 * @param {Number} size The size of font.
	 * @param {String} style The style of the font.
	 * @param {String} variant The variant of the font.
	 * @param {String} weight The weight of the font.
	 * @param {String} family The family of the font.
	 * @param {String} horizontalAlignment The vertical alignment of the font.
	 * @alias Font
	 * @constructor
	 * @classdesc Holds attributes controlling the style, size and other attributes of {@link Text} shapes and
	 * the textual features of {@link Placemark} and other shapes. The values used for these attributes are those
	 * defined by the [CSS Font property]{@link http://www.w3schools.com/cssref/pr_font_font.asp}.
	 */

	function Font(size, style, variant, weight, family, horizontalAlignment) {
	  /*
	   * All properties of Font are intended to be private and must be accessed via public getters and setters.
	   */
	  if (!size) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Font", "constructor", "missingSize"));
	  } else if (size <= 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Font", "constructor", "invalidSize"));
	  } else {
	    this._size = size;
	  }

	  this.style = style || "normal";
	  this.variant = variant || "normal";
	  this.weight = weight || "normal";
	  this.family = family || "sans-serif";
	  this.horizontalAlignment = horizontalAlignment || "center";
	}

	Object.defineProperties(Font.prototype, {
	  /**
	   * The font size.
	   * @memberof Font.prototype
	   * @type Number
	   */
	  size: {
	    get: function () {
	      return this._size;
	    },
	    set: function (value) {
	      this._fontString = null;
	      this._size = value;
	    }
	  },

	  /**
	   * The font style.
	   * See [CSS font-style]{@link http://www.w3schools.com/cssref/pr_font_font-style.asp} for defined values.
	   * @memberof Font.prototype
	   * @type {String}
	   * @default "normal"
	   */
	  style: {
	    get: function () {
	      return this._style;
	    },
	    set: function (value) {
	      this._fontString = null;
	      this._style = value;
	    }
	  },

	  /**
	   * The font variant.
	   * See [CSS font-variant]{@link http://www.w3schools.com/cssref/pr_font_font-variant.asp} for defined values.
	   * @memberof Font.prototype
	   * @type {String}
	   * @default "normal"
	   */
	  variant: {
	    get: function () {
	      return this._variant;
	    },
	    set: function (value) {
	      this._fontString = null;
	      this._variant = value;
	    }
	  },

	  /**
	   * The font weight.
	   * See [CSS font-weight]{@link http://www.w3schools.com/cssref/pr_font_weight.asp} for defined values.
	   * @memberof Font.prototype
	   * @type {String}
	   * @default "normal"
	   */
	  weight: {
	    get: function () {
	      return this._weight;
	    },
	    set: function (value) {
	      this._fontString = null;
	      this._weight = value;
	    }
	  },

	  /**
	   * The font family.
	   * See [CSS font-family]{@link http://www.w3schools.com/cssref/pr_font_font-family.asp} for defined values.
	   * @memberof Font.prototype
	   * @type {String}
	   * @default "sans-serif"
	   */
	  family: {
	    get: function () {
	      return this._family;
	    },
	    set: function (value) {
	      this._fontString = null;
	      this._family = value;
	    }
	  },

	  /**
	   * The horizontal alignment of the font.
	   * Recognized values are "left", "center" and "right".
	   * @memberof Font.prototype
	   * @type {String}
	   * @default "center"
	   */
	  horizontalAlignment: {
	    get: function () {
	      return this._horizontalAlignment;
	    },
	    set: function (value) {
	      this._toString = null;
	      this._horizontalAlignment = value;
	    }
	  },

	  /**
	   * A string representing this font's style, weight, size and family properties, suitable for
	   * passing directly to a 2D canvas context.
	   * @memberof Font.prototype
	   */
	  fontString: {
	    get: function () {
	      if (!this._fontString) {
	        this._fontString = this._style + " " + this.variant + " " + this._weight + " " + this._size.toString() + "px " + this._family;
	      }

	      return this._fontString;
	    }
	  }
	});
	/**
	 * Returns a string representation of this object.
	 * @returns {String} A string representation of this object.
	 */

	Font.prototype.toString = function () {
	  if (!this._toString || !this._fontString) {
	    this._toString = this.fontString + " " + this.horizontalAlignment;
	  }

	  return this._toString;
	};

	/**
	 * Constructs an Insets object that is a representation of the borders of a container.
	 * It specifies the space that a container must leave at each of its edges.
	 * @alias Insets
	 * @param {Number} top The inset from the top.
	 * @param {Number} left The inset from the left.
	 * @param {Number} bottom The inset from the bottom.
	 * @param {Number} right The inset from the right.
	 * @constructor
	 */

	function Insets(top, left, bottom, right) {
	  if (arguments.length !== 4) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Insets", "constructor", "invalidArgumentCount"));
	  } // These are all documented with their property accessors below.


	  this._top = top;
	  this._left = left;
	  this._bottom = bottom;
	  this._right = right;
	}
	/**
	 * Set top, left, bottom, and right to the specified values.
	 * @param {Number} top The inset from the top.
	 * @param {Number} left The inset from the left.
	 * @param {Number} bottom The inset from the bottom.
	 * @param {Number} right The inset from the right.
	 */


	Insets.prototype.set = function (top, left, bottom, right) {
	  this._top = top;
	  this._left = left;
	  this._bottom = bottom;
	  this._right = right;
	};
	/**
	 * Creates a new copy of this insets with identical property values.
	 * @returns {Insets} A new insets instance with its property values the same as this one's.
	 */


	Insets.prototype.clone = function () {
	  return new Insets(this._top, this._left, this._bottom, this._right);
	};
	/**
	 * Returns a string representation of this object.
	 * @returns {String} A string representation of this object.
	 */


	Insets.prototype.toString = function () {
	  return this._top + " " + this._left + " " + this._bottom + " " + this._right;
	};

	Object.defineProperties(Insets.prototype, {
	  /**
	   * Indicates the the inset from the top.
	   * @type {Number}
	   * @memberof Insets.prototype
	   */
	  top: {
	    get: function () {
	      return this._top;
	    },
	    set: function (value) {
	      this._top = value;
	    }
	  },

	  /**
	   * Indicates the the inset from the left.
	   * @type {Number}
	   * @memberof Insets.prototype
	   */
	  left: {
	    get: function () {
	      return this._left;
	    },
	    set: function (value) {
	      this._left = value;
	    }
	  },

	  /**
	   * Indicates the the inset from the bottom.
	   * @type {Number}
	   * @memberof Insets.prototype
	   */
	  bottom: {
	    get: function () {
	      return this._bottom;
	    },
	    set: function (value) {
	      this._bottom = value;
	    }
	  },

	  /**
	   * Indicates the the inset from the right.
	   * @type {Number}
	   * @memberof Insets.prototype
	   */
	  right: {
	    get: function () {
	      return this._right;
	    },
	    set: function (value) {
	      this._right = value;
	    }
	  }
	});

	/**
	 * Constructs a three-component vector.
	 * @alias Vec3
	 * @classdesc Represents a three-component vector. Access the X component of the vector as v[0], the Y
	 * component as v[1] and the Z component as v[2].
	 * @augments Float64Array
	 * @param {Number} x X component of vector.
	 * @param {Number} y Y component of vector.
	 * @param {Number} z Z component of vector.
	 * @constructor
	 */

	function Vec3$1(x, y, z) {
	  this[0] = x;
	  this[1] = y;
	  this[2] = z;
	} // Vec3 extends Float64Array.


	Vec3$1.prototype = new Float64Array(3);
	/**
	 * A vector corresponding to the origin.
	 * @type {Vec3}
	 */

	Vec3$1.ZERO = new Vec3$1(0, 0, 0);
	/**
	 * Computes the average of a specified array of vectors.
	 * @param {Vec3[]} vectors The vectors whose average to compute.
	 * @param {Vec3} result A pre-allocated Vec3 in which to return the computed average.
	 * @returns {Vec3} The result argument set to the average of the specified array of vectors.
	 * @throws {ArgumentError} If the specified array of vectors is null, undefined or empty or the specified
	 * result argument is null or undefined.
	 */

	Vec3$1.average = function (vectors, result) {
	  if (!vectors || vectors.length < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "average", "missingArray"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "average", "missingResult"));
	  }

	  var count = vectors.length,
	      vec;
	  result[0] = 0;
	  result[1] = 0;
	  result[2] = 0;

	  for (var i = 0, len = vectors.length; i < len; i++) {
	    vec = vectors[i];
	    result[0] += vec[0] / count;
	    result[1] += vec[1] / count;
	    result[2] += vec[2] / count;
	  }

	  return result;
	};
	/**
	 * Computes the average of a specified array of points packed into a single array.
	 * @param {Float32Array | Float64Array | Number[]} points The points whose average to compute.
	 * @param {Vec3} result A pre-allocated Vec3 in which to return the computed average.
	 * @returns {Vec3} The result argument set to the average of the specified array of points.
	 * @throws {ArgumentError} If the specified array of points is null, undefined or empty or the result argument
	 * is null or undefined.
	 */


	Vec3$1.averageOfBuffer = function (points, result) {
	  if (!points || points.length < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "averageBuffer", "missingArray"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "averageBuffer", "missingResult"));
	  }

	  var count = points.length / 3;
	  result[0] = 0;
	  result[1] = 0;
	  result[2] = 0;

	  for (var i = 0; i < count; i++) {
	    result[0] += points[i * 3] / count;
	    result[1] += points[i * 3 + 1] / count;
	    result[2] += points[i * 3 + 2] / count;
	  }

	  return result;
	};
	/**
	 * Indicates whether three vectors are colinear.
	 * @param {Vec3} a The first vector.
	 * @param {Vec3} b The second vector.
	 * @param {Vec3} c The third vector.
	 * @returns {Boolean} true if the vectors are colinear, otherwise false.
	 * @throws {ArgumentError} If any of the specified vectors are null or undefined.
	 */


	Vec3$1.areColinear = function (a, b, c) {
	  if (!a || !b || !c) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "areColinear", "missingVector"));
	  }

	  var ab = new Vec3$1(a[0] - b[0], a[1] - b[1], a[2] - b[2]).normalize(),
	      bc = new Vec3$1(c[0] - b[0], c[1] - b[1], c[2] - b[2]).normalize(); // ab and bc are considered colinear if their dot product is near +/-1.

	  return Math.abs(ab.dot(bc)) > 0.999;
	};
	/**
	 * Computes the normal vector of a specified triangle.
	 *
	 * @param {Vec3} a The triangle's first vertex.
	 * @param {Vec3} b The triangle's second vertex.
	 * @param {Vec3} c The triangle's third vertex.
	 * @returns {Vec3} The triangle's unit-normal vector.
	 * @throws {ArgumentError} If any of the specified vectors are null or undefined.
	 */


	Vec3$1.computeTriangleNormal = function (a, b, c) {
	  if (!a || !b || !c) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "areColinear", "missingVector"));
	  }

	  var x = (b[1] - a[1]) * (c[2] - a[2]) - (b[2] - a[2]) * (c[1] - a[1]),
	      y = (b[2] - a[2]) * (c[0] - a[0]) - (b[0] - a[0]) * (c[2] - a[2]),
	      z = (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]),
	      length = x * x + y * y + z * z;

	  if (length === 0) {
	    return new Vec3$1(x, y, z);
	  }

	  length = Math.sqrt(length);
	  return new Vec3$1(x / length, y / length, z / length);
	};
	/**
	 * Finds three non-colinear points in an array of coordinates.
	 *
	 * @param {Number[]} coords The coordinates, in the order x0, y0, z0, x1, y1, z1, ...
	 * @param {Number} stride The number of numbers between successive points. 0 indicates that the points
	 * are arranged one immediately after the other, as would the value 3.
	 * @returns {Vec3[]} Three non-colinear points from the input array of coordinates, or null if three
	 * non-colinear points could not be found or the specified coordinates array is null, undefined or
	 * contains fewer than three points.
	 */


	Vec3$1.findThreeIndependentVertices = function (coords, stride) {
	  var xstride = stride && stride > 0 ? stride : 3;

	  if (!coords || coords.length < 3 * xstride) {
	    return null;
	  }

	  var a = new Vec3$1(coords[0], coords[1], coords[2]),
	      b = null,
	      c = null,
	      k = xstride;

	  for (; k < coords.length; k += xstride) {
	    b = new Vec3$1(coords[k], coords[k + 1], coords[k + 2]);

	    if (!(b[0] === a[0] && b[1] === a[1] && b[2] === a[2])) {
	      break;
	    }

	    b = null;
	  }

	  if (!b) {
	    return null;
	  }

	  for (k += xstride; k < coords.length; k += xstride) {
	    c = new Vec3$1(coords[k], coords[k + 1], coords[k + 2]); // if c is not coincident with a or b, and the vectors ab and bc are not colinear, break and
	    // return a, b, c.

	    if (!(c[0] === a[0] && c[1] === a[1] && c[2] === a[2] || c[0] === b[0] && c[1] === b[1] && c[2] === b[2])) {
	      if (!Vec3$1.areColinear(a, b, c)) break;
	    }

	    c = null;
	  }

	  return c ? [a, b, c] : null;
	};
	/**
	 * Computes a unit-normal vector for a buffer of coordinate triples. The normal vector is computed from the
	 * first three non-colinear points in the buffer.
	 *
	 * @param {Number[]} coords The coordinates, in the order x0, y0, z0, x1, y1, z1, ...
	 * @param {Number} stride The number of numbers between successive points. 0 indicates that the points
	 * are arranged one immediately after the other, as would the value 3.
	 * @returns {Vec3} The computed unit-length normal vector.
	 */


	Vec3$1.computeBufferNormal = function (coords, stride) {
	  var vertices = Vec3$1.findThreeIndependentVertices(coords, stride);
	  return vertices ? Vec3$1.computeTriangleNormal(vertices[0], vertices[1], vertices[2]) : null;
	};
	/**
	 * Assigns the components of this vector.
	 * @param {Number} x The X component of the vector.
	 * @param {Number} y The Y component of the vector.
	 * @param {Number} z The Z component of the vector.
	 * @returns {Vec3} This vector with the specified components assigned.
	 */


	Vec3$1.prototype.set = function (x, y, z) {
	  this[0] = x;
	  this[1] = y;
	  this[2] = z;
	  return this;
	};
	/**
	 * Copies the components of a specified vector to this vector.
	 * @param {Vec3} vector The vector to copy.
	 * @returns {Vec3} This vector set to the X, Y and Z values of the specified vector.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Vec3$1.prototype.copy = function (vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "copy", "missingVector"));
	  }

	  this[0] = vector[0];
	  this[1] = vector[1];
	  this[2] = vector[2];
	  return this;
	};
	/**
	 * Indicates whether the components of this vector are identical to those of a specified vector.
	 * @param {Vec3} vector The vector to test.
	 * @returns {Boolean} true if the components of this vector are equal to those of the specified one,
	 * otherwise false.
	 */


	Vec3$1.prototype.equals = function (vector) {
	  return this[0] === vector[0] && this[1] === vector[1] && this[2] === vector[2];
	};
	/**
	 * Adds a specified vector to this vector.
	 * @param {Vec3} addend The vector to add.
	 * @returns {Vec3} This vector after adding the specified vector to it.
	 * @throws {ArgumentError} If the addend is null or undefined.
	 */


	Vec3$1.prototype.add = function (addend) {
	  if (!addend) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "add", "missingVector"));
	  }

	  this[0] += addend[0];
	  this[1] += addend[1];
	  this[2] += addend[2];
	  return this;
	};
	/**
	 * Subtracts a specified vector from this vector.
	 * @param {Vec3} subtrahend The vector to subtract
	 * @returns {Vec3} This vector after subtracting the specified vector from it.
	 * @throws {ArgumentError} If the subtrahend is null or undefined.
	 */


	Vec3$1.prototype.subtract = function (subtrahend) {
	  if (!subtrahend) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "subtract", "missingVector"));
	  }

	  this[0] -= subtrahend[0];
	  this[1] -= subtrahend[1];
	  this[2] -= subtrahend[2];
	  return this;
	};
	/**
	 * Multiplies this vector by a scalar.
	 * @param {Number} scalar The scalar to multiply this vector by.
	 * @returns {Vec3} This vector multiplied by the specified scalar.
	 */


	Vec3$1.prototype.multiply = function (scalar) {
	  this[0] *= scalar;
	  this[1] *= scalar;
	  this[2] *= scalar;
	  return this;
	};
	/**
	 * Divides this vector by a scalar.
	 * @param {Number} divisor The scalar to divide this vector by.
	 * @returns {Vec3} This vector divided by the specified scalar.
	 */


	Vec3$1.prototype.divide = function (divisor) {
	  this[0] /= divisor;
	  this[1] /= divisor;
	  this[2] /= divisor;
	  return this;
	};
	/**
	 * Multiplies this vector by a 4x4 matrix. The multiplication is performed with an implicit W component of 1.
	 * The resultant W component of the product is then divided through the X, Y, and Z components.
	 *
	 * @param {Matrix} matrix The matrix to multiply this vector by.
	 * @returns {Vec3} This vector multiplied by the specified matrix.
	 * @throws ArgumentError If the specified matrix is null or undefined.
	 */


	Vec3$1.prototype.multiplyByMatrix = function (matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "multiplyByMatrix", "missingMatrix"));
	  }

	  var x = matrix[0] * this[0] + matrix[1] * this[1] + matrix[2] * this[2] + matrix[3],
	      y = matrix[4] * this[0] + matrix[5] * this[1] + matrix[6] * this[2] + matrix[7],
	      z = matrix[8] * this[0] + matrix[9] * this[1] + matrix[10] * this[2] + matrix[11],
	      w = matrix[12] * this[0] + matrix[13] * this[1] + matrix[14] * this[2] + matrix[15];
	  this[0] = x / w;
	  this[1] = y / w;
	  this[2] = z / w;
	  return this;
	};
	/**
	 * Mixes (interpolates) a specified vector with this vector, modifying this vector.
	 * @param {Vec3} vector The vector to mix with this one.
	 * @param {Number} weight The relative weight of this vector.
	 * @returns {Vec3} This vector modified to the mix of itself and the specified vector.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Vec3$1.prototype.mix = function (vector, weight) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "mix", "missingVector"));
	  }

	  var w0 = 1 - weight,
	      w1 = weight;
	  this[0] = this[0] * w0 + vector[0] * w1;
	  this[1] = this[1] * w0 + vector[1] * w1;
	  this[2] = this[2] * w0 + vector[2] * w1;
	  return this;
	};
	/**
	 * Negates the components of this vector.
	 * @returns {Vec3} This vector, negated.
	 */


	Vec3$1.prototype.negate = function () {
	  this[0] = -this[0];
	  this[1] = -this[1];
	  this[2] = -this[2];
	  return this;
	};
	/**
	 * Computes the scalar dot product of this vector and a specified vector.
	 * @param {Vec3} vector The vector to multiply.
	 * @returns {Number} The dot product of the two vectors.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Vec3$1.prototype.dot = function (vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "dot", "missingVector"));
	  }

	  return this[0] * vector[0] + this[1] * vector[1] + this[2] * vector[2];
	};
	/**
	 * Computes the cross product of this vector and a specified vector, modifying this vector.
	 * @param {Vec3} vector The vector to cross with this vector.
	 * @returns {Vec3} This vector set to the cross product of itself and the specified vector.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Vec3$1.prototype.cross = function (vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "cross", "missingVector"));
	  }

	  var x = this[1] * vector[2] - this[2] * vector[1],
	      y = this[2] * vector[0] - this[0] * vector[2],
	      z = this[0] * vector[1] - this[1] * vector[0];
	  this[0] = x;
	  this[1] = y;
	  this[2] = z;
	  return this;
	};
	/**
	 * Computes the squared magnitude of this vector.
	 * @returns {Number} The squared magnitude of this vector.
	 */


	Vec3$1.prototype.magnitudeSquared = function () {
	  return this.dot(this);
	};
	/**
	 * Computes the magnitude of this vector.
	 * @returns {Number} The magnitude of this vector.
	 */


	Vec3$1.prototype.magnitude = function () {
	  return Math.sqrt(this.magnitudeSquared());
	};
	/**
	 * Normalizes this vector to a unit vector.
	 * @returns {Vec3} This vector, normalized.
	 */


	Vec3$1.prototype.normalize = function () {
	  var magnitude = this.magnitude(),
	      magnitudeInverse = 1 / magnitude;
	  this[0] *= magnitudeInverse;
	  this[1] *= magnitudeInverse;
	  this[2] *= magnitudeInverse;
	  return this;
	};
	/**
	 * Computes the squared distance from this vector to a specified vector.
	 * @param {Vec3} vector The vector to compute the distance to.
	 * @returns {Number} The squared distance between the vectors.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Vec3$1.prototype.distanceToSquared = function (vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "distanceToSquared", "missingVector"));
	  }

	  var dx = this[0] - vector[0],
	      dy = this[1] - vector[1],
	      dz = this[2] - vector[2];
	  return dx * dx + dy * dy + dz * dz;
	};
	/**
	 * Computes the distance from this vector to another vector.
	 * @param {Vec3} vector The vector to compute the distance to.
	 * @returns {number} The distance between the vectors.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Vec3$1.prototype.distanceTo = function (vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec3", "distanceTo", "missingVector"));
	  }

	  return Math.sqrt(this.distanceToSquared(vector));
	};
	/**
	 * Swaps this vector with that vector. This vector's components are set to the values of the specified
	 * vector's components, and the specified vector's components are set to the values of this vector's components.
	 * @param {Vec3} that The vector to swap.
	 * @returns {Vec3} This vector set to the values of the specified vector.
	 */


	Vec3$1.prototype.swap = function (that) {
	  var tmp = this[0];
	  this[0] = that[0];
	  that[0] = tmp;
	  tmp = this[1];
	  this[1] = that[1];
	  that[1] = tmp;
	  tmp = this[2];
	  this[2] = that[2];
	  that[2] = tmp;
	  return this;
	};
	/**
	 * Returns a string representation of this vector.
	 * @returns {String} A string representation of this vector, in the form "(x, y, z)".
	 */


	Vec3$1.prototype.toString = function () {
	  return "(" + this[0] + ", " + this[1] + ", " + this[2] + ")";
	};

	/**
	 * Constructs a two-component vector.
	 * @alias Vec2
	 * @classdesc Represents a two-component vector. Access the X component of the vector as v[0] and the Y
	 * component as v[1].
	 * @augments Float64Array
	 * @param {Number} x X component of vector.
	 * @param {Number} y Y component of vector.
	 * @constructor
	 */

	function Vec2(x, y) {
	  this[0] = x;
	  this[1] = y;
	} // Vec2 inherits from Float64Array.


	Vec2.prototype = new Float64Array(2);
	/**
	 * Assigns the components of this vector.
	 * @param {Number} x The X component of the vector.
	 * @param {Number} y The Y component of the vector.
	 * @returns {Vec2} This vector with the specified components assigned.
	 */

	Vec2.prototype.set = function (x, y) {
	  this[0] = x;
	  this[1] = y;
	  return this;
	};
	/**
	 * Copies the components of a specified vector to this vector.
	 * @param {Vec2} vector The vector to copy.
	 * @returns {Vec2} This vector set to the values of the specified vector.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Vec2.prototype.copy = function (vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec2", "copy", "missingVector"));
	  }

	  this[0] = vector[0];
	  this[1] = vector[1];
	  return this;
	};
	/**
	 * Indicates whether the X and Y components of this vector are identical to those of a specified vector.
	 * @param {Vec2} vector The vector to test.
	 * @returns {Boolean} true if this vector's components are equal to those of the specified vector,
	 * otherwise false.
	 */


	Vec2.prototype.equals = function (vector) {
	  return this[0] === vector[0] && this[1] === vector[1];
	};
	/**
	 * Computes the average of a specified array of vectors.
	 * @param {Vec2[]} vectors The vectors whose average to compute.
	 * @param {Vec2} result A pre-allocated Vec2 in which to return the computed average.
	 * @returns {Vec2} The result argument set to the average of the specified lists of vectors.
	 * @throws {ArgumentError} If the specified array of vectors is null, undefined or empty, or the specified
	 * result argument is null or undefined.
	 */


	Vec2.average = function (vectors, result) {
	  if (!vectors || vectors.length < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec2", "average", "missingArray"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec2", "average", "missingResult"));
	  }

	  var count = vectors.length,
	      vec;
	  result[0] = 0;
	  result[1] = 0;

	  for (var i = 0, len = vectors.length; i < len; i++) {
	    vec = vectors[i];
	    result[0] += vec[0] / count;
	    result[1] += vec[1] / count;
	  }

	  return result;
	};
	/**
	 * Adds a vector to this vector.
	 * @param {Vec2} addend The vector to add to this one.
	 * @returns {Vec2} This vector after adding the specified vector to it.
	 * @throws {ArgumentError} If the specified addend is null or undefined.
	 */


	Vec2.prototype.add = function (addend) {
	  if (!addend) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec2", "add", "missingVector"));
	  }

	  this[0] += addend[0];
	  this[1] += addend[1];
	  return this;
	};
	/**
	 * Subtracts a vector from this vector.
	 * @param {Vec2} subtrahend The vector to subtract from this one.
	 * @returns {Vec2} This vector after subtracting the specified vector from it.
	 * @throws {ArgumentError} If the subtrahend is null or undefined.
	 */


	Vec2.prototype.subtract = function (subtrahend) {
	  if (!subtrahend) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec2", "subtract", "missingVector"));
	  }

	  this[0] -= subtrahend[0];
	  this[1] -= subtrahend[1];
	  return this;
	};
	/**
	 * Multiplies this vector by a scalar.
	 * @param {Number} scalar The scalar to multiply this vector by.
	 * @returns {Vec2} This vector multiplied by the specified scalar.
	 */


	Vec2.prototype.multiply = function (scalar) {
	  this[0] *= scalar;
	  this[1] *= scalar;
	  return this;
	};
	/**
	 * Divide this vector by a scalar.
	 * @param {Number} divisor The scalar to divide this vector by.
	 * @returns {Vec2} This vector divided by the specified scalar.
	 */


	Vec2.prototype.divide = function (divisor) {
	  this[0] /= divisor;
	  this[1] /= divisor;
	  return this;
	};
	/**
	 * Mixes (interpolates) a specified vector with this vector, modifying this vector.
	 * @param {Vec2} vector The vector to mix.
	 * @param {Number} weight The relative weight of this vector.
	 * @returns {Vec2} This vector modified to the mix of itself and the specified vector.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Vec2.prototype.mix = function (vector, weight) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec2", "mix", "missingVector"));
	  }

	  var w0 = 1 - weight,
	      w1 = weight;
	  this[0] = this[0] * w0 + vector[0] * w1;
	  this[1] = this[1] * w0 + vector[1] * w1;
	  return this;
	};
	/**
	 * Negates this vector.
	 * @returns {Vec2} This vector, negated.
	 */


	Vec2.prototype.negate = function () {
	  this[0] = -this[0];
	  this[1] = -this[1];
	  return this;
	};
	/**
	 * Computes the scalar dot product of this vector and a specified vector.
	 * @param {Vec2} vector The vector to multiply.
	 * @returns {Number} The scalar dot product of the vectors.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Vec2.prototype.dot = function (vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec2", "dot", "missingVector"));
	  }

	  return this[0] * vector[0] + this[1] * vector[1];
	};
	/**
	 * Computes the squared magnitude of this vector.
	 * @returns {Number} The squared magnitude of this vector.
	 */


	Vec2.prototype.magnitudeSquared = function () {
	  return this.dot(this);
	};
	/**
	 * Computes the magnitude of this vector.
	 * @returns {Number} The magnitude of this vector.
	 */


	Vec2.prototype.magnitude = function () {
	  return Math.sqrt(this.magnitudeSquared());
	};
	/**
	 * Normalizes this vector to a unit vector.
	 * @returns {Vec2} This vector, normalized.
	 */


	Vec2.prototype.normalize = function () {
	  var magnitude = this.magnitude(),
	      magnitudeInverse = 1 / magnitude;
	  this[0] *= magnitudeInverse;
	  this[1] *= magnitudeInverse;
	  return this;
	};
	/**
	 * Computes the squared distance from this vector to a specified vector.
	 * @param {Vec2} vector The vector to compute the distance to.
	 * @returns {Number} The squared distance between the vectors.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Vec2.prototype.distanceToSquared = function (vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec2", "distanceToSquared", "missingVector"));
	  }

	  var dx = this[0] - vector[0],
	      dy = this[1] - vector[1];
	  return dx * dx + dy * dy;
	};
	/**
	 * Computes the distance from this vector to a specified vector.
	 * @param {Vec2} vector The vector to compute the distance to.
	 * @returns {Number} The distance between the vectors.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Vec2.prototype.distanceTo = function (vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Vec2", "distanceTo", "missingVector"));
	  }

	  return Math.sqrt(this.distanceToSquared(vector));
	};
	/**
	 * Creates a {@link Vec3} using this vector's X and Y components and a Z component of 0.
	 * @returns {Vec3} A new vector whose X and Y components are those of this vector and whose Z component is 0.
	 */


	Vec2.prototype.toVec3 = function () {
	  return new Vec3$1(this[0], this[1], 0);
	};
	/**
	 * Swaps the components of this vector with those of another vector. This vector is set to the values of the
	 * specified vector, and the specified vector's components are set to the values of this vector.
	 * @param {Vec2} that The vector to swap.
	 * @returns {Vec2} This vector set to the values of the specified vector.
	 */


	Vec2.prototype.swap = function (that) {
	  var tmp = this[0];
	  this[0] = that[0];
	  that[0] = tmp;
	  tmp = this[1];
	  this[1] = that[1];
	  that[1] = tmp;
	  return this;
	};
	/**
	 * Returns a string representation of this vector.
	 * @returns {String} A string representation of this vector, in the form "(x, y)".
	 */


	Vec2.prototype.toString = function () {
	  return "(" + this[0] + ", " + this[1] + ")";
	};

	/**
	 * @exports Offset
	 */
	/**
	 * Constructs an offset instance given specified units and offsets.
	 * @alias Offset
	 * @constructor
	 * @classdesc Specifies an offset relative to a rectangle. Used by [Placemark]{@link Placemark} and
	 * other shapes.
	 * @param {String} xUnits The type of units specified for the X dimension. May be one of the following:
	 * <ul>
	 *     <li>[WorldWind.OFFSET_FRACTION]{@link WorldWind#OFFSET_FRACTION}</li>
	 *     <li>[WorldWind.OFFSET_INSET_PIXELS]{@link WorldWind#OFFSET_INSET_PIXELS}</li>
	 *     <li>[WorldWind.OFFSET_PIXELS]{@link WorldWind#OFFSET_PIXELS}</li>
	 * </ul>
	 * @param {Number} x The offset in the X dimension.
	 * @param {String} yUnits The type of units specified for the Y dimension, assuming a lower-left Y origin.
	 * May be one of the following:
	 * <ul>
	 *     <li>[WorldWind.OFFSET_FRACTION]{@link WorldWind#OFFSET_FRACTION}</li>
	 *     <li>[WorldWind.OFFSET_INSET_PIXELS]{@link WorldWind#OFFSET_INSET_PIXELS}</li>
	 *     <li>[WorldWind.OFFSET_PIXELS]{@link WorldWind#OFFSET_PIXELS}</li>
	 * </ul>
	 * @param {Number} y The offset in the Y dimension.
	 */

	function Offset(xUnits, x, yUnits, y) {
	  /**
	   * The offset in the X dimension, interpreted according to this instance's xUnits argument.
	   * @type {Number}
	   */
	  this.x = x;
	  /**
	   * The offset in the Y dimension, interpreted according to this instance's yUnits argument.
	   * @type {Number}
	   */

	  this.y = y;
	  /**
	   * The units of this instance's X offset. See this class' constructor description for a list of the
	   * possible values.
	   * @type {String}
	   */

	  this.xUnits = xUnits;
	  /**
	   * The units of this instance's Y offset. See this class' constructor description for a list of the
	   * possible values.
	   * @type {String}
	   */

	  this.yUnits = yUnits;
	}
	/**
	 * Creates a new copy of this offset with identical property values.
	 * @returns {Offset} A new offset instance with its property values the same as this one's.
	 */


	Offset.prototype.clone = function () {
	  return new Offset(this.xUnits, this.x, this.yUnits, this.y);
	};
	/**
	 * Returns this offset's absolute X and Y coordinates in pixels for a rectangle of a specified size in pixels.
	 * The returned offset is in pixels relative to the rectangle's origin, and is defined in the coordinate
	 * system used by the caller.
	 * @param {Number} width The rectangle's width in pixels.
	 * @param {Number} height The rectangles height in pixels.
	 * @returns {Vec2} The computed offset relative to the rectangle's origin.
	 */


	Offset.prototype.offsetForSize = function (width, height) {
	  var x, y;

	  if (this.xUnits === WorldWind.OFFSET_FRACTION) {
	    x = width * this.x;
	  } else if (this.xUnits === WorldWind.OFFSET_INSET_PIXELS) {
	    x = width - this.x;
	  } else {
	    // default to OFFSET_PIXELS
	    x = this.x;
	  }

	  if (this.yUnits === WorldWind.OFFSET_FRACTION) {
	    y = height * this.y;
	  } else if (this.yUnits === WorldWind.OFFSET_INSET_PIXELS) {
	    y = height - this.y;
	  } else {
	    // default to OFFSET_PIXELS
	    y = this.y;
	  }

	  return new Vec2(x, y);
	};
	/**
	 * Returns a string representation of this object.
	 * @returns {String} A string representation of this object.
	 */


	Offset.prototype.toString = function () {
	  return this.xUnits + " " + this.x + " " + this.yUnits + " " + this.y;
	};

	/**
	 * @exports TextAttributes
	 */
	/**
	 * Constructs a text attributes bundle.
	 * @alias TextAttributes
	 * @constructor
	 * @classdesc Holds attributes applied to [Text]{@link Text} shapes and [Placemark]{@link Placemark} labels.
	 *
	 * @param {TextAttributes} attributes Attributes to initialize this attributes instance to. May be null,
	 * in which case the new instance contains default attributes.
	 */

	function TextAttributes(attributes) {
	  this._color = attributes ? attributes._color.clone() : Color.WHITE.clone();
	  this._font = attributes ? attributes._font : new Font(14);
	  this._offset = attributes ? attributes._offset : new Offset(WorldWind.OFFSET_FRACTION, 0.5, WorldWind.OFFSET_FRACTION, 0.0);
	  this._scale = attributes ? attributes._scale : 1;
	  this._depthTest = attributes ? attributes._depthTest : false;
	  this._enableOutline = attributes ? attributes._enableOutline : true;
	  this._outlineWidth = attributes ? attributes._outlineWidth : 4;
	  this._outlineColor = attributes ? attributes._outlineColor : new Color(0, 0, 0, 0.5);
	  /**
	   * Indicates whether this object's state key is invalid. Subclasses must set this value to true when their
	   * attributes change. The state key will be automatically computed the next time it's requested. This flag
	   * will be set to false when that occurs.
	   * @type {boolean}
	   * @protected
	   */

	  this.stateKeyInvalid = true;
	}
	/**
	 * Computes the state key for this attributes object. Subclasses that define additional attributes must
	 * override this method, call it from that method, and append the state of their attributes to its
	 * return value.
	 * @returns {String} The state key for this object.
	 * @protected
	 */


	TextAttributes.prototype.computeStateKey = function () {
	  return "c " + this._color.toHexString(true) + " f " + this._font.toString() + " o " + this._offset.toString() + " s " + this._scale + " dt " + this._depthTest + " eo " + this._enableOutline + " ow " + this._outlineWidth + " oc " + this._outlineColor.toHexString(true);
	};

	Object.defineProperties(TextAttributes.prototype, {
	  /**
	   * A string identifying the state of this attributes object. The string encodes the current values of all
	   * this object's properties. It's typically used to validate cached representations of shapes associated
	   * with this attributes object.
	   * @type {String}
	   * @readonly
	   * @memberof TextAttributes.prototype
	   */
	  stateKey: {
	    get: function () {
	      if (this.stateKeyInvalid) {
	        this._stateKey = this.computeStateKey();
	        this.stateKeyInvalid = false;
	      }

	      return this._stateKey;
	    }
	  },

	  /**
	   * The text color.
	   * @type {Color}
	   * @default White (1, 1, 1, 1)
	   * @memberof TextAttributes.prototype
	   */
	  color: {
	    get: function () {
	      return this._color;
	    },
	    set: function (value) {
	      this._color = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * The text size, face and other characteristics, as described in [Font]{@link Font}.
	   * @type {Font}
	   * @default Those of [Font]{@link Font}, but with a font size of 14.
	   * @memberof TextAttributes.prototype
	   */
	  font: {
	    get: function () {
	      return this._font;
	    },
	    set: function (value) {
	      this._font = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the location of the text relative to its specified position.
	   * May be null, in which case the text's bottom-left corner is placed at the specified position.
	   * @type {Offset}
	   * @default 0.5, 0.0, both fractional (Places the text's horizontal center and vertical bottom at the
	   * specified position.)
	   * @memberof TextAttributes.prototype
	   */
	  offset: {
	    get: function () {
	      return this._offset;
	    },
	    set: function (value) {
	      this._offset = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the amount to scale the text. A value of 0 makes the text disappear.
	   * @type {Number}
	   * @default 1.0
	   * @memberof TextAttributes.prototype
	   */
	  scale: {
	    get: function () {
	      return this._scale;
	    },
	    set: function (value) {
	      this._scale = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates whether the text should be depth-tested against other objects in the scene. If true,
	   * the text may be occluded by terrain and other objects in certain viewing situations. If false,
	   * the text will not be occluded by terrain and other objects.
	   * @type {Boolean}
	   * @default false
	   * @memberof TextAttributes.prototype
	   */
	  depthTest: {
	    get: function () {
	      return this._depthTest;
	    },
	    set: function (value) {
	      this._depthTest = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates if the text will feature an outline around its characters.
	   * @type {Boolean}
	   * @default true
	   * @memberof TextAttributes.prototype
	   */
	  enableOutline: {
	    get: function () {
	      return this._enableOutline;
	    },
	    set: function (value) {
	      this._enableOutline = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the text outline width (or thickness) in pixels.
	   * @type {Number}
	   * @default 4
	   * @memberof TextAttributes.prototype
	   */
	  outlineWidth: {
	    get: function () {
	      return this._outlineWidth;
	    },
	    set: function (value) {
	      this._outlineWidth = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * The color of the outline.
	   * @type {Color}
	   * @default Half-transparent black (0, 0, 0, 0.5)
	   * @memberof TextAttributes.prototype
	   */
	  outlineColor: {
	    get: function () {
	      return this._outlineColor;
	    },
	    set: function (value) {
	      this._outlineColor = value;
	      this.stateKeyInvalid = true;
	    }
	  }
	});

	/**
	 * Constructs an annotation attributes bundle.
	 * @alias AnnotationAttributes
	 * @constructor
	 * @classdesc Holds attributes applied to {@link Annotation} shapes.
	 * @param {AnnotationAttributes} attributes Attributes to initialize this attributes instance to. May be null,
	 * in which case the new instance contains default attributes.
	 */

	function AnnotationAttributes(attributes) {
	  // These are all documented with their property accessors below.
	  this._cornerRadius = attributes ? attributes._cornerRadius : 0;
	  this._insets = attributes ? attributes._insets : new Insets(0, 0, 0, 0);
	  this._backgroundColor = attributes ? attributes._backgroundColor.clone() : Color.WHITE.clone();
	  this._leaderGapWidth = attributes ? attributes._leaderGapWidth : 40;
	  this._leaderGapHeight = attributes ? attributes._leaderGapHeight : 30;
	  this._opacity = attributes ? attributes._opacity : 1;
	  this._scale = attributes ? attributes._scale : 1;
	  this._drawLeader = attributes ? attributes._drawLeader : true;
	  this._width = attributes ? attributes._width : 200;
	  this._height = attributes ? attributes._height : 100;
	  this._textAttributes = attributes ? attributes._textAttributes : this.createDefaultTextAttributes();
	  /**
	   * Indicates whether this object's state key is invalid. Subclasses must set this value to true when their
	   * attributes change. The state key will be automatically computed the next time it's requested. This flag
	   * will be set to false when that occurs.
	   * @type {Boolean}
	   * @protected
	   */

	  this.stateKeyInvalid = true;
	}
	/**
	 * Computes the state key for this attributes object. Subclasses that define additional attributes must
	 * override this method, call it from that method, and append the state of their attributes to its
	 * return value.
	 * @returns {String} The state key for this object.
	 * @protected
	 */


	AnnotationAttributes.prototype.computeStateKey = function () {
	  return "wi " + this._width + " he " + this._height + " cr " + this._cornerRadius + " in " + this._insets.toString() + " bg " + this.backgroundColor.toHexString(true) + " dl " + this.drawLeader + " lgw " + this.leaderGapWidth + " lgh " + this.leaderGapHeight + " op " + this.opacity + " ta " + this._textAttributes.stateKey + " sc " + this.scale;
	}; // Internal use only. Intentionally not documented.


	AnnotationAttributes.prototype.createDefaultTextAttributes = function () {
	  var attributes = new TextAttributes(null);
	  attributes.enableOutline = false; // Annotations display text without an outline by default

	  return attributes;
	};

	Object.defineProperties(AnnotationAttributes.prototype, {
	  /**
	   * Indicates the width of the callout.
	   * @type {Number}
	   * @default 200
	   * @memberof AnnotationAttributes.prototype
	   */
	  width: {
	    get: function () {
	      return this._width;
	    },
	    set: function (value) {
	      this._width = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates height of the callout.
	   * @type {Number}
	   * @default 100
	   * @memberof AnnotationAttributes.prototype
	   */
	  height: {
	    get: function () {
	      return this._height;
	    },
	    set: function (value) {
	      this._height = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the radius for the corners.
	   * @type {Number}
	   * @default 0
	   * @memberof AnnotationAttributes.prototype
	   */
	  cornerRadius: {
	    get: function () {
	      return this._cornerRadius;
	    },
	    set: function (value) {
	      this._cornerRadius = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the insets instance of this object.
	   * Insets adjusts top, bottom, left, right padding for the text.
	   * @type {Insets}
	   * @default 0, 0, 0, 0
	   * @memberof AnnotationAttributes.prototype
	   */
	  insets: {
	    get: function () {
	      return this._insets;
	    },
	    set: function (value) {
	      this._insets = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the background color of the callout.
	   * @type {Color}
	   * @default White
	   * @memberof AnnotationAttributes.prototype
	   */
	  backgroundColor: {
	    get: function () {
	      return this._backgroundColor;
	    },
	    set: function (value) {
	      this._backgroundColor = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the attributes to apply to the annotation's text.
	   * @type {TextAttributes}
	   * @default The defaults of {@link TextAttributes}.
	   * @memberof AnnotationAttributes.prototype
	   */
	  textAttributes: {
	    get: function () {
	      return this._textAttributes;
	    },
	    set: function (value) {
	      this._textAttributes = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates whether to draw a leader pointing to the annotation's geographic position.
	   * @type {Boolean}
	   * @default true
	   * @memberof AnnotationAttributes.prototype
	   */
	  drawLeader: {
	    get: function () {
	      return this._drawLeader;
	    },
	    set: function (value) {
	      this._drawLeader = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the gap width of the leader in pixels.
	   * @type {Number}
	   * @default 40
	   * @memberof AnnotationAttributes.prototype
	   */
	  leaderGapWidth: {
	    get: function () {
	      return this._leaderGapWidth;
	    },
	    set: function (value) {
	      this._leaderGapWidth = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the gap height of the leader in pixels.
	   * @type {Number}
	   * @default 30
	   * @memberof AnnotationAttributes.prototype
	   */
	  leaderGapHeight: {
	    get: function () {
	      return this._leaderGapHeight;
	    },
	    set: function (value) {
	      this._leaderGapHeight = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the opacity of the annotation.
	   * The value ranges from 0 to 1.
	   * Opacity affects both callout and text.
	   * @type {Number}
	   * @default 1
	   * @memberof AnnotationAttributes.prototype
	   */
	  opacity: {
	    get: function () {
	      return this._opacity;
	    },
	    set: function (value) {
	      this._opacity = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the scale multiplier.
	   * @type {Number}
	   * @default 1
	   * @memberof AnnotationAttributes.prototype
	   */
	  scale: {
	    get: function () {
	      return this._scale;
	    },
	    set: function (value) {
	      this._scale = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * A string identifying the state of this attributes object. The string encodes the current values of all
	   * this object's properties. It's typically used to validate cached representations of shapes associated
	   * with this attributes object.
	   * @type {String}
	   * @readonly
	   * @memberof AnnotationAttributes.prototype
	   */
	  stateKey: {
	    get: function () {
	      if (this.stateKeyInvalid) {
	        this._stateKey = this.computeStateKey();
	        this.stateKeyInvalid = false;
	      }

	      return this._stateKey;
	    }
	  }
	});

	/**
	 * @exports GpuShader
	 */
	/**
	 * Constructs a GPU shader of a specified type with specified GLSL source code.
	 *
	 * @alias GpuShader
	 * @constructor
	 * @classdesc
	 * Represents an OpenGL shading language (GLSL) shader and provides methods for compiling and disposing
	 * of them.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} shaderType The type of shader, either WebGLRenderingContext.VERTEX_SHADER
	 * or WebGLRenderingContext.FRAGMENT_SHADER.
	 * @param {String} shaderSource The shader's source code.
	 * @throws {ArgumentError} If the shader type is unrecognized, the shader source is null or undefined or shader
	 * compilation fails. If the compilation fails the error thrown contains any compilation messages.
	 */

	function GpuShader(gl, shaderType, shaderSource) {
	  if (!(shaderType === gl.VERTEX_SHADER || shaderType === gl.FRAGMENT_SHADER)) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuShader", "constructor", "The specified shader type is unrecognized."));
	  }

	  if (!shaderSource) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuShader", "constructor", "The specified shader source is null or undefined."));
	  }

	  var shader = gl.createShader(shaderType);

	  if (!shader) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuShader", "constructor", "Unable to create shader of type " + (shaderType == gl.VERTEX_SHADER ? "VERTEX_SHADER." : "FRAGMENT_SHADER.")));
	  }

	  if (!this.compile(gl, shader, shaderType, shaderSource)) {
	    var infoLog = gl.getShaderInfoLog(shader);
	    gl.deleteShader(shader);
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuShader", "constructor", "Unable to compile shader: " + infoLog));
	  }

	  this.shaderId = shader;
	}
	/**
	 * Compiles the source code for this shader. This method is not meant to be invoked by applications. It is
	 * invoked internally as needed.
	 * @param {WebGLRenderingContext} gl The current WebGL rendering context.
	 * @param {WebGLShader} shaderId The shader ID.
	 * @param {Number} shaderType The type of shader, either WebGLRenderingContext.VERTEX_SHADER
	 * or WebGLRenderingContext.FRAGMENT_SHADER.
	 * @param {String} shaderSource The shader's source code.
	 * @returns {boolean} <code>true</code> if the shader compiled successfully, otherwise <code>false</code>.
	 */


	GpuShader.prototype.compile = function (gl, shaderId, shaderType, shaderSource) {
	  gl.shaderSource(shaderId, shaderSource);
	  gl.compileShader(shaderId);
	  return gl.getShaderParameter(shaderId, gl.COMPILE_STATUS);
	};
	/**
	 * Releases this shader's WebGL shader.
	 * @param {WebGLRenderingContext} gl The current WebGL rendering context.
	 */


	GpuShader.prototype.dispose = function (gl) {
	  if (this.shaderId) {
	    gl.deleteShader(this.shaderId);
	    delete this.shaderId;
	  }
	};

	/**
	 * @exports GpuProgram
	 */
	/**
	 * Constructs a GPU program with specified source code for vertex and fragment shaders.
	 * This constructor is intended to be called only by subclasses.
	 * <p>
	 * This constructor creates WebGL shaders for the specified shader sources and attaches them to a new GLSL
	 * program. The method compiles the shaders and then links the program if compilation is successful. Use the
	 * [DrawContext.bindProgram]{@link DrawContext#bindProgram} function to make the program current during rendering.
	 *
	 * @alias GpuProgram
	 * @constructor
	 * @classdesc
	 * Represents an OpenGL shading language (GLSL) shader program and provides methods for identifying and
	 * accessing shader variables. Shader programs are created by instances of this class and made current when the
	 * DrawContext.bindProgram function is invoked.
	 * <p>
	 * This is an abstract class and not intended to be created directly.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {String} vertexShaderSource The source code for the vertex shader.
	 * @param {String} fragmentShaderSource The source code for the fragment shader.
	 * @param {String[]} attributeBindings An array of attribute variable names whose bindings are to be explicitly
	 * specified. Each name is bound to its corresponding index in the array. May be null, in which case the
	 * linker determines all the bindings.
	 * @throws {ArgumentError} If either source is null or undefined, the shaders cannot be compiled, or linking of
	 * the compiled shaders into a program fails.
	 */

	function GpuProgram(gl, vertexShaderSource, fragmentShaderSource, attributeBindings) {
	  if (!vertexShaderSource || !fragmentShaderSource) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuProgram", "constructor", "The specified shader source is null or undefined."));
	  }

	  var program, vShader, fShader;

	  try {
	    vShader = new GpuShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
	    fShader = new GpuShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
	  } catch (e) {
	    if (vShader) vShader.dispose(gl);
	    if (fShader) fShader.dispose(gl);
	    throw e;
	  }

	  program = gl.createProgram();

	  if (!program) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuProgram", "constructor", "Unable to create shader program."));
	  }

	  gl.attachShader(program, vShader.shaderId);
	  gl.attachShader(program, fShader.shaderId);

	  if (attributeBindings) {
	    for (var i = 0, len = attributeBindings.length; i < len; i++) {
	      gl.bindAttribLocation(program, i, attributeBindings[i]);
	    }
	  }

	  if (!this.link(gl, program)) {
	    // Get the info log before deleting the program.
	    var infoLog = gl.getProgramInfoLog(program);
	    gl.detachShader(program, vShader.shaderId);
	    gl.detachShader(program, fShader.shaderId);
	    gl.deleteProgram(program);
	    vShader.dispose(gl);
	    fShader.dispose(gl);
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuProgram", "constructor", "Unable to link shader program: " + infoLog));
	  }
	  /**
	   * Indicates the WebGL program object associated with this GPU program.
	   * @type {WebGLProgram}
	   * @readonly
	   */


	  this.programId = program; // Internal. Intentionally not documented. These will be filled in as attribute locations are requested.

	  this.attributeLocations = {};
	  this.uniformLocations = {}; // Internal. Intentionally not documented.

	  this.vertexShader = vShader; // Internal. Intentionally not documented.

	  this.fragmentShader = fShader; // Internal. Intentionally not documented.

	  this.size = vertexShaderSource.length + fragmentShaderSource.length; // Internal. Intentionally not documented.

	  this.scratchArray = new Float32Array(16);
	}
	/**
	 * Releases this GPU program's WebGL program and associated shaders. Upon return this GPU program's WebGL
	 * program ID is 0 as is that of the associated shaders.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 */


	GpuProgram.prototype.dispose = function (gl) {
	  if (this.programId) {
	    if (this.vertexShader) {
	      gl.detachShader(this.programId, this.vertexShader.shaderId);
	    }

	    if (this.fragmentShader) {
	      gl.detachShader(this.programId, this.fragmentShader.shaderId);
	    }

	    gl.deleteProgram(this.programId);
	    delete this.programId;
	  }

	  if (this.vertexShader) {
	    this.vertexShader.dispose(gl);
	    delete this.vertexShader;
	  }

	  if (this.fragmentShader) {
	    this.fragmentShader.dispose(gl);
	    delete this.fragmentShader;
	  }

	  this.attributeLocations = {};
	  this.uniformLocations = {};
	};
	/**
	 * Returns the GLSL attribute location of a specified attribute name.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {String} attributeName The name of the attribute whose location is determined.
	 * @returns {Number} The WebGL attribute location of the specified attribute, or -1 if the attribute is not
	 * found.
	 * @throws {ArgumentError} If the specified attribute name is null, empty or undefined.
	 */


	GpuProgram.prototype.attributeLocation = function (gl, attributeName) {
	  if (!attributeName || attributeName.length == 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuProgram", "attributeLocation", "The specified attribute name is null, undefined or empty."));
	  }

	  var location = this.attributeLocations[attributeName];

	  if (!location) {
	    location = gl.getAttribLocation(this.programId, attributeName);
	    this.attributeLocations[attributeName] = location;
	  }

	  return location;
	};
	/**
	 * Returns the GLSL uniform location of a specified uniform name.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {String} uniformName The name of the uniform variable whose location is determined.
	 * @returns {WebGLUniformLocation} The WebGL uniform location of the specified uniform variable,
	 * or -1 if the uniform is not found.
	 * @throws {ArgumentError} If the specified uniform name is null, empty or undefined.
	 */


	GpuProgram.prototype.uniformLocation = function (gl, uniformName) {
	  if (!uniformName || uniformName.length == 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuProgram", "uniformLocation", "The specified uniform name is null, undefined or empty."));
	  }

	  var location = this.uniformLocations[uniformName];

	  if (!location) {
	    location = gl.getUniformLocation(this.programId, uniformName);
	    this.uniformLocations[uniformName] = location;
	  }

	  return location;
	};
	/**
	 * Links a specified GLSL program. This method is not meant to be called by applications. It is called
	 * internally as needed.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {WebGLProgram} program The WebGL program.
	 * @returns {Boolean} true if linking was successful, otherwise false.
	 * @protected
	 */


	GpuProgram.prototype.link = function (gl, program) {
	  gl.linkProgram(program);
	  return gl.getProgramParameter(program, gl.LINK_STATUS);
	};
	/**
	 * Loads a specified matrix as the value of a GLSL 4x4 matrix uniform variable with the specified location.
	 * <p>
	 * This functions converts the matrix into column-major order prior to loading its components into the GLSL
	 * uniform variable, but does not modify the specified matrix.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix} matrix The matrix to load.
	 * @param {WebGLUniformLocation} location The location of the uniform variable in the currently bound GLSL program.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */


	GpuProgram.prototype.loadUniformMatrix = function (gl, matrix, location) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuProgram", "loadUniformMatrix", "missingMatrix"));
	  }

	  var columnMajorArray = matrix.columnMajorComponents(this.scratchArray);
	  gl.uniformMatrix4fv(location, false, columnMajorArray);
	};
	/**
	 * Loads a specified color as the value of a GLSL vec4 uniform variable with the specified location.
	 * <p>
	 * This function multiplies the red, green and blue components by the alpha component prior to loading the color
	 * in the GLSL uniform variable, but does not modify the specified color.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Color} color The color to load.
	 * @param {WebGLUniformLocation} location The location of the uniform variable in the currently bound GLSL program.
	 * @throws {ArgumentError} If the specified color is null or undefined.
	 */


	GpuProgram.prototype.loadUniformColor = function (gl, color, location) {
	  if (!color) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuProgram", "loadUniformColor", "missingColor"));
	  }

	  var premul = color.premultipliedComponents(this.scratchArray);
	  gl.uniform4f(location, premul[0], premul[1], premul[2], premul[3]);
	};
	/**
	 * Loads the specified RGBA color components as the value of a GLSL vec4 uniform variable with the specified
	 * location.
	 * <p>
	 * This function multiplies the red, green and blue components by the alpha component prior to loading the color
	 * in the GLSL uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} red The red component, a number between 0 and 1.
	 * @param {Number} green The green component, a number between 0 and 1.
	 * @param {Number} blue The blue component, a number between 0 and 1.
	 * @param {Number} alpha The alpha component, a number between 0 and 1.
	 * @param {WebGLUniformLocation} location The location of the uniform variable in the currently bound GLSL program.
	 */


	GpuProgram.prototype.loadUniformColorComponents = function (gl, red, green, blue, alpha, location) {
	  gl.uniform4f(location, red * alpha, green * alpha, blue * alpha, alpha);
	};

	var BasicTextureVertex = "\r\nattribute vec4 vertexPoint;\r\nattribute vec4 vertexTexCoord;\r\nattribute vec4 normalVector;\r\n\r\nuniform mat4 mvpMatrix;\r\nuniform mat4 mvInverseMatrix;\r\nuniform mat4 texCoordMatrix;\r\nuniform bool applyLighting;\r\n\r\nvarying vec2 texCoord;\r\nvarying vec4 normal;\r\n\r\nvoid main() {\r\n    gl_Position = mvpMatrix * vertexPoint;\r\n    texCoord = (texCoordMatrix * vertexTexCoord).st;\r\n    if (applyLighting) {\r\n        normal = mvInverseMatrix * normalVector;\r\n    }\r\n}";

	var BasicTextureFragment = "\r\nprecision mediump float;\r\n\r\nuniform float opacity;\r\nuniform vec4 color;\r\nuniform bool enableTexture;\r\nuniform bool modulateColor;\r\nuniform sampler2D textureSampler;\r\nuniform bool applyLighting;\r\n\r\nvarying vec2 texCoord;\r\nvarying vec4 normal;\r\n\r\nvoid main() {\r\n    vec4 textureColor = texture2D(textureSampler, texCoord);\r\n    float ambient = 0.15;\r\n    vec4 lightDirection = vec4(0, 0, 1, 0);\r\n    \r\n    if (enableTexture && !modulateColor)\r\n        gl_FragColor = textureColor * color * opacity;\r\n    else if (enableTexture && modulateColor)\r\n        gl_FragColor = color * floor(textureColor.a + 0.5);\r\n    else\r\n        gl_FragColor = color * opacity;\r\n    if (gl_FragColor.a == 0.0) {\r\n        discard;\r\n    }\r\n    if (applyLighting) {\r\n        vec4 n = normal * (gl_FrontFacing ? 1.0 : -1.0);\r\n        gl_FragColor.rgb *= clamp(ambient + dot(lightDirection, n), 0.0, 1.0);\r\n    }\r\n}";

	/**
	 * @exports BasicTextureProgram
	 */
	/**
	 * Constructs a new program.
	 * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	 * <p>
	 * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program. This
	 * method then compiles the shaders and then links the program if compilation is successful. Use the bind method to make the
	 * program current during rendering.
	 *
	 * @alias BasicTextureProgram
	 * @constructor
	 * @augments GpuProgram
	 * @classdesc BasicTextureProgram is a GLSL program that draws textured or untextured geometry.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @throws {ArgumentError} If the shaders cannot be compiled, or if linking of
	 * the compiled shaders into a program fails.
	 */

	function BasicTextureProgram(gl) {
	  var vertexShaderSource = BasicTextureVertex,
	      fragmentShaderSource = BasicTextureFragment; // Specify bindings to avoid the WebGL performance warning that's generated when normalVector gets
	  // bound to location 0.

	  var bindings = ["vertexPoint", "normalVector", "vertexTexCoord"]; // Call to the superclass, which performs shader program compiling and linking.

	  GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, bindings);
	  /**
	   * The WebGL location for this program's 'vertexPoint' attribute.
	   * @type {Number}
	   * @readonly
	   */

	  this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");
	  /**
	   * The WebGL location for this program's 'normalVector' attribute.
	   * @type {Number}
	   * @readonly
	   */

	  this.normalVectorLocation = this.attributeLocation(gl, "normalVector");
	  /**
	   * The WebGL location for this program's 'vertexTexCoord' attribute.
	   * @type {Number}
	   * @readonly
	   */

	  this.vertexTexCoordLocation = this.attributeLocation(gl, "vertexTexCoord");
	  /**
	   * The WebGL location for this program's 'mvpMatrix' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");
	  /**
	   * The WebGL location for this program's 'mvInverseMatrix' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.mvInverseMatrixLocation = this.uniformLocation(gl, "mvInverseMatrix");
	  /**
	   * The WebGL location for this program's 'color' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.colorLocation = this.uniformLocation(gl, "color");
	  /**
	   * The WebGL location for this program's 'enableTexture' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.textureEnabledLocation = this.uniformLocation(gl, "enableTexture");
	  /**
	   * The WebGL location for this program's 'modulateColor' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.modulateColorLocation = this.uniformLocation(gl, "modulateColor");
	  /**
	   * The WebGL location for this program's 'textureSampler' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.textureUnitLocation = this.uniformLocation(gl, "textureSampler");
	  /**
	   * The WebGL location for this program's 'texCoordMatrix' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.textureMatrixLocation = this.uniformLocation(gl, "texCoordMatrix");
	  /**
	   * The WebGL location for this program's 'opacity' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.opacityLocation = this.uniformLocation(gl, "opacity");
	  /**
	   * The WegGL location for this program's 'enableLighting' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.applyLightingLocation = this.uniformLocation(gl, "applyLighting");
	}
	/**
	 * A string that uniquely identifies this program.
	 * @type {string}
	 * @readonly
	 */


	BasicTextureProgram.key = "WorldWindGpuBasicTextureProgram"; // Inherit from GpuProgram.

	BasicTextureProgram.prototype = Object.create(GpuProgram.prototype);
	/**
	 * Loads the specified matrix as the value of this program's 'mvInverseMatrix' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix} matrix The matrix to load.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */

	BasicTextureProgram.prototype.loadModelviewInverse = function (gl, matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BasicTextureProgram", "loadModelviewInverse", "missingMatrix"));
	  }

	  this.loadUniformMatrix(gl, matrix, this.mvInverseMatrixLocation);
	};
	/**
	 * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix} matrix The matrix to load.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */


	BasicTextureProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BasicTextureProgram", "loadModelviewProjection", "missingMatrix"));
	  }

	  this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	};
	/**
	 * Loads the specified color as the value of this program's 'color' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Color} color The color to load.
	 * @throws {ArgumentError} If the specified color is null or undefined.
	 */


	BasicTextureProgram.prototype.loadColor = function (gl, color) {
	  if (!color) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BasicTextureProgram", "loadColor", "missingColor"));
	  }

	  this.loadUniformColor(gl, color, this.colorLocation);
	};
	/**
	 * Loads the specified boolean as the value of this program's 'enableTexture' uniform variable.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Boolean} enable true to enable texturing, false to disable texturing.
	 */


	BasicTextureProgram.prototype.loadTextureEnabled = function (gl, enable) {
	  gl.uniform1i(this.textureEnabledLocation, enable ? 1 : 0);
	};
	/**
	 * Loads the specified boolean as the value of this program's 'modulateColor' uniform variable. When this
	 * value is true and the value of the textureEnabled variable is true, the color uniform of this shader is
	 * multiplied by the rounded alpha component of the texture color at each fragment. This causes the color
	 * to be either fully opaque or fully transparent depending on the value of the texture color's alpha value.
	 * This is used during picking to replace opaque or mostly opaque texture colors with the pick color, and
	 * to make all other texture colors transparent.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Boolean} enable true to enable modulation, false to disable modulation.
	 */


	BasicTextureProgram.prototype.loadModulateColor = function (gl, enable) {
	  gl.uniform1i(this.modulateColorLocation, enable ? 1 : 0);
	};
	/**
	 * Loads the specified number as the value of this program's 'textureSampler' uniform variable.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} unit The texture unit.
	 */


	BasicTextureProgram.prototype.loadTextureUnit = function (gl, unit) {
	  gl.uniform1i(this.textureUnitLocation, unit - gl.TEXTURE0);
	};
	/**
	 * Loads the specified matrix as the value of this program's 'texCoordMatrix' uniform variable.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix} matrix The texture coordinate matrix.
	 */


	BasicTextureProgram.prototype.loadTextureMatrix = function (gl, matrix) {
	  this.loadUniformMatrix(gl, matrix, this.textureMatrixLocation);
	};
	/**
	 * Loads the specified number as the value of this program's 'opacity' uniform variable.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} opacity The opacity in the range [0, 1].
	 */


	BasicTextureProgram.prototype.loadOpacity = function (gl, opacity) {
	  gl.uniform1f(this.opacityLocation, opacity);
	};
	/**
	 * Loads the specified boolean as the value of this program's 'applyLighting' uniform variable.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} applyLighting true to apply lighting, otherwise false.
	 */


	BasicTextureProgram.prototype.loadApplyLighting = function (gl, applyLighting) {
	  gl.uniform1i(this.applyLightingLocation, applyLighting);
	};

	/**
	 * Provides constants and functions for working with angles.
	 * @exports Angle
	 */
	var Angle = {
	  /**
	   * Conversion factor for degrees to radians.
	   * @constant
	   */
	  DEGREES_TO_RADIANS: Math.PI / 180.0,

	  /**
	   * Conversion factor for radians to degrees.
	   * @constant
	   */
	  RADIANS_TO_DEGREES: 180.0 / Math.PI,

	  /**
	   * 2 pi.
	   * @constant
	   */
	  TWO_PI: 2 * Math.PI,

	  /**
	   * pi / 2
	   * @constant
	   */
	  HALF_PI: Math.PI / 2,

	  /**
	   * Normalizes a specified value to be within the range of [-180, 180] degrees.
	   * @param {Number} degrees The value to normalize, in degrees.
	   * @returns {Number} The specified value normalized to [-180, 180] degrees.
	   */
	  normalizedDegrees: function (degrees) {
	    var angle = degrees % 360;
	    return angle > 180 ? angle - 360 : angle < -180 ? 360 + angle : angle;
	  },

	  /**
	   * Normalizes a specified value to be within the range of [-90, 90] degrees.
	   * @param {Number} degrees The value to normalize, in degrees.
	   * @returns {Number} The specified value normalized to the normal range of latitude.
	   */
	  normalizedDegreesLatitude: function (degrees) {
	    var lat = degrees % 180;
	    return lat > 90 ? 180 - lat : lat < -90 ? -180 - lat : lat;
	  },

	  /**
	   * Normalizes a specified value to be within the range of [-180, 180] degrees.
	   * @param {Number} degrees The value to normalize, in degrees.
	   * @returns {Number} The specified value normalized to the normal range of longitude.
	   */
	  normalizedDegreesLongitude: function (degrees) {
	    var lon = degrees % 360;
	    return lon > 180 ? lon - 360 : lon < -180 ? 360 + lon : lon;
	  },

	  /**
	   * Normalizes a specified value to be within the range of [-Pi, Pi] radians.
	   * @param {Number} radians The value to normalize, in radians.
	   * @returns {Number} The specified value normalized to [-Pi, Pi] radians.
	   */
	  normalizedRadians: function (radians) {
	    var angle = radians % this.TWO_PI;
	    return angle > Math.PI ? angle - this.TWO_PI : angle < -Math.PI ? this.TWO_PI + angle : angle;
	  },

	  /**
	   * Normalizes a specified value to be within the range of [-Pi/2, Pi/2] radians.
	   * @param {Number} radians The value to normalize, in radians.
	   * @returns {Number} The specified value normalized to the normal range of latitude.
	   */
	  normalizedRadiansLatitude: function (radians) {
	    var lat = radians % Math.PI;
	    return lat > this.HALF_PI ? Math.PI - lat : lat < -this.HALF_PI ? -Math.PI - lat : lat;
	  },

	  /**
	   * Normalizes a specified value to be within the range of [-Pi, Pi] radians.
	   * @param {Number} radians The value to normalize, in radians.
	   * @returns {Number} The specified value normalized to the normal range of longitude.
	   */
	  normalizedRadiansLongitude: function (radians) {
	    var lon = radians % this.TWO_PI;
	    return lon > Math.PI ? lon - this.TWO_PI : lon < -Math.PI ? this.TWO_PI + lon : lon;
	  },

	  /**
	   * Indicates whether a specified value is within the normal range of latitude, [-90, 90].
	   * @param {Number} degrees The value to test, in degrees.
	   * @returns {Boolean} true if the value is within the normal range of latitude, otherwise false.
	   */
	  isValidLatitude: function (degrees) {
	    return degrees >= -90 && degrees <= 90;
	  },

	  /**
	   * Indicates whether a specified value is within the normal range of longitude, [-180, 180].
	   * @param {Number} degrees The value to test, in degrees.
	   * @returns {boolean} true if the value is within the normal range of longitude, otherwise false.
	   */
	  isValidLongitude: function (degrees) {
	    return degrees >= -180 && degrees <= 180;
	  },

	  /**
	   * Returns a string representation of a specified value in degrees.
	   * @param {Number} degrees The value for which to compute the string.
	   * @returns {String} The computed string, which is a decimal degrees value followed by the degree symbol.
	   */
	  toString: function (degrees) {
	    return degrees.toString() + '\u00B0';
	  },

	  /**
	   * Returns a decimal degrees string representation of a specified value in degrees.
	   * @param {Number} degrees The value for which to compute the string.
	   * @returns {String} The computed string, which is a decimal degrees value followed by the degree symbol.
	   */
	  toDecimalDegreesString: function (degrees) {
	    return degrees.toString() + '\u00B0';
	  },

	  /**
	   * Returns a degrees-minutes-seconds string representation of a specified value in degrees.
	   * @param {Number} degrees The value for which to compute the string.
	   * @returns {String} The computed string in degrees, minutes and decimal seconds.
	   */
	  toDMSString: function (degrees) {
	    var sign, temp, d, m, s;
	    sign = degrees < 0 ? -1 : 1;
	    temp = sign * degrees;
	    d = Math.floor(temp);
	    temp = (temp - d) * 60;
	    m = Math.floor(temp);
	    temp = (temp - m) * 60;
	    s = Math.round(temp);

	    if (s == 60) {
	      m++;
	      s = 0;
	    }

	    if (m == 60) {
	      d++;
	      m = 0;
	    }

	    return (sign == -1 ? "-" : "") + d + "\u00B0" + " " + m + "\u2019" + " " + s + "\u201D";
	  },

	  /**
	   * Returns a degrees-minutes string representation of a specified value in degrees.
	   * @param {Number} degrees The value for which to compute the string.
	   * @returns {String} The computed string in degrees and decimal minutes.
	   */
	  toDMString: function (degrees) {
	    var sign, temp, d, m, s, mf;
	    sign = degrees < 0 ? -1 : 1;
	    temp = sign * degrees;
	    d = Math.floor(temp);
	    temp = (temp - d) * 60;
	    m = Math.floor(temp);
	    temp = (temp - m) * 60;
	    s = Math.round(temp);

	    if (s == 60) {
	      m++;
	      s = 0;
	    }

	    if (m == 60) {
	      d++;
	      m = 0;
	    }

	    mf = s == 0 ? m : m + s / 60;
	    return (sign == -1 ? "-" : "") + d + "\u00B0" + " " + mf + "\u2019";
	  }
	};

	/**
	 * @exports Line
	 */
	/**
	 * Constructs a line from a specified origin and direction.
	 * @alias Line
	 * @constructor
	 * @classdesc Represents a line in Cartesian coordinates.
	 * @param {Vec3} origin The line's origin.
	 * @param {Vec3} direction The line's direction.
	 * @throws {ArgumentError} If either the origin or the direction are null or undefined.
	 */

	function Line(origin, direction) {
	  if (!origin) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Line", "constructor", "Origin is null or undefined."));
	  }

	  if (!direction) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Line", "constructor", "Direction is null or undefined."));
	  }
	  /**
	   * This line's origin.
	   * @type {Vec3}
	   */


	  this.origin = origin;
	  /**
	   * This line's direction.
	   * @type {Vec3}
	   */

	  this.direction = direction;
	}
	/**
	 * Creates a line given two specified endpoints.
	 * @param {Vec3} pointA The first endpoint.
	 * @param {Vec3} pointB The second endpoint.
	 * @return {Line} The new line.
	 * @throws {ArgumentError} If either endpoint is null or undefined.
	 */


	Line.fromSegment = function (pointA, pointB) {
	  if (!pointA || !pointB) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Line", "fromSegment", "missingPoint"));
	  }

	  var origin = new Vec3$1(pointA[0], pointA[1], pointA[2]),
	      direction = new Vec3$1(pointB[0] - pointA[0], pointB[1] - pointA[1], pointB[2] - pointA[2]);
	  return new Line(origin, direction);
	};
	/**
	 * Computes a Cartesian point a specified distance along this line.
	 * @param {Number} distance The distance from this line's origin at which to compute the point.
	 * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed point.
	 * @return {Vec3} The specified result argument containing the computed point.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Line.prototype.pointAt = function (distance, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Line", "pointAt", "missingResult."));
	  }

	  result[0] = this.origin[0] + this.direction[0] * distance;
	  result[1] = this.origin[1] + this.direction[1] * distance;
	  result[2] = this.origin[2] + this.direction[2] * distance;
	  return result;
	};
	/**
	 * Indicates whether the components of this line are equal to those of a specified line.
	 * @param {Line} otherLine The line to test equality with. May be null or undefined, in which case this
	 * function returns false.
	 * @returns {boolean} true if all components of this line are equal to the corresponding
	 * components of the specified line, otherwise false.
	 */


	Line.prototype.equals = function (otherLine) {
	  if (otherLine) {
	    return this.origin.equals(otherLine.origin) && this.direction.equals(otherLine.direction);
	  }

	  return false;
	};
	/**
	 * Creates a new line that is a copy of this line.
	 * @returns {Line} The new line.
	 */


	Line.prototype.clone = function () {
	  var clone = new Line(new Vec3$1(0, 0, 0), new Vec3$1(0, 0, 0));
	  clone.copy(this);
	  return clone;
	};
	/**
	 * Copies the components of a specified line to this line.
	 * @param {Line} copyLine The line to copy.
	 * @returns {Line} A copy of this line equal to otherLine.
	 * @throws {ArgumentError} If the specified line is null or undefined.
	 */


	Line.prototype.copy = function (copyLine) {
	  if (!copyLine) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Line", "copy", "missingLine"));
	  }

	  this.origin.copy(copyLine.origin);
	  this.direction.copy(copyLine.direction);
	  return this;
	};

	/**
	 * @exports Plane
	 */
	/**
	 * Constructs a plane.
	 * This constructor does not normalize the components. It assumes that a unit normal vector is provided.
	 * @alias Plane
	 * @constructor
	 * @classdesc Represents a plane in Cartesian coordinates.
	 * The plane's X, Y and Z components indicate the plane's normal vector. The distance component
	 * indicates the plane's distance from the origin relative to its unit normal.
	 * The components are expected to be normalized.
	 * @param {Number} x The X coordinate of the plane's unit normal vector.
	 * @param {Number} y The Y coordinate of the plane's unit normal vector.
	 * @param {Number} z The Z coordinate of the plane's unit normal vector.
	 * @param {Number} distance The plane's distance from the origin.
	 */

	function Plane(x, y, z, distance) {
	  /**
	   * The normal vector to the plane.
	   * @type {Vec3}
	   */
	  this.normal = new Vec3$1(x, y, z);
	  /**
	   * The plane's distance from the origin.
	   * @type {Number}
	   */

	  this.distance = distance;
	}
	/**
	 * Computes a plane that passes through the specified three points.
	 * The plane's normal is the cross product of the
	 * two vectors from pb to pa and pc to pa, respectively. The
	 * returned plane is undefined if any of the specified points are colinear.
	 *
	 * @param {Vec3} pa The first point.
	 * @param {Vec3} pb The second point.
	 * @param {Vec3} pc The third point.
	 *
	 * @return {Plane} A plane passing through the specified points.
	 *
	 * @throws {ArgumentError} if pa, pb, or pc is null or undefined.
	 */


	Plane.fromPoints = function (pa, pb, pc) {
	  if (!pa || !pb || !pc) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Plane", "fromPoints", "missingVector"));
	  }

	  var vab = new Vec3$1(pb[0], pb[1], pb[2]);
	  vab.subtract(pa);
	  var vac = new Vec3$1(pc[0], pc[1], pc[2]);
	  vac.subtract(pa);
	  vab.cross(vac);
	  vab.normalize();
	  var d = -vab.dot(pa);
	  return new Plane(vab[0], vab[1], vab[2], d);
	};
	/**
	 * Computes the dot product of this plane's normal vector with a specified vector.
	 * Since the plane was defined with a unit normal vector, this function returns the distance of the vector from
	 * the plane.
	 * @param {Vec3} vector The vector to dot with this plane's normal vector.
	 * @returns {Number} The computed dot product.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Plane.prototype.dot = function (vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Plane", "dot", "missingVector"));
	  }

	  return this.normal.dot(vector) + this.distance;
	};
	/**
	 * Computes the distance between this plane and a point.
	 * @param {Vec3} point The point whose distance to compute.
	 * @returns {Number} The computed distance.
	 * @throws {ArgumentError} If the specified point is null or undefined.
	 */


	Plane.prototype.distanceToPoint = function (point) {
	  return this.dot(point);
	};
	/**
	 * Transforms this plane by a specified matrix.
	 * @param {Matrix} matrix The matrix to apply to this plane.
	 * @returns {Plane} This plane transformed by the specified matrix.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */


	Plane.prototype.transformByMatrix = function (matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Plane", "transformByMatrix", "missingMatrix"));
	  }

	  var x = matrix[0] * this.normal[0] + matrix[1] * this.normal[1] + matrix[2] * this.normal[2] + matrix[3] * this.distance,
	      y = matrix[4] * this.normal[0] + matrix[5] * this.normal[1] + matrix[6] * this.normal[2] + matrix[7] * this.distance,
	      z = matrix[8] * this.normal[0] + matrix[9] * this.normal[1] + matrix[10] * this.normal[2] + matrix[11] * this.distance,
	      distance = matrix[12] * this.normal[0] + matrix[13] * this.normal[1] + matrix[14] * this.normal[2] + matrix[15] * this.distance;
	  this.normal[0] = x;
	  this.normal[1] = y;
	  this.normal[2] = z;
	  this.distance = distance;
	  return this;
	};
	/**
	 * Normalizes the components of this plane.
	 * @returns {Plane} This plane with its components normalized.
	 */


	Plane.prototype.normalize = function () {
	  var magnitude = this.normal.magnitude();
	  if (magnitude === 0) return this;
	  this.normal.divide(magnitude);
	  this.distance /= magnitude;
	  return this;
	};
	/**
	 * Determines whether a specified line segment intersects this plane.
	 *
	 * @param {Vec3} endPoint1 The first end point of the line segment.
	 * @param {Vec3} endPoint2 The second end point of the line segment.
	 * @returns {Boolean} true if the line segment intersects this plane, otherwise false.
	 */


	Plane.prototype.intersectsSegment = function (endPoint1, endPoint2) {
	  var distance1 = this.dot(endPoint1),
	      distance2 = this.dot(endPoint2);
	  return distance1 * distance2 <= 0;
	};
	/**
	 * Computes the intersection point of this plane with a specified line segment.
	 *
	 * @param {Vec3} endPoint1 The first end point of the line segment.
	 * @param {Vec3} endPoint2 The second end point of the line segment.
	 * @param {Vec3} result A variable in which to return the intersection point of the line segment with this plane.
	 * @returns {Boolean} true If the line segment intersects this plane, otherwise false.
	 */


	Plane.prototype.intersectsSegmentAt = function (endPoint1, endPoint2, result) {
	  // Compute the distance from the end-points.
	  var distance1 = this.dot(endPoint1),
	      distance2 = this.dot(endPoint2); // If both points points lie on the plane, ...

	  if (distance1 === 0 && distance2 === 0) {
	    // Choose an arbitrary endpoint as the intersection.
	    result[0] = endPoint1[0];
	    result[1] = endPoint1[1];
	    result[2] = endPoint1[2];
	    return true;
	  } else if (distance1 === distance2) {
	    // The intersection is undefined.
	    return false;
	  }

	  var weight1 = -distance1 / (distance2 - distance1),
	      weight2 = 1 - weight1;
	  result[0] = weight1 * endPoint1[0] + weight2 * endPoint2[0];
	  result[1] = weight1 * endPoint1[1] + weight2 * endPoint2[1];
	  result[2] = weight1 * endPoint1[2] + weight2 * endPoint2[2];
	  return distance1 * distance2 <= 0;
	};
	/**
	 * Determines whether two points are on the same side of this plane.
	 *
	 * @param {Vec3} pointA the first point.
	 * @param {Vec3} pointB the second point.
	 *
	 * @return {Number} -1 If both points are on the negative side of this plane, +1 if both points are on the
	 * positive side of this plane, 0 if the points are on opposite sides of this plane.
	 *
	 * @throws {ArgumentError} If either point is null or undefined.
	 */


	Plane.prototype.onSameSide = function (pointA, pointB) {
	  if (!pointA || !pointB) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Plane", "onSameSide", "missingPoint"));
	  }

	  var da = this.distanceToPoint(pointA),
	      db = this.distanceToPoint(pointB);
	  if (da < 0 && db < 0) return -1;
	  if (da > 0 && db > 0) return 1;
	  return 0;
	};
	/**
	 * Clips a line segment to this plane.
	 * @param {Vec3} pointA The first line segment endpoint.
	 * @param {Vec3} pointB The second line segment endpoint.
	 *
	 * @returns {Vec3[]}  An array of two points both on the positive side of the plane. If the direction of the line formed by the
	 *         two points is positive with respect to this plane's normal vector, the first point in the array will be
	 *         the intersection point on the plane, and the second point will be the original segment end point. If the
	 *         direction of the line is negative with respect to this plane's normal vector, the first point in the
	 *         array will be the original segment's begin point, and the second point will be the intersection point on
	 *         the plane. If the segment does not intersect the plane, null is returned. If the segment is coincident
	 *         with the plane, the input points are returned, in their input order.
	 *
	 * @throws {ArgumentError} If either point is null or undefined.
	 */


	Plane.prototype.clip = function (pointA, pointB) {
	  if (!pointA || !pointB) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Plane", "clip", "missingPoint"));
	  }

	  if (pointA.equals(pointB)) {
	    return null;
	  } // Get the projection of the segment onto the plane.


	  var line = Line.fromSegment(pointA, pointB),
	      lDotV = this.normal.dot(line.direction),
	      lDotS,
	      t,
	      p; // Are the line and plane parallel?

	  if (lDotV === 0) {
	    // line and plane are parallel and may be coincident.
	    lDotS = this.dot(line.origin);

	    if (lDotS === 0) {
	      return [pointA, pointB]; // line is coincident with the plane
	    } else {
	      return null; // line is not coincident with the plane.
	    }
	  } // Not parallel so the line intersects. But does the segment intersect?


	  t = -this.dot(line.origin) / lDotV; // lDotS / lDotV

	  if (t < 0 || t > 1) {
	    // segment does not intersect
	    return null;
	  }

	  p = line.pointAt(t, new Vec3$1(0, 0, 0));

	  if (lDotV > 0) {
	    return [p, pointB];
	  } else {
	    return [pointA, p];
	  }
	};

	/**
	 * @exports Rectangle
	 */

	/**
	 * Constructs a rectangle with a specified origin and size.
	 * @alias Rectangle
	 * @constructor
	 * @classdesc Represents a rectangle in 2D Cartesian coordinates.
	 * @param {Number} x The X coordinate of the rectangle's origin.
	 * @param {Number} y The Y coordinate of the rectangle's origin.
	 * @param {Number} width The rectangle's width.
	 * @param {Number} height The rectangle's height.
	 */
	function Rectangle(x, y, width, height) {
	  /**
	   * The X coordinate of this rectangle's origin.
	   * @type {Number}
	   */
	  this.x = x;
	  /**
	   * The Y coordinate of this rectangle's origin.
	   * @type {Number}
	   */

	  this.y = y;
	  /**
	   * This rectangle's width.
	   * @type {Number}
	   */

	  this.width = width;
	  /**
	   * This rectangle's height.
	   * @type {Number}
	   */

	  this.height = height;
	}
	/**
	 * Sets all this rectangle's properties.
	 * @param {Number} x The X coordinate of the rectangle's origin.
	 * @param {Number} y The Y coordinate of the rectangle's origin.
	 * @param {Number} width The rectangle's width.
	 * @param {Number} height The rectangle's height.
	 */


	Rectangle.prototype.set = function (x, y, width, height) {
	  this.x = x;
	  this.y = y;
	  this.width = width;
	  this.height = height;
	};
	/**
	 * Returns the minimum X value of this rectangle.
	 * @returns {Number} The rectangle's minimum X value.
	 */


	Rectangle.prototype.getMinX = function () {
	  return this.x;
	};
	/**
	 * Returns the minimum Y value of this rectangle.
	 * @returns {Number} The rectangle's minimum Y value.
	 */


	Rectangle.prototype.getMinY = function () {
	  return this.y;
	};
	/**
	 * Returns the maximum X value of this rectangle.
	 * @returns {Number} The rectangle's maximum X value.
	 */


	Rectangle.prototype.getMaxX = function () {
	  return this.x + this.width;
	};
	/**
	 * Returns the maximum Y value of this rectangle.
	 * @returns {Number} The rectangle's maximum Y value.
	 */


	Rectangle.prototype.getMaxY = function () {
	  return this.y + this.height;
	};
	/**
	 * Indicates whether this rectangle contains a specified point.
	 * @param {Vec2} point The point to test.
	 * @returns {Boolean} true if this rectangle contains the specified point, otherwise false.
	 */


	Rectangle.prototype.containsPoint = function (point) {
	  return point[0] >= this.x && point[0] <= this.x + this.width && point[1] >= this.y && point[1] <= this.y + this.height;
	};
	/**
	 *
	 * Indicates whether this rectangle intersects a specified one.
	 * @param {Rectangle} that The rectangle to test.
	 * @returns {Boolean} true if this triangle and the specified one intersect, otherwise false.
	 */


	Rectangle.prototype.intersects = function (that) {
	  if (that.x + that.width < this.x) return false;
	  if (that.x > this.x + this.width) return false;
	  if (that.y + that.height < this.y) return false; //noinspection RedundantIfStatementJS

	  if (that.y > this.y + this.height) return false;
	  return true;
	};
	/**
	 * Indicates whether this rectangle intersects any rectangle in a specified array of rectangles.
	 * @param {Rectangle[]} rectangles The rectangles to test intersection with.
	 * @returns {Boolean} true if this rectangle intersects any rectangle in the array, otherwise false.
	 */


	Rectangle.prototype.intersectsRectangles = function (rectangles) {
	  if (rectangles) {
	    for (var i = 0; i < rectangles.length; i++) {
	      if (this.intersects(rectangles[i])) {
	        return true;
	      }
	    }
	  }

	  return false;
	};
	/**
	 * Returns a string representation of this object.
	 * @returns {String} A string representation of this object.
	 */


	Rectangle.prototype.toString = function () {
	  return this.x + ", " + this.y + ", " + this.width + ", " + this.height;
	};

	/**
	 * Provides math constants and functions.
	 * @exports WWMath
	 */

	var WWMath = {
	  /**
	   * Returns a number within the range of a specified minimum and maximum.
	   * @param {Number} value The value to clamp.
	   * @param {Number} minimum The minimum value to return.
	   * @param {Number} maximum The maximum value to return.
	   * @returns {Number} The minimum value if the specified value is less than the minimum, the maximum value if
	   * the specified value is greater than the maximum, otherwise the value specified is returned.
	   */
	  clamp: function (value, minimum, maximum) {
	    return value < minimum ? minimum : value > maximum ? maximum : value;
	  },

	  /**
	   * Computes a number between two numbers.
	   * @param amount {Number} The relative distance between the numbers at which to compute the new number. This
	   * should normally be a number between 0 and 1 but whatever number is specified is applied.
	   * @param {Number} value1 The first number.
	   * @param {Number} value2 The second number.
	   * @returns {Number} the computed value.
	   */
	  interpolate: function (amount, value1, value2) {
	    return (1 - amount) * value1 + amount * value2;
	  },

	  /**
	   * Returns the cube root of a specified value.
	   * @param {Number} x The value whose cube root is computed.
	   * @returns {Number} The cube root of the specified number.
	   */
	  cbrt: function (x) {
	    // Use the built-in version if it exists. cbrt() is defined in ECMA6.
	    if (typeof Math.cbrt === 'function') {
	      return Math.cbrt(x);
	    } else {
	      return Math.pow(x, 1 / 3);
	    }
	  },

	  /**
	   * Computes the Cartesian intersection point of a specified line with an ellipsoid.
	   * @param {Line} line The line for which to compute the intersection.
	   * @param {Number} equatorialRadius The ellipsoid's major radius.
	   * @param {Number} polarRadius The ellipsoid's minor radius.
	   * @param {Vec3} result A pre-allocated Vec3 instance in which to return the computed point.
	   * @returns {boolean} true if the line intersects the ellipsoid, otherwise false
	   * @throws {ArgumentError} If the specified line or result is null or undefined.
	   * @deprecated utilize the Globe.intersectsLine method attached implementation
	   */
	  computeEllipsoidalGlobeIntersection: function (line, equatorialRadius, polarRadius, result) {
	    if (!line) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeEllipsoidalGlobeIntersection", "missingLine"));
	    }

	    if (!result) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeEllipsoidalGlobeIntersection", "missingResult"));
	    } // Taken from "Mathematics for 3D Game Programming and Computer Graphics, Second Edition", Section 5.2.3.
	    //
	    // Note that the parameter n from in equations 5.70 and 5.71 is omitted here. For an ellipsoidal globe this
	    // parameter is always 1, so its square and its product with any other value simplifies to the identity.


	    var vx = line.direction[0],
	        vy = line.direction[1],
	        vz = line.direction[2],
	        sx = line.origin[0],
	        sy = line.origin[1],
	        sz = line.origin[2],
	        m = equatorialRadius / polarRadius,
	        // ratio of the x semi-axis length to the y semi-axis length
	    m2 = m * m,
	        r2 = equatorialRadius * equatorialRadius,
	        // nominal radius squared
	    a = vx * vx + m2 * vy * vy + vz * vz,
	        b = 2 * (sx * vx + m2 * sy * vy + sz * vz),
	        c = sx * sx + m2 * sy * sy + sz * sz - r2,
	        d = b * b - 4 * a * c,
	        // discriminant
	    t;

	    if (d < 0) {
	      return false;
	    } else {
	      t = (-b - Math.sqrt(d)) / (2 * a);
	      result[0] = sx + vx * t;
	      result[1] = sy + vy * t;
	      result[2] = sz + vz * t;
	      return true;
	    }
	  },

	  /**
	   * Computes the Cartesian intersection point of a specified line with a triangle.
	   * @param {Line} line The line for which to compute the intersection.
	   * @param {Vec3} vertex0 The triangle's first vertex.
	   * @param {Vec3} vertex1 The triangle's second vertex.
	   * @param {Vec3} vertex2 The triangle's third vertex.
	   * @param {Vec3} result A pre-allocated Vec3 instance in which to return the computed point.
	   * @returns {boolean} true if the line intersects the triangle, otherwise false
	   * @throws {ArgumentError} If the specified line, vertex or result is null or undefined.
	   */
	  computeTriangleIntersection: function (line, vertex0, vertex1, vertex2, result) {
	    if (!line) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeTriangleIntersection", "missingLine"));
	    }

	    if (!vertex0 || !vertex1 || !vertex2) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeTriangleIntersection", "missingVertex"));
	    }

	    if (!result) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeTriangleIntersection", "missingResult"));
	    } // Taken from Moller and Trumbore
	    // https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf


	    var vx = line.direction[0],
	        vy = line.direction[1],
	        vz = line.direction[2],
	        sx = line.origin[0],
	        sy = line.origin[1],
	        sz = line.origin[2],
	        EPSILON = 0.00001; // find vectors for two edges sharing point a: vertex1 - vertex0 and vertex2 - vertex0

	    var edge1x = vertex1[0] - vertex0[0],
	        edge1y = vertex1[1] - vertex0[1],
	        edge1z = vertex1[2] - vertex0[2],
	        edge2x = vertex2[0] - vertex0[0],
	        edge2y = vertex2[1] - vertex0[1],
	        edge2z = vertex2[2] - vertex0[2]; // Compute cross product of line direction and edge2

	    var px = vy * edge2z - vz * edge2y,
	        py = vz * edge2x - vx * edge2z,
	        pz = vx * edge2y - vy * edge2x; // Get determinant

	    var det = edge1x * px + edge1y * py + edge1z * pz; // edge1 dot p

	    if (det > -EPSILON && det < EPSILON) {
	      // if det is near zero then ray lies in plane of triangle
	      return false;
	    }

	    var inv_det = 1.0 / det; // Compute distance for vertex A to ray origin: origin - vertex0

	    var tx = sx - vertex0[0],
	        ty = sy - vertex0[1],
	        tz = sz - vertex0[2]; // Calculate u parameter and test bounds: 1/det * t dot p

	    var u = inv_det * (tx * px + ty * py + tz * pz);

	    if (u < -EPSILON || u > 1 + EPSILON) {
	      return false;
	    } // Prepare to test v parameter: t cross edge1


	    var qx = ty * edge1z - tz * edge1y,
	        qy = tz * edge1x - tx * edge1z,
	        qz = tx * edge1y - ty * edge1x; // Calculate v parameter and test bounds: 1/det * dir dot q

	    var v = inv_det * (vx * qx + vy * qy + vz * qz);

	    if (v < -EPSILON || u + v > 1 + EPSILON) {
	      return false;
	    } // Calculate the point of intersection on the line: t = 1/det * edge2 dot q


	    var t = inv_det * (edge2x * qx + edge2y * qy + edge2z * qz);

	    if (t < 0) {
	      return false;
	    } else {
	      result[0] = sx + vx * t;
	      result[1] = sy + vy * t;
	      result[2] = sz + vz * t;
	      return true;
	    }
	  },
	  computeIndexedTrianglesIntersection: function (line, points, indices, results) {
	    if (!line) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeIndexedTrianglesIntersection", "missingLine"));
	    }

	    if (!points) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeIndexedTrianglesIntersection", "missingPoints"));
	    }

	    if (!indices) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeIndexedTrianglesIntersection", "missingIndices"));
	    }

	    if (!results) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeIndexedTrianglesIntersection", "missingResults"));
	    }

	    var v0 = new Vec3$1(0, 0, 0),
	        v1 = new Vec3$1(0, 0, 0),
	        v2 = new Vec3$1(0, 0, 0),
	        iPoint = new Vec3$1(0, 0, 0);

	    for (var i = 0, len = indices.length; i < len; i += 3) {
	      var i0 = 3 * indices[i],
	          i1 = 3 * indices[i + 1],
	          i2 = 3 * indices[i + 2];
	      v0[0] = points[i0];
	      v0[1] = points[i0 + 1];
	      v0[2] = points[i0 + 2];
	      v1[0] = points[i1];
	      v1[1] = points[i1 + 1];
	      v1[2] = points[i1 + 2];
	      v2[0] = points[i2];
	      v2[1] = points[i2 + 1];
	      v2[2] = points[i2 + 2];

	      if (WWMath.computeTriangleIntersection(line, v0, v1, v2, iPoint)) {
	        results.push(iPoint);
	        iPoint = new Vec3$1(0, 0, 0);
	      }
	    }

	    return results.length > 0;
	  },

	  /**
	   * Computes the Cartesian intersection points of a specified line with a triangle strip. The triangle strip
	   * is specified by a list of vertex points and a list of indices indicating the triangle strip tessellation
	   * of those vertices. The triangle strip indices are interpreted in the same manner as WebGL, where each
	   * index indicates a vertex position rather than an actual index into the points array (e.g. a triangle
	   * strip index of 1 indicates the XYZ tuple starting at array index 3). This is equivalent to calling
	   * computeTriangleIntersection for each individual triangle in the triangle strip, but is potentially much
	   * more efficient.
	   * @param {Line} line The line for which to compute the intersection.
	   * @param {Array} points The list of vertex points, organized as a list of tightly-packed XYZ tuples.
	   * @param {Array} indices The list of triangle strip indices, organized as a list of vertex positions.
	   * @param {Array} results A pre-allocated array instance in which to return the intersection points as
	   * {@link Vec3} instances.
	   * @throws {ArgumentError} If the specified line, points, indices or results is null or undefined.
	   */
	  computeTriStripIntersections: function (line, points, indices, results) {
	    if (!line) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeTriStripIntersections", "missingLine"));
	    }

	    if (!points) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeTriStripIntersections", "missingPoints"));
	    }

	    if (!indices) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeTriStripIntersections", "missingIndices"));
	    }

	    if (!results) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "computeTriStripIntersections", "missingResults"));
	    } // Taken from Moller and Trumbore
	    // https://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf
	    // Adapted from the original ray-triangle intersection algorithm to optimize for ray-triangle strip
	    // intersection. We optimize by reusing constant terms, replacing use of Vec3 with inline primitives,
	    // and exploiting the triangle strip organization to reuse computations common to adjacent triangles.
	    // These optimizations reduce worst-case terrain picking performance by approximately 50% in Chrome on a
	    // 2010 iMac and a Nexus 9.


	    var vx = line.direction[0],
	        vy = line.direction[1],
	        vz = line.direction[2],
	        sx = line.origin[0],
	        sy = line.origin[1],
	        sz = line.origin[2],
	        vert0x,
	        vert0y,
	        vert0z,
	        vert1x,
	        vert1y,
	        vert1z,
	        vert2x,
	        vert2y,
	        vert2z,
	        edge1x,
	        edge1y,
	        edge1z,
	        edge2x,
	        edge2y,
	        edge2z,
	        px,
	        py,
	        pz,
	        tx,
	        ty,
	        tz,
	        qx,
	        qy,
	        qz,
	        u,
	        v,
	        t,
	        det,
	        inv_det,
	        index,
	        EPSILON = 0.00001; // Get the triangle strip's first vertex.

	    index = 3 * indices[0];
	    vert1x = points[index++];
	    vert1y = points[index++];
	    vert1z = points[index]; // Get the triangle strip's second vertex.

	    index = 3 * indices[1];
	    vert2x = points[index++];
	    vert2y = points[index++];
	    vert2z = points[index]; // Compute the intersection of each triangle with the specified ray.

	    for (var i = 2, len = indices.length; i < len; i++) {
	      // Move the last two vertices into the first two vertices. This takes advantage of the triangle
	      // strip's structure and avoids redundant reads from points and indices. During the first
	      // iteration this places the triangle strip's first three vertices in vert0, vert1 and vert2,
	      // respectively.
	      vert0x = vert1x;
	      vert0y = vert1y;
	      vert0z = vert1z;
	      vert1x = vert2x;
	      vert1y = vert2y;
	      vert1z = vert2z; // Get the triangle strip's next vertex.

	      index = 3 * indices[i];
	      vert2x = points[index++];
	      vert2y = points[index++];
	      vert2z = points[index]; // find vectors for two edges sharing point a: vert1 - vert0 and vert2 - vert0

	      edge1x = vert1x - vert0x;
	      edge1y = vert1y - vert0y;
	      edge1z = vert1z - vert0z;
	      edge2x = vert2x - vert0x;
	      edge2y = vert2y - vert0y;
	      edge2z = vert2z - vert0z; // Compute cross product of line direction and edge2

	      px = vy * edge2z - vz * edge2y;
	      py = vz * edge2x - vx * edge2z;
	      pz = vx * edge2y - vy * edge2x; // Get determinant

	      det = edge1x * px + edge1y * py + edge1z * pz; // edge1 dot p

	      if (det > -EPSILON && det < EPSILON) {
	        // if det is near zero then ray lies in plane of triangle
	        continue;
	      }

	      inv_det = 1.0 / det; // Compute distance for vertex A to ray origin: origin - vert0

	      tx = sx - vert0x;
	      ty = sy - vert0y;
	      tz = sz - vert0z; // Calculate u parameter and test bounds: 1/det * t dot p

	      u = inv_det * (tx * px + ty * py + tz * pz);

	      if (u < -EPSILON || u > 1 + EPSILON) {
	        continue;
	      } // Prepare to test v parameter: tvec cross edge1


	      qx = ty * edge1z - tz * edge1y;
	      qy = tz * edge1x - tx * edge1z;
	      qz = tx * edge1y - ty * edge1x; // Calculate v parameter and test bounds: 1/det * dir dot q

	      v = inv_det * (vx * qx + vy * qy + vz * qz);

	      if (v < -EPSILON || u + v > 1 + EPSILON) {
	        continue;
	      } // Calculate the point of intersection on the line: t = 1/det * edge2 dot q


	      t = inv_det * (edge2x * qx + edge2y * qy + edge2z * qz);

	      if (t >= 0) {
	        results.push(new Vec3$1(sx + vx * t, sy + vy * t, sz + vz * t));
	      }
	    }
	  },

	  /**
	   * Computes the absolute value of a specified value.
	   * @param {Number} a The value whose absolute value to compute.
	   * @returns {Number} The absolute value of the specified number.
	   */
	  fabs: function (a) {
	    return a >= 0 ? a : -a;
	  },

	  /**
	   * Computes the floating-point modulus of a specified number.
	   * @param {Number} number The number whose modulus to compute.
	   * @param {Number} modulus The modulus.
	   * @returns {Number} The remainder after dividing the number by the modulus: number % modulus.
	   */
	  fmod: function (number, modulus) {
	    return modulus === 0 ? 0 : number - Math.floor(number / modulus) * modulus;
	  },

	  /**
	   * Returns the fractional part of a specified number
	   * @param {Number} number The number whose fractional part to compute.
	   * @returns {Number} The fractional part of the specified number: number - floor(number).
	   */
	  fract: function (number) {
	    return number - Math.floor(number);
	  },

	  /**
	   * Returns the integer modulus of a specified number. This differs from the % operator in that
	   * the result is always positive when the modulus is positive. For example -1 % 10 = -1,
	   * whereas mod(-1, 10) = 1.
	   * @param {Number} number The number whose modulus to compute.
	   * @param {Number} modulus The modulus.
	   * @returns {Number} The remainder after dividing the number by the modulus.
	   */
	  mod: function (number, modulus) {
	    return (number % modulus + modulus) % modulus;
	  },

	  /**
	   * Returns the maximum of two specified numbers.
	   * @param {Number} value1 The first value to compare.
	   * @param {Number} value2 The second value to compare.
	   * @returns {Number} The maximum of the two specified values.
	   */
	  max: function (value1, value2) {
	    return value1 > value2 ? value1 : value2;
	  },

	  /**
	   * Computes the axes of a local coordinate system on the specified globe, placing the resultant axes in the specified
	   * axis arguments.
	   *
	   * Upon return the specified axis arguments contain three orthogonal axes identifying the X, Y, and Z axes. Each
	   * axis has unit length.
	   *
	   * The local coordinate system is defined such that the Z axis maps to the globe's surface normal at the point, the
	   * Y axis maps to the north pointing tangent, and the X axis maps to the east pointing tangent.
	   *
	   * @param {Vec3} origin The local coordinate system origin, in model coordinates.
	   * @param {Globe} globe The globe the coordinate system is relative to.
	   * @param {Vec3} xAxisResult A pre-allocated Vec3 in which to return the computed X axis.
	   * @param {Vec3} yAxisResult A pre-allocated Vec3 in which to return the computed Y axis.
	   * @param {Vec3} zAxisResult A pre-allocated Vec3 in which to return the computed Z axis.
	   * @throws {ArgumentError} If any argument is null or undefined.
	   */
	  localCoordinateAxesAtPoint: function (origin, globe, xAxisResult, yAxisResult, zAxisResult) {
	    if (!origin) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "localCoordinateAxesAtPoint", "missingVector"));
	    }

	    if (!globe) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "localCoordinateAxesAtPoint", "missingGlobe"));
	    }

	    if (!xAxisResult || !yAxisResult || !zAxisResult) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "localCoordinateAxesAtPoint", "missingResult"));
	    }

	    var x = origin[0],
	        y = origin[1],
	        z = origin[2]; // Compute the z axis from the surface normal in model coordinates. This axis is used to determine the other two
	    // axes, and is the only constant in the computations below.

	    globe.surfaceNormalAtPoint(x, y, z, zAxisResult); // Compute the y axis from the north pointing tangent in model coordinates. This axis is known to be orthogonal to
	    // the z axis, and is therefore used to compute the x axis.

	    globe.northTangentAtPoint(x, y, z, yAxisResult); // Compute the x axis as the cross product of the y and z axes. This ensures that the x and z axes are orthogonal.

	    xAxisResult.set(yAxisResult[0], yAxisResult[1], yAxisResult[2]);
	    xAxisResult.cross(zAxisResult);
	    xAxisResult.normalize(); // Re-compute the y axis as the cross product of the z and x axes. This ensures that all three axes are orthogonal.
	    // Though the initial y axis computed above is likely to be very nearly orthogonal, we re-compute it using cross
	    // products to reduce the effect of floating point rounding errors caused by working with Earth sized coordinates.

	    yAxisResult.set(zAxisResult[0], zAxisResult[1], zAxisResult[2]);
	    yAxisResult.cross(xAxisResult);
	    yAxisResult.normalize();
	  },

	  /**
	   * Computes the distance to a globe's horizon from a viewer at a given altitude.
	   *
	   * Only the globe's ellipsoid is considered; terrain height is not incorporated. This returns zero if the radius is zero
	   * or if the altitude is less than or equal to zero.
	   *
	   * @param {Number} radius The globe's radius, in meters.
	   * @param {Number} altitude The viewer's altitude above the globe, in meters.
	   * @returns {Number} The distance to the horizon, in model coordinates.
	   * @throws {ArgumentError} If the specified globe radius is negative.
	   */
	  horizonDistanceForGlobeRadius: function (radius, altitude) {
	    if (radius < 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "horizontalDistanceForGlobeRadius", "The specified globe radius is negative."));
	    }

	    return radius > 0 && altitude > 0 ? Math.sqrt(altitude * (2 * radius + altitude)) : 0;
	  },

	  /**
	   * Computes the near clip distance that corresponds to a specified far clip distance and resolution at the far clip
	   * plane.
	   *
	   * This computes a near clip distance appropriate for use in [perspectiveFrustumRect]{@link WWMath#perspectiveFrustumRectangle}
	   * and [setToPerspectiveProjection]{@link Matrix#setToPerspectiveProjection}. This returns zero if either the distance or the
	   * resolution are zero.
	   *
	   * @param {Number} farDistance The far clip distance, in meters.
	   * @param {Number} farResolution The depth resolution at the far clip plane, in meters.
	   * @param {Number} depthBits The number of bit-planes in the depth buffer.
	   * @returns {Number} The near clip distance, in meters.
	   * @throws {ArgumentError} If either the distance or resolution is negative, or if the depth bits is less
	   * than one.
	   */
	  perspectiveNearDistanceForFarDistance: function (farDistance, farResolution, depthBits) {
	    if (farDistance < 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance", "The specified distance is negative."));
	    }

	    if (farResolution < 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance", "The specified resolution is negative."));
	    }

	    if (depthBits < 1) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectiveNearDistanceForFarDistance", "The specified depth bits is negative."));
	    }

	    var maxDepthValue = (1 << depthBits) - 1;
	    return farDistance / (maxDepthValue / (1 - farResolution / farDistance) - maxDepthValue + 1);
	  },

	  /**
	   * Computes the maximum near clip distance for a perspective projection that avoids clipping an object at a
	   * given distance from the eye point.
	   * <p/>
	   * This computes a near clip distance appropriate for use in perspectiveFrustumRect and
	   * Matrix.setToPerspectiveProjection. The given distance should specify the smallest distance between the
	   * eye and the object being viewed, but may be an approximation if an exact distance is not required.
	   *
	   * @param {Number} viewportWidth The viewport width, in screen coordinates.
	   * @param {Number} viewportHeight The viewport height, in screen coordinates.
	   * @param {Number} distanceToSurface The distance from the perspective eye point to the nearest object, in
	   * meters.
	   * @returns {Number} The maximum near clip distance, in meters.
	   * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
	   * specified distance is negative.
	   */
	  perspectiveNearDistance: function (viewportWidth, viewportHeight, distanceToSurface) {
	    if (viewportWidth <= 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance", "invalidWidth"));
	    }

	    if (viewportHeight <= 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance", "invalidHeight"));
	    }

	    if (distanceToSurface < 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectiveNearDistance", "The specified distance is negative."));
	    } // Compute the maximum near clip distance that avoids clipping an object at the specified distance from
	    // the eye. Since the furthest points on the near clip rectangle are the four corners, we compute a near
	    // distance that puts any one of these corners exactly at the given distance. The distance to one of the
	    // four corners can be expressed in terms of the near clip distance, given distance to a corner 'd',
	    // near distance 'n', and aspect ratio 'a':
	    //
	    // d*d = x*x + y*y + z*z
	    // d*d = (n*n/4 * a*a) + (n*n/4) + (n*n)
	    //
	    // Extracting 'n*n/4' from the right hand side gives:
	    //
	    // d*d = (n*n/4) * (a*a + 1 + 4)
	    // d*d = (n*n/4) * (a*a + 5)
	    //
	    // Finally, solving for 'n' gives:
	    //
	    // n*n = 4 * d*d / (a*a + 5)
	    // n = 2 * d / sqrt(a*a + 5)
	    // Assumes a 45 degree horizontal field of view.


	    var aspectRatio = viewportHeight / viewportWidth;
	    return 2 * distanceToSurface / Math.sqrt(aspectRatio * aspectRatio + 5);
	  },

	  /**
	   * Computes the coordinates of a rectangle carved out of a perspective projection's frustum at a given
	   * distance in model coordinates. This returns an empty rectangle if the specified distance is zero.
	   *
	   * @param {Number} viewportWidth The viewport width, in screen coordinates.
	   * @param {Number} viewportHeight The viewport height, in screen coordinates.
	   * @param {Number} distance The distance along the negative Z axis, in model coordinates.
	   * @returns {Rectangle} The frustum rectangle, in model coordinates.
	   * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
	   * specified distance is negative.
	   */
	  perspectiveFrustumRectangle: function (viewportWidth, viewportHeight, distance) {
	    if (viewportWidth <= 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle", "invalidWidth"));
	    }

	    if (viewportHeight <= 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle", "invalidHeight"));
	    }

	    if (distance < 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectiveFrustumRectangle", "The specified distance is negative."));
	    } // Assumes a 45 degree horizontal field of view.


	    var width = distance,
	        height = distance * viewportHeight / viewportWidth;
	    return new Rectangle(-width / 2, -height / 2, width, height);
	  },

	  /**
	   * Computes the vertical size of a pixel in model coordinates at a given distance from the eye point in a
	   * perspective projection. This returns zero if the specified distance is zero. The returned size is
	   * undefined if the distance is less than zero.
	   * <p/>
	   * This method assumes the model of a screen composed of rectangular pixels, where pixel coordinates denote
	   * infinitely thin space between pixels. The units of the returned size are in model coordinates per pixel
	   * (usually meters per pixel).
	   *
	   * @param {Number} viewportWidth The viewport width, in screen coordinates.
	   * @param {Number} viewportHeight The viewport height, in screen coordinates.
	   * @param {Number} distance The distance from the perspective eye point at which to determine pixel size, in
	   * model coordinates.
	   * @returns {Number} The pixel size at the specified distance from the eye point, in model coordinates per
	   * pixel.
	   * @throws {ArgumentError} If the specified width or height is less than or equal to zero, or if the
	   * specified distance is negative.
	   */
	  perspectivePixelSize: function (viewportWidth, viewportHeight, distance) {
	    if (viewportWidth <= 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectivePixelSize", "invalidWidth"));
	    }

	    if (viewportHeight <= 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectivePixelSize", "invalidHeight"));
	    }

	    if (distance < 0) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "perspectivePixelSize", "The specified distance is negative."));
	    }

	    var frustumHeight = WWMath.perspectiveFrustumRectangle(viewportWidth, viewportHeight, distance).height;
	    return frustumHeight / viewportHeight;
	  },

	  /**
	   * Computes the bounding rectangle for a unit quadrilateral after applying a transformation matrix to that
	   * quadrilateral.
	   * @param {Matrix} transformMatrix The matrix to apply to the unit quadrilateral.
	   * @returns {Rectangle} The computed bounding rectangle.
	   */
	  boundingRectForUnitQuad: function (transformMatrix) {
	    if (!transformMatrix) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WWMath", "boundingRectForUnitQuad", "missingMatrix"));
	    }

	    var m = transformMatrix,
	        // transform of (0, 0)
	    x1 = m[3],
	        y1 = m[7],
	        // transform of (1, 0)
	    x2 = m[0] + m[3],
	        y2 = m[4] + m[7],
	        // transform of (0, 1)
	    x3 = m[1] + m[3],
	        y3 = m[5] + m[7],
	        // transform of (1, 1)
	    x4 = m[0] + m[1] + m[3],
	        y4 = m[4] + m[5] + m[7],
	        minX = Math.min(Math.min(x1, x2), Math.min(x3, x4)),
	        maxX = Math.max(Math.max(x1, x2), Math.max(x3, x4)),
	        minY = Math.min(Math.min(y1, y2), Math.min(y3, y4)),
	        maxY = Math.max(Math.max(y1, y2), Math.max(y3, y4));
	    return new Rectangle(minX, minY, maxX - minX, maxY - minY);
	  },

	  /**
	   * Indicates whether a specified value is a power of two.
	   * @param {Number} value The value to test.
	   * @returns {boolean} <code>true</code> if the specified value is a power of two,
	   * otherwise <code>false</code>.
	   */
	  isPowerOfTwo: function (value) {
	    return value != 0 && (value & value - 1) === 0;
	  },

	  /**
	   * Determine the sign of a number.
	   * @param {Number} value The value to determine the sign of.
	   * @returns {Number} 1, -1, or 0, depending on the sign of the value.
	   */
	  signum: function (value) {
	    return value > 0 ? 1 : value < 0 ? -1 : 0;
	  },

	  /**
	   * Calculates the Gudermannian inverse used to unproject Mercator projections.
	   * @param {Number} latitude The latitude in degrees.
	   * @returns {Number} The Gudermannian inverse for the specified latitude.
	   */
	  gudermannianInverse: function (latitude) {
	    return Math.log(Math.tan(Math.PI / 4 + latitude * Angle.DEGREES_TO_RADIANS / 2)) / Math.PI;
	  },
	  epsg3857ToEpsg4326: function (easting, northing) {
	    var r = 6.3781e6,
	        latRadians = Math.PI / 2 - 2 * Math.atan(Math.exp(-northing / r)),
	        lonRadians = easting / r;
	    return [WWMath.clamp(latRadians * Angle.RADIANS_TO_DEGREES, -90, 90), WWMath.clamp(lonRadians * Angle.RADIANS_TO_DEGREES, -180, 180)];
	  },

	  /**
	   * Returns the value that is the nearest power of 2 less than or equal to the given value.
	   * @param {Number} value the reference value. The power of 2 returned is less than or equal to this value.
	   * @returns {Number} the value that is the nearest power of 2 less than or equal to the reference value
	   */
	  powerOfTwoFloor: function (value) {
	    var power = Math.floor(Math.log(value) / Math.log(2));
	    return Math.pow(2, power);
	  },

	  /**
	   * Restricts an angle to the range [0, 360] degrees, wrapping angles outside the range.
	   * Wrapping takes place as though traversing the edge of a unit circle;
	   * angles less than 0 wrap back to 360, while angles greater than 360 wrap back to 0.
	   *
	   * @param {Number} degrees the angle to wrap in degrees
	   *
	   * @return {Number} the specified angle wrapped to [0, 360] degrees
	   */
	  normalizeAngle360: function (degrees) {
	    var angle = degrees % 360;
	    return angle >= 0 ? angle : angle < 0 ? 360 + angle : 360 - angle;
	  }
	};

	/**
	 * @exports Location
	 */
	/**
	 * Constructs a location from a specified latitude and longitude in degrees.
	 * @alias Location
	 * @constructor
	 * @classdesc Represents a latitude, longitude pair in degrees.
	 * @param {Number} latitude The latitude in degrees.
	 * @param {Number} longitude The longitude in degrees.
	 */

	function Location(latitude, longitude) {
	  /**
	   * The latitude in degrees.
	   * @type {Number}
	   */
	  this.latitude = latitude;
	  /**
	   * The longitude in degrees.
	   * @type {Number}
	   */

	  this.longitude = longitude;
	}
	/**
	 * A location with latitude and longitude both 0.
	 * @constant
	 * @type {Location}
	 */


	Location.ZERO = new Location(0, 0);
	/**
	 * Creates a location from angles specified in radians.
	 * @param {Number} latitudeRadians The latitude in radians.
	 * @param {Number} longitudeRadians The longitude in radians.
	 * @returns {Location} The new location with latitude and longitude in degrees.
	 */

	Location.fromRadians = function (latitudeRadians, longitudeRadians) {
	  return new Location(latitudeRadians * Angle.RADIANS_TO_DEGREES, longitudeRadians * Angle.RADIANS_TO_DEGREES);
	};
	/**
	 * Copies this location to the latitude and longitude of a specified location.
	 * @param {Location} location The location to copy.
	 * @returns {Location} This location, set to the values of the specified location.
	 * @throws {ArgumentError} If the specified location is null or undefined.
	 */


	Location.prototype.copy = function (location) {
	  if (!location) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "copy", "missingLocation"));
	  }

	  this.latitude = location.latitude;
	  this.longitude = location.longitude;
	  return this;
	};
	/**
	 * Sets this location to the latitude and longitude.
	 * @param {Number} latitude The latitude to set.
	 * @param {Number} longitude The longitude to set.
	 * @returns {Location} This location, set to the values of the specified latitude and longitude.
	 */


	Location.prototype.set = function (latitude, longitude) {
	  this.latitude = latitude;
	  this.longitude = longitude;
	  return this;
	};
	/**
	 * Indicates whether this location is equal to a specified location.
	 * @param {Location} location The location to compare this one to.
	 * @returns {Boolean} <code>true</code> if this location is equal to the specified location, otherwise
	 * <code>false</code>.
	 */


	Location.prototype.equals = function (location) {
	  return location && location.latitude === this.latitude && location.longitude === this.longitude;
	};
	/**
	 * Compute a location along a path at a specified distance between two specified locations.
	 * @param {String} pathType The type of path to assume. Recognized values are
	 * [WorldWind.GREAT_CIRCLE]{@link WorldWind#GREAT_CIRCLE},
	 * [WorldWind.RHUMB_LINE]{@link WorldWind#RHUMB_LINE} and
	 * [WorldWind.LINEAR]{@link WorldWind#LINEAR}.
	 * If the path type is not recognized then WorldWind.LINEAR is used.
	 * @param {Number} amount The fraction of the path between the two locations at which to compute the new
	 * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	 * @param {Location} location1 The starting location.
	 * @param {Location} location2 The ending location.
	 * @param {Location} result A Location in which to return the result.
	 * @returns {Location} The specified result location.
	 * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
	 */


	Location.interpolateAlongPath = function (pathType, amount, location1, location2, result) {
	  if (!location1 || !location2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "interpolateAlongPath", "missingLocation"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "interpolateAlongPath", "missingResult"));
	  }

	  if (pathType === WorldWind.GREAT_CIRCLE) {
	    return this.interpolateGreatCircle(amount, location1, location2, result);
	  } else if (pathType && pathType === WorldWind.RHUMB_LINE) {
	    return this.interpolateRhumb(amount, location1, location2, result);
	  } else {
	    return this.interpolateLinear(amount, location1, location2, result);
	  }
	};
	/**
	 * Compute a location along a great circle path at a specified distance between two specified locations.
	 * @param {Number} amount The fraction of the path between the two locations at which to compute the new
	 * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	 * This function uses a spherical model, not elliptical.
	 * @param {Location} location1 The starting location.
	 * @param {Location} location2 The ending location.
	 * @param {Location} result A Location in which to return the result.
	 * @returns {Location} The specified result location.
	 * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
	 */


	Location.interpolateGreatCircle = function (amount, location1, location2, result) {
	  if (!location1 || !location2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "interpolateGreatCircle", "missingLocation"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "interpolateGreatCircle", "missingResult"));
	  }

	  if (location1.equals(location2)) {
	    result.latitude = location1.latitude;
	    result.longitude = location1.longitude;
	    return result;
	  }

	  var t = WWMath.clamp(amount, 0, 1),
	      azimuthDegrees = this.greatCircleAzimuth(location1, location2),
	      distanceRadians = this.greatCircleDistance(location1, location2);
	  return this.greatCircleLocation(location1, azimuthDegrees, t * distanceRadians, result);
	};
	/**
	 * Computes the azimuth angle (clockwise from North) that points from the first location to the second location.
	 * This angle can be used as the starting azimuth for a great circle arc that begins at the first location, and
	 * passes through the second location.
	 * This function uses a spherical model, not elliptical.
	 * @param {Location} location1 The starting location.
	 * @param {Location} location2 The ending location.
	 * @returns {Number} The computed azimuth, in degrees.
	 * @throws {ArgumentError} If either specified location is null or undefined.
	 */


	Location.greatCircleAzimuth = function (location1, location2) {
	  if (!location1 || !location2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "greatCircleAzimuth", "missingLocation"));
	  }

	  var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
	      lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
	      lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
	      lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
	      x,
	      y,
	      azimuthRadians;

	  if (lat1 == lat2 && lon1 == lon2) {
	    return 0;
	  }

	  if (lon1 == lon2) {
	    return lat1 > lat2 ? 180 : 0;
	  } // Taken from "Map Projections - A Working Manual", page 30, equation 5-4b.
	  // The atan2() function is used in place of the traditional atan(y/x) to simplify the case when x == 0.


	  y = Math.cos(lat2) * Math.sin(lon2 - lon1);
	  x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
	  azimuthRadians = Math.atan2(y, x);
	  return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;
	};
	/**
	 * Computes the great circle angular distance between two locations. The return value gives the distance as the
	 * angle between the two positions. In radians, this angle is the arc length of the segment between the two
	 * positions. To compute a distance in meters from this value, multiply the return value by the radius of the
	 * globe.
	 * This function uses a spherical model, not elliptical.
	 *
	 * @param {Location} location1 The starting location.
	 * @param {Location} location2 The ending location.
	 * @returns {Number} The computed distance, in radians.
	 * @throws {ArgumentError} If either specified location is null or undefined.
	 */


	Location.greatCircleDistance = function (location1, location2) {
	  if (!location1 || !location2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "greatCircleDistance", "missingLocation"));
	  }

	  var lat1Radians = location1.latitude * Angle.DEGREES_TO_RADIANS,
	      lat2Radians = location2.latitude * Angle.DEGREES_TO_RADIANS,
	      lon1Radians = location1.longitude * Angle.DEGREES_TO_RADIANS,
	      lon2Radians = location2.longitude * Angle.DEGREES_TO_RADIANS,
	      a,
	      b,
	      c,
	      distanceRadians;

	  if (lat1Radians == lat2Radians && lon1Radians == lon2Radians) {
	    return 0;
	  } // "Haversine formula," taken from https://en.wikipedia.org/wiki/Great-circle_distance#Formul.C3.A6


	  a = Math.sin((lat2Radians - lat1Radians) / 2.0);
	  b = Math.sin((lon2Radians - lon1Radians) / 2.0);
	  c = a * a + Math.cos(lat1Radians) * Math.cos(lat2Radians) * b * b;
	  distanceRadians = 2.0 * Math.asin(Math.sqrt(c));
	  return isNaN(distanceRadians) ? 0 : distanceRadians;
	};
	/**
	 * Computes the location on a great circle path corresponding to a given starting location, azimuth, and
	 * arc distance.
	 * This function uses a spherical model, not elliptical.
	 *
	 * @param {Location} location The starting location.
	 * @param {Number} greatCircleAzimuthDegrees The azimuth in degrees.
	 * @param {Number} pathLengthRadians The radian distance along the path at which to compute the end location.
	 * @param {Location} result A Location in which to return the result.
	 * @returns {Location} The specified result location.
	 * @throws {ArgumentError} If the specified location or the result argument is null or undefined.
	 */


	Location.greatCircleLocation = function (location, greatCircleAzimuthDegrees, pathLengthRadians, result) {
	  if (!location) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "greatCircleLocation", "missingLocation"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "greatCircleLocation", "missingResult"));
	  }

	  if (pathLengthRadians == 0) {
	    result.latitude = location.latitude;
	    result.longitude = location.longitude;
	    return result;
	  }

	  var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,
	      lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,
	      azimuthRadians = greatCircleAzimuthDegrees * Angle.DEGREES_TO_RADIANS,
	      endLatRadians,
	      endLonRadians; // Taken from "Map Projections - A Working Manual", page 31, equation 5-5 and 5-6.

	  endLatRadians = Math.asin(Math.sin(latRadians) * Math.cos(pathLengthRadians) + Math.cos(latRadians) * Math.sin(pathLengthRadians) * Math.cos(azimuthRadians));
	  endLonRadians = lonRadians + Math.atan2(Math.sin(pathLengthRadians) * Math.sin(azimuthRadians), Math.cos(latRadians) * Math.cos(pathLengthRadians) - Math.sin(latRadians) * Math.sin(pathLengthRadians) * Math.cos(azimuthRadians));

	  if (isNaN(endLatRadians) || isNaN(endLonRadians)) {
	    result.latitude = location.latitude;
	    result.longitude = location.longitude;
	  } else {
	    result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);
	    result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);
	  }

	  return result;
	};
	/**
	 * Compute a location along a rhumb path at a specified distance between two specified locations.
	 * This function uses a spherical model, not elliptical.
	 * @param {Number} amount The fraction of the path between the two locations at which to compute the new
	 * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	 * @param {Location} location1 The starting location.
	 * @param {Location} location2 The ending location.
	 * @param {Location} result A Location in which to return the result.
	 * @returns {Location} The specified result location.
	 * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
	 */


	Location.interpolateRhumb = function (amount, location1, location2, result) {
	  if (!location1 || !location2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "interpolateRhumb", "missingLocation"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "interpolateRhumb", "missingResult"));
	  }

	  if (location1.equals(location2)) {
	    result.latitude = location1.latitude;
	    result.longitude = location1.longitude;
	    return result;
	  }

	  var t = WWMath.clamp(amount, 0, 1),
	      azimuthDegrees = this.rhumbAzimuth(location1, location2),
	      distanceRadians = this.rhumbDistance(location1, location2);
	  return this.rhumbLocation(location1, azimuthDegrees, t * distanceRadians, result);
	};
	/**
	 * Computes the azimuth angle (clockwise from North) that points from the first location to the second location.
	 * This angle can be used as the azimuth for a rhumb arc that begins at the first location, and
	 * passes through the second location.
	 * This function uses a spherical model, not elliptical.
	 * @param {Location} location1 The starting location.
	 * @param {Location} location2 The ending location.
	 * @returns {Number} The computed azimuth, in degrees.
	 * @throws {ArgumentError} If either specified location is null or undefined.
	 */


	Location.rhumbAzimuth = function (location1, location2) {
	  if (!location1 || !location2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "rhumbAzimuth", "missingLocation"));
	  }

	  var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
	      lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
	      lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
	      lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
	      dLon,
	      dPhi,
	      azimuthRadians;

	  if (lat1 == lat2 && lon1 == lon2) {
	    return 0;
	  }

	  dLon = lon2 - lon1;
	  dPhi = Math.log(Math.tan(lat2 / 2.0 + Math.PI / 4) / Math.tan(lat1 / 2.0 + Math.PI / 4)); // If lonChange over 180 take shorter rhumb across 180 meridian.

	  if (WWMath.fabs(dLon) > Math.PI) {
	    dLon = dLon > 0 ? -(2 * Math.PI - dLon) : 2 * Math.PI + dLon;
	  }

	  azimuthRadians = Math.atan2(dLon, dPhi);
	  return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;
	};
	/**
	 * Computes the rhumb angular distance between two locations. The return value gives the distance as the
	 * angle between the two positions in radians. This angle is the arc length of the segment between the two
	 * positions. To compute a distance in meters from this value, multiply the return value by the radius of the
	 * globe.
	 * This function uses a spherical model, not elliptical.
	 *
	 * @param {Location} location1 The starting location.
	 * @param {Location} location2 The ending location.
	 * @returns {Number} The computed distance, in radians.
	 * @throws {ArgumentError} If either specified location is null or undefined.
	 */


	Location.rhumbDistance = function (location1, location2) {
	  if (!location1 || !location2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "rhumbDistance", "missingLocation"));
	  }

	  var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
	      lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
	      lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
	      lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
	      dLat,
	      dLon,
	      dPhi,
	      q,
	      distanceRadians;

	  if (lat1 == lat2 && lon1 == lon2) {
	    return 0;
	  }

	  dLat = lat2 - lat1;
	  dLon = lon2 - lon1;
	  dPhi = Math.log(Math.tan(lat2 / 2.0 + Math.PI / 4) / Math.tan(lat1 / 2.0 + Math.PI / 4));
	  q = dLat / dPhi;

	  if (isNaN(dPhi) || isNaN(q)) {
	    q = Math.cos(lat1);
	  } // If lonChange over 180 take shorter rhumb across 180 meridian.


	  if (WWMath.fabs(dLon) > Math.PI) {
	    dLon = dLon > 0 ? -(2 * Math.PI - dLon) : 2 * Math.PI + dLon;
	  }

	  distanceRadians = Math.sqrt(dLat * dLat + q * q * dLon * dLon);
	  return isNaN(distanceRadians) ? 0 : distanceRadians;
	};
	/**
	 * Computes the location on a rhumb arc with the given starting location, azimuth, and arc distance.
	 * This function uses a spherical model, not elliptical.
	 *
	 * @param {Location} location The starting location.
	 * @param {Number} azimuthDegrees The azimuth in degrees.
	 * @param {Number} pathLengthRadians The radian distance along the path at which to compute the location.
	 * @param {Location} result A Location in which to return the result.
	 * @returns {Location} The specified result location.
	 * @throws {ArgumentError} If the specified location or the result argument is null or undefined.
	 */


	Location.rhumbLocation = function (location, azimuthDegrees, pathLengthRadians, result) {
	  if (!location) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "rhumbLocation", "missingLocation"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "rhumbLocation", "missingResult"));
	  }

	  if (pathLengthRadians == 0) {
	    result.latitude = location.latitude;
	    result.longitude = location.longitude;
	    return result;
	  }

	  var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,
	      lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,
	      azimuthRadians = azimuthDegrees * Angle.DEGREES_TO_RADIANS,
	      endLatRadians = latRadians + pathLengthRadians * Math.cos(azimuthRadians),
	      dPhi = Math.log(Math.tan(endLatRadians / 2 + Math.PI / 4) / Math.tan(latRadians / 2 + Math.PI / 4)),
	      q = (endLatRadians - latRadians) / dPhi,
	      dLon,
	      endLonRadians;

	  if (isNaN(dPhi) || isNaN(q) || !isFinite(q)) {
	    q = Math.cos(latRadians);
	  }

	  dLon = pathLengthRadians * Math.sin(azimuthRadians) / q; // Handle latitude passing over either pole.

	  if (WWMath.fabs(endLatRadians) > Math.PI / 2) {
	    endLatRadians = endLatRadians > 0 ? Math.PI - endLatRadians : -Math.PI - endLatRadians;
	  }

	  endLonRadians = WWMath.fmod(lonRadians + dLon + Math.PI, 2 * Math.PI) - Math.PI;

	  if (isNaN(endLatRadians) || isNaN(endLonRadians)) {
	    result.latitude = location.latitude;
	    result.longitude = location.longitude;
	  } else {
	    result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);
	    result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);
	  }

	  return result;
	};
	/**
	 * Compute a location along a linear path at a specified distance between two specified locations.
	 * @param {Number} amount The fraction of the path between the two locations at which to compute the new
	 * location. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	 * @param {Location} location1 The starting location.
	 * @param {Location} location2 The ending location.
	 * @param {Location} result A Location in which to return the result.
	 * @returns {Location} The specified result location.
	 * @throws {ArgumentError} If either specified location or the result argument is null or undefined.
	 */


	Location.interpolateLinear = function (amount, location1, location2, result) {
	  if (!location1 || !location2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "interpolateLinear", "missingLocation"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "interpolateLinear", "missingResult"));
	  }

	  if (location1.equals(location2)) {
	    result.latitude = location1.latitude;
	    result.longitude = location1.longitude;
	    return result;
	  }

	  var t = WWMath.clamp(amount, 0, 1),
	      azimuthDegrees = this.linearAzimuth(location1, location2),
	      distanceRadians = this.linearDistance(location1, location2);
	  return this.linearLocation(location1, azimuthDegrees, t * distanceRadians, result);
	};
	/**
	 * Computes the azimuth angle (clockwise from North) that points from the first location to the second location.
	 * This angle can be used as the azimuth for a linear arc that begins at the first location, and
	 * passes through the second location.
	 * @param {Location} location1 The starting location.
	 * @param {Location} location2 The ending location.
	 * @returns {Number} The computed azimuth, in degrees.
	 * @throws {ArgumentError} If either specified location is null or undefined.
	 */


	Location.linearAzimuth = function (location1, location2) {
	  if (!location1 || !location2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "linearAzimuth", "missingLocation"));
	  }

	  var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
	      lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
	      lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
	      lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
	      dLon,
	      dPhi,
	      azimuthRadians;

	  if (lat1 == lat2 && lon1 == lon2) {
	    return 0;
	  }

	  dLon = lon2 - lon1;
	  dPhi = lat2 - lat1; // If longitude change is over 180 take shorter path across 180 meridian.

	  if (WWMath.fabs(dLon) > Math.PI) {
	    dLon = dLon > 0 ? -(2 * Math.PI - dLon) : 2 * Math.PI + dLon;
	  }

	  azimuthRadians = Math.atan2(dLon, dPhi);
	  return isNaN(azimuthRadians) ? 0 : azimuthRadians * Angle.RADIANS_TO_DEGREES;
	};
	/**
	 * Computes the linear angular distance between two locations. The return value gives the distance as the
	 * angle between the two positions in radians. This angle is the arc length of the segment between the two
	 * positions. To compute a distance in meters from this value, multiply the return value by the radius of the
	 * globe.
	 *
	 * @param {Location} location1 The starting location.
	 * @param {Location} location2 The ending location.
	 * @returns {Number} The computed distance, in radians.
	 * @throws {ArgumentError} If either specified location is null or undefined.
	 */


	Location.linearDistance = function (location1, location2) {
	  if (!location1 || !location2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "linearDistance", "missingLocation"));
	  }

	  var lat1 = location1.latitude * Angle.DEGREES_TO_RADIANS,
	      lat2 = location2.latitude * Angle.DEGREES_TO_RADIANS,
	      lon1 = location1.longitude * Angle.DEGREES_TO_RADIANS,
	      lon2 = location2.longitude * Angle.DEGREES_TO_RADIANS,
	      dLat,
	      dLon,
	      distanceRadians;

	  if (lat1 == lat2 && lon1 == lon2) {
	    return 0;
	  }

	  dLat = lat2 - lat1;
	  dLon = lon2 - lon1; // If lonChange over 180 take shorter path across 180 meridian.

	  if (WWMath.fabs(dLon) > Math.PI) {
	    dLon = dLon > 0 ? -(2 * Math.PI - dLon) : 2 * Math.PI + dLon;
	  }

	  distanceRadians = Math.sqrt(dLat * dLat + dLon * dLon);
	  return isNaN(distanceRadians) ? 0 : distanceRadians;
	};
	/**
	 * Computes the location on a linear path with the given starting location, azimuth, and arc distance.
	 *
	 * @param {Location} location The starting location.
	 * @param {Number} azimuthDegrees The azimuth in degrees.
	 * @param {Number} pathLengthRadians The radian distance along the path at which to compute the location.
	 * @param {Location} result A Location in which to return the result.
	 * @returns {Location} The specified result location.
	 * @throws {ArgumentError} If the specified location or the result argument is null or undefined.
	 */


	Location.linearLocation = function (location, azimuthDegrees, pathLengthRadians, result) {
	  if (!location) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "linearLocation", "missingLocation"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "linearLocation", "missingResult"));
	  }

	  if (pathLengthRadians == 0) {
	    result.latitude = location.latitude;
	    result.longitude = location.longitude;
	    return result;
	  }

	  var latRadians = location.latitude * Angle.DEGREES_TO_RADIANS,
	      lonRadians = location.longitude * Angle.DEGREES_TO_RADIANS,
	      azimuthRadians = azimuthDegrees * Angle.DEGREES_TO_RADIANS,
	      endLatRadians = latRadians + pathLengthRadians * Math.cos(azimuthRadians),
	      endLonRadians; // Handle latitude passing over either pole.

	  if (WWMath.fabs(endLatRadians) > Math.PI / 2) {
	    endLatRadians = endLatRadians > 0 ? Math.PI - endLatRadians : -Math.PI - endLatRadians;
	  }

	  endLonRadians = WWMath.fmod(lonRadians + pathLengthRadians * Math.sin(azimuthRadians) + Math.PI, 2 * Math.PI) - Math.PI;

	  if (isNaN(endLatRadians) || isNaN(endLonRadians)) {
	    result.latitude = location.latitude;
	    result.longitude = location.longitude;
	  } else {
	    result.latitude = Angle.normalizedDegreesLatitude(endLatRadians * Angle.RADIANS_TO_DEGREES);
	    result.longitude = Angle.normalizedDegreesLongitude(endLonRadians * Angle.RADIANS_TO_DEGREES);
	  }

	  return result;
	};
	/**
	 * Determine whether a list of locations crosses the dateline.
	 * @param {Location[]} locations The locations to test.
	 * @returns {boolean} True if the dateline is crossed, else false.
	 * @throws {ArgumentError} If the locations list is null.
	 */


	Location.locationsCrossDateLine = function (locations) {
	  if (!locations) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "locationsCrossDateline", "missingLocation"));
	  }

	  var pos = null;

	  for (var idx = 0, len = locations.length; idx < len; idx += 1) {
	    var posNext = locations[idx];

	    if (pos != null) {
	      // A segment cross the line if end pos have different longitude signs
	      // and are more than 180 degrees longitude apart
	      if (WWMath.signum(pos.longitude) != WWMath.signum(posNext.longitude)) {
	        var delta = Math.abs(pos.longitude - posNext.longitude);
	        if (delta > 180 && delta < 360) return true;
	      }
	    }

	    pos = posNext;
	  }

	  return false;
	};
	/**
	 * Returns two locations with the most extreme latitudes on the sequence of great circle arcs defined by each pair
	 * of locations in the specified iterable.
	 *
	 * @param {Location[]} locations The pairs of locations defining a sequence of great circle arcs.
	 *
	 * @return {Location[]} Two locations with the most extreme latitudes on the great circle arcs.
	 *
	 * @throws IllegalArgumentException if locations is null.
	 */


	Location.greatCircleArcExtremeLocations = function (locations) {
	  if (!locations) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "greatCircleArcExtremeLocations", "missingLocation"));
	  }

	  var minLatLocation = null;
	  var maxLatLocation = null;
	  var lastLocation = null;

	  for (var idx = 0, len = locations.length; idx < len; idx += 1) {
	    var location = locations[idx];

	    if (lastLocation != null) {
	      var extremes = Location.greatCircleArcExtremeForTwoLocations(lastLocation, location);

	      if (extremes == null) {
	        continue;
	      }

	      if (minLatLocation == null || minLatLocation.latitude > extremes[0].latitude) {
	        minLatLocation = extremes[0];
	      }

	      if (maxLatLocation == null || maxLatLocation.latitude < extremes[1].latitude) {
	        maxLatLocation = extremes[1];
	      }
	    }

	    lastLocation = location;
	  }

	  return [minLatLocation, maxLatLocation];
	};
	/**
	 * Returns two locations with the most extreme latitudes on the great circle arc defined by, and limited to, the two
	 * locations.
	 *
	 * @param {Location} begin Beginning location on the great circle arc.
	 * @param {Location} end   Ending location on the great circle arc.
	 *
	 * @return {Location[]} Two locations with the most extreme latitudes on the great circle arc.
	 *
	 * @throws {ArgumentError} If either begin or end are null.
	 */


	Location.greatCircleArcExtremeForTwoLocations = function (begin, end) {
	  if (!begin || !end) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "greatCircleArcExtremeForTwoLocations", "missingLocation"));
	  }

	  var idx, len, location; // Iteration variables.

	  var minLatLocation = null;
	  var maxLatLocation = null;
	  var minLat = 90;
	  var maxLat = -90; // Compute the min and max latitude and associated locations from the arc endpoints.

	  var locations = [begin, end];

	  for (idx = 0, len = locations.length; idx < len; idx += 1) {
	    location = locations[idx];

	    if (minLat >= location.latitude) {
	      minLat = location.latitude;
	      minLatLocation = location;
	    }

	    if (maxLat <= location.latitude) {
	      maxLat = location.latitude;
	      maxLatLocation = location;
	    }
	  } // The above could be written for greater clarity, simplicity, and speed:
	  // minLat = Math.min(begin.latitude, end.latitude);
	  // maxLat = Math.max(begin.latitude, end.latitude);
	  // minLatLocation = minLat == begin.latitude ? begin : end;
	  // maxLatLocation = maxLat == begin.latitude ? begin : end;
	  // Compute parameters for the great circle arc defined by begin and end. Then compute the locations of extreme
	  // latitude on entire the great circle which that arc is part of.


	  var greatArcAzimuth = Location.greatCircleAzimuth(begin, end);
	  var greatArcDistance = Location.greatCircleDistance(begin, end);
	  var greatCircleExtremes = Location.greatCircleExtremeLocationsUsingAzimuth(begin, greatArcAzimuth); // Determine whether either of the extreme locations are inside the arc defined by begin and end. If so,
	  // adjust the min and max latitude accordingly.

	  for (idx = 0, len = greatCircleExtremes.length; idx < len; idx += 1) {
	    location = greatCircleExtremes[idx];
	    var az = Location.greatCircleAzimuth(begin, location);
	    var d = Location.greatCircleDistance(begin, location); // The extreme location must be between the begin and end locations. Therefore its azimuth relative to
	    // the begin location should have the same signum, and its distance relative to the begin location should
	    // be between 0 and greatArcDistance, inclusive.

	    if (WWMath.signum(az) == WWMath.signum(greatArcAzimuth)) {
	      if (d >= 0 && d <= greatArcDistance) {
	        if (minLat >= location.latitude) {
	          minLat = location.latitude;
	          minLatLocation = location;
	        }

	        if (maxLat <= location.latitude) {
	          maxLat = location.latitude;
	          maxLatLocation = location;
	        }
	      }
	    }
	  }

	  return [minLatLocation, maxLatLocation];
	};
	/**
	 * Returns two locations with the most extreme latitudes on the great circle with the given starting location and
	 * azimuth.
	 *
	 * @param {Location} location Location on the great circle.
	 * @param {number} azimuth  Great circle azimuth angle (clockwise from North).
	 *
	 * @return {Location[]} Two locations where the great circle has its extreme latitudes.
	 *
	 * @throws {ArgumentError} If location is null.
	 */


	Location.greatCircleExtremeLocationsUsingAzimuth = function (location, azimuth) {
	  if (!location) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Location", "greatCircleArcExtremeLocationsUsingAzimuth", "missingLocation"));
	  }

	  var lat0 = location.latitude;
	  var az = azimuth * Angle.DEGREES_TO_RADIANS; // Derived by solving the function for longitude on a great circle against the desired longitude. We start
	  // with the equation in "Map Projections - A Working Manual", page 31, equation 5-5:
	  //
	  //     lat = asin( sin(lat0) * cos(C) + cos(lat0) * sin(C) * cos(Az) )
	  //
	  // Where (lat0, lon) are the starting coordinates, c is the angular distance along the great circle from the
	  // starting coordinate, and Az is the azimuth. All values are in radians. Solving for angular distance gives
	  // distance to the equator:
	  //
	  //     tan(C) = -tan(lat0) / cos(Az)
	  //
	  // The great circle is by definition centered about the Globe's origin. Therefore intersections with the
	  // equator will be antipodal (exactly 180 degrees opposite each other), as will be the extreme latitudes.
	  // By observing the symmetry of a great circle, it is also apparent that the extreme latitudes will be 90
	  // degrees from either intersection with the equator.
	  //
	  // d1 = c + 90
	  // d2 = c - 90

	  var tanDistance = -Math.tan(lat0) / Math.cos(az);
	  var distance = Math.atan(tanDistance);
	  var extremeDistance1 = distance + Math.PI / 2.0;
	  var extremeDistance2 = distance - Math.PI / 2.0;
	  return [Location.greatCircleLocation(location, azimuth, extremeDistance1, new Location(0, 0)), Location.greatCircleLocation(location, azimuth, extremeDistance2, new Location(0, 0))];
	};
	/**
	 * Determine where a line between two positions crosses a given meridian. The intersection test is performed by
	 * intersecting a line in Cartesian space between the two positions with a plane through the meridian. Thus, it is
	 * most suitable for working with positions that are fairly close together as the calculation does not take into
	 * account great circle or rhumb paths.
	 *
	 * @param {Location} p1         First position.
	 * @param {Location} p2         Second position.
	 * @param {number} meridian     Longitude line to intersect with.
	 * @param {Globe} globe         Globe used to compute intersection.
	 *
	 * @return {number} latitude The intersection latitude along the meridian
	 *
	 * TODO: this code allocates 4 new Vec3 and 1 new Position; use scratch variables???
	 * TODO: Why not? Every location created would then allocated those variables as well, even if they aren't needed :(.
	 */


	Location.intersectionWithMeridian = function (p1, p2, meridian, globe) {
	  // TODO: add support for 2D
	  //if (globe instanceof Globe2D)
	  //{
	  //    // y = mx + b case after normalizing negative angles.
	  //    double lon1 = p1.getLongitude().degrees < 0 ? p1.getLongitude().degrees + 360 : p1.getLongitude().degrees;
	  //    double lon2 = p2.getLongitude().degrees < 0 ? p2.getLongitude().degrees + 360 : p2.getLongitude().degrees;
	  //    if (lon1 == lon2)
	  //        return null;
	  //
	  //    double med = meridian.degrees < 0 ? meridian.degrees + 360 : meridian.degrees;
	  //    double slope = (p2.latitude.degrees - p1.latitude.degrees) / (lon2 - lon1);
	  //    double lat = p1.latitude.degrees + slope * (med - lon1);
	  //
	  //    return LatLon.fromDegrees(lat, meridian.degrees);
	  //}
	  var pt1 = globe.computePointFromLocation(p1.latitude, p1.longitude, new Vec3$1(0, 0, 0));
	  var pt2 = globe.computePointFromLocation(p2.latitude, p2.longitude, new Vec3$1(0, 0, 0)); // Compute a plane through the origin, North Pole, and the desired meridian.

	  var northPole = globe.computePointFromLocation(90, meridian, new Vec3$1(0, 0, 0));
	  var pointOnEquator = globe.computePointFromLocation(0, meridian, new Vec3$1(0, 0, 0));
	  var plane = Plane.fromPoints(northPole, pointOnEquator, Vec3$1.ZERO);
	  var intersectionPoint = new Vec3$1(0, 0, 0);

	  if (!plane.intersectsSegmentAt(pt1, pt2, intersectionPoint)) {
	    return null;
	  } // TODO: unable to simply create a new Position(0, 0, 0)


	  var pos = new WorldWind.Position(0, 0, 0);
	  globe.computePositionFromPoint(intersectionPoint[0], intersectionPoint[1], intersectionPoint[2], pos);
	  return pos.latitude;
	};
	/**
	 * Determine where a line between two positions crosses a given meridian. The intersection test is performed by
	 * intersecting a line in Cartesian space. Thus, it is most suitable for working with positions that are fairly
	 * close together as the calculation does not take into account great circle or rhumb paths.
	 *
	 * @param {Location | Position} p1 First position.
	 * @param {Location | Position} p2 Second position.
	 * @param {number} meridian Longitude line to intersect with.
	 *
	 * @return {number | null} latitude The intersection latitude along the meridian
	 * or null if the line is collinear with the meridian
	 */


	Location.meridianIntersection = function (p1, p2, meridian) {
	  // y = mx + b case after normalizing negative angles.
	  var lon1 = p1.longitude < 0 ? p1.longitude + 360 : p1.longitude;
	  var lon2 = p2.longitude < 0 ? p2.longitude + 360 : p2.longitude;

	  if (lon1 === lon2) {
	    //infinite solutions, the line is collinear with the anti-meridian
	    return null;
	  }

	  var med = meridian < 0 ? meridian + 360 : meridian;
	  var slope = (p2.latitude - p1.latitude) / (lon2 - lon1);
	  var lat = p1.latitude + slope * (med - lon1);
	  return lat;
	};
	/**
	 * A bit mask indicating which if any pole is being referenced.
	 * This corresponds to Java WW's AVKey.NORTH and AVKey.SOUTH,
	 * although this encoding can capture both poles simultaneously, which was
	 * a 'to do' item in the Java implementation.
	 * @type {{NONE: number, NORTH: number, SOUTH: number}}
	 */


	Location.poles = {
	  'NONE': 0,
	  'NORTH': 1,
	  'SOUTH': 2
	};

	/**
	 * @exports Position
	 */
	/**
	 * Constructs a position from a specified latitude and longitude in degrees and altitude in meters.
	 * @alias Position
	 * @constructor
	 * @classdesc Represents a latitude, longitude, altitude triple, with latitude and longitude in degrees and
	 * altitude in meters.
	 * @param {Number} latitude The latitude in degrees.
	 * @param {Number} longitude The longitude in degrees.
	 * @param {Number} altitude The altitude in meters.
	 */

	function Position(latitude, longitude, altitude) {
	  /**
	   * The latitude in degrees.
	   * @type {Number}
	   */
	  this.latitude = latitude;
	  /**
	   * The longitude in degrees.
	   * @type {Number}
	   */

	  this.longitude = longitude;
	  /**
	   * The altitude in meters.
	   * @type {Number}
	   */

	  this.altitude = altitude;
	}
	/**
	 * A Position with latitude, longitude and altitude all 0.
	 * @constant
	 * @type {Position}
	 */


	Position.ZERO = new Position(0, 0, 0);
	/**
	 * Creates a position from angles specified in radians.
	 * @param {Number} latitudeRadians The latitude in radians.
	 * @param {Number} longitudeRadians The longitude in radians.
	 * @param {Number} altitude The altitude in meters.
	 * @returns {Position} The new position with latitude and longitude in degrees.
	 */

	Position.fromRadians = function (latitudeRadians, longitudeRadians, altitude) {
	  return new Position(latitudeRadians * Angle.RADIANS_TO_DEGREES, longitudeRadians * Angle.RADIANS_TO_DEGREES, altitude);
	};
	/**
	 * Sets this position to the latitude, longitude and altitude of a specified position.
	 * @param {Position} position The position to copy.
	 * @returns {Position} This position, set to the values of the specified position.
	 * @throws {ArgumentError} If the specified position is null or undefined.
	 */


	Position.prototype.copy = function (position) {
	  if (!position) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Position", "copy", "missingPosition"));
	  }

	  this.latitude = position.latitude;
	  this.longitude = position.longitude;
	  this.altitude = position.altitude;
	  return this;
	};
	/**
	 * Indicates whether this position has the same latitude, longitude and altitude as a specified position.
	 * @param {Position} position The position to compare with this one.
	 * @returns {Boolean} true if this position is equal to the specified one, otherwise false.
	 */


	Position.prototype.equals = function (position) {
	  return position && position.latitude === this.latitude && position.longitude === this.longitude && position.altitude === this.altitude;
	};
	/**
	 * Computes a position along a great circle path at a specified distance between two specified positions.
	 * @param {Number} amount The fraction of the path between the two positions at which to compute the new
	 * position. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	 * @param {Position} position1 The starting position.
	 * @param {Position} position2 The ending position.
	 * @param {Position} result A Position in which to return the result.
	 * @returns {Position} The specified result position.
	 * @throws {ArgumentError} If either specified position or the result argument is null or undefined.
	 */


	Position.interpolateGreatCircle = function (amount, position1, position2, result) {
	  if (!position1 || !position2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Position", "interpolateGreatCircle", "missingPosition"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Position", "interpolateGreatCircle", "missingResult"));
	  }

	  var t = WWMath.clamp(amount, 0, 1);
	  result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude); //noinspection JSCheckFunctionSignatures

	  Location.interpolateGreatCircle(t, position1, position2, result);
	  return result;
	};
	/**
	 * Computes a position along a rhumb path at a specified distance between two specified positions.
	 * @param {Number} amount The fraction of the path between the two positions at which to compute the new
	 * position. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	 * @param {Position} position1 The starting position.
	 * @param {Position} position2 The ending position.
	 * @param {Position} result A Position in which to return the result.
	 * @returns {Position} The specified result position.
	 * @throws {ArgumentError} If either specified position or the result argument is null or undefined.
	 */


	Position.interpolateRhumb = function (amount, position1, position2, result) {
	  if (!position1 || !position2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Position", "interpolateRhumb", "missingPosition"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Position", "interpolateRhumb", "missingResult"));
	  }

	  var t = WWMath.clamp(amount, 0, 1);
	  result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude); //noinspection JSCheckFunctionSignatures

	  Location.interpolateRhumb(t, position1, position2, result);
	  return result;
	};
	/**
	 * Computes a position along a linear path at a specified distance between two specified positions.
	 * @param {Number} amount The fraction of the path between the two positions at which to compute the new
	 * position. This number should be between 0 and 1. If not, it is clamped to the nearest of those values.
	 * @param {Position} position1 The starting position.
	 * @param {Position} position2 The ending position.
	 * @param {Position} result A Position in which to return the result.
	 * @returns {Position} The specified result position.
	 * @throws {ArgumentError} If either specified position or the result argument is null or undefined.
	 */


	Position.interpolateLinear = function (amount, position1, position2, result) {
	  if (!position1 || !position2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Position", "interpolateLinear", "missingPosition"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Position", "interpolateLinear", "missingResult"));
	  }

	  var t = WWMath.clamp(amount, 0, 1);
	  result.altitude = WWMath.interpolate(t, position1.altitude, position2.altitude); //noinspection JSCheckFunctionSignatures

	  Location.interpolateLinear(t, position1, position2, result);
	  return result;
	};
	/**
	 * Returns a string representation of this position.
	 * @returns {String}
	 */


	Position.prototype.toString = function () {
	  return "(" + this.latitude.toString() + "\u00b0, " + this.longitude.toString() + "\u00b0, " + this.altitude.toString() + ")";
	};

	/**
	 * @exports Matrix
	 */
	/**
	 * Constructs a matrix.
	 * @alias Matrix
	 * @constructor
	 * @classdesc Represents a 4 x 4 double precision matrix stored in a Float64Array in row-major order.
	 * @param {Number} m11 matrix element at row 1, column 1.
	 * @param {Number} m12 matrix element at row 1, column 2.
	 * @param {Number} m13 matrix element at row 1, column 3.
	 * @param {Number} m14 matrix element at row 1, column 4.
	 * @param {Number} m21 matrix element at row 2, column 1.
	 * @param {Number} m22 matrix element at row 2, column 2.
	 * @param {Number} m23 matrix element at row 2, column 3.
	 * @param {Number} m24 matrix element at row 2, column 4.
	 * @param {Number} m31 matrix element at row 3, column 1.
	 * @param {Number} m32 matrix element at row 3, column 2.
	 * @param {Number} m33 matrix element at row 3, column 3.
	 * @param {Number} m34 matrix element at row 3, column 4.
	 * @param {Number} m41 matrix element at row 4, column 1.
	 * @param {Number} m42 matrix element at row 4, column 2.
	 * @param {Number} m43 matrix element at row 4, column 3.
	 * @param {Number} m44 matrix element at row 4, column 4.
	 */

	function Matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
	  this[0] = m11;
	  this[1] = m12;
	  this[2] = m13;
	  this[3] = m14;
	  this[4] = m21;
	  this[5] = m22;
	  this[6] = m23;
	  this[7] = m24;
	  this[8] = m31;
	  this[9] = m32;
	  this[10] = m33;
	  this[11] = m34;
	  this[12] = m41;
	  this[13] = m42;
	  this[14] = m43;
	  this[15] = m44;
	} // Derives from Float64Array.


	Matrix.prototype = new Float64Array(16);
	/**
	 * Creates an identity matrix.
	 * @returns {Matrix} A new identity matrix.
	 */

	Matrix.fromIdentity = function () {
	  return new Matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	};
	/**
	 * Computes the principal axes of a point collection expressed in a typed array.
	 * @param {Float32Array} points The points for which to compute the axes,
	 * expressed as X0, Y0, Z0, X1, Y1, Z1, ...
	 * @param {Vec3} axis1 A vector in which to return the first (longest) principal axis.
	 * @param {Vec3} axis2 A vector in which to return the second (mid-length) principal axis.
	 * @param {Vec3} axis3 A vector in which to return the third (shortest) principal axis.
	 * @throws {ArgumentError} If the specified points array is null, undefined or empty, or one of the
	 * specified axes arguments is null or undefined.
	 */


	Matrix.principalAxesFromPoints = function (points, axis1, axis2, axis3) {
	  if (!points || points.length < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "principalAxesFromPoints", "missingPoints"));
	  }

	  if (!axis1 || !axis2 || !axis3) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "principalAxesFromPoints", "An axis argument is null or undefined."));
	  } // Compute the covariance matrix.


	  var covariance = Matrix.fromIdentity();
	  covariance.setToCovarianceOfPoints(points); // Compute the eigenvectors from the covariance matrix. Since the covariance matrix is symmetric by
	  // definition, we can safely use the "symmetric" method below.

	  covariance.eigensystemFromSymmetricMatrix(axis1, axis2, axis3); // Normalize the eigenvectors, which are already sorted in order from most prominent to least prominent.

	  axis1.normalize();
	  axis2.normalize();
	  axis3.normalize();
	};
	/**
	 * Sets the components of this matrix to specified values.
	 * @param {Number} m11 matrix element at row 1, column 1.
	 * @param {Number} m12 matrix element at row 1, column 2.
	 * @param {Number} m13 matrix element at row 1, column 3.
	 * @param {Number} m14 matrix element at row 1, column 4.
	 * @param {Number} m21 matrix element at row 2, column 1.
	 * @param {Number} m22 matrix element at row 2, column 2.
	 * @param {Number} m23 matrix element at row 2, column 3.
	 * @param {Number} m24 matrix element at row 2, column 4.
	 * @param {Number} m31 matrix element at row 3, column 1.
	 * @param {Number} m32 matrix element at row 3, column 2.
	 * @param {Number} m33 matrix element at row 3, column 3.
	 * @param {Number} m34 matrix element at row 3, column 4.
	 * @param {Number} m41 matrix element at row 4, column 1.
	 * @param {Number} m42 matrix element at row 4, column 2.
	 * @param {Number} m43 matrix element at row 4, column 3.
	 * @param {Number} m44 matrix element at row 4, column 4.
	 * @returns {Matrix} This matrix with its components set to the specified values.
	 */


	Matrix.prototype.set = function (m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
	  this[0] = m11;
	  this[1] = m12;
	  this[2] = m13;
	  this[3] = m14;
	  this[4] = m21;
	  this[5] = m22;
	  this[6] = m23;
	  this[7] = m24;
	  this[8] = m31;
	  this[9] = m32;
	  this[10] = m33;
	  this[11] = m34;
	  this[12] = m41;
	  this[13] = m42;
	  this[14] = m43;
	  this[15] = m44;
	  return this;
	};
	/**
	 * Sets this matrix to the identity matrix.
	 * @returns {Matrix} This matrix set to the identity matrix.
	 */


	Matrix.prototype.setToIdentity = function () {
	  this[0] = 1;
	  this[1] = 0;
	  this[2] = 0;
	  this[3] = 0;
	  this[4] = 0;
	  this[5] = 1;
	  this[6] = 0;
	  this[7] = 0;
	  this[8] = 0;
	  this[9] = 0;
	  this[10] = 1;
	  this[11] = 0;
	  this[12] = 0;
	  this[13] = 0;
	  this[14] = 0;
	  this[15] = 1;
	};
	/**
	 * Copies the components of a specified matrix to this matrix.
	 * @param {Matrix} matrix The matrix to copy.
	 * @returns {Matrix} This matrix set to the values of the specified matrix.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */


	Matrix.prototype.copy = function (matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "copy", "missingMatrix"));
	  }

	  this[0] = matrix[0];
	  this[1] = matrix[1];
	  this[2] = matrix[2];
	  this[3] = matrix[3];
	  this[4] = matrix[4];
	  this[5] = matrix[5];
	  this[6] = matrix[6];
	  this[7] = matrix[7];
	  this[8] = matrix[8];
	  this[9] = matrix[9];
	  this[10] = matrix[10];
	  this[11] = matrix[11];
	  this[12] = matrix[12];
	  this[13] = matrix[13];
	  this[14] = matrix[14];
	  this[15] = matrix[15];
	};
	/**
	 * Creates a new matrix that is a copy of this matrix.
	 * @returns {Matrix} The new matrix.
	 */


	Matrix.prototype.clone = function () {
	  var clone = Matrix.fromIdentity();
	  clone.copy(this);
	  return clone;
	};
	/**
	 * Indicates whether the components of this matrix are equal to those of a specified matrix.
	 * @param {Matrix} matrix The matrix to test equality with. May be null or undefined, in which case this
	 * function returns false.
	 * @returns {boolean} true if all components of this matrix are equal to the corresponding
	 * components of the specified matrix, otherwise false.
	 */


	Matrix.prototype.equals = function (matrix) {
	  return matrix && this[0] == matrix[0] && this[1] == matrix[1] && this[2] == matrix[2] && this[3] == matrix[3] && this[4] == matrix[4] && this[5] == matrix[5] && this[6] == matrix[6] && this[7] == matrix[7] && this[8] == matrix[8] && this[9] == matrix[9] && this[10] == matrix[10] && this[11] == matrix[11] && this[12] == matrix[12] && this[13] == matrix[13] && this[14] == matrix[14] && this[15] == matrix[15];
	};
	/**
	 * Stores this matrix's components in column-major order in a specified array.
	 * <p>
	 * The array must have space for at least 16 elements. This matrix's components are stored in the array
	 * starting with row 0 column 0 in index 0, row 1 column 0 in index 1, row 2 column 0 in index 2, and so on.
	 *
	 * @param {Float32Array | Float64Array | Number[]} result An array of at least 16 elements. Upon return,
	 * contains this matrix's components in column-major.
	 * @returns {Float32Array} The specified result array.
	 * @throws {ArgumentError} If the specified result array in null or undefined.
	 */


	Matrix.prototype.columnMajorComponents = function (result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "columnMajorComponents", "missingResult"));
	  } // Column 1


	  result[0] = this[0];
	  result[1] = this[4];
	  result[2] = this[8];
	  result[3] = this[12]; // Column 2

	  result[4] = this[1];
	  result[5] = this[5];
	  result[6] = this[9];
	  result[7] = this[13]; // Column 3

	  result[8] = this[2];
	  result[9] = this[6];
	  result[10] = this[10];
	  result[11] = this[14]; // Column 4

	  result[12] = this[3];
	  result[13] = this[7];
	  result[14] = this[11];
	  result[15] = this[15];
	  return result;
	};
	/**
	 * Sets this matrix to a translation matrix with specified translation components.
	 * @param {Number} x The X translation component.
	 * @param {Number} y The Y translation component.
	 * @param {Number} z The Z translation component.
	 * @returns {Matrix} This matrix with its translation components set to those specified and all other
	 * components set to that of an identity matrix.
	 */


	Matrix.prototype.setToTranslation = function (x, y, z) {
	  this[0] = 1;
	  this[1] = 0;
	  this[2] = 0;
	  this[3] = x;
	  this[4] = 0;
	  this[5] = 1;
	  this[6] = 0;
	  this[7] = y;
	  this[8] = 0;
	  this[9] = 0;
	  this[10] = 1;
	  this[11] = z;
	  this[12] = 0;
	  this[13] = 0;
	  this[14] = 0;
	  this[15] = 1;
	  return this;
	};
	/**
	 * Sets the translation components of this matrix to specified values.
	 * @param {Number} x The X translation component.
	 * @param {Number} y The Y translation component.
	 * @param {Number} z The Z translation component.
	 * @returns {Matrix} This matrix with its translation components set to the specified values and all other
	 * components unmodified.
	 */


	Matrix.prototype.setTranslation = function (x, y, z) {
	  this[3] = x;
	  this[7] = y;
	  this[11] = z;
	  return this;
	};
	/**
	 * Sets this matrix to a scale matrix with specified scale components.
	 * @param {Number} xScale The X scale component.
	 * @param {Number} yScale The Y scale component.
	 * @param {Number} zScale The Z scale component.
	 * @returns {Matrix} This matrix with its scale components set to those specified and all other
	 * components set to that of an identity matrix.
	 */


	Matrix.prototype.setToScale = function (xScale, yScale, zScale) {
	  this[0] = xScale;
	  this[1] = 0;
	  this[2] = 0;
	  this[3] = 0;
	  this[4] = 0;
	  this[5] = yScale;
	  this[6] = 0;
	  this[7] = 0;
	  this[8] = 0;
	  this[9] = 0;
	  this[10] = zScale;
	  this[11] = 0;
	  this[12] = 0;
	  this[13] = 0;
	  this[14] = 0;
	  this[15] = 1;
	  return this;
	};
	/**
	 * Sets the scale components of this matrix to specified values.
	 * @param {Number} xScale The X scale component.
	 * @param {Number} yScale The Y scale component.
	 * @param {Number} zScale The Z scale component.
	 * @returns {Matrix} This matrix with its scale components set to the specified values and all other
	 * components unmodified.
	 */


	Matrix.prototype.setScale = function (xScale, yScale, zScale) {
	  this[0] = xScale;
	  this[5] = yScale;
	  this[10] = zScale;
	  return this;
	};
	/**
	 * Sets this matrix to the transpose of a specified matrix.
	 * @param {Matrix} matrix The matrix whose transpose is to be copied.
	 * @returns {Matrix} This matrix, with its values set to the transpose of the specified matrix.
	 * @throws {ArgumentError} If the specified matrix in null or undefined.
	 */


	Matrix.prototype.setToTransposeOfMatrix = function (matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "setToTransposeOfMatrix", "missingMatrix"));
	  }

	  this[0] = matrix[0];
	  this[1] = matrix[4];
	  this[2] = matrix[8];
	  this[3] = matrix[12];
	  this[4] = matrix[1];
	  this[5] = matrix[5];
	  this[6] = matrix[9];
	  this[7] = matrix[13];
	  this[8] = matrix[2];
	  this[9] = matrix[6];
	  this[10] = matrix[10];
	  this[11] = matrix[14];
	  this[12] = matrix[3];
	  this[13] = matrix[7];
	  this[14] = matrix[11];
	  this[15] = matrix[15];
	  return this;
	};
	/**
	 * Sets this matrix to the matrix product of two specified matrices.
	 * @param {Matrix} matrixA The first matrix multiplicand.
	 * @param {Matrix} matrixB The second matrix multiplicand.
	 * @returns {Matrix} This matrix set to the product of matrixA x matrixB.
	 * @throws {ArgumentError} If either specified matrix is null or undefined.
	 */


	Matrix.prototype.setToMultiply = function (matrixA, matrixB) {
	  if (!matrixA || !matrixB) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "setToMultiply", "missingMatrix"));
	  }

	  var ma = matrixA,
	      mb = matrixB;
	  this[0] = ma[0] * mb[0] + ma[1] * mb[4] + ma[2] * mb[8] + ma[3] * mb[12];
	  this[1] = ma[0] * mb[1] + ma[1] * mb[5] + ma[2] * mb[9] + ma[3] * mb[13];
	  this[2] = ma[0] * mb[2] + ma[1] * mb[6] + ma[2] * mb[10] + ma[3] * mb[14];
	  this[3] = ma[0] * mb[3] + ma[1] * mb[7] + ma[2] * mb[11] + ma[3] * mb[15];
	  this[4] = ma[4] * mb[0] + ma[5] * mb[4] + ma[6] * mb[8] + ma[7] * mb[12];
	  this[5] = ma[4] * mb[1] + ma[5] * mb[5] + ma[6] * mb[9] + ma[7] * mb[13];
	  this[6] = ma[4] * mb[2] + ma[5] * mb[6] + ma[6] * mb[10] + ma[7] * mb[14];
	  this[7] = ma[4] * mb[3] + ma[5] * mb[7] + ma[6] * mb[11] + ma[7] * mb[15];
	  this[8] = ma[8] * mb[0] + ma[9] * mb[4] + ma[10] * mb[8] + ma[11] * mb[12];
	  this[9] = ma[8] * mb[1] + ma[9] * mb[5] + ma[10] * mb[9] + ma[11] * mb[13];
	  this[10] = ma[8] * mb[2] + ma[9] * mb[6] + ma[10] * mb[10] + ma[11] * mb[14];
	  this[11] = ma[8] * mb[3] + ma[9] * mb[7] + ma[10] * mb[11] + ma[11] * mb[15];
	  this[12] = ma[12] * mb[0] + ma[13] * mb[4] + ma[14] * mb[8] + ma[15] * mb[12];
	  this[13] = ma[12] * mb[1] + ma[13] * mb[5] + ma[14] * mb[9] + ma[15] * mb[13];
	  this[14] = ma[12] * mb[2] + ma[13] * mb[6] + ma[14] * mb[10] + ma[15] * mb[14];
	  this[15] = ma[12] * mb[3] + ma[13] * mb[7] + ma[14] * mb[11] + ma[15] * mb[15];
	  return this;
	};
	/**
	 * Sets this matrix to the symmetric covariance Matrix computed from the x, y, z coordinates of a specified
	 * points array.
	 * <p/>
	 * The computed covariance matrix represents the correlation between each pair of x-, y-, and z-coordinates as
	 * they're distributed about the point array's arithmetic mean. Its layout is as follows:
	 * <p/>
	 * <code> C(x, x)  C(x, y)  C(x, z) <br/> C(x, y)  C(y, y)  C(y, z) <br/> C(x, z)  C(y, z)  C(z, z) </code>
	 * <p/>
	 * C(i, j) is the covariance of coordinates i and j, where i or j are a coordinate's dispersion about its mean
	 * value. If any entry is zero, then there's no correlation between the two coordinates defining that entry. If the
	 * returned matrix is diagonal, then all three coordinates are uncorrelated, and the specified point is
	 * distributed evenly about its mean point.
	 * @param {Float32Array | Float64Array | Number[]} points The points to consider.
	 * @returns {Matrix} This matrix set to the covariance matrix for the specified list of points.
	 * @throws {ArgumentError} If the specified array of points is null, undefined or empty.
	 */


	Matrix.prototype.setToCovarianceOfPoints = function (points) {
	  if (!points || points.length < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "setToCovarianceOfPoints", "missingArray"));
	  }

	  var mean,
	      dx,
	      dy,
	      dz,
	      count = 0,
	      c11 = 0,
	      c22 = 0,
	      c33 = 0,
	      c12 = 0,
	      c13 = 0,
	      c23 = 0,
	      vec = new Vec3$1(0, 0, 0);
	  mean = Vec3$1.averageOfBuffer(points, new Vec3$1(0, 0, 0));

	  for (var i = 0, len = points.length / 3; i < len; i++) {
	    vec[0] = points[i * 3];
	    vec[1] = points[i * 3 + 1];
	    vec[2] = points[i * 3 + 2];
	    dx = vec[0] - mean[0];
	    dy = vec[1] - mean[1];
	    dz = vec[2] - mean[2];
	    ++count;
	    c11 += dx * dx;
	    c22 += dy * dy;
	    c33 += dz * dz;
	    c12 += dx * dy; // c12 = c21

	    c13 += dx * dz; // c13 = c31

	    c23 += dy * dz; // c23 = c32
	  } // Row 1


	  this[0] = c11 / count;
	  this[1] = c12 / count;
	  this[2] = c13 / count;
	  this[3] = 0; // Row 2

	  this[4] = c12 / count;
	  this[5] = c22 / count;
	  this[6] = c23 / count;
	  this[7] = 0; // Row 3

	  this[8] = c13 / count;
	  this[9] = c23 / count;
	  this[10] = c33 / count;
	  this[11] = 0; // Row 4

	  this[12] = 0;
	  this[13] = 0;
	  this[14] = 0;
	  this[15] = 0;
	  return this;
	};
	/**
	 * Multiplies this matrix by a translation matrix with specified translation values.
	 * @param {Number} x The X translation component.
	 * @param {Number} y The Y translation component.
	 * @param {Number} z The Z translation component.
	 * @returns {Matrix} This matrix multiplied by the translation matrix implied by the specified values.
	 */


	Matrix.prototype.multiplyByTranslation = function (x, y, z) {
	  this.multiply(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
	  return this;
	};
	/**
	 * Multiplies this matrix by a rotation matrix about a specified axis and angle.
	 * @param {Number} x The X component of the rotation axis.
	 * @param {Number} y The Y component of the rotation axis.
	 * @param {Number} z The Z component of the rotation axis.
	 * @param {Number} angleDegrees The angle to rotate, in degrees.
	 * @returns {Matrix} This matrix multiplied by the rotation matrix implied by the specified values.
	 */


	Matrix.prototype.multiplyByRotation = function (x, y, z, angleDegrees) {
	  var c = Math.cos(angleDegrees * Angle.DEGREES_TO_RADIANS),
	      s = Math.sin(angleDegrees * Angle.DEGREES_TO_RADIANS);
	  this.multiply(c + (1 - c) * x * x, (1 - c) * x * y - s * z, (1 - c) * x * z + s * y, 0, (1 - c) * x * y + s * z, c + (1 - c) * y * y, (1 - c) * y * z - s * x, 0, (1 - c) * x * z - s * y, (1 - c) * y * z + s * x, c + (1 - c) * z * z, 0, 0, 0, 0, 1);
	  return this;
	};
	/**
	 * Multiplies this matrix by a scale matrix with specified values.
	 * @param {Number} xScale The X scale component.
	 * @param {Number} yScale The Y scale component.
	 * @param {Number} zScale The Z scale component.
	 * @returns {Matrix} This matrix multiplied by the scale matrix implied by the specified values.
	 */


	Matrix.prototype.multiplyByScale = function (xScale, yScale, zScale) {
	  this.multiply(xScale, 0, 0, 0, 0, yScale, 0, 0, 0, 0, zScale, 0, 0, 0, 0, 1);
	  return this;
	};
	/**
	 * Sets this matrix to one that flips and shifts the y-axis.
	 * <p>
	 * The resultant matrix maps Y=0 to Y=1 and Y=1 to Y=0. All existing values are overwritten. This matrix is
	 * usually used to change the coordinate origin from an upper left coordinate origin to a lower left coordinate
	 * origin. This is typically necessary to align the coordinate system of images (top-left origin) with that of
	 * OpenGL (bottom-left origin).
	 * @returns {Matrix} This matrix set to values described above.
	 */


	Matrix.prototype.setToUnitYFlip = function () {
	  this[0] = 1;
	  this[1] = 0;
	  this[2] = 0;
	  this[3] = 0;
	  this[4] = 0;
	  this[5] = -1;
	  this[6] = 0;
	  this[7] = 1;
	  this[8] = 0;
	  this[9] = 0;
	  this[10] = 1;
	  this[11] = 0;
	  this[12] = 0;
	  this[13] = 0;
	  this[14] = 0;
	  this[15] = 1;
	  return this;
	};
	/**
	 * Multiplies this matrix by a local coordinate system transform for the specified globe.
	 * <p>
	 * The local coordinate system is defined such that the local origin (0, 0, 0) maps to the specified origin
	 * point, the z axis maps to the globe's surface normal at the point, the y-axis maps to the north pointing
	 * tangent, and the x-axis maps to the east pointing tangent.
	 *
	 * @param {Vec3} origin The local coordinate system origin, in model coordinates.
	 * @param {Globe} globe The globe the coordinate system is relative to.
	 *
	 * @throws {ArgumentError} If either argument is null or undefined.
	 */


	Matrix.prototype.multiplyByLocalCoordinateTransform = function (origin, globe) {
	  if (!origin) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "multiplyByLocalCoordinateTransform", "Origin vector is null or undefined"));
	  }

	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "multiplyByLocalCoordinateTransform", "missingGlobe"));
	  }

	  var xAxis = new Vec3$1(0, 0, 0),
	      yAxis = new Vec3$1(0, 0, 0),
	      zAxis = new Vec3$1(0, 0, 0);
	  WWMath.localCoordinateAxesAtPoint(origin, globe, xAxis, yAxis, zAxis);
	  this.multiply(xAxis[0], yAxis[0], zAxis[0], origin[0], xAxis[1], yAxis[1], zAxis[1], origin[1], xAxis[2], yAxis[2], zAxis[2], origin[2], 0, 0, 0, 1);
	  return this;
	};
	/**
	 * Multiplies this matrix by a texture transform for the specified texture.
	 * <p>
	 * A texture image transform maps the bottom-left corner of the texture's image data to coordinate [0,0] and maps the
	 * top-right of the texture's image data to coordinate [1,1]. This correctly handles textures whose image data has
	 * non-power-of-two dimensions, and correctly orients textures whose image data has its origin in the upper-left corner.
	 *
	 * @param {Texture} texture The texture to multiply a transform for.
	 *
	 * @throws {ArgumentError} If the texture is null or undefined.
	 */


	Matrix.prototype.multiplyByTextureTransform = function (texture) {
	  if (!texture) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "multiplyByTextureTransform", "missingTexture"));
	  } // Compute the scale necessary to map the edge of the image data to the range [0,1]. When the texture contains
	  // power-of-two image data the scale is 1 and has no effect. Otherwise, the scale is computed such that the portion
	  // of the texture containing image data maps to the range [0,1].


	  var sx = texture.originalImageWidth / texture.imageWidth,
	      sy = texture.originalImageHeight / texture.imageHeight; // Multiply this by a scaling matrix that maps the texture's image data to the range [0,1] and inverts the y axis.
	  // We have precomputed the result here in order to avoid an unnecessary matrix multiplication.

	  this.multiply(sx, 0, 0, 0, 0, -sy, 0, sy, 0, 0, 1, 0, 0, 0, 0, 1);
	  return this;
	};
	/**
	 * Returns the translation components of this matrix.
	 * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the translation components.
	 * @returns {Vec3} The specified result argument set to the translation components of this matrix.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Matrix.prototype.extractTranslation = function (result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "extractTranslation", "missingResult"));
	  }

	  result[0] = this[3];
	  result[1] = this[7];
	  result[2] = this[11];
	  return result;
	};
	/**
	 * Returns the rotation angles of this matrix.
	 * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the rotation angles.
	 * @returns {Vec3} The specified result argument set to the rotation angles of this matrix. The angles are in
	 * degrees.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Matrix.prototype.extractRotationAngles = function (result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "extractRotationAngles", "missingResult"));
	  } // Taken from Extracting Euler Angles from a Rotation Matrix by Mike Day, Insomniac Games.
	  // http://www.insomniacgames.com/mike-day-extracting-euler-angles-from-a-rotation-matrix/


	  var x = Math.atan2(this[6], this[10]),
	      y = Math.atan2(-this[2], Math.sqrt(this[0] * this[0] + this[1] * this[1])),
	      cx = Math.cos(x),
	      sx = Math.sin(x),
	      z = Math.atan2(sx * this[8] - cx * this[4], cx * this[5] - sx * this[9]);
	  result[0] = x * Angle.RADIANS_TO_DEGREES;
	  result[1] = y * Angle.RADIANS_TO_DEGREES;
	  result[2] = z * Angle.RADIANS_TO_DEGREES;
	  return result;
	};
	/**
	 * Multiplies this matrix by a first person viewing matrix for the specified globe.
	 * <p>
	 * A first person viewing matrix places the viewer's eye at the specified eyePosition. By default the viewer is looking
	 * straight down at the globe's surface from the eye position, with the globe's normal vector coming out of the screen
	 * and north pointing toward the top of the screen.
	 * <p>
	 * Heading specifies the viewer's azimuth, or its angle relative to North. Heading values range from -180 degrees to 180
	 * degrees. A heading of 0 degrees looks North, 90 degrees looks East, +-180 degrees looks South, and -90 degrees looks
	 * West.
	 * <p>
	 * Tilt specifies the viewer's angle relative to the surface. Tilt values range from -180 degrees to 180 degrees. A tilt
	 * of 0 degrees looks straight down at the globe's surface, 90 degrees looks at the horizon, and 180 degrees looks
	 * straight up. Tilt values greater than 180 degrees cause the viewer to turn upside down, and are therefore rarely used.
	 * <p>
	 * Roll specifies the viewer's angle relative to the horizon. Roll values range from -180 degrees to 180 degrees. A roll
	 * of 0 degrees orients the viewer so that up is pointing to the top of the screen, at 90 degrees up is pointing to the
	 * right, at +-180 degrees up is pointing to the bottom, and at -90 up is pointing to the left.
	 *
	 * @param {Position} eyePosition The viewer's geographic eye position relative to the specified globe.
	 * @param {Number} heading The viewer's angle relative to north, in degrees.
	 * @param {Number} tilt The viewer's angle relative to the surface, in degrees.
	 * @param {Number} roll The viewer's angle relative to the horizon, in degrees.
	 * @param {Globe} globe The globe the viewer is looking at.
	 *
	 * @throws {ArgumentError} If the specified position or globe is null or undefined.
	 */


	Matrix.prototype.multiplyByFirstPersonModelview = function (eyePosition, heading, tilt, roll, globe) {
	  if (!eyePosition) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "multiplyByFirstPersonModelview", "missingPosition"));
	  }

	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "multiplyByFirstPersonModelview", "missingGlobe"));
	  }

	  var c,
	      s,
	      ex,
	      ey,
	      ez,
	      xx,
	      xy,
	      xz,
	      yx,
	      yy,
	      yz,
	      zx,
	      zy,
	      zz,
	      eyePoint = new Vec3$1(0, 0, 0),
	      xAxis = new Vec3$1(0, 0, 0),
	      yAxis = new Vec3$1(0, 0, 0),
	      zAxis = new Vec3$1(0, 0, 0); // Roll. Rotate the eye point in a counter-clockwise direction about the z axis. Note that we invert the sines used
	  // in the rotation matrix in order to produce the counter-clockwise rotation. We invert only the cosines since
	  // sin(-a) = -sin(a) and cos(-a) = cos(a).

	  c = Math.cos(roll * Angle.DEGREES_TO_RADIANS);
	  s = Math.sin(roll * Angle.DEGREES_TO_RADIANS);
	  this.multiply(c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); // Tilt. Rotate the eye point in a counter-clockwise direction about the x axis. Note that we invert the sines used
	  // in the rotation matrix in order to produce the counter-clockwise rotation. We invert only the cosines since
	  // sin(-a) = -sin(a) and cos(-a) = cos(a).

	  c = Math.cos(tilt * Angle.DEGREES_TO_RADIANS);
	  s = Math.sin(tilt * Angle.DEGREES_TO_RADIANS);
	  this.multiply(1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1); // Heading. Rotate the eye point in a clockwise direction about the z axis again. This has a different effect than
	  // roll when tilt is non-zero because the viewer is no longer looking down the z axis.

	  c = Math.cos(heading * Angle.DEGREES_TO_RADIANS);
	  s = Math.sin(heading * Angle.DEGREES_TO_RADIANS);
	  this.multiply(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); // Compute the eye point in model coordinates. This point is mapped to the origin in the look at transform below.

	  globe.computePointFromPosition(eyePosition.latitude, eyePosition.longitude, eyePosition.altitude, eyePoint);
	  ex = eyePoint[0];
	  ey = eyePoint[1];
	  ez = eyePoint[2]; // Transform the origin to the local coordinate system at the eye point.

	  WWMath.localCoordinateAxesAtPoint(eyePoint, globe, xAxis, yAxis, zAxis);
	  xx = xAxis[0];
	  xy = xAxis[1];
	  xz = xAxis[2];
	  yx = yAxis[0];
	  yy = yAxis[1];
	  yz = yAxis[2];
	  zx = zAxis[0];
	  zy = zAxis[1];
	  zz = zAxis[2];
	  this.multiply(xx, xy, xz, -xx * ex - xy * ey - xz * ez, yx, yy, yz, -yx * ex - yy * ey - yz * ez, zx, zy, zz, -zx * ex - zy * ey - zz * ez, 0, 0, 0, 1);
	  return this;
	};
	/**
	 * Multiplies this matrix by a look at viewing matrix for the specified globe.
	 * <p>
	 * A look at viewing matrix places the center of the screen at the specified lookAtPosition. By default the viewer is
	 * looking straight down at the look at position from the specified range, with the globe's normal vector coming out of
	 * the screen and north pointing toward the top of the screen.
	 * <p>
	 * Range specifies the distance between the look at position and the viewer's eye point. Range values may be any positive
	 * real number. A range of 0 places the eye point at the look at point, while a positive range moves the eye point away
	 * from but still looking at the look at point.
	 * <p>
	 * Heading specifies the viewer's azimuth, or its angle relative to North. Heading values range from -180 degrees to 180
	 * degrees. A heading of 0 degrees looks North, 90 degrees looks East, +-180 degrees looks South, and -90 degrees looks
	 * West.
	 * <p>
	 * Tilt specifies the viewer's angle relative to the surface. Tilt values range from -180 degrees to 180 degrees. A tilt
	 * of 0 degrees looks straight down at the globe's surface, 90 degrees looks at the horizon, and 180 degrees looks
	 * straight up. Tilt values greater than 180 degrees cause the viewer to turn upside down, and are therefore rarely used.
	 * <p>
	 * Roll specifies the viewer's angle relative to the horizon. Roll values range from -180 degrees to 180 degrees. A roll
	 * of 0 degrees orients the viewer so that up is pointing to the top of the screen, at 90 degrees up is pointing to the
	 * right, at +-180 degrees up is pointing to the bottom, and at -90 up is pointing to the left.
	 *
	 * @param {Position} lookAtPosition The viewer's geographic look at position relative to the specified globe.
	 * @param {Number} range The distance between the eye point and the look at point, in model coordinates.
	 * @param {Number} heading The viewer's angle relative to north, in degrees.
	 * @param {Number} tilt The viewer's angle relative to the surface, in degrees.
	 * @param {Number} roll The viewer's angle relative to the horizon, in degrees.
	 * @param {Globe} globe The globe the viewer is looking at.
	 *
	 * @throws {ArgumentError} If either the specified look-at position or globe is null or undefined, or the
	 * specified range is less than zero.
	 */


	Matrix.prototype.multiplyByLookAtModelview = function (lookAtPosition, range, heading, tilt, roll, globe) {
	  if (!lookAtPosition) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "multiplyByLookAtModelview", "missingPosition"));
	  }

	  if (range < 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "multiplyByLookAtModelview", "Range is less than zero"));
	  }

	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "multiplyByLookAtModelview", "missingGlobe"));
	  } // Translate the eye point along the positive z axis while keeping the look at point in the center of the viewport.


	  this.multiplyByTranslation(0, 0, -range); // Transform the origin to the local coordinate system at the look at position, and rotate the viewer by the
	  // specified heading, tilt and roll.

	  this.multiplyByFirstPersonModelview(lookAtPosition, heading, tilt, roll, globe);
	  return this;
	};
	/**
	 * Sets this matrix to a perspective projection matrix for the specified viewport dimensions and clip distances.
	 * <p>
	 * A perspective projection matrix maps points in eye coordinates into clip coordinates in a way that causes
	 * distant objects to appear smaller, and preserves the appropriate depth information for each point. In model
	 * coordinates, a perspective projection is defined by frustum originating at the eye position and extending
	 * outward in the viewer's direction. The near distance and the far distance identify the minimum and maximum
	 * distance, respectively, at which an object in the scene is visible. Near and far distances must be positive
	 * and may not be equal.
	 *
	 * @param {Number} viewportWidth The viewport width, in screen coordinates.
	 * @param {Number} viewportHeight The viewport height, in screen coordinates.
	 * @param {Number} nearDistance The near clip plane distance, in model coordinates.
	 * @param {Number} farDistance The far clip plane distance, in model coordinates.
	 * @throws {ArgumentError} If the specified width or height is less than or equal to zero, if the near and far
	 * distances are equal, or if either the near or far distance are less than or equal to zero.
	 */


	Matrix.prototype.setToPerspectiveProjection = function (viewportWidth, viewportHeight, nearDistance, farDistance) {
	  if (viewportWidth <= 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection", "invalidWidth"));
	  }

	  if (viewportHeight <= 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection", "invalidHeight"));
	  }

	  if (nearDistance === farDistance) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection", "Near and far distance are the same."));
	  }

	  if (nearDistance <= 0 || farDistance <= 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "setToPerspectiveProjection", "Near or far distance is less than or equal to zero."));
	  } // Compute the dimensions of the viewport rectangle at the near distance.


	  var nearRect = WWMath.perspectiveFrustumRectangle(viewportWidth, viewportHeight, nearDistance),
	      left = nearRect.getMinX(),
	      right = nearRect.getMaxX(),
	      bottom = nearRect.getMinY(),
	      top = nearRect.getMaxY(); // Taken from Mathematics for 3D Game Programming and Computer Graphics, Second Edition, equation 4.52.
	  // Row 1

	  this[0] = 2 * nearDistance / (right - left);
	  this[1] = 0;
	  this[2] = (right + left) / (right - left);
	  this[3] = 0; // Row 2

	  this[4] = 0;
	  this[5] = 2 * nearDistance / (top - bottom);
	  this[6] = (top + bottom) / (top - bottom);
	  this[7] = 0; // Row 3

	  this[8] = 0;
	  this[9] = 0;
	  this[10] = -(farDistance + nearDistance) / (farDistance - nearDistance);
	  this[11] = -2 * nearDistance * farDistance / (farDistance - nearDistance); // Row 4

	  this[12] = 0;
	  this[13] = 0;
	  this[14] = -1;
	  this[15] = 0;
	  return this;
	};
	/**
	 * Sets this matrix to a screen projection matrix for the specified viewport dimensions.
	 * <p>
	 * A screen projection matrix is an orthographic projection that assumes that points in model coordinates
	 * represent a screen point and a depth. Screen projection matrices therefore map model coordinates directly
	 * into screen coordinates without modification. A point's xy coordinates are interpreted as literal screen
	 * coordinates and must be in the viewport to be visible. A point's z coordinate is interpreted as a depth value
	 * that ranges from 0 to 1. Additionally, the screen projection matrix preserves the depth value returned by
	 * [DrawContext.project]{@link DrawContext#project}.
	 *
	 * @param {Number} viewportWidth The viewport width, in screen coordinates.
	 * @param {Number} viewportHeight The viewport height, in screen coordinates.
	 * @throws {ArgumentError} If the specified width or height is less than or equal to zero.
	 */


	Matrix.prototype.setToScreenProjection = function (viewportWidth, viewportHeight) {
	  if (viewportWidth <= 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "setToScreenProjection", "invalidWidth"));
	  }

	  if (viewportHeight <= 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "setToScreenProjection", "invalidHeight"));
	  } // Taken from Mathematics for 3D Game Programming and Computer Graphics, Second Edition, equation 4.57.
	  // Simplified to assume that the viewport origin is (0, 0).
	  //
	  // The third row of this projection matrix is configured so that points with z coordinates representing
	  // depth values ranging from 0 to 1 are not modified after transformation into window coordinates. This
	  // projection matrix maps z values in the range [0, 1] to the range [-1, 1] by applying the following
	  // function to incoming z coordinates:
	  //
	  // zp = z0 * 2 - 1
	  //
	  // Where 'z0' is the point's z coordinate and 'zp' is the projected z coordinate. The GPU then maps the
	  // projected z coordinate into window coordinates in the range [0, 1] by applying the following function:
	  //
	  // zw = zp * 0.5 + 0.5
	  //
	  // The result is that a point's z coordinate is effectively passed to the GPU without modification.
	  // Row 1


	  this[0] = 2 / viewportWidth;
	  this[1] = 0;
	  this[2] = 0;
	  this[3] = -1; // Row 2

	  this[4] = 0;
	  this[5] = 2 / viewportHeight;
	  this[6] = 0;
	  this[7] = -1; // Row 3

	  this[8] = 0;
	  this[9] = 0;
	  this[10] = 2;
	  this[11] = -1; // Row 4

	  this[12] = 0;
	  this[13] = 0;
	  this[14] = 0;
	  this[15] = 1;
	  return this;
	};
	/**
	 * Returns this viewing matrix's eye point.
	 * <p>
	 * This method assumes that this matrix represents a viewing matrix. If this does not represent a viewing matrix the
	 * results are undefined.
	 * <p>
	 * In model coordinates, a viewing matrix's eye point is the point the viewer is looking from and maps to the center of
	 * the screen.
	 *
	 * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the extracted values.
	 * @return {Vec3} The specified result argument containing the viewing matrix's eye point, in model coordinates.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Matrix.prototype.extractEyePoint = function (result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "extractEyePoint", "missingResult"));
	  } // The eye point of a modelview matrix is computed by transforming the origin (0, 0, 0, 1) by the matrix's inverse.
	  // This is equivalent to transforming the inverse of this matrix's translation components in the rightmost column by
	  // the transpose of its upper 3x3 components.


	  result[0] = -(this[0] * this[3]) - this[4] * this[7] - this[8] * this[11];
	  result[1] = -(this[1] * this[3]) - this[5] * this[7] - this[9] * this[11];
	  result[2] = -(this[2] * this[3]) - this[6] * this[7] - this[10] * this[11];
	  return result;
	};
	/**
	 * Returns this viewing matrix's forward vector.
	 * <p>
	 * This method assumes that this matrix represents a viewing matrix. If this does not represent a viewing matrix the
	 * results are undefined.
	 *
	 * @param {Vec3} result A pre-allocated {@link Vec3} in which to return the extracted values.
	 * @return {Vec3} The specified result argument containing the viewing matrix's forward vector, in model coordinates.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Matrix.prototype.extractForwardVector = function (result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "extractForwardVector", "missingResult"));
	  } // The forward vector of a modelview matrix is computed by transforming the negative Z axis (0, 0, -1, 0) by the
	  // matrix's inverse. We have pre-computed the result inline here to simplify this computation.


	  result[0] = -this[8];
	  result[1] = -this[9];
	  result[2] = -this[10];
	  return result;
	};
	/**
	 * Extracts this viewing matrix's parameters given a viewing origin and a globe.
	 * <p>
	 * This method assumes that this matrix represents a viewing matrix. If this does not represent a viewing matrix the
	 * results are undefined.
	 * <p>
	 * This returns a parameterization of this viewing matrix based on the specified origin and globe. The origin indicates
	 * the model coordinate point that the view's orientation is relative to, while the globe provides the necessary model
	 * coordinate context for the origin and the orientation. The origin should be either the view's eye point or a point on
	 * the view's forward vector. The view's roll must be specified in order to disambiguate heading and roll when the view's
	 * tilt is zero.
	 * <p>
	 * The following list outlines the returned key-value pairs and their meanings:
	 * <ul>
	 * <li> 'origin' - The geographic position corresponding to the origin point.</li>
	 * <li> 'range' - The distance between the specified origin point and the view's eye point, in model coordinates.</li>
	 * <li> 'heading' - The view's heading angle relative to the globe's north pointing tangent at the origin point, in degrees.</li>
	 * <li> 'tilt' - The view's tilt angle relative to the globe's normal vector at the origin point, in degrees.</li>
	 * <li> 'roll' - The view's roll relative to the globe's normal vector at the origin point, in degrees.</li>
	 * </ul>
	 * @param {Vec3} origin The origin of the viewing parameters, in model coordinates.
	 * @param {Number} roll The view's roll, in degrees.
	 * @param {Globe} globe The globe the viewer is looking at.
	 * @param {Object} result A pre-allocated object in which to return the viewing parameters.
	 *
	 * @return {Object} The specified result argument containing a parameterization of this viewing matrix.
	 *
	 * @throws {ArgumentError} If either the specified origin or globe are null or undefined or the specified
	 * result argument is null or undefined.
	 */


	Matrix.prototype.extractViewingParameters = function (origin, roll, globe, result) {
	  if (!origin) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "extractViewingParameters", "The specified origin is null or undefined."));
	  }

	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "extractViewingParameters", "missingGlobe"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "extractViewingParameters", "missingResult"));
	  }

	  var originPos = new Position(0, 0, 0),
	      modelviewLocal = Matrix.fromIdentity(),
	      range,
	      ct,
	      st,
	      tilt,
	      cr,
	      sr,
	      ch,
	      sh,
	      heading;
	  globe.computePositionFromPoint(origin[0], origin[1], origin[2], originPos); // Transform the modelview matrix to a local coordinate system at the origin. This eliminates the geographic
	  // transform contained in the modelview matrix while maintaining rotation and translation relative to the origin.

	  modelviewLocal.copy(this);
	  modelviewLocal.multiplyByLocalCoordinateTransform(origin, globe);
	  range = -modelviewLocal[11];
	  ct = modelviewLocal[10];
	  st = Math.sqrt(modelviewLocal[2] * modelviewLocal[2] + modelviewLocal[6] * modelviewLocal[6]);
	  tilt = Math.atan2(st, ct) * Angle.RADIANS_TO_DEGREES;
	  cr = Math.cos(roll * Angle.DEGREES_TO_RADIANS);
	  sr = Math.sin(roll * Angle.DEGREES_TO_RADIANS);
	  ch = cr * modelviewLocal[0] - sr * modelviewLocal[4];
	  sh = sr * modelviewLocal[5] - cr * modelviewLocal[1];
	  heading = Math.atan2(sh, ch) * Angle.RADIANS_TO_DEGREES;
	  result['origin'] = originPos;
	  result['range'] = range;
	  result['heading'] = heading;
	  result['tilt'] = tilt;
	  result['roll'] = roll;
	  return result;
	};
	/**
	 * Applies a specified depth offset to this projection matrix.
	 * <p>
	 * This method assumes that this matrix represents a projection matrix. If this does not represent a projection
	 * matrix the results are undefined. Projection matrices can be created by calling
	 * [setToPerspectiveProjection]{@link Matrix#setToPerspectiveProjection} or [setToScreenProjection]{@link Matrix#setToScreenProjection}.
	 * <p>
	 * The depth offset may be any real number and is typically used to draw geometry slightly closer to the user's
	 * eye in order to give those shapes visual priority over nearby or geometry. An offset of zero has no effect.
	 * An offset less than zero brings depth values closer to the eye, while an offset greater than zero pushes
	 * depth values away from the eye.
	 * <p>
	 * Depth offset may be applied to both perspective and orthographic projection matrices. The effect on each
	 * projection type is outlined here:
	 * <p>
	 * <strong>Perspective Projection</strong>
	 * <p>
	 * The effect of depth offset on a perspective projection increases exponentially with distance from the eye.
	 * This has the effect of adjusting the offset for the loss in depth precision with geometry drawn further from
	 * the eye. Distant geometry requires a greater offset to differentiate itself from nearby geometry, while close
	 * geometry does not.
	 * <p>
	 * <strong>Orthographic Projection</strong>
	 * <p>
	 * The effect of depth offset on an orthographic projection increases linearly with distance from the eye. While
	 * it is reasonable to apply a depth offset to an orthographic projection, the effect is most appropriate when
	 * applied to the projection used to draw the scene. For example, when an object's coordinates are projected by
	 * a perspective projection into screen coordinates then drawn using an orthographic projection, it is best to
	 * apply the offset to the original perspective projection. The method [DrawContext.project]{@link DrawContext#project} performs the
	 * correct behavior for the projection type used to draw the scene.
	 *
	 * @param {Number} depthOffset The amount of offset to apply.
	 * @returns {Matrix} This matrix with it's depth offset set to the specified offset.
	 */


	Matrix.prototype.offsetProjectionDepth = function (depthOffset) {
	  this[10] *= 1 + depthOffset;
	  return this;
	};
	/**
	 * Multiplies this matrix by a specified matrix.
	 *
	 * @param {Matrix} matrix The matrix to multiply with this matrix.
	 * @returns {Matrix} This matrix after multiplying it by the specified matrix.
	 * @throws {ArgumentError} if the specified matrix is null or undefined.
	 */


	Matrix.prototype.multiplyMatrix = function (matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "multiplyMatrix", "missingMatrix"));
	  }

	  var ma = this,
	      mb = matrix,
	      ma0,
	      ma1,
	      ma2,
	      ma3; // Row 1

	  ma0 = ma[0];
	  ma1 = ma[1];
	  ma2 = ma[2];
	  ma3 = ma[3];
	  ma[0] = ma0 * mb[0] + ma1 * mb[4] + ma2 * mb[8] + ma3 * mb[12];
	  ma[1] = ma0 * mb[1] + ma1 * mb[5] + ma2 * mb[9] + ma3 * mb[13];
	  ma[2] = ma0 * mb[2] + ma1 * mb[6] + ma2 * mb[10] + ma3 * mb[14];
	  ma[3] = ma0 * mb[3] + ma1 * mb[7] + ma2 * mb[11] + ma3 * mb[15]; // Row 2

	  ma0 = ma[4];
	  ma1 = ma[5];
	  ma2 = ma[6];
	  ma3 = ma[7];
	  ma[4] = ma0 * mb[0] + ma1 * mb[4] + ma2 * mb[8] + ma3 * mb[12];
	  ma[5] = ma0 * mb[1] + ma1 * mb[5] + ma2 * mb[9] + ma3 * mb[13];
	  ma[6] = ma0 * mb[2] + ma1 * mb[6] + ma2 * mb[10] + ma3 * mb[14];
	  ma[7] = ma0 * mb[3] + ma1 * mb[7] + ma2 * mb[11] + ma3 * mb[15]; // Row 3

	  ma0 = ma[8];
	  ma1 = ma[9];
	  ma2 = ma[10];
	  ma3 = ma[11];
	  ma[8] = ma0 * mb[0] + ma1 * mb[4] + ma2 * mb[8] + ma3 * mb[12];
	  ma[9] = ma0 * mb[1] + ma1 * mb[5] + ma2 * mb[9] + ma3 * mb[13];
	  ma[10] = ma0 * mb[2] + ma1 * mb[6] + ma2 * mb[10] + ma3 * mb[14];
	  ma[11] = ma0 * mb[3] + ma1 * mb[7] + ma2 * mb[11] + ma3 * mb[15]; // Row 4

	  ma0 = ma[12];
	  ma1 = ma[13];
	  ma2 = ma[14];
	  ma3 = ma[15];
	  ma[12] = ma0 * mb[0] + ma1 * mb[4] + ma2 * mb[8] + ma3 * mb[12];
	  ma[13] = ma0 * mb[1] + ma1 * mb[5] + ma2 * mb[9] + ma3 * mb[13];
	  ma[14] = ma0 * mb[2] + ma1 * mb[6] + ma2 * mb[10] + ma3 * mb[14];
	  ma[15] = ma0 * mb[3] + ma1 * mb[7] + ma2 * mb[11] + ma3 * mb[15];
	  return this;
	};
	/**
	 * Multiplies this matrix by a matrix specified by individual components.
	 *
	 * @param {Number} m00 matrix element at row 1, column 1.
	 * @param {Number} m01 matrix element at row 1, column 2.
	 * @param {Number} m02 matrix element at row 1, column 3.
	 * @param {Number} m03 matrix element at row 1, column 4.
	 * @param {Number} m10 matrix element at row 2, column 1.
	 * @param {Number} m11 matrix element at row 2, column 2.
	 * @param {Number} m12 matrix element at row 2, column 3.
	 * @param {Number} m13 matrix element at row 2, column 4.
	 * @param {Number} m20 matrix element at row 3, column 1.
	 * @param {Number} m21 matrix element at row 3, column 2.
	 * @param {Number} m22 matrix element at row 3, column 3.
	 * @param {Number} m23 matrix element at row 3, column 4.
	 * @param {Number} m30 matrix element at row 4, column 1.
	 * @param {Number} m31 matrix element at row 4, column 2.
	 * @param {Number} m32 matrix element at row 4, column 3.
	 * @param {Number} m33 matrix element at row 4, column 4.
	 * @returns {Matrix} This matrix with its components multiplied by the specified values.
	 */


	Matrix.prototype.multiply = function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
	  var ma = this,
	      ma0,
	      ma1,
	      ma2,
	      ma3; // Row 1

	  ma0 = ma[0];
	  ma1 = ma[1];
	  ma2 = ma[2];
	  ma3 = ma[3];
	  ma[0] = ma0 * m00 + ma1 * m10 + ma2 * m20 + ma3 * m30;
	  ma[1] = ma0 * m01 + ma1 * m11 + ma2 * m21 + ma3 * m31;
	  ma[2] = ma0 * m02 + ma1 * m12 + ma2 * m22 + ma3 * m32;
	  ma[3] = ma0 * m03 + ma1 * m13 + ma2 * m23 + ma3 * m33; // Row 2

	  ma0 = ma[4];
	  ma1 = ma[5];
	  ma2 = ma[6];
	  ma3 = ma[7];
	  ma[4] = ma0 * m00 + ma1 * m10 + ma2 * m20 + ma3 * m30;
	  ma[5] = ma0 * m01 + ma1 * m11 + ma2 * m21 + ma3 * m31;
	  ma[6] = ma0 * m02 + ma1 * m12 + ma2 * m22 + ma3 * m32;
	  ma[7] = ma0 * m03 + ma1 * m13 + ma2 * m23 + ma3 * m33; // Row 3

	  ma0 = ma[8];
	  ma1 = ma[9];
	  ma2 = ma[10];
	  ma3 = ma[11];
	  ma[8] = ma0 * m00 + ma1 * m10 + ma2 * m20 + ma3 * m30;
	  ma[9] = ma0 * m01 + ma1 * m11 + ma2 * m21 + ma3 * m31;
	  ma[10] = ma0 * m02 + ma1 * m12 + ma2 * m22 + ma3 * m32;
	  ma[11] = ma0 * m03 + ma1 * m13 + ma2 * m23 + ma3 * m33; // Row 4

	  ma0 = ma[12];
	  ma1 = ma[13];
	  ma2 = ma[14];
	  ma3 = ma[15];
	  ma[12] = ma0 * m00 + ma1 * m10 + ma2 * m20 + ma3 * m30;
	  ma[13] = ma0 * m01 + ma1 * m11 + ma2 * m21 + ma3 * m31;
	  ma[14] = ma0 * m02 + ma1 * m12 + ma2 * m22 + ma3 * m32;
	  ma[15] = ma0 * m03 + ma1 * m13 + ma2 * m23 + ma3 * m33;
	  return this;
	};
	/**
	 * Inverts the specified matrix and stores the result in this matrix.
	 * <p>
	 * This throws an exception if the specified matrix is singular.
	 * <p>
	 * The result of this method is undefined if this matrix is passed in as the matrix to invert.
	 *
	 * @param {Matrix} matrix The matrix whose inverse is computed.
	 * @returns {Matrix} This matrix set to the inverse of the specified matrix.
	 *
	 * @throws {ArgumentError} If the specified matrix is null, undefined or cannot be inverted.
	 */


	Matrix.prototype.invertMatrix = function (matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "invertMatrix", "missingMatrix"));
	  } // Copy the specified matrix into a mutable two-dimensional array.


	  var A = [[], [], [], []];
	  A[0][0] = matrix[0];
	  A[0][1] = matrix[1];
	  A[0][2] = matrix[2];
	  A[0][3] = matrix[3];
	  A[1][0] = matrix[4];
	  A[1][1] = matrix[5];
	  A[1][2] = matrix[6];
	  A[1][3] = matrix[7];
	  A[2][0] = matrix[8];
	  A[2][1] = matrix[9];
	  A[2][2] = matrix[10];
	  A[2][3] = matrix[11];
	  A[3][0] = matrix[12];
	  A[3][1] = matrix[13];
	  A[3][2] = matrix[14];
	  A[3][3] = matrix[15];
	  var index = [],
	      d = Matrix.ludcmp(A, index),
	      i,
	      j; // Compute the matrix's determinant.

	  for (i = 0; i < 4; i += 1) {
	    d *= A[i][i];
	  } // The matrix is singular if its determinant is zero or very close to zero.


	  if (Math.abs(d) < 1.0e-8) return null;
	  var Y = [[], [], [], []],
	      col = [];

	  for (j = 0; j < 4; j += 1) {
	    for (i = 0; i < 4; i += 1) {
	      col[i] = 0.0;
	    }

	    col[j] = 1.0;
	    Matrix.lubksb(A, index, col);

	    for (i = 0; i < 4; i += 1) {
	      Y[i][j] = col[i];
	    }
	  }

	  this[0] = Y[0][0];
	  this[1] = Y[0][1];
	  this[2] = Y[0][2];
	  this[3] = Y[0][3];
	  this[4] = Y[1][0];
	  this[5] = Y[1][1];
	  this[6] = Y[1][2];
	  this[7] = Y[1][3];
	  this[8] = Y[2][0];
	  this[9] = Y[2][1];
	  this[10] = Y[2][2];
	  this[11] = Y[2][3];
	  this[12] = Y[3][0];
	  this[13] = Y[3][1];
	  this[14] = Y[3][2];
	  this[15] = Y[3][3];
	  return this;
	};
	/* Internal. Intentionally not documented.
	 * Utility method to solve a linear system with an LU factorization of a matrix.
	 * Solves Ax=b, where A is in LU factorized form.
	 * Algorithm derived from "Numerical Recipes in C", Press et al., 1988.
	 *
	 * @param {Number[]} A An LU factorization of a matrix.
	 * @param {Number[]} index Permutation vector of that LU factorization.
	 * @param {Number[]} b Vector to be solved.
	 */
	// Method "lubksb" derived from "Numerical Recipes in C", Press et al., 1988


	Matrix.lubksb = function (A, index, b) {
	  var ii = -1,
	      i,
	      j,
	      sum;

	  for (i = 0; i < 4; i += 1) {
	    var ip = index[i];
	    sum = b[ip];
	    b[ip] = b[i];

	    if (ii != -1) {
	      for (j = ii; j <= i - 1; j += 1) {
	        sum -= A[i][j] * b[j];
	      }
	    } else if (sum != 0.0) {
	      ii = i;
	    }

	    b[i] = sum;
	  }

	  for (i = 3; i >= 0; i -= 1) {
	    sum = b[i];

	    for (j = i + 1; j < 4; j += 1) {
	      sum -= A[i][j] * b[j];
	    }

	    b[i] = sum / A[i][i];
	  }
	};
	/* Internal. Intentionally not documented.
	 * Utility method to perform an LU factorization of a matrix.
	 * "ludcmp" is derived from "Numerical Recipes in C", Press et al., 1988.
	 *
	 * @param {Number[]} A matrix to be factored
	 * @param {Number[]} index permutation vector
	 * @returns {Number} Condition number of matrix.
	 */


	Matrix.ludcmp = function (A, index) {
	  var TINY = 1.0e-20,
	      vv = [],

	  /* new double[4]; */
	  d = 1.0,
	      temp,
	      i,
	      j,
	      k,
	      big,
	      sum,
	      imax,
	      dum;

	  for (i = 0; i < 4; i += 1) {
	    big = 0.0;

	    for (j = 0; j < 4; j += 1) {
	      if ((temp = Math.abs(A[i][j])) > big) {
	        big = temp;
	      }
	    }

	    if (big == 0.0) {
	      return 0.0; // Matrix is singular if the entire row contains zero.
	    } else {
	      vv[i] = 1.0 / big;
	    }
	  }

	  for (j = 0; j < 4; j += 1) {
	    for (i = 0; i < j; i += 1) {
	      sum = A[i][j];

	      for (k = 0; k < i; k += 1) {
	        sum -= A[i][k] * A[k][j];
	      }

	      A[i][j] = sum;
	    }

	    big = 0.0;
	    imax = -1;

	    for (i = j; i < 4; i += 1) {
	      sum = A[i][j];

	      for (k = 0; k < j; k++) {
	        sum -= A[i][k] * A[k][j];
	      }

	      A[i][j] = sum;

	      if ((dum = vv[i] * Math.abs(sum)) >= big) {
	        big = dum;
	        imax = i;
	      }
	    }

	    if (j != imax) {
	      for (k = 0; k < 4; k += 1) {
	        dum = A[imax][k];
	        A[imax][k] = A[j][k];
	        A[j][k] = dum;
	      }

	      d = -d;
	      vv[imax] = vv[j];
	    }

	    index[j] = imax;
	    if (A[j][j] == 0.0) A[j][j] = TINY;

	    if (j != 3) {
	      dum = 1.0 / A[j][j];

	      for (i = j + 1; i < 4; i += 1) {
	        A[i][j] *= dum;
	      }
	    }
	  }

	  return d;
	};
	/**
	 * Inverts the specified matrix and stores the result in this matrix.
	 * <p>
	 * The specified matrix is assumed to represent an orthonormal transform matrix. This matrix's upper 3x3 is
	 * transposed, then its fourth column is transformed by the transposed upper 3x3 and negated.
	 * <p>
	 * The result of this method is undefined if this matrix is passed in as the matrix to invert.
	 *
	 * @param {Matrix} matrix The matrix whose inverse is computed. This matrix is assumed to represent an
	 * orthonormal transform matrix.
	 * @returns {Matrix} This matrix set to the inverse of the specified matrix.
	 *
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */


	Matrix.prototype.invertOrthonormalMatrix = function (matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "invertOrthonormalMatrix", "missingMatrix"));
	  } // 'a' is assumed to contain a 3D transformation matrix.
	  // Upper-3x3 is inverted, translation is transformed by inverted-upper-3x3 and negated.


	  var a = matrix;
	  this[0] = a[0];
	  this[1] = a[4];
	  this[2] = a[8];
	  this[3] = 0.0 - a[0] * a[3] - a[4] * a[7] - a[8] * a[11];
	  this[4] = a[1];
	  this[5] = a[5];
	  this[6] = a[9];
	  this[7] = 0.0 - a[1] * a[3] - a[5] * a[7] - a[9] * a[11];
	  this[8] = a[2];
	  this[9] = a[6];
	  this[10] = a[10];
	  this[11] = 0.0 - a[2] * a[3] - a[6] * a[7] - a[10] * a[11];
	  this[12] = 0;
	  this[13] = 0;
	  this[14] = 0;
	  this[15] = 1;
	  return this;
	};
	/**
	 * Computes the eigenvectors of this matrix.
	 * <p>
	 * The eigenvectors are returned sorted from the most prominent vector to the least prominent vector.
	 * Each eigenvector has length equal to its corresponding eigenvalue.
	 *
	 * @param {Vec3} result1 A pre-allocated vector in which to return the most prominent eigenvector.
	 * @param {Vec3} result2 A pre-allocated vector in which to return the second most prominent eigenvector.
	 * @param {Vec3} result3 A pre-allocated vector in which to return the least prominent eigenvector.
	 *
	 * @throws {ArgumentError} if any argument is null or undefined or if this matrix is not symmetric.
	 */


	Matrix.prototype.eigensystemFromSymmetricMatrix = function (result1, result2, result3) {
	  if (!result1 || !result2 || !result3) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "eigensystemFromSymmetricMatrix", "missingResult"));
	  }

	  if (this[1] != this[4] || this[2] != this[8] || this[6] != this[9]) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "eigensystemFromSymmetricMatrix", "Matrix is not symmetric"));
	  } // Taken from Mathematics for 3D Game Programming and Computer Graphics, Second Edition, listing 14.6.


	  var epsilon = 1.0e-10,
	      // Since the matrix is symmetric m12=m21, m13=m31 and m23=m32, therefore we can ignore the values m21,
	  // m32 and m32.
	  m11 = this[0],
	      m12 = this[1],
	      m13 = this[2],
	      m22 = this[5],
	      m23 = this[6],
	      m33 = this[10],
	      r = [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
	      maxSweeps = 32,
	      u,
	      u2,
	      u2p1,
	      t,
	      c,
	      s,
	      temp,
	      i,
	      i1,
	      i2,
	      i3;

	  for (var a = 0; a < maxSweeps; a++) {
	    // Exit if off-diagonal entries small enough
	    if (WWMath.fabs(m12) < epsilon && WWMath.fabs(m13) < epsilon && WWMath.fabs(m23) < epsilon) break; // Annihilate (1,2) entry.

	    if (m12 != 0) {
	      u = (m22 - m11) * 0.5 / m12;
	      u2 = u * u;
	      u2p1 = u2 + 1;
	      t = u2p1 != u2 ? (u < 0 ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;
	      c = 1 / Math.sqrt(t * t + 1);
	      s = c * t;
	      m11 -= t * m12;
	      m22 += t * m12;
	      m12 = 0;
	      temp = c * m13 - s * m23;
	      m23 = s * m13 + c * m23;
	      m13 = temp;

	      for (i = 0; i < 3; i++) {
	        temp = c * r[i][0] - s * r[i][1];
	        r[i][1] = s * r[i][0] + c * r[i][1];
	        r[i][0] = temp;
	      }
	    } // Annihilate (1,3) entry.


	    if (m13 != 0) {
	      u = (m33 - m11) * 0.5 / m13;
	      u2 = u * u;
	      u2p1 = u2 + 1;
	      t = u2p1 != u2 ? (u < 0 ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;
	      c = 1 / Math.sqrt(t * t + 1);
	      s = c * t;
	      m11 -= t * m13;
	      m33 += t * m13;
	      m13 = 0;
	      temp = c * m12 - s * m23;
	      m23 = s * m12 + c * m23;
	      m12 = temp;

	      for (i = 0; i < 3; i++) {
	        temp = c * r[i][0] - s * r[i][2];
	        r[i][2] = s * r[i][0] + c * r[i][2];
	        r[i][0] = temp;
	      }
	    } // Annihilate (2,3) entry.


	    if (m23 != 0) {
	      u = (m33 - m22) * 0.5 / m23;
	      u2 = u * u;
	      u2p1 = u2 + 1;
	      t = u2p1 != u2 ? (u < 0 ? -1 : 1) * (Math.sqrt(u2p1) - WWMath.fabs(u)) : 0.5 / u;
	      c = 1 / Math.sqrt(t * t + 1);
	      s = c * t;
	      m22 -= t * m23;
	      m33 += t * m23;
	      m23 = 0;
	      temp = c * m12 - s * m13;
	      m13 = s * m12 + c * m13;
	      m12 = temp;

	      for (i = 0; i < 3; i++) {
	        temp = c * r[i][1] - s * r[i][2];
	        r[i][2] = s * r[i][1] + c * r[i][2];
	        r[i][1] = temp;
	      }
	    }
	  }

	  i1 = 0;
	  i2 = 1;
	  i3 = 2;

	  if (m11 < m22) {
	    temp = m11;
	    m11 = m22;
	    m22 = temp;
	    temp = i1;
	    i1 = i2;
	    i2 = temp;
	  }

	  if (m22 < m33) {
	    temp = m22;
	    m22 = m33;
	    m33 = temp;
	    temp = i2;
	    i2 = i3;
	    i3 = temp;
	  }

	  if (m11 < m22) {
	    temp = m11;
	    m11 = m22;
	    m22 = temp;
	    temp = i1;
	    i1 = i2;
	    i2 = temp;
	  }

	  result1[0] = r[0][i1];
	  result1[1] = r[1][i1];
	  result1[2] = r[2][i1];
	  result2[0] = r[0][i2];
	  result2[1] = r[1][i2];
	  result2[2] = r[2][i2];
	  result3[0] = r[0][i3];
	  result3[1] = r[1][i3];
	  result3[2] = r[2][i3];
	  result1.normalize();
	  result2.normalize();
	  result3.normalize();
	  result1.multiply(m11);
	  result2.multiply(m22);
	  result3.multiply(m33);
	};
	/**
	 * Extracts and returns a new matrix whose upper 3x3 entries are identical to those of this matrix,
	 * and whose fourth row and column are 0 except for a 1 in the diagonal position.
	 * @returns {Matrix} The upper 3x3 matrix of this matrix.
	 */


	Matrix.prototype.upper3By3 = function () {
	  var result = Matrix.fromIdentity();
	  result[0] = this[0];
	  result[1] = this[1];
	  result[2] = this[2];
	  result[4] = this[4];
	  result[5] = this[5];
	  result[6] = this[6];
	  result[8] = this[8];
	  result[9] = this[9];
	  result[10] = this[10];
	  return result;
	};
	/**
	 * Transforms the specified screen point from WebGL screen coordinates to model coordinates. This method assumes
	 * this matrix represents an inverse modelview-projection matrix. The result of this method is
	 * undefined if this matrix is not an inverse modelview-projection matrix.
	 * <p>
	 * The screen point is understood to be in WebGL screen coordinates, with the origin in the bottom-left corner
	 * and axes that extend up and to the right from the origin.
	 * <p>
	 * This function stores the transformed point in the result argument, and returns true or false to indicate whether the
	 * transformation is successful. It returns false if the modelview or projection matrices
	 * are malformed, or if the screenPoint is clipped by the near clipping plane or the far clipping plane.
	 *
	 * @param {Vec3} screenPoint The screen coordinate point to un-project.
	 * @param {Rectangle} viewport The viewport defining the screen point's coordinate system
	 * @param {Vec3} result A pre-allocated vector in which to return the unprojected point.
	 * @returns {boolean} true if the transformation is successful, otherwise false.
	 * @throws {ArgumentError} If either the specified point or result argument is null or undefined.
	 */


	Matrix.prototype.unProject = function (screenPoint, viewport, result) {
	  if (!screenPoint) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "unProject", "missingPoint"));
	  }

	  if (!viewport) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "unProject", "missingViewport"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix", "unProject", "missingResult"));
	  }

	  var sx = screenPoint[0],
	      sy = screenPoint[1],
	      sz = screenPoint[2]; // Convert the XY screen coordinates to coordinates in the range [0, 1]. This enables the XY coordinates to
	  // be converted to clip coordinates.

	  sx = (sx - viewport.x) / viewport.width;
	  sy = (sy - viewport.y) / viewport.height; // Convert from coordinates in the range [0, 1] to clip coordinates in the range [-1, 1].

	  sx = sx * 2 - 1;
	  sy = sy * 2 - 1;
	  sz = sz * 2 - 1; // Clip the point against the near and far clip planes. In clip coordinates the near and far clip planes are
	  // perpendicular to the Z axis and are located at -1 and 1, respectively.

	  if (sz < -1 || sz > 1) {
	    return false;
	  } // Transform the screen point from clip coordinates to model coordinates. This inverts the Z axis and stores
	  // the negative of the eye coordinate Z value in the W coordinate.


	  var x = this[0] * sx + this[1] * sy + this[2] * sz + this[3],
	      y = this[4] * sx + this[5] * sy + this[6] * sz + this[7],
	      z = this[8] * sx + this[9] * sy + this[10] * sz + this[11],
	      w = this[12] * sx + this[13] * sy + this[14] * sz + this[15];

	  if (w === 0) {
	    return false;
	  } // Complete the conversion from model coordinates to clip coordinates by dividing by W.


	  result[0] = x / w;
	  result[1] = y / w;
	  result[2] = z / w;
	  return true;
	};

	/**
	 * @exports PickedObject
	 */

	/**
	 * Constructs a picked object.
	 * @alias PickedObject
	 * @constructor
	 * @classdesc Represents a picked object.
	 * @param {Color} color The pick color identifying the object.
	 * @param {Object} userObject An object to associate with this picked object, usually the picked shape.
	 * @param {Position} position The picked object's geographic position. May be null if unknown.
	 * @param {Layer} parentLayer The layer containing the picked object.
	 * @param {Boolean} isTerrain true if the picked object is terrain, otherwise false.
	 */
	function PickedObject(color, userObject, position, parentLayer, isTerrain) {
	  /**
	   * This picked object's pick color.
	   * @type {Color}
	   * @readonly
	   */
	  this.color = color;
	  /**
	   * The picked shape.
	   * @type {Object}
	   * @readonly
	   */

	  this.userObject = userObject;
	  /**
	   * This picked object's geographic position.
	   * @type {Position}
	   * @readonly
	   */

	  this.position = position;
	  /**
	   * The layer containing this picked object.
	   * @type {Layer}
	   * @readonly
	   */

	  this.parentLayer = parentLayer;
	  /**
	   * Indicates whether this picked object is terrain.
	   * @type {Boolean}
	   * @readonly
	   */

	  this.isTerrain = isTerrain;
	  /**
	   * Indicates whether this picked object is the top object.
	   * @type {boolean}
	   */

	  this.isOnTop = false;
	}

	/**
	 * @exports UnsupportedOperationError
	 */
	/**
	 * Constructs an unsupported-operation error with a specified message.
	 * @alias UnsupportedOperationError
	 * @constructor
	 * @classdesc Represents an error associated with an operation that is not available or should not be invoked.
	 * Typically raised when an abstract function of an abstract base class is called because a subclass has not
	 * implemented the function.
	 * @augments AbstractError
	 * @param {String} message The message.
	 */

	function UnsupportedOperationError$1(message) {
	  AbstractError.call(this, "UnsupportedOperationError", message);
	  var stack;

	  try {
	    //noinspection ExceptionCaughtLocallyJS
	    throw new Error();
	  } catch (e) {
	    stack = e.stack;
	  }

	  this.stack = stack;
	}

	UnsupportedOperationError$1.prototype = Object.create(AbstractError.prototype);

	/**
	 * @exports Renderable
	 */
	/**
	 * Constructs a base renderable.
	 * @alias Renderable
	 * @constructor
	 * @classdesc Represents a shape or other object that can be rendered. This is an abstract class and is not
	 * meant to be instantiated directly.
	 */

	function Renderable() {
	  /**
	   * The display name of the renderable.
	   * @type {String}
	   * @default "Renderable"
	   */
	  this.displayName = "Renderable";
	  /**
	   * Indicates whether to display this renderable.
	   * @type {Boolean}
	   * @default true
	   */

	  this.enabled = true;
	  /**
	   * Indicates the object to return as the userObject of this shape when picked. If null,
	   * then this shape is returned as the userObject.
	   * @type {Object}
	   * @default null
	   * @see  [PickedObject.userObject]{@link PickedObject#userObject}
	   */

	  this.pickDelegate = null;
	  /**
	   * An application defined object associated with this renderable. A typical use case is to associate
	   * application defined data with a picked renderable.
	   * @type {Object}
	   * @default An empty object
	   */

	  this.userProperties = {};
	}
	/**
	 * Render this renderable. Some shapes actually draw themselves during this call, others only add themselves
	 * to the draw context's ordered rendering list for subsequent drawing when their renderOrdered method is called.
	 * This method is intended to be called by layers such as {@link RenderableLayer} and not by applications.
	 * @param {DrawContext} dc The current draw context.
	 */


	Renderable.prototype.render = function (dc) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Renderable", "render", "abstractInvocation"));
	};

	/**
	 * Constructs an annotation.
	 * @alias Annotation
	 * @constructor
	 * @augments Renderable
	 * @classdesc Represents an Annotation shape. An annotation displays a callout, a text and a leader pointing
	 * the annotation's geographic position to the ground.
	 * @param {Position} position The annotations's geographic position.
	 * @param {AnnotationAttributes} attributes The attributes to associate with this annotation.
	 * @throws {ArgumentError} If the specified position is null or undefined.
	 */

	function Annotation(position, attributes) {
	  if (!position) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Annotation", "constructor", "missingPosition"));
	  }

	  Renderable.call(this);
	  /**
	   * This annotation's geographic position.
	   * @type {Position}
	   */

	  this.position = position;
	  /**
	   * The annotation's attributes.
	   * @type {AnnotationAttributes}
	   * @default see [AnnotationAttributes]{@link AnnotationAttributes}
	   */

	  this.attributes = attributes ? attributes : new AnnotationAttributes(null);
	  /**
	   * This annotation's altitude mode. May be one of
	   * <ul>
	   *  <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	   *  <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	   *  <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	   * </ul>
	   * @default WorldWind.ABSOLUTE
	   */

	  this.altitudeMode = WorldWind.ABSOLUTE; // Internal use only. Intentionally not documented.

	  this.layer = null; // Internal use only. Intentionally not documented.

	  this.lastStateKey = null; // Internal use only. Intentionally not documented.

	  this.calloutTransform = Matrix.fromIdentity(); // Internal use only. Intentionally not documented.

	  this.calloutOffset = new WorldWind.Offset(WorldWind.OFFSET_FRACTION, 0.5, WorldWind.OFFSET_FRACTION, 0); // Internal use only. Intentionally not documented.

	  this.label = ""; // Internal use only. Intentionally not documented.

	  this.labelTexture = null; // Internal use only. Intentionally not documented.

	  this.labelTransform = Matrix.fromIdentity(); // Internal use only. Intentionally not documented.

	  this.placePoint = new Vec3$1(0, 0, 0); // Internal use only. Intentionally not documented.

	  this.depthOffset = -2.05; // Internal use only. Intentionally not documented.

	  this.calloutPoints = null;
	}

	Annotation.matrix = Matrix.fromIdentity();
	Annotation.screenPoint = new Vec3$1(0, 0, 0);
	Annotation.scratchPoint = new Vec3$1(0, 0, 0);
	Annotation.prototype = Object.create(Renderable.prototype);
	Object.defineProperties(Annotation.prototype, {
	  /**
	   * The text for this annotation.
	   * @type {String}
	   * @memberof Annotation.prototype
	   */
	  text: {
	    get: function () {
	      return this.label;
	    },
	    set: function (value) {
	      this.label = value;
	      this.lastStateKey = null;
	    }
	  }
	});
	/**
	 * Draws this shape as an ordered renderable. Applications do not call this function. It is called by
	 * [WorldWindow]{@link WorldWindow} during rendering.
	 * @param {DrawContext} dc The current draw context.
	 */

	Annotation.prototype.renderOrdered = function (dc) {
	  this.drawOrderedAnnotation(dc);

	  if (dc.pickingMode) {
	    var po = new PickedObject(this.pickColor.clone(), this, this.position, this.layer, false);

	    if (dc.pickPoint) {
	      if (this.labelBounds.containsPoint(dc.convertPointToViewport(dc.pickPoint, Annotation.scratchPoint))) {
	        po.labelPicked = true;
	      }
	    }

	    dc.resolvePick(po);
	  }
	};
	/**
	 * Creates a new annotation that is a copy of this annotation.
	 * @returns {Annotation} The new annotation.
	 */


	Annotation.prototype.clone = function () {
	  var clone = new Annotation(this.position);
	  clone.copy(this);
	  clone.pickDelegate = this.pickDelegate ? this.pickDelegate : this;
	  return clone;
	};
	/**
	 * Copies the contents of a specified annotation to this annotation.
	 * @param {Annotation} that The Annotation to copy.
	 */


	Annotation.prototype.copy = function (that) {
	  this.position = that.position;
	  this.enabled = that.enabled;
	  this.attributes = that.attributes;
	  this.label = that.label;
	  this.altitudeMode = that.altitudeMode;
	  this.pickDelegate = that.pickDelegate;
	  this.depthOffset = that.depthOffset;
	  return this;
	};
	/**
	 * Renders this annotation. This method is typically not called by applications but is called by
	 * {@link RenderableLayer} during rendering. For this shape this method creates and
	 * enques an ordered renderable with the draw context and does not actually draw the annotation.
	 * @param {DrawContext} dc The current draw context.
	 */


	Annotation.prototype.render = function (dc) {
	  if (!this.enabled) {
	    return;
	  }

	  if (!dc.accumulateOrderedRenderables) {
	    return;
	  }

	  if (dc.globe.projectionLimits && !dc.globe.projectionLimits.containsLocation(this.position.latitude, this.position.longitude)) {
	    return;
	  }

	  var orderedAnnotation;

	  if (this.lastFrameTime !== dc.timestamp) {
	    orderedAnnotation = this.makeOrderedRenderable(dc);
	  } else {
	    var annotationCopy = this.clone();
	    orderedAnnotation = annotationCopy.makeOrderedRenderable(dc);
	  }

	  if (!orderedAnnotation) {
	    return;
	  }

	  orderedAnnotation.layer = dc.currentLayer;
	  this.lastFrameTime = dc.timestamp;
	  dc.addOrderedRenderable(orderedAnnotation);
	}; // Internal. Intentionally not documented.


	Annotation.prototype.drawOrderedAnnotation = function (dc) {
	  this.beginDrawing(dc);

	  try {
	    this.doDrawOrderedAnnotation(dc);
	  } finally {
	    this.endDrawing(dc);
	  }
	};
	/* Intentionally not documented
	 * Creates an ordered renderable for this shape.
	 * @protected
	 * @param {DrawContext} dc The current draw context.
	 * @returns {OrderedRenderable} The ordered renderable. May be null, in which case an ordered renderable
	 * cannot be created or should not be created at the time this method is called.
	 */


	Annotation.prototype.makeOrderedRenderable = function (dc) {
	  var w, h, s, iLeft, iRight, iTop, iBottom, offset, leaderGapHeight; // Wraps the text based and the width and height that were set for the
	  // annotation

	  this.label = dc.textRenderer.wrap(this.label, this.attributes.width, this.attributes.height); // Compute the annotation's model point.

	  dc.surfacePointForMode(this.position.latitude, this.position.longitude, this.position.altitude, this.altitudeMode, this.placePoint);
	  this.eyeDistance = dc.eyePoint.distanceTo(this.placePoint); // Compute the annotation's screen point in the OpenGL coordinate system of the WorldWindow
	  // by projecting its model coordinate point onto the viewport. Apply a depth offset in order
	  // to cause the annotation to appear above nearby terrain.

	  if (!dc.projectWithDepth(this.placePoint, this.depthOffset, Annotation.screenPoint)) {
	    return null;
	  }

	  this.labelTexture = dc.createTextTexture(this.label, this.attributes.textAttributes);
	  w = this.labelTexture.imageWidth;
	  h = this.labelTexture.imageHeight;
	  s = this.attributes.scale;
	  iLeft = this.attributes.insets.left;
	  iRight = this.attributes.insets.right;
	  iTop = this.attributes.insets.top;
	  iBottom = this.attributes.insets.bottom;
	  leaderGapHeight = this.attributes.leaderGapHeight;
	  offset = this.calloutOffset.offsetForSize((w + iLeft + iRight) * s, (h + iTop + iBottom) * s);
	  this.calloutTransform.setTranslation(Annotation.screenPoint[0] - offset[0], Annotation.screenPoint[1] + leaderGapHeight, Annotation.screenPoint[2]);
	  this.labelTransform.setTranslation(Annotation.screenPoint[0] - offset[0] + iLeft * s, Annotation.screenPoint[1] + leaderGapHeight + iBottom * s, Annotation.screenPoint[2]);
	  this.labelTransform.setScale(w * s, h * s, 1);
	  this.labelBounds = WWMath.boundingRectForUnitQuad(this.labelTransform); // Compute dimensions of the callout taking in consideration the insets

	  var width = (w + iLeft + iRight) * s;
	  var height = (h + iTop + iBottom) * s;
	  var leaderOffsetX = width / 2;
	  var leaderOffsetY = -leaderGapHeight;

	  if (!this.attributes.drawLeader) {
	    leaderOffsetY = 0;
	  }

	  if (this.attributes.stateKey !== this.lastStateKey) {
	    this.calloutPoints = this.createCallout(width, height, leaderOffsetX, leaderOffsetY, this.attributes.leaderGapWidth, this.attributes.cornerRadius);
	  }

	  return this;
	}; // Internal. Intentionally not documented.


	Annotation.prototype.beginDrawing = function (dc) {
	  var gl = dc.currentGlContext,
	      program;
	  dc.findAndBindProgram(BasicTextureProgram);
	  program = dc.currentProgram;
	  gl.enableVertexAttribArray(program.vertexPointLocation);
	  gl.enableVertexAttribArray(program.vertexTexCoordLocation);
	  program.loadModulateColor(gl, dc.pickingMode);
	}; // Internal. Intentionally not documented.


	Annotation.prototype.endDrawing = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram; // Clear the vertex attribute state.

	  gl.disableVertexAttribArray(program.vertexPointLocation);
	  gl.disableVertexAttribArray(program.vertexTexCoordLocation); // Clear GL bindings.

	  dc.bindProgram(null);
	}; // Internal. Intentionally not documented.


	Annotation.prototype.drawCorner = function (x0, y0, cornerRadius, start, end, steps, buffer, startIdx) {
	  if (cornerRadius < 1) {
	    return startIdx;
	  }

	  var step = (end - start) / (steps - 1);

	  for (var i = 1; i < steps - 1; i++) {
	    var a = start + step * i;
	    var x = x0 + Math.cos(a) * cornerRadius;
	    var y = y0 + Math.sin(a) * cornerRadius;
	    buffer[startIdx++] = x;
	    buffer[startIdx++] = y;
	  }

	  return startIdx;
	}; // Internal. Intentionally not documented.


	Annotation.prototype.createCallout = function (width, height, leaderOffsetX, leaderOffsetY, leaderGapWidth, cornerRadius) {
	  var cornerSteps = 16;
	  var numVertices = 2 * (12 + (cornerRadius < 1 ? 0 : 4 * (cornerSteps - 2)));
	  var buffer = new Float32Array(numVertices);
	  var idx = 0; //Bottom right

	  buffer[idx++] = width / 2 + leaderGapWidth / 2;
	  buffer[idx++] = 0;
	  buffer[idx++] = width - cornerRadius;
	  buffer[idx++] = 0;
	  idx = this.drawCorner(width - cornerRadius, cornerRadius, cornerRadius, -Math.PI / 2, 0, cornerSteps, buffer, idx); //Right

	  buffer[idx++] = width;
	  buffer[idx++] = cornerRadius;
	  buffer[idx++] = width;
	  buffer[idx++] = height - cornerRadius;
	  idx = this.drawCorner(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, cornerSteps, buffer, idx); //Top

	  buffer[idx++] = width - cornerRadius;
	  buffer[idx++] = height;
	  buffer[idx++] = cornerRadius;
	  buffer[idx++] = height;
	  idx = this.drawCorner(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, cornerSteps, buffer, idx); //Left

	  buffer[idx++] = 0;
	  buffer[idx++] = height - cornerRadius;
	  buffer[idx++] = 0;
	  buffer[idx++] = cornerRadius;
	  idx = this.drawCorner(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 1.5, cornerSteps, buffer, idx); //Bottom left

	  buffer[idx++] = cornerRadius;
	  buffer[idx++] = 0;
	  buffer[idx++] = width / 2 - leaderGapWidth / 2;
	  buffer[idx++] = 0; //Draw leader

	  buffer[idx++] = leaderOffsetX;
	  buffer[idx++] = leaderOffsetY;
	  buffer[idx++] = width / 2 + leaderGapWidth / 2;
	  buffer[idx] = 0;
	  return buffer;
	}; // Internal. Intentionally not documented.


	Annotation.prototype.doDrawOrderedAnnotation = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram,
	      textureBound;
	  var refreshBuffers = false;

	  if (dc.pickingMode) {
	    this.pickColor = dc.uniquePickColor();
	  }

	  program.loadOpacity(gl, dc.pickingMode ? 1 : this.attributes.opacity * this.layer.opacity); // Attributes have changed. We need to track this because the callout vbo data may
	  // have changed if scaled or text wrapping changes callout dimensions

	  var calloutAttributesChanged = this.attributes.stateKey !== this.lastStateKey; // Create new cache key if callout drawing points have changed

	  if (!this.calloutCacheKey || calloutAttributesChanged) {
	    this.calloutCacheKey = dc.gpuResourceCache.generateCacheKey();
	  }

	  var calloutVboId = dc.gpuResourceCache.resourceForKey(this.calloutCacheKey);

	  if (!calloutVboId) {
	    calloutVboId = gl.createBuffer();
	    dc.gpuResourceCache.putResource(this.calloutCacheKey, calloutVboId, this.calloutPoints.length * 4);
	    refreshBuffers = true;
	  } // Remove the last generated vbo data if attributes changed


	  if (calloutAttributesChanged && this.calloutCacheKey) {
	    dc.gpuResourceCache.removeResource(this.calloutCacheKey);
	  } // Store current statekey because we are no longer using it
	  // in this iteration


	  this.lastStateKey = this.attributes.stateKey; // Compute and specify the MVP matrix.

	  Annotation.matrix.copy(dc.screenProjection);
	  Annotation.matrix.multiplyMatrix(this.calloutTransform);
	  program.loadModelviewProjection(gl, Annotation.matrix);
	  gl.bindBuffer(gl.ARRAY_BUFFER, calloutVboId);

	  if (refreshBuffers) {
	    gl.bufferData(gl.ARRAY_BUFFER, this.calloutPoints, gl.STATIC_DRAW);
	    dc.frameStatistics.incrementVboLoadCount(1);
	  }

	  program.loadColor(gl, dc.pickingMode ? this.pickColor : this.attributes.backgroundColor);
	  program.loadTextureEnabled(gl, false);
	  gl.vertexAttribPointer(program.vertexPointLocation, 2, gl.FLOAT, false, 0, 0);
	  gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	  gl.drawArrays(gl.TRIANGLE_FAN, 0, this.calloutPoints.length / 2); // Draw text

	  Annotation.matrix.copy(dc.screenProjection);
	  Annotation.matrix.multiplyMatrix(this.labelTransform);
	  program.loadModelviewProjection(gl, Annotation.matrix);
	  Annotation.matrix.setToIdentity();
	  Annotation.matrix.multiplyByTextureTransform(this.labelTexture);
	  program.loadTextureMatrix(gl, Annotation.matrix);
	  program.loadColor(gl, dc.pickingMode ? this.pickColor : Color.WHITE);
	  textureBound = this.labelTexture.bind(dc);
	  program.loadTextureEnabled(gl, textureBound); // Configure GL to use the draw context's unit quad VBOs for both model coordinates and texture coordinates.
	  // Most browsers can share the same buffer for vertex and texture coordinates, but Internet Explorer requires
	  // that they be in separate buffers, so the code below uses the 3D buffer for vertex coords and the 2D
	  // buffer for texture coords.

	  gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer3());
	  gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	  gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer());
	  gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	};

	/**
	 * Provides utilities for Measurements.
	 * @exports MeasurerUtils
	 */

	var MeasurerUtils = {
	  /**
	   * Subdivide a list of positions so that no segment is longer then the provided maxLength.
	   * <p>If needed, new intermediate positions will be created along lines that follow the given pathType one
	   * of WorldWind.LINEAR, WorldWind.RHUMB_LINE or WorldWind.GREAT_CIRCLE.
	   * All position elevations will be either at the terrain surface if followTerrain is true, or interpolated
	   * according to the original elevations.</p>
	   *
	   * @param {Globe} globe
	   * @param {Position[]} positions
	   * @param {Boolean} followTerrain
	   * @param {String} pathType One of WorldWind.LINEAR, WorldWind.RHUMB_LINE or WorldWind.GREAT_CIRCLE
	   * @param {Number} maxLength The maximum length for one segment
	   *
	   * @return {Position[]} a list of positions with no segment longer then maxLength and elevations following
	   * terrain or not.
	   */
	  subdividePositions: function (globe, positions, followTerrain, pathType, maxLength) {
	    var subdividedPositions = [];
	    var loc = new Location(0, 0);
	    var destLatLon = new Location(0, 0);
	    var pos1 = positions[0];
	    var elevation;
	    this.addPosition(globe, subdividedPositions, pos1, followTerrain);

	    for (var i = 1; i < positions.length; i++) {
	      var pos2 = positions[i];
	      var arcLengthRadians = Location.greatCircleDistance(pos1, pos2);
	      loc = Location.interpolateAlongPath(pathType, 0.5, pos1, pos2, loc);
	      var arcLength = arcLengthRadians * globe.radiusAt(loc.latitude, loc.longitude);

	      if (arcLength > maxLength) {
	        // if necessary subdivide segment at regular intervals smaller then maxLength
	        var segmentAzimuth = null;
	        var segmentDistance = null;
	        var steps = Math.ceil(arcLength / maxLength); // number of intervals - at least two

	        for (var j = 1; j < steps; j++) {
	          var s = j / steps;

	          if (pathType === WorldWind.LINEAR) {
	            destLatLon = Location.interpolateLinear(s, pos1, pos2, destLatLon);
	          } else if (pathType === WorldWind.RHUMB_LINE) {
	            if (segmentAzimuth == null) {
	              segmentAzimuth = Location.rhumbAzimuth(pos1, pos2);
	              segmentDistance = Location.rhumbDistance(pos1, pos2);
	            }

	            destLatLon = Location.rhumbLocation(pos1, segmentAzimuth, s * segmentDistance, destLatLon);
	          } else {
	            //GREAT_CIRCLE
	            if (segmentAzimuth == null) {
	              segmentAzimuth = Location.greatCircleAzimuth(pos1, pos2); //degrees

	              segmentDistance = Location.greatCircleDistance(pos1, pos2); //radians
	            } //Location, degrees, radians, Location


	            destLatLon = Location.greatCircleLocation(pos1, segmentAzimuth, s * segmentDistance, destLatLon);
	          } // Set elevation


	          if (followTerrain) {
	            elevation = globe.elevationAtLocation(destLatLon.latitude, destLatLon.longitude);
	          } else {
	            elevation = pos1.altitude * (1 - s) + pos2.altitude * s;
	          }

	          subdividedPositions.push(new Position(destLatLon.latitude, destLatLon.longitude, elevation));
	        }
	      } // Finally add the segment end position


	      this.addPosition(globe, subdividedPositions, pos2, followTerrain); // Prepare for next segment

	      pos1 = pos2;
	    }

	    return subdividedPositions;
	  },

	  /**
	   * Adds a position to a list of positions.
	   * If the path is following the terrain the elevation is also computed.
	   *
	   * @param {Globe} globe
	   * @param {Position[]} positions The list of positions to add to
	   * @param {Position} position The position to add to the list
	   * @param {Boolean} followTerrain
	   *
	   * @return {Position[]} The list of positions
	   */
	  addPosition: function (globe, positions, position, followTerrain) {
	    var elevation = position.altitude;

	    if (followTerrain) {
	      elevation = globe.elevationAtLocation(position.latitude, position.longitude);
	    }

	    positions.push(new Position(position.latitude, position.longitude, elevation));
	    return positions;
	  },

	  /**
	   * Determines whether a location is located inside a given polygon.
	   *
	   * @param {Location} location
	   * @param {Location[]}locations The list of positions describing the polygon.
	   * Last one should be the same as the first one.
	   *
	   * @return {Boolean} true if the location is inside the polygon.
	   */
	  isLocationInside: function (location, locations) {
	    var result = false;
	    var p1 = locations[0];

	    for (var i = 1, len = locations.length; i < len; i++) {
	      var p2 = locations[i];

	      if ((p2.latitude <= location.latitude && location.latitude < p1.latitude || p1.latitude <= location.latitude && location.latitude < p2.latitude) && location.longitude < (p1.longitude - p2.longitude) * (location.latitude - p2.latitude) / (p1.latitude - p2.latitude) + p2.longitude) {
	        result = !result;
	      }

	      p1 = p2;
	    }

	    return result;
	  },

	  /**
	   * Computes the angle between two Vec3 in radians.
	   *
	   * @param {Vec3} v1
	   * @param {Vec3} v2
	   *
	   * @return {Number} The ange in radians
	   */
	  angleBetweenVectors: function (v1, v2) {
	    var dot = v1.dot(v2); // Compute the sum of magnitudes.

	    var length = v1.magnitude() * v2.magnitude(); // Normalize the dot product, if necessary.

	    if (!(length === 0) && length !== 1.0) {
	      dot /= length;
	    } // The normalized dot product should be in the range [-1, 1]. Otherwise the result is an error from
	    // floating point roundoff. So if dot is less than -1 or greater than +1, we treat it as -1 and +1
	    // respectively.


	    if (dot < -1.0) {
	      dot = -1.0;
	    } else if (dot > 1.0) {
	      dot = 1.0;
	    } // Angle is arc-cosine of normalized dot product.


	    return Math.acos(dot);
	  }
	};

	/**
	 * @exports Sector
	 */
	/**
	 * Constructs a Sector from specified minimum and maximum latitudes and longitudes in degrees.
	 * @alias Sector
	 * @constructor
	 * @classdesc Represents a rectangular region in geographic coordinates in degrees.
	 * @param {Number} minLatitude The sector's minimum latitude in degrees.
	 * @param {Number} maxLatitude The sector's maximum latitude in degrees.
	 * @param {Number} minLongitude The sector's minimum longitude in degrees.
	 * @param {Number} maxLongitude The sector's maximum longitude in degrees.
	 */

	function Sector(minLatitude, maxLatitude, minLongitude, maxLongitude) {
	  /**
	   * This sector's minimum latitude in degrees.
	   * @type {Number}
	   */
	  this.minLatitude = minLatitude;
	  /**
	   * This sector's maximum latitude in degrees.
	   * @type {Number}
	   */

	  this.maxLatitude = maxLatitude;
	  /**
	   * This sector's minimum longitude in degrees.
	   * @type {Number}
	   */

	  this.minLongitude = minLongitude;
	  /**
	   * This sector's maximum longitude in degrees.
	   * @type {Number}
	   */

	  this.maxLongitude = maxLongitude;
	}
	/**
	 * A sector with minimum and maximum latitudes and minimum and maximum longitudes all zero.
	 * @constant
	 * @type {Sector}
	 */


	Sector.ZERO = new Sector(0, 0, 0, 0);
	/**
	 * A sector that encompasses the full range of latitude ([-90, 90]) and longitude ([-180, 180]).
	 * @constant
	 * @type {Sector}
	 */

	Sector.FULL_SPHERE = new Sector(-90, 90, -180, 180);
	/**
	 * Sets this sector's latitudes and longitudes to those of a specified sector.
	 * @param {Sector} sector The sector to copy.
	 * @returns {Sector} This sector, set to the values of the specified sector.
	 * @throws {ArgumentError} If the specified sector is null or undefined.
	 */

	Sector.prototype.copy = function (sector) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Sector", "copy", "missingSector"));
	  }

	  this.minLatitude = sector.minLatitude;
	  this.maxLatitude = sector.maxLatitude;
	  this.minLongitude = sector.minLongitude;
	  this.maxLongitude = sector.maxLongitude;
	  return this;
	};
	/**
	 * Indicates whether this sector has width or height.
	 * @returns {Boolean} true if this sector's minimum and maximum latitudes or minimum and maximum
	 * longitudes do not differ, otherwise false.
	 */


	Sector.prototype.isEmpty = function () {
	  return this.minLatitude === this.maxLatitude && this.minLongitude === this.maxLongitude;
	};
	/**
	 * Returns the angle between this sector's minimum and maximum latitudes, in degrees.
	 * @returns {Number} The difference between this sector's minimum and maximum latitudes, in degrees.
	 */


	Sector.prototype.deltaLatitude = function () {
	  return this.maxLatitude - this.minLatitude;
	};
	/**
	 * Returns the angle between this sector's minimum and maximum longitudes, in degrees.
	 * @returns {Number} The difference between this sector's minimum and maximum longitudes, in degrees.
	 */


	Sector.prototype.deltaLongitude = function () {
	  return this.maxLongitude - this.minLongitude;
	};
	/**
	 * Returns the angle midway between this sector's minimum and maximum latitudes.
	 * @returns {Number} The mid-angle of this sector's minimum and maximum latitudes, in degrees.
	 */


	Sector.prototype.centroidLatitude = function () {
	  return 0.5 * (this.minLatitude + this.maxLatitude);
	};
	/**
	 * Returns the angle midway between this sector's minimum and maximum longitudes.
	 * @returns {Number} The mid-angle of this sector's minimum and maximum longitudes, in degrees.
	 */


	Sector.prototype.centroidLongitude = function () {
	  return 0.5 * (this.minLongitude + this.maxLongitude);
	};
	/**
	 * Computes the location of the angular center of this sector, which is the mid-angle of each of this sector's
	 * latitude and longitude dimensions.
	 * @param {Location} result A pre-allocated {@link Location} in which to return the computed centroid.
	 * @returns {Location} The specified result argument containing the computed centroid.
	 * @throws {ArgumentError} If the result argument is null or undefined.
	 */


	Sector.prototype.centroid = function (result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Sector", "centroid", "missingResult"));
	  }

	  result.latitude = this.centroidLatitude();
	  result.longitude = this.centroidLongitude();
	  return result;
	};
	/**
	 * Returns this sector's minimum latitude in radians.
	 * @returns {Number} This sector's minimum latitude in radians.
	 */


	Sector.prototype.minLatitudeRadians = function () {
	  return this.minLatitude * Angle.DEGREES_TO_RADIANS;
	};
	/**
	 * Returns this sector's maximum latitude in radians.
	 * @returns {Number} This sector's maximum latitude in radians.
	 */


	Sector.prototype.maxLatitudeRadians = function () {
	  return this.maxLatitude * Angle.DEGREES_TO_RADIANS;
	};
	/**
	 * Returns this sector's minimum longitude in radians.
	 * @returns {Number} This sector's minimum longitude in radians.
	 */


	Sector.prototype.minLongitudeRadians = function () {
	  return this.minLongitude * Angle.DEGREES_TO_RADIANS;
	};
	/**
	 * Returns this sector's maximum longitude in radians.
	 * @returns {Number} This sector's maximum longitude in radians.
	 */


	Sector.prototype.maxLongitudeRadians = function () {
	  return this.maxLongitude * Angle.DEGREES_TO_RADIANS;
	};
	/**
	 * Modifies this sector to encompass an array of specified locations.
	 * @param {Location[]} locations An array of locations. The array may be sparse.
	 * @returns {Sector} This sector, modified to encompass all locations in the specified array.
	 * @throws {ArgumentError} If the specified array is null, undefined or empty or has fewer than two locations.
	 */


	Sector.prototype.setToBoundingSector = function (locations) {
	  if (!locations || locations.length < 2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Sector", "setToBoundingSector", "missingArray"));
	  }

	  var minLatitude = 90,
	      maxLatitude = -90,
	      minLongitude = 180,
	      maxLongitude = -180;

	  for (var idx = 0, len = locations.length; idx < len; idx += 1) {
	    var location = locations[idx];

	    if (!location) {
	      continue;
	    }

	    minLatitude = Math.min(minLatitude, location.latitude);
	    maxLatitude = Math.max(maxLatitude, location.latitude);
	    minLongitude = Math.min(minLongitude, location.longitude);
	    maxLongitude = Math.max(maxLongitude, location.longitude);
	  }

	  this.minLatitude = minLatitude;
	  this.maxLatitude = maxLatitude;
	  this.minLongitude = minLongitude;
	  this.maxLongitude = maxLongitude;
	  return this;
	};
	/**
	 * Computes bounding sectors from a list of locations that span the dateline.
	 * @param {Location[]} locations The locations to bound.
	 * @returns {Sector[]} Two sectors, one in the eastern hemisphere and one in the western hemisphere.
	 * Returns null if the computed bounding sector has zero width or height.
	 * @throws {ArgumentError} If the specified array is null, undefined or empty or the number of locations
	 * is less than 2.
	 */


	Sector.splitBoundingSectors = function (locations) {
	  if (!locations || locations.length < 2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Sector", "splitBoundingSectors", "missingArray"));
	  }

	  var minLat = 90;
	  var minLon = 180;
	  var maxLat = -90;
	  var maxLon = -180;
	  var lastLocation = null;

	  for (var idx = 0, len = locations.length; idx < len; idx += 1) {
	    var location = locations[idx];
	    var lat = location.latitude;

	    if (lat < minLat) {
	      minLat = lat;
	    }

	    if (lat > maxLat) {
	      maxLat = lat;
	    }

	    var lon = location.longitude;

	    if (lon >= 0 && lon < minLon) {
	      minLon = lon;
	    }

	    if (lon <= 0 && lon > maxLon) {
	      maxLon = lon;
	    }

	    if (lastLocation != null) {
	      var lastLon = lastLocation.longitude;

	      if (WWMath.signum(lon) != WWMath.signum(lastLon)) {
	        if (Math.abs(lon - lastLon) < 180) {
	          // Crossing the zero longitude line too
	          maxLon = 0;
	          minLon = 0;
	        }
	      }
	    }

	    lastLocation = location;
	  }

	  if (minLat === maxLat && minLon === maxLon) {
	    return null;
	  }

	  return [new Sector(minLat, maxLat, minLon, 180), // Sector on eastern hemisphere.
	  new Sector(minLat, maxLat, -180, maxLon) // Sector on western hemisphere.
	  ];
	};
	/**
	 * Indicates whether this sector intersects a specified sector.
	 * This sector intersects the specified sector when each sector's boundaries either overlap with the specified
	 * sector or are adjacent to the specified sector.
	 * The sectors are assumed to have normalized angles (angles within the range [-90, 90] latitude and
	 * [-180, 180] longitude).
	 * @param {Sector} sector The sector to test intersection with. May be null or undefined, in which case this
	 * function returns false.
	 * @returns {Boolean} true if the specifies sector intersections this sector, otherwise false.
	 */


	Sector.prototype.intersects = function (sector) {
	  // Assumes normalized angles: [-90, 90], [-180, 180].
	  return sector && this.minLongitude <= sector.maxLongitude && this.maxLongitude >= sector.minLongitude && this.minLatitude <= sector.maxLatitude && this.maxLatitude >= sector.minLatitude;
	};
	/**
	 * Indicates whether this sector intersects a specified sector exclusive of the sector boundaries.
	 * This sector overlaps the specified sector when the union of the two sectors defines a non-empty sector.
	 * The sectors are assumed to have normalized angles (angles within the range [-90, 90] latitude and
	 * [-180, 180] longitude).
	 * @param {Sector} sector The sector to test overlap with. May be null or undefined, in which case this
	 * function returns false.
	 * @returns {Boolean} true if the specified sector overlaps this sector, otherwise false.
	 */


	Sector.prototype.overlaps = function (sector) {
	  // Assumes normalized angles: [-90, 90], [-180, 180].
	  return sector && this.minLongitude < sector.maxLongitude && this.maxLongitude > sector.minLongitude && this.minLatitude < sector.maxLatitude && this.maxLatitude > sector.minLatitude;
	};
	/**
	 * Indicates whether this sector fully contains a specified sector.
	 * This sector contains the specified sector when the specified sector's boundaries are completely contained
	 * within this sector's boundaries, or are equal to this sector's boundaries.
	 * The sectors are assumed to have normalized angles (angles within the range [-90, 90] latitude and
	 * [-180, 180] longitude).
	 * @param {Sector} sector The sector to test containment with. May be null or undefined, in which case this
	 * function returns false.
	 * @returns {Boolean} true if the specified sector contains this sector, otherwise false.
	 */


	Sector.prototype.contains = function (sector) {
	  // Assumes normalized angles: [-90, 90], [-180, 180].
	  return sector && this.minLatitude <= sector.minLatitude && this.maxLatitude >= sector.maxLatitude && this.minLongitude <= sector.minLongitude && this.maxLongitude >= sector.maxLongitude;
	};
	/**
	 * Indicates whether this sector contains a specified geographic location.
	 * @param {Number} latitude The location's latitude in degrees.
	 * @param {Number} longitude The location's longitude in degrees.
	 * @returns {Boolean} true if this sector contains the location, otherwise false.
	 */


	Sector.prototype.containsLocation = function (latitude, longitude) {
	  // Assumes normalized angles: [-90, 90], [-180, 180].
	  return this.minLatitude <= latitude && this.maxLatitude >= latitude && this.minLongitude <= longitude && this.maxLongitude >= longitude;
	};
	/**
	 * Sets this sector to the intersection of itself and a specified sector.
	 * @param {Sector} sector The sector to intersect with this one.
	 * @returns {Sector} This sector, set to its intersection with the specified sector.
	 * @throws {ArgumentError} If the specified sector is null or undefined.
	 */


	Sector.prototype.intersection = function (sector) {
	  if (!sector instanceof Sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Sector", "intersection", "missingSector"));
	  } // Assumes normalized angles: [-180, 180], [-90, 90].


	  if (this.minLatitude < sector.minLatitude) this.minLatitude = sector.minLatitude;
	  if (this.maxLatitude > sector.maxLatitude) this.maxLatitude = sector.maxLatitude;
	  if (this.minLongitude < sector.minLongitude) this.minLongitude = sector.minLongitude;
	  if (this.maxLongitude > sector.maxLongitude) this.maxLongitude = sector.maxLongitude; // If the sectors do not overlap in either latitude or longitude, then the result of the above logic results in
	  // the max being greater than the min. In this case, set the max to indicate that the sector is empty in
	  // that dimension.

	  if (this.maxLatitude < this.minLatitude) this.maxLatitude = this.minLatitude;
	  if (this.maxLongitude < this.minLongitude) this.maxLongitude = this.minLongitude;
	  return this;
	};
	/**
	 * Returns a list of the Lat/Lon coordinates of a Sector's corners.
	 *
	 * @returns {Array} an array of the four corner locations, in the order SW, SE, NE, NW
	 */


	Sector.prototype.getCorners = function () {
	  var corners = [];
	  corners.push(new Location(this.minLatitude, this.minLongitude));
	  corners.push(new Location(this.minLatitude, this.maxLongitude));
	  corners.push(new Location(this.maxLatitude, this.maxLongitude));
	  corners.push(new Location(this.maxLatitude, this.minLongitude));
	  return corners;
	};
	/**
	 * Returns an array of {@link Vec3} that bounds the specified sector on the surface of the specified
	 * {@link Globe}. The returned points enclose the globe's surface terrain in the sector,
	 * according to the specified vertical exaggeration, minimum elevation, and maximum elevation. If the minimum and
	 * maximum elevation are equal, this assumes a maximum elevation of 10 + the minimum.
	 *
	 * @param {Globe} globe the globe the extent relates to.
	 * @param {Number} verticalExaggeration the globe's vertical surface exaggeration.
	 *
	 * @returns {Vec3} a set of points that enclose the globe's surface on the specified sector. Can be turned into a {@link BoundingBox}
	 * with the setToVec3Points method.
	 *
	 * @throws {ArgumentError} if the globe is null.
	 */


	Sector.prototype.computeBoundingPoints = function (globe, verticalExaggeration) {
	  // TODO: Refactor this method back to computeBoundingBox.
	  // This method was originally computeBoundingBox and returned a BoundingBox. This created a circular dependency between
	  // Sector and BoundingBox that the Karma unit test suite doesn't appear to like. If we discover a way to make Karma handle this
	  // situation, we should refactor this method.
	  if (globe === null) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Sector", "computeBoundingBox", "missingGlobe"));
	  }

	  var minAndMaxElevations = globe.minAndMaxElevationsForSector(this); // Compute the exaggerated minimum and maximum heights.

	  var minHeight = minAndMaxElevations[0] * verticalExaggeration;
	  var maxHeight = minAndMaxElevations[1] * verticalExaggeration;
	  if (minHeight === maxHeight) maxHeight = minHeight + 10; // Ensure the top and bottom heights are not equal.

	  var points = [];
	  var corners = this.getCorners();

	  for (var i = 0; i < corners.length; i++) {
	    points.push(globe.computePointFromPosition(corners[i].latitude, corners[i].longitude, minHeight, new Vec3$1(0, 0, 0)));
	    points.push(globe.computePointFromPosition(corners[i].latitude, corners[i].longitude, maxHeight, new Vec3$1(0, 0, 0)));
	  } // A point at the centroid captures the maximum vertical dimension.


	  var centroid = this.centroid(new Location(0, 0));
	  points.push(globe.computePointFromPosition(centroid.latitude, centroid.longitude, maxHeight, new Vec3$1(0, 0, 0))); // If the sector spans the equator, then the curvature of all four edges need to be taken into account. The
	  // extreme points along the top and bottom edges are located at their mid-points, and the extreme points along
	  // the left and right edges are on the equator. Add points with the longitude of the sector's centroid but with
	  // the sector's min and max latitude, and add points with the sector's min and max longitude but with latitude
	  // at the equator. See WWJINT-225.

	  if (this.minLatitude < 0 && this.maxLatitude > 0) {
	    points.push(globe.computePointFromPosition(this.minLatitude, centroid.longitude, maxHeight, new Vec3$1(0, 0, 0)));
	    points.push(globe.computePointFromPosition(this.maxLatitude, centroid.longitude, maxHeight, new Vec3$1(0, 0, 0)));
	    points.push(globe.computePointFromPosition(0, this.minLongitude, maxHeight, new Vec3$1(0, 0, 0)));
	    points.push(globe.computePointFromPosition(0, this.maxLongitude, maxHeight, new Vec3$1(0, 0, 0)));
	  } // If the sector is located entirely in the southern hemisphere, then the curvature of its top edge needs to be
	  // taken into account. The extreme point along the top edge is located at its mid-point. Add a point with the
	  // longitude of the sector's centroid but with the sector's max latitude. See WWJINT-225.
	  else if (this.minLatitude < 0) {
	      points.push(globe.computePointFromPosition(this.maxLatitude, centroid.longitude, maxHeight, new Vec3$1(0, 0, 0)));
	    } // If the sector is located entirely in the northern hemisphere, then the curvature of its bottom edge needs to
	    // be taken into account. The extreme point along the bottom edge is located at its mid-point. Add a point with
	    // the longitude of the sector's centroid but with the sector's min latitude. See WWJINT-225.
	    else {
	        points.push(globe.computePointFromPosition(this.minLatitude, centroid.longitude, maxHeight, new Vec3$1(0, 0, 0)));
	      } // If the sector spans 360 degrees of longitude then is a band around the entire globe. (If one edge is a pole
	  // then the sector looks like a circle around the pole.) Add points at the min and max latitudes and longitudes
	  // 0, 180, 90, and -90 to capture full extent of the band.


	  if (this.deltaLongitude() >= 360) {
	    var minLat = this.minLatitude;
	    points.push(globe.computePointFromPosition(minLat, 0, maxHeight, new Vec3$1(0, 0, 0)));
	    points.push(globe.computePointFromPosition(minLat, 90, maxHeight, new Vec3$1(0, 0, 0)));
	    points.push(globe.computePointFromPosition(minLat, -90, maxHeight, new Vec3$1(0, 0, 0)));
	    points.push(globe.computePointFromPosition(minLat, 180, maxHeight, new Vec3$1(0, 0, 0)));
	    var maxLat = this.maxLatitude;
	    points.push(globe.computePointFromPosition(maxLat, 0, maxHeight, new Vec3$1(0, 0, 0)));
	    points.push(globe.computePointFromPosition(maxLat, 90, maxHeight, new Vec3$1(0, 0, 0)));
	    points.push(globe.computePointFromPosition(maxLat, -90, maxHeight, new Vec3$1(0, 0, 0)));
	    points.push(globe.computePointFromPosition(maxLat, 180, maxHeight, new Vec3$1(0, 0, 0)));
	  } else if (this.deltaLongitude() > 180) {
	    // Need to compute more points to ensure the box encompasses the full sector.
	    var cLon = centroid.longitude;
	    var cLat = centroid.latitude; // centroid latitude, longitude midway between min longitude and centroid longitude

	    var lon = (this.minLongitude + cLon) / 2;
	    points.push(globe.computePointFromPosition(cLat, lon, maxHeight, new Vec3$1(0, 0, 0))); // centroid latitude, longitude midway between centroid longitude and max longitude

	    lon = (cLon + this.maxLongitude) / 2;
	    points.push(globe.computePointFromPosition(cLat, lon, maxHeight, new Vec3$1(0, 0, 0))); // centroid latitude, longitude at min longitude and max longitude

	    points.push(globe.computePointFromPosition(cLat, this.minLongitude, maxHeight, new Vec3$1(0, 0, 0)));
	    points.push(globe.computePointFromPosition(cLat, this.maxLongitude, maxHeight, new Vec3$1(0, 0, 0)));
	  }

	  return points;
	};
	/**
	 * Sets this sector to the union of itself and a specified sector.
	 * @param {Sector} sector The sector to union with this one.
	 * @returns {Sector} This sector, set to its union with the specified sector.
	 * @throws {ArgumentError} if the specified sector is null or undefined.
	 */


	Sector.prototype.union = function (sector) {
	  if (!sector instanceof Sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Sector", "union", "missingSector"));
	  } // Assumes normalized angles: [-180, 180], [-90, 90].


	  if (this.minLatitude > sector.minLatitude) this.minLatitude = sector.minLatitude;
	  if (this.maxLatitude < sector.maxLatitude) this.maxLatitude = sector.maxLatitude;
	  if (this.minLongitude > sector.minLongitude) this.minLongitude = sector.minLongitude;
	  if (this.maxLongitude < sector.maxLongitude) this.maxLongitude = sector.maxLongitude;
	  return this;
	};

	var libtess_1 = createCommonjsModule(function (module) {
	  /*
	   * @license
	   * Copyright 2000, Silicon Graphics, Inc. All Rights Reserved.
	   * Copyright 2014, Google Inc. All Rights Reserved.
	   *
	   * Permission is hereby granted, free of charge, to any person obtaining a copy
	   * of this software and associated documentation files (the "Software"), to
	   * deal in the Software without restriction, including without limitation the
	   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	   * sell copies of the Software, and to permit persons to whom the Software is
	   * furnished to do so, subject to the following conditions:
	   *
	   * The above copyright notice including the dates of first publication and
	   * either this permission notice or a reference to http://oss.sgi.com/projects/FreeB/
	   * shall be included in all copies or substantial portions of the Software.
	   *
	   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
	   * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	   * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
	   * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	   *
	   * Original Code. The Original Code is: OpenGL Sample Implementation,
	   * Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
	   * Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
	   * Copyright in any portions created by third parties is as indicated
	   * elsewhere herein. All Rights Reserved.
	   */

	  /*
	   * @author ericv@cs.stanford.edu (Eric Veach)
	   * @author bckenny@google.com (Brendan Kenny)
	   */

	  /*
	   * Base namespace.
	   * @const
	   */
	  var libtess = {};
	  /**
	   * Whether to run asserts and extra debug checks.
	   * @define {boolean}
	   */

	  libtess.DEBUG = false;
	  /**
	   * Checks if the condition evaluates to true if libtess.DEBUG is true.
	   * @param {*} condition The condition to check.
	   * @param {string=} opt_message Error message in case of failure.
	   * @throws {Error} Assertion failed, the condition evaluates to false.
	   */

	  libtess.assert = function (condition, opt_message) {
	    if (libtess.DEBUG && !condition) {
	      throw new Error('Assertion failed' + (opt_message ? ': ' + opt_message : ''));
	    }
	  };
	  /**
	   * The maximum vertex coordinate size, 1e150. Anything larger will trigger a
	   * GLU_TESS_COORD_TOO_LARGE error callback and the vertex will be clamped to
	   * this value for all tessellation calculations.
	   * @const {number}
	   */


	  libtess.GLU_TESS_MAX_COORD = 1e150; // NOTE(bckenny): value from glu.pl generator

	  /**
	   * Normally the polygon is projected to a plane perpendicular to one of the
	   * three coordinate axes before tessellating in 2d. This helps numerical
	   * accuracy by forgoing a transformation step by simply dropping one coordinate
	   * dimension.
	   *
	   * However, this can affect the placement of intersection points for non-axis-
	   * aligned polygons. Setting TRUE_PROJECT to true will instead project onto a
	   * plane actually perpendicular to the polygon's normal.
	   *
	   * NOTE(bckenny): I can find no instances on the internet in which this mode has
	   * been used, but it's difficult to search for. This was a compile-time setting
	   * in the original, so setting this as constant. If this is exposed in the
	   * public API, remove the ignore coverage directives on
	   * libtess.normal.projectPolygon and libtess.normal.normalize_.
	   * @const {boolean}
	   */

	  libtess.TRUE_PROJECT = false;
	  /**
	   * We cache vertex data for single-contour polygons so that we can try a
	   * quick-and-dirty decomposition first.
	   * @const {number}
	   */

	  libtess.TESS_MAX_CACHE = 100;
	  /**
	   * The default tolerance for merging features, 0, meaning vertices are only
	   * merged if they are exactly coincident
	   * If a higher tolerance is needed, significant rewriting will need to occur.
	   * See libtess.sweep.TOLERANCE_NONZERO_ as a starting place.
	   * @const {number}
	   */

	  libtess.GLU_TESS_DEFAULT_TOLERANCE = 0;
	  /**
	   * The input contours parition the plane into regions. A winding
	   * rule determines which of these regions are inside the polygon.
	   *
	   * For a single contour C, the winding number of a point x is simply
	   * the signed number of revolutions we make around x as we travel
	   * once around C (where CCW is positive). When there are several
	   * contours, the individual winding numbers are summed. This
	   * procedure associates a signed integer value with each point x in
	   * the plane. Note that the winding number is the same for all
	   * points in a single region.
	   *
	   * The winding rule classifies a region as "inside" if its winding
	   * number belongs to the chosen category (odd, nonzero, positive,
	   * negative, or absolute value of at least two). The current GLU
	   * tesselator implements the "odd" rule. The "nonzero" rule is another
	   * common way to define the interior. The other three rules are
	   * useful for polygon CSG operations.
	   * @enum {number}
	   */

	  libtess.windingRule = {
	    // NOTE(bckenny): values from enumglu.spec
	    GLU_TESS_WINDING_ODD: 100130,
	    GLU_TESS_WINDING_NONZERO: 100131,
	    GLU_TESS_WINDING_POSITIVE: 100132,
	    GLU_TESS_WINDING_NEGATIVE: 100133,
	    GLU_TESS_WINDING_ABS_GEQ_TWO: 100134
	  };
	  /**
	   * The type of primitive return from a "begin" callback. GL_LINE_LOOP is only
	   * returned when GLU_TESS_BOUNDARY_ONLY is true. GL_TRIANGLE_STRIP and
	   * GL_TRIANGLE_FAN are no longer returned since 1.1.0 (see release notes).
	   * @enum {number}
	   */

	  libtess.primitiveType = {
	    GL_LINE_LOOP: 2,
	    GL_TRIANGLES: 4,
	    GL_TRIANGLE_STRIP: 5,
	    GL_TRIANGLE_FAN: 6
	  };
	  /**
	   * The types of errors provided in the error callback.
	   * @enum {number}
	   */

	  libtess.errorType = {
	    // TODO(bckenny) doc types
	    // NOTE(bckenny): values from enumglu.spec
	    GLU_TESS_MISSING_BEGIN_POLYGON: 100151,
	    GLU_TESS_MISSING_END_POLYGON: 100153,
	    GLU_TESS_MISSING_BEGIN_CONTOUR: 100152,
	    GLU_TESS_MISSING_END_CONTOUR: 100154,
	    GLU_TESS_COORD_TOO_LARGE: 100155,
	    GLU_TESS_NEED_COMBINE_CALLBACK: 100156
	  };
	  /**
	   * Enum values necessary for providing settings and callbacks. See the readme
	   * for details.
	   * @enum {number}
	   */

	  libtess.gluEnum = {
	    // TODO(bckenny): rename so not always typing libtess.gluEnum.*?
	    // NOTE(bckenny): values from enumglu.spec
	    GLU_TESS_BEGIN: 100100,
	    GLU_TESS_VERTEX: 100101,
	    GLU_TESS_END: 100102,
	    GLU_TESS_ERROR: 100103,
	    GLU_TESS_EDGE_FLAG: 100104,
	    GLU_TESS_COMBINE: 100105,
	    GLU_TESS_BEGIN_DATA: 100106,
	    GLU_TESS_VERTEX_DATA: 100107,
	    GLU_TESS_END_DATA: 100108,
	    GLU_TESS_ERROR_DATA: 100109,
	    GLU_TESS_EDGE_FLAG_DATA: 100110,
	    GLU_TESS_COMBINE_DATA: 100111,
	    GLU_TESS_MESH: 100112,
	    //  NOTE(bckenny): from tess.c
	    GLU_TESS_TOLERANCE: 100142,
	    GLU_TESS_WINDING_RULE: 100140,
	    GLU_TESS_BOUNDARY_ONLY: 100141,
	    // TODO(bckenny): move this to libtess.errorType?
	    GLU_INVALID_ENUM: 100900,
	    GLU_INVALID_VALUE: 100901
	  };
	  /* global libtess */

	  /** @const */

	  libtess.geom = {};
	  /**
	   * Returns whether vertex u and vertex v are equal.
	   * @param {libtess.GluVertex} u
	   * @param {libtess.GluVertex} v
	   * @return {boolean}
	   */

	  libtess.geom.vertEq = function (u, v) {
	    return u.s === v.s && u.t === v.t;
	  };
	  /**
	   * Returns whether vertex u is lexicographically less than or equal to vertex v.
	   * @param {libtess.GluVertex} u
	   * @param {libtess.GluVertex} v
	   * @return {boolean}
	   */


	  libtess.geom.vertLeq = function (u, v) {
	    return u.s < v.s || u.s === v.s && u.t <= v.t;
	  };
	  /**
	   * Given three vertices u,v,w such that geom.vertLeq(u,v) && geom.vertLeq(v,w),
	   * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
	   * Returns v.t - (uw)(v.s), ie. the signed distance from uw to v.
	   * If uw is vertical (and thus passes thru v), the result is zero.
	   *
	   * The calculation is extremely accurate and stable, even when v
	   * is very close to u or w.  In particular if we set v.t = 0 and
	   * let r be the negated result (this evaluates (uw)(v.s)), then
	   * r is guaranteed to satisfy MIN(u.t,w.t) <= r <= MAX(u.t,w.t).
	   * @param {libtess.GluVertex} u
	   * @param {libtess.GluVertex} v
	   * @param {libtess.GluVertex} w
	   * @return {number}
	   */


	  libtess.geom.edgeEval = function (u, v, w) {
	    var gapL = v.s - u.s;
	    var gapR = w.s - v.s;

	    if (gapL + gapR > 0) {
	      if (gapL < gapR) {
	        return v.t - u.t + (u.t - w.t) * (gapL / (gapL + gapR));
	      } else {
	        return v.t - w.t + (w.t - u.t) * (gapR / (gapL + gapR));
	      }
	    } // vertical line


	    return 0;
	  };
	  /**
	   * Returns a number whose sign matches geom.edgeEval(u,v,w) but which
	   * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
	   * as v is above, on, or below the edge uw.
	   * @param {libtess.GluVertex} u
	   * @param {libtess.GluVertex} v
	   * @param {libtess.GluVertex} w
	   * @return {number}
	   */


	  libtess.geom.edgeSign = function (u, v, w) {
	    var gapL = v.s - u.s;
	    var gapR = w.s - v.s;

	    if (gapL + gapR > 0) {
	      return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
	    } // vertical line


	    return 0;
	  };
	  /**
	   * Version of VertLeq with s and t transposed.
	   * Returns whether vertex u is lexicographically less than or equal to vertex v.
	   * @param {libtess.GluVertex} u
	   * @param {libtess.GluVertex} v
	   * @return {boolean}
	   */


	  libtess.geom.transLeq = function (u, v) {
	    return u.t < v.t || u.t === v.t && u.s <= v.s;
	  };
	  /**
	   * Version of geom.edgeEval with s and t transposed.
	   * Given three vertices u,v,w such that geom.transLeq(u,v) &&
	   * geom.transLeq(v,w), evaluates the t-coord of the edge uw at the s-coord of
	   * the vertex v. Returns v.s - (uw)(v.t), ie. the signed distance from uw to v.
	   * If uw is vertical (and thus passes thru v), the result is zero.
	   *
	   * The calculation is extremely accurate and stable, even when v
	   * is very close to u or w.  In particular if we set v.s = 0 and
	   * let r be the negated result (this evaluates (uw)(v.t)), then
	   * r is guaranteed to satisfy MIN(u.s,w.s) <= r <= MAX(u.s,w.s).
	   * @param {libtess.GluVertex} u
	   * @param {libtess.GluVertex} v
	   * @param {libtess.GluVertex} w
	   * @return {number}
	   */


	  libtess.geom.transEval = function (u, v, w) {
	    var gapL = v.t - u.t;
	    var gapR = w.t - v.t;

	    if (gapL + gapR > 0) {
	      if (gapL < gapR) {
	        return v.s - u.s + (u.s - w.s) * (gapL / (gapL + gapR));
	      } else {
	        return v.s - w.s + (w.s - u.s) * (gapR / (gapL + gapR));
	      }
	    } // vertical line


	    return 0;
	  };
	  /**
	   * Version of geom.edgeSign with s and t transposed.
	   * Returns a number whose sign matches geom.transEval(u,v,w) but which
	   * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
	   * as v is above, on, or below the edge uw.
	   * @param {libtess.GluVertex} u
	   * @param {libtess.GluVertex} v
	   * @param {libtess.GluVertex} w
	   * @return {number}
	   */


	  libtess.geom.transSign = function (u, v, w) {
	    var gapL = v.t - u.t;
	    var gapR = w.t - v.t;

	    if (gapL + gapR > 0) {
	      return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
	    } // vertical line


	    return 0;
	  };
	  /**
	   * Returns whether edge is directed from right to left.
	   * @param {libtess.GluHalfEdge} e
	   * @return {boolean}
	   */


	  libtess.geom.edgeGoesLeft = function (e) {
	    return libtess.geom.vertLeq(e.dst(), e.org);
	  };
	  /**
	   * Returns whether edge is directed from left to right.
	   * @param {libtess.GluHalfEdge} e
	   * @return {boolean}
	   */


	  libtess.geom.edgeGoesRight = function (e) {
	    return libtess.geom.vertLeq(e.org, e.dst());
	  };
	  /**
	   * Calculates the L1 distance between vertices u and v.
	   * @param {libtess.GluVertex} u
	   * @param {libtess.GluVertex} v
	   * @return {number}
	   */


	  libtess.geom.vertL1dist = function (u, v) {
	    return Math.abs(u.s - v.s) + Math.abs(u.t - v.t);
	  }; // NOTE(bckenny): vertCCW is called nowhere in libtess and isn't part of the
	  // public API.

	  /* istanbul ignore next */

	  /**
	   * For almost-degenerate situations, the results are not reliable.
	   * Unless the floating-point arithmetic can be performed without
	   * rounding errors, *any* implementation will give incorrect results
	   * on some degenerate inputs, so the client must have some way to
	   * handle this situation.
	   * @param {!libtess.GluVertex} u
	   * @param {!libtess.GluVertex} v
	   * @param {!libtess.GluVertex} w
	   * @return {boolean}
	   */


	  libtess.geom.vertCCW = function (u, v, w) {
	    return u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t) >= 0;
	  };
	  /**
	   * Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
	   * or (x+y)/2 if a==b==0. It requires that a,b >= 0, and enforces
	   * this in the rare case that one argument is slightly negative.
	   * The implementation is extremely stable numerically.
	   * In particular it guarantees that the result r satisfies
	   * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
	   * even when a and b differ greatly in magnitude.
	   * @private
	   * @param {number} a
	   * @param {number} x
	   * @param {number} b
	   * @param {number} y
	   * @return {number}
	   */


	  libtess.geom.interpolate_ = function (a, x, b, y) {
	    // from Macro RealInterpolate:
	    //(a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b, ((a <= b) ? ((b == 0) ? ((x+y) / 2) : (x + (y-x) * (a/(a+b)))) : (y + (x-y) * (b/(a+b)))))
	    a = a < 0 ? 0 : a;
	    b = b < 0 ? 0 : b;

	    if (a <= b) {
	      if (b === 0) {
	        return (x + y) / 2;
	      } else {
	        return x + (y - x) * (a / (a + b));
	      }
	    } else {
	      return y + (x - y) * (b / (a + b));
	    }
	  };
	  /**
	   * Given edges (o1,d1) and (o2,d2), compute their point of intersection.
	   * The computed point is guaranteed to lie in the intersection of the
	   * bounding rectangles defined by each edge.
	   * @param {!libtess.GluVertex} o1
	   * @param {!libtess.GluVertex} d1
	   * @param {!libtess.GluVertex} o2
	   * @param {!libtess.GluVertex} d2
	   * @param {!libtess.GluVertex} v
	   */


	  libtess.geom.edgeIntersect = function (o1, d1, o2, d2, v) {
	    // This is certainly not the most efficient way to find the intersection
	    // of two line segments, but it is very numerically stable.
	    // Strategy: find the two middle vertices in the VertLeq ordering,
	    // and interpolate the intersection s-value from these. Then repeat
	    // using the TransLeq ordering to find the intersection t-value.
	    var z1;
	    var z2;
	    var tmp;

	    if (!libtess.geom.vertLeq(o1, d1)) {
	      // Swap(o1, d1);
	      tmp = o1;
	      o1 = d1;
	      d1 = tmp;
	    }

	    if (!libtess.geom.vertLeq(o2, d2)) {
	      // Swap(o2, d2);
	      tmp = o2;
	      o2 = d2;
	      d2 = tmp;
	    }

	    if (!libtess.geom.vertLeq(o1, o2)) {
	      // Swap(o1, o2);
	      tmp = o1;
	      o1 = o2;
	      o2 = tmp; // Swap(d1, d2);

	      tmp = d1;
	      d1 = d2;
	      d2 = tmp;
	    }

	    if (!libtess.geom.vertLeq(o2, d1)) {
	      // Technically, no intersection -- do our best
	      v.s = (o2.s + d1.s) / 2;
	    } else if (libtess.geom.vertLeq(d1, d2)) {
	      // Interpolate between o2 and d1
	      z1 = libtess.geom.edgeEval(o1, o2, d1);
	      z2 = libtess.geom.edgeEval(o2, d1, d2);

	      if (z1 + z2 < 0) {
	        z1 = -z1;
	        z2 = -z2;
	      }

	      v.s = libtess.geom.interpolate_(z1, o2.s, z2, d1.s);
	    } else {
	      // Interpolate between o2 and d2
	      z1 = libtess.geom.edgeSign(o1, o2, d1);
	      z2 = -libtess.geom.edgeSign(o1, d2, d1);

	      if (z1 + z2 < 0) {
	        z1 = -z1;
	        z2 = -z2;
	      }

	      v.s = libtess.geom.interpolate_(z1, o2.s, z2, d2.s);
	    } // Now repeat the process for t


	    if (!libtess.geom.transLeq(o1, d1)) {
	      // Swap(o1, d1);
	      tmp = o1;
	      o1 = d1;
	      d1 = tmp;
	    }

	    if (!libtess.geom.transLeq(o2, d2)) {
	      // Swap(o2, d2);
	      tmp = o2;
	      o2 = d2;
	      d2 = tmp;
	    }

	    if (!libtess.geom.transLeq(o1, o2)) {
	      // Swap(o1, o2);
	      tmp = o1;
	      o1 = o2;
	      o2 = tmp; // Swap(d1, d2);

	      tmp = d1;
	      d1 = d2;
	      d2 = tmp;
	    }

	    if (!libtess.geom.transLeq(o2, d1)) {
	      // Technically, no intersection -- do our best
	      v.t = (o2.t + d1.t) / 2;
	    } else if (libtess.geom.transLeq(d1, d2)) {
	      // Interpolate between o2 and d1
	      z1 = libtess.geom.transEval(o1, o2, d1);
	      z2 = libtess.geom.transEval(o2, d1, d2);

	      if (z1 + z2 < 0) {
	        z1 = -z1;
	        z2 = -z2;
	      }

	      v.t = libtess.geom.interpolate_(z1, o2.t, z2, d1.t);
	    } else {
	      // Interpolate between o2 and d2
	      z1 = libtess.geom.transSign(o1, o2, d1);
	      z2 = -libtess.geom.transSign(o1, d2, d1);

	      if (z1 + z2 < 0) {
	        z1 = -z1;
	        z2 = -z2;
	      }

	      v.t = libtess.geom.interpolate_(z1, o2.t, z2, d2.t);
	    }
	  };
	  /* global libtess */
	  // TODO(bckenny): could maybe merge GluMesh and mesh.js since these are
	  // operations on the mesh

	  /** @const */


	  libtess.mesh = {};
	  /****************** Basic Edge Operations **********************/

	  /**
	   * makeEdge creates one edge, two vertices, and a loop (face).
	   * The loop consists of the two new half-edges.
	   *
	   * @param {libtess.GluMesh} mesh [description].
	   * @return {libtess.GluHalfEdge} [description].
	   */

	  libtess.mesh.makeEdge = function (mesh) {
	    // TODO(bckenny): probably move to GluMesh, but needs Make* methods with it
	    var e = libtess.mesh.makeEdgePair_(mesh.eHead); // complete edge with vertices and face (see mesh.makeEdgePair_)

	    libtess.mesh.makeVertex_(e, mesh.vHead);
	    libtess.mesh.makeVertex_(e.sym, mesh.vHead);
	    libtess.mesh.makeFace_(e, mesh.fHead);
	    return e;
	  };
	  /**
	   * meshSplice(eOrg, eDst) is the basic operation for changing the
	   * mesh connectivity and topology. It changes the mesh so that
	   *  eOrg.oNext <- OLD( eDst.oNext )
	   *  eDst.oNext <- OLD( eOrg.oNext )
	   * where OLD(...) means the value before the meshSplice operation.
	   *
	   * This can have two effects on the vertex structure:
	   *  - if eOrg.org != eDst.org, the two vertices are merged together
	   *  - if eOrg.org == eDst.org, the origin is split into two vertices
	   * In both cases, eDst.org is changed and eOrg.org is untouched.
	   *
	   * Similarly (and independently) for the face structure,
	   *  - if eOrg.lFace == eDst.lFace, one loop is split into two
	   *  - if eOrg.lFace != eDst.lFace, two distinct loops are joined into one
	   * In both cases, eDst.lFace is changed and eOrg.lFace is unaffected.
	   *
	   * Some special cases:
	   * If eDst == eOrg, the operation has no effect.
	   * If eDst == eOrg.lNext, the new face will have a single edge.
	   * If eDst == eOrg.lPrev(), the old face will have a single edge.
	   * If eDst == eOrg.oNext, the new vertex will have a single edge.
	   * If eDst == eOrg.oPrev(), the old vertex will have a single edge.
	   *
	   * @param {libtess.GluHalfEdge} eOrg [description].
	   * @param {libtess.GluHalfEdge} eDst [description].
	   */


	  libtess.mesh.meshSplice = function (eOrg, eDst) {
	    // TODO: more descriptive name?
	    var joiningLoops = false;
	    var joiningVertices = false;

	    if (eOrg === eDst) {
	      return;
	    }

	    if (eDst.org !== eOrg.org) {
	      // We are merging two disjoint vertices -- destroy eDst.org
	      joiningVertices = true;
	      libtess.mesh.killVertex_(eDst.org, eOrg.org);
	    }

	    if (eDst.lFace !== eOrg.lFace) {
	      // We are connecting two disjoint loops -- destroy eDst.lFace
	      joiningLoops = true;
	      libtess.mesh.killFace_(eDst.lFace, eOrg.lFace);
	    } // Change the edge structure


	    libtess.mesh.splice_(eDst, eOrg);

	    if (!joiningVertices) {
	      // We split one vertex into two -- the new vertex is eDst.org.
	      // Make sure the old vertex points to a valid half-edge.
	      libtess.mesh.makeVertex_(eDst, eOrg.org);
	      eOrg.org.anEdge = eOrg;
	    }

	    if (!joiningLoops) {
	      // We split one loop into two -- the new loop is eDst.lFace.
	      // Make sure the old face points to a valid half-edge.
	      libtess.mesh.makeFace_(eDst, eOrg.lFace);
	      eOrg.lFace.anEdge = eOrg;
	    }
	  };
	  /**
	   * deleteEdge(eDel) removes the edge eDel. There are several cases:
	   * if (eDel.lFace != eDel.rFace()), we join two loops into one; the loop
	   * eDel.lFace is deleted. Otherwise, we are splitting one loop into two;
	   * the newly created loop will contain eDel.dst(). If the deletion of eDel
	   * would create isolated vertices, those are deleted as well.
	   *
	   * This function could be implemented as two calls to __gl_meshSplice
	   * plus a few calls to memFree, but this would allocate and delete
	   * unnecessary vertices and faces.
	   *
	   * @param {libtess.GluHalfEdge} eDel [description].
	   */


	  libtess.mesh.deleteEdge = function (eDel) {
	    var eDelSym = eDel.sym;
	    var joiningLoops = false; // First step: disconnect the origin vertex eDel.org.  We make all
	    // changes to get a consistent mesh in this "intermediate" state.

	    if (eDel.lFace !== eDel.rFace()) {
	      // We are joining two loops into one -- remove the left face
	      joiningLoops = true;
	      libtess.mesh.killFace_(eDel.lFace, eDel.rFace());
	    }

	    if (eDel.oNext === eDel) {
	      libtess.mesh.killVertex_(eDel.org, null);
	    } else {
	      // Make sure that eDel.org and eDel.rFace() point to valid half-edges
	      eDel.rFace().anEdge = eDel.oPrev();
	      eDel.org.anEdge = eDel.oNext;
	      libtess.mesh.splice_(eDel, eDel.oPrev());

	      if (!joiningLoops) {
	        // We are splitting one loop into two -- create a new loop for eDel.
	        libtess.mesh.makeFace_(eDel, eDel.lFace);
	      }
	    } // Claim: the mesh is now in a consistent state, except that eDel.org
	    // may have been deleted.  Now we disconnect eDel.dst().


	    if (eDelSym.oNext === eDelSym) {
	      libtess.mesh.killVertex_(eDelSym.org, null);
	      libtess.mesh.killFace_(eDelSym.lFace, null);
	    } else {
	      // Make sure that eDel.dst() and eDel.lFace point to valid half-edges
	      eDel.lFace.anEdge = eDelSym.oPrev();
	      eDelSym.org.anEdge = eDelSym.oNext;
	      libtess.mesh.splice_(eDelSym, eDelSym.oPrev());
	    } // Any isolated vertices or faces have already been freed.


	    libtess.mesh.killEdge_(eDel);
	  };
	  /******************** Other Edge Operations **********************/

	  /* All these routines can be implemented with the basic edge
	   * operations above.  They are provided for convenience and efficiency.
	   */

	  /**
	   * addEdgeVertex(eOrg) creates a new edge eNew such that
	   * eNew == eOrg.lNext, and eNew.dst() is a newly created vertex.
	   * eOrg and eNew will have the same left face.
	   *
	   * @param {libtess.GluHalfEdge} eOrg [description].
	   * @return {libtess.GluHalfEdge} [description].
	   */


	  libtess.mesh.addEdgeVertex = function (eOrg) {
	    // TODO(bckenny): why is it named this?
	    var eNew = libtess.mesh.makeEdgePair_(eOrg);
	    var eNewSym = eNew.sym; // Connect the new edge appropriately

	    libtess.mesh.splice_(eNew, eOrg.lNext); // Set the vertex and face information

	    eNew.org = eOrg.dst();
	    libtess.mesh.makeVertex_(eNewSym, eNew.org);
	    eNew.lFace = eNewSym.lFace = eOrg.lFace;
	    return eNew;
	  };
	  /**
	   * splitEdge(eOrg) splits eOrg into two edges eOrg and eNew,
	   * such that eNew == eOrg.lNext. The new vertex is eOrg.dst() == eNew.org.
	   * eOrg and eNew will have the same left face.
	   *
	   * @param {libtess.GluHalfEdge} eOrg [description].
	   * @return {!libtess.GluHalfEdge} [description].
	   */


	  libtess.mesh.splitEdge = function (eOrg) {
	    var tempHalfEdge = libtess.mesh.addEdgeVertex(eOrg);
	    var eNew = tempHalfEdge.sym; // Disconnect eOrg from eOrg.dst() and connect it to eNew.org

	    libtess.mesh.splice_(eOrg.sym, eOrg.sym.oPrev());
	    libtess.mesh.splice_(eOrg.sym, eNew); // Set the vertex and face information

	    eOrg.sym.org = eNew.org; // NOTE(bckenny): assignment to dst

	    eNew.dst().anEdge = eNew.sym; // may have pointed to eOrg.sym

	    eNew.sym.lFace = eOrg.rFace(); // NOTE(bckenny): assignment to rFace

	    eNew.winding = eOrg.winding; // copy old winding information

	    eNew.sym.winding = eOrg.sym.winding;
	    return eNew;
	  };
	  /**
	   * connect(eOrg, eDst) creates a new edge from eOrg.dst()
	   * to eDst.org, and returns the corresponding half-edge eNew.
	   * If eOrg.lFace == eDst.lFace, this splits one loop into two,
	   * and the newly created loop is eNew.lFace. Otherwise, two disjoint
	   * loops are merged into one, and the loop eDst.lFace is destroyed.
	   *
	   * If (eOrg == eDst), the new face will have only two edges.
	   * If (eOrg.lNext == eDst), the old face is reduced to a single edge.
	   * If (eOrg.lNext.lNext == eDst), the old face is reduced to two edges.
	   *
	   * @param {libtess.GluHalfEdge} eOrg [description].
	   * @param {libtess.GluHalfEdge} eDst [description].
	   * @return {!libtess.GluHalfEdge} [description].
	   */


	  libtess.mesh.connect = function (eOrg, eDst) {
	    var joiningLoops = false;
	    var eNew = libtess.mesh.makeEdgePair_(eOrg);
	    var eNewSym = eNew.sym;

	    if (eDst.lFace !== eOrg.lFace) {
	      // We are connecting two disjoint loops -- destroy eDst.lFace
	      joiningLoops = true;
	      libtess.mesh.killFace_(eDst.lFace, eOrg.lFace);
	    } // Connect the new edge appropriately


	    libtess.mesh.splice_(eNew, eOrg.lNext);
	    libtess.mesh.splice_(eNewSym, eDst); // Set the vertex and face information

	    eNew.org = eOrg.dst();
	    eNewSym.org = eDst.org;
	    eNew.lFace = eNewSym.lFace = eOrg.lFace; // Make sure the old face points to a valid half-edge

	    eOrg.lFace.anEdge = eNewSym;

	    if (!joiningLoops) {
	      // We split one loop into two -- the new loop is eNew.lFace
	      libtess.mesh.makeFace_(eNew, eOrg.lFace);
	    }

	    return eNew;
	  };
	  /******************** Other Operations **********************/

	  /**
	   * zapFace(fZap) destroys a face and removes it from the
	   * global face list. All edges of fZap will have a null pointer as their
	   * left face. Any edges which also have a null pointer as their right face
	   * are deleted entirely (along with any isolated vertices this produces).
	   * An entire mesh can be deleted by zapping its faces, one at a time,
	   * in any order. Zapped faces cannot be used in further mesh operations!
	   *
	   * @param {libtess.GluFace} fZap [description].
	   */


	  libtess.mesh.zapFace = function (fZap) {
	    var eStart = fZap.anEdge; // walk around face, deleting edges whose right face is also NULL

	    var eNext = eStart.lNext;
	    var e;

	    do {
	      e = eNext;
	      eNext = e.lNext;
	      e.lFace = null;

	      if (e.rFace() === null) {
	        // delete the edge -- see mesh.deleteEdge above
	        if (e.oNext === e) {
	          libtess.mesh.killVertex_(e.org, null);
	        } else {
	          // Make sure that e.org points to a valid half-edge
	          e.org.anEdge = e.oNext;
	          libtess.mesh.splice_(e, e.oPrev());
	        }

	        var eSym = e.sym;

	        if (eSym.oNext === eSym) {
	          libtess.mesh.killVertex_(eSym.org, null);
	        } else {
	          // Make sure that eSym.org points to a valid half-edge
	          eSym.org.anEdge = eSym.oNext;
	          libtess.mesh.splice_(eSym, eSym.oPrev());
	        }

	        libtess.mesh.killEdge_(e);
	      }
	    } while (e !== eStart); // delete from circular doubly-linked list


	    var fPrev = fZap.prev;
	    var fNext = fZap.next;
	    fNext.prev = fPrev;
	    fPrev.next = fNext; // TODO(bckenny): memFree( fZap );
	    // TODO(bckenny): probably null at callsite
	  }; // TODO(bckenny): meshUnion isn't called within libtess and isn't part of the
	  // public API. Could be useful if more mesh manipulation functions are exposed.

	  /* istanbul ignore next */

	  /**
	   * meshUnion() forms the union of all structures in
	   * both meshes, and returns the new mesh (the old meshes are destroyed).
	   *
	   * @param {!libtess.GluMesh} mesh1
	   * @param {!libtess.GluMesh} mesh2
	   * @return {!libtess.GluMesh}
	   */


	  libtess.mesh.meshUnion = function (mesh1, mesh2) {
	    // TODO(bceknny): probably move to GluMesh method
	    var f1 = mesh1.fHead;
	    var v1 = mesh1.vHead;
	    var e1 = mesh1.eHead;
	    var f2 = mesh2.fHead;
	    var v2 = mesh2.vHead;
	    var e2 = mesh2.eHead; // Add the faces, vertices, and edges of mesh2 to those of mesh1

	    if (f2.next !== f2) {
	      f1.prev.next = f2.next;
	      f2.next.prev = f1.prev;
	      f2.prev.next = f1;
	      f1.prev = f2.prev;
	    }

	    if (v2.next !== v2) {
	      v1.prev.next = v2.next;
	      v2.next.prev = v1.prev;
	      v2.prev.next = v1;
	      v1.prev = v2.prev;
	    }

	    if (e2.next !== e2) {
	      e1.sym.next.sym.next = e2.next;
	      e2.next.sym.next = e1.sym.next;
	      e2.sym.next.sym.next = e1;
	      e1.sym.next = e2.sym.next;
	    } // TODO(bckenny): memFree(mesh2);
	    // TODO(bckenny): If function is kept, remove mesh2's data to enforce.


	    return mesh1;
	  };
	  /**
	   * deleteMesh(mesh) will free all storage for any valid mesh.
	   * @param {libtess.GluMesh} mesh [description].
	   */


	  libtess.mesh.deleteMesh = function (mesh) {// TODO(bckenny): unnecessary, I think.
	    // TODO(bckenny): might want to explicitly null at callsite
	    // lots of memFrees. see also DELETE_BY_ZAPPING
	  };
	  /************************ Utility Routines ************************/

	  /**
	   * Creates a new pair of half-edges which form their own loop.
	   * No vertex or face structures are allocated, but these must be assigned
	   * before the current edge operation is completed.
	   *
	   * TODO(bckenny): warning about eNext strictly being first of pair? (see code)
	   *
	   * @private
	   * @param {libtess.GluHalfEdge} eNext [description].
	   * @return {libtess.GluHalfEdge} [description].
	   */


	  libtess.mesh.makeEdgePair_ = function (eNext) {
	    var e = new libtess.GluHalfEdge();
	    var eSym = new libtess.GluHalfEdge(); // TODO(bckenny): how do we ensure this? see above comment in jsdoc
	    // Make sure eNext points to the first edge of the edge pair
	    // if (eNext->Sym < eNext ) { eNext = eNext->Sym; }
	    // NOTE(bckenny): check this for bugs in current implementation!
	    // Insert in circular doubly-linked list before eNext.
	    // Note that the prev pointer is stored in sym.next.

	    var ePrev = eNext.sym.next;
	    eSym.next = ePrev;
	    ePrev.sym.next = e;
	    e.next = eNext;
	    eNext.sym.next = eSym;
	    e.sym = eSym;
	    e.oNext = e;
	    e.lNext = eSym;
	    eSym.sym = e;
	    eSym.oNext = eSym;
	    eSym.lNext = e;
	    return e;
	  };
	  /**
	   * splice_ is best described by the Guibas/Stolfi paper or the
	   * CS348a notes. Basically, it modifies the mesh so that
	   * a.oNext and b.oNext are exchanged. This can have various effects
	   * depending on whether a and b belong to different face or vertex rings.
	   * For more explanation see mesh.meshSplice below.
	   *
	   * @private
	   * @param {libtess.GluHalfEdge} a [description].
	   * @param {libtess.GluHalfEdge} b [description].
	   */


	  libtess.mesh.splice_ = function (a, b) {
	    var aONext = a.oNext;
	    var bONext = b.oNext;
	    aONext.sym.lNext = b;
	    bONext.sym.lNext = a;
	    a.oNext = bONext;
	    b.oNext = aONext;
	  };
	  /**
	   * makeVertex_(eOrig, vNext) attaches a new vertex and makes it the
	   * origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
	   * a place to insert the new vertex in the global vertex list.  We insert
	   * the new vertex *before* vNext so that algorithms which walk the vertex
	   * list will not see the newly created vertices.
	   *
	   * NOTE: unlike original, acutally allocates new vertex.
	   *
	   * @private
	   * @param {libtess.GluHalfEdge} eOrig [description].
	   * @param {libtess.GluVertex} vNext [description].
	   */


	  libtess.mesh.makeVertex_ = function (eOrig, vNext) {
	    // insert in circular doubly-linked list before vNext
	    var vPrev = vNext.prev;
	    var vNew = new libtess.GluVertex(vNext, vPrev);
	    vPrev.next = vNew;
	    vNext.prev = vNew;
	    vNew.anEdge = eOrig; // leave coords, s, t undefined
	    // TODO(bckenny): does above line mean 0 specifically, or does it matter?
	    // fix other edges on this vertex loop

	    var e = eOrig;

	    do {
	      e.org = vNew;
	      e = e.oNext;
	    } while (e !== eOrig);
	  };
	  /**
	   * makeFace_(eOrig, fNext) attaches a new face and makes it the left
	   * face of all edges in the face loop to which eOrig belongs. "fNext" gives
	   * a place to insert the new face in the global face list.  We insert
	   * the new face *before* fNext so that algorithms which walk the face
	   * list will not see the newly created faces.
	   *
	   * NOTE: unlike original, acutally allocates new face.
	   *
	   * @private
	   * @param {libtess.GluHalfEdge} eOrig [description].
	   * @param {libtess.GluFace} fNext [description].
	   */


	  libtess.mesh.makeFace_ = function (eOrig, fNext) {
	    // insert in circular doubly-linked list before fNext
	    var fPrev = fNext.prev;
	    var fNew = new libtess.GluFace(fNext, fPrev);
	    fPrev.next = fNew;
	    fNext.prev = fNew;
	    fNew.anEdge = eOrig; // The new face is marked "inside" if the old one was.  This is a
	    // convenience for the common case where a face has been split in two.

	    fNew.inside = fNext.inside; // fix other edges on this face loop

	    var e = eOrig;

	    do {
	      e.lFace = fNew;
	      e = e.lNext;
	    } while (e !== eOrig);
	  };
	  /**
	   * killEdge_ destroys an edge (the half-edges eDel and eDel.sym),
	   * and removes from the global edge list.
	   *
	   * @private
	   * @param {libtess.GluHalfEdge} eDel [description].
	   */


	  libtess.mesh.killEdge_ = function (eDel) {
	    // TODO(bckenny): in this case, no need to worry(?), but check when checking mesh.makeEdgePair_
	    // Half-edges are allocated in pairs, see EdgePair above
	    // if (eDel->Sym < eDel ) { eDel = eDel->Sym; }
	    // delete from circular doubly-linked list
	    var eNext = eDel.next;
	    var ePrev = eDel.sym.next;
	    eNext.sym.next = ePrev;
	    ePrev.sym.next = eNext; // TODO(bckenny): memFree( eDel ); (which also frees eDel.sym)
	    // TODO(bckenny): need to null at callsites?
	  };
	  /**
	   * killVertex_ destroys a vertex and removes it from the global
	   * vertex list. It updates the vertex loop to point to a given new vertex.
	   *
	   * @private
	   * @param {libtess.GluVertex} vDel [description].
	   * @param {libtess.GluVertex} newOrg [description].
	   */


	  libtess.mesh.killVertex_ = function (vDel, newOrg) {
	    var eStart = vDel.anEdge; // change the origin of all affected edges

	    var e = eStart;

	    do {
	      e.org = newOrg;
	      e = e.oNext;
	    } while (e !== eStart); // delete from circular doubly-linked list


	    var vPrev = vDel.prev;
	    var vNext = vDel.next;
	    vNext.prev = vPrev;
	    vPrev.next = vNext; // TODO(bckenny): memFree( vDel );
	    // TODO(bckenny): need to null at callsites?
	  };
	  /**
	   * killFace_ destroys a face and removes it from the global face
	   * list. It updates the face loop to point to a given new face.
	   *
	   * @private
	   * @param {libtess.GluFace} fDel [description].
	   * @param {libtess.GluFace} newLFace [description].
	   */


	  libtess.mesh.killFace_ = function (fDel, newLFace) {
	    var eStart = fDel.anEdge; // change the left face of all affected edges

	    var e = eStart;

	    do {
	      e.lFace = newLFace;
	      e = e.lNext;
	    } while (e !== eStart); // delete from circular doubly-linked list


	    var fPrev = fDel.prev;
	    var fNext = fDel.next;
	    fNext.prev = fPrev;
	    fPrev.next = fNext; // TODO(bckenny): memFree( fDel );
	    // TODO(bckenny): need to null at callsites?
	  };
	  /* global libtess */

	  /** @const */


	  libtess.normal = {}; // TODO(bckenny): Integrate SLANTED_SWEEP somehow?

	  /* The "feature merging" is not intended to be complete. There are
	   * special cases where edges are nearly parallel to the sweep line
	   * which are not implemented. The algorithm should still behave
	   * robustly (ie. produce a reasonable tesselation) in the presence
	   * of such edges, however it may miss features which could have been
	   * merged. We could minimize this effect by choosing the sweep line
	   * direction to be something unusual (ie. not parallel to one of the
	   * coordinate axes).
	   * #if defined(SLANTED_SWEEP)
	   * #define S_UNIT_X  0.50941539564955385 // Pre-normalized
	   * #define S_UNIT_Y  0.86052074622010633
	   * #endif
	   */

	  /**
	   * X coordinate of local basis for polygon projection.
	   * @private
	   * @const
	   */

	  libtess.normal.S_UNIT_X_ = 1.0;
	  /**
	   * Y coordinate of local basis for polygon projection.
	   * @private
	   * @const
	   */

	  libtess.normal.S_UNIT_Y_ = 0.0;
	  /**
	   * Determines a polygon normal and projects vertices onto the plane of the
	   * polygon.
	   * @param {!libtess.GluTesselator} tess
	   */

	  libtess.normal.projectPolygon = function (tess) {
	    var computedNormal = false;
	    var norm = [tess.normal[0], tess.normal[1], tess.normal[2]];

	    if (norm[0] === 0 && norm[1] === 0 && norm[2] === 0) {
	      libtess.normal.computeNormal_(tess, norm);
	      computedNormal = true;
	    }

	    var sUnit = tess.sUnit;
	    var tUnit = tess.tUnit;
	    var i = libtess.normal.longAxis_(norm); // NOTE(bckenny): This branch is never taken. See comment on
	    // libtess.TRUE_PROJECT.

	    /* istanbul ignore if */

	    if (libtess.TRUE_PROJECT) {
	      // Choose the initial sUnit vector to be approximately perpendicular
	      // to the normal.
	      libtess.normal.normalize_(norm);
	      sUnit[i] = 0;
	      sUnit[(i + 1) % 3] = libtess.normal.S_UNIT_X_;
	      sUnit[(i + 2) % 3] = libtess.normal.S_UNIT_Y_; // Now make it exactly perpendicular

	      var w = libtess.normal.dot_(sUnit, norm);
	      sUnit[0] -= w * norm[0];
	      sUnit[1] -= w * norm[1];
	      sUnit[2] -= w * norm[2];
	      libtess.normal.normalize_(sUnit); // Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame

	      tUnit[0] = norm[1] * sUnit[2] - norm[2] * sUnit[1];
	      tUnit[1] = norm[2] * sUnit[0] - norm[0] * sUnit[2];
	      tUnit[2] = norm[0] * sUnit[1] - norm[1] * sUnit[0];
	      libtess.normal.normalize_(tUnit);
	    } else {
	      // Project perpendicular to a coordinate axis -- better numerically
	      sUnit[i] = 0;
	      sUnit[(i + 1) % 3] = libtess.normal.S_UNIT_X_;
	      sUnit[(i + 2) % 3] = libtess.normal.S_UNIT_Y_;
	      tUnit[i] = 0;
	      tUnit[(i + 1) % 3] = norm[i] > 0 ? -libtess.normal.S_UNIT_Y_ : libtess.normal.S_UNIT_Y_;
	      tUnit[(i + 2) % 3] = norm[i] > 0 ? libtess.normal.S_UNIT_X_ : -libtess.normal.S_UNIT_X_;
	    } // Project the vertices onto the sweep plane


	    var vHead = tess.mesh.vHead;

	    for (var v = vHead.next; v !== vHead; v = v.next) {
	      v.s = libtess.normal.dot_(v.coords, sUnit);
	      v.t = libtess.normal.dot_(v.coords, tUnit);
	    }

	    if (computedNormal) {
	      libtess.normal.checkOrientation_(tess);
	    }
	  };
	  /**
	   * Computes the dot product of vectors u and v.
	   * @private
	   * @param {!Array.<number>} u
	   * @param {!Array.<number>} v
	   * @return {number}
	   */


	  libtess.normal.dot_ = function (u, v) {
	    return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
	  }; // NOTE(bckenny): only called from within libtess.normal.projectPolygon's
	  // TRUE_PROJECT branch, so ignoring for code coverage.

	  /* istanbul ignore next */

	  /**
	   * Normalize vector v.
	   * @private
	   * @param {!Array.<number>} v
	   */


	  libtess.normal.normalize_ = function (v) {
	    var len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
	    len = Math.sqrt(len);
	    v[0] /= len;
	    v[1] /= len;
	    v[2] /= len;
	  };
	  /**
	   * Returns the index of the longest component of vector v.
	   * @private
	   * @param {!Array.<number>} v
	   * @return {number}
	   */


	  libtess.normal.longAxis_ = function (v) {
	    var i = 0;

	    if (Math.abs(v[1]) > Math.abs(v[0])) {
	      i = 1;
	    }

	    if (Math.abs(v[2]) > Math.abs(v[i])) {
	      i = 2;
	    }

	    return i;
	  };
	  /**
	   * Compute an approximate normal of the polygon from the vertices themselves.
	   * Result returned in norm.
	   * @private
	   * @param {!libtess.GluTesselator} tess
	   * @param {!Array.<number>} norm
	   */


	  libtess.normal.computeNormal_ = function (tess, norm) {
	    var maxVal = [-2 * libtess.GLU_TESS_MAX_COORD, -2 * libtess.GLU_TESS_MAX_COORD, -2 * libtess.GLU_TESS_MAX_COORD];
	    var minVal = [2 * libtess.GLU_TESS_MAX_COORD, 2 * libtess.GLU_TESS_MAX_COORD, 2 * libtess.GLU_TESS_MAX_COORD];
	    var maxVert = [];
	    var minVert = [];
	    var v;
	    var vHead = tess.mesh.vHead;

	    for (v = vHead.next; v !== vHead; v = v.next) {
	      for (var i = 0; i < 3; ++i) {
	        var c = v.coords[i];

	        if (c < minVal[i]) {
	          minVal[i] = c;
	          minVert[i] = v;
	        }

	        if (c > maxVal[i]) {
	          maxVal[i] = c;
	          maxVert[i] = v;
	        }
	      }
	    } // Find two vertices separated by at least 1/sqrt(3) of the maximum
	    // distance between any two vertices


	    var index = 0;

	    if (maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) {
	      index = 1;
	    }

	    if (maxVal[2] - minVal[2] > maxVal[index] - minVal[index]) {
	      index = 2;
	    }

	    if (minVal[index] >= maxVal[index]) {
	      // All vertices are the same -- normal doesn't matter
	      norm[0] = 0;
	      norm[1] = 0;
	      norm[2] = 1;
	      return;
	    } // Look for a third vertex which forms the triangle with maximum area
	    // (Length of normal == twice the triangle area)


	    var maxLen2 = 0;
	    var v1 = minVert[index];
	    var v2 = maxVert[index];
	    var tNorm = [0, 0, 0];
	    var d1 = [v1.coords[0] - v2.coords[0], v1.coords[1] - v2.coords[1], v1.coords[2] - v2.coords[2]];
	    var d2 = [0, 0, 0];

	    for (v = vHead.next; v !== vHead; v = v.next) {
	      d2[0] = v.coords[0] - v2.coords[0];
	      d2[1] = v.coords[1] - v2.coords[1];
	      d2[2] = v.coords[2] - v2.coords[2];
	      tNorm[0] = d1[1] * d2[2] - d1[2] * d2[1];
	      tNorm[1] = d1[2] * d2[0] - d1[0] * d2[2];
	      tNorm[2] = d1[0] * d2[1] - d1[1] * d2[0];
	      var tLen2 = tNorm[0] * tNorm[0] + tNorm[1] * tNorm[1] + tNorm[2] * tNorm[2];

	      if (tLen2 > maxLen2) {
	        maxLen2 = tLen2;
	        norm[0] = tNorm[0];
	        norm[1] = tNorm[1];
	        norm[2] = tNorm[2];
	      }
	    }

	    if (maxLen2 <= 0) {
	      // All points lie on a single line -- any decent normal will do
	      norm[0] = norm[1] = norm[2] = 0;
	      norm[libtess.normal.longAxis_(d1)] = 1;
	    }
	  };
	  /**
	   * Check that the sum of the signed area of all projected contours is
	   * non-negative. If not, negate the t-coordinates to reverse the orientation and
	   * make it so.
	   * @private
	   * @param {!libtess.GluTesselator} tess
	   */


	  libtess.normal.checkOrientation_ = function (tess) {
	    var area = 0;
	    var fHead = tess.mesh.fHead;

	    for (var f = fHead.next; f !== fHead; f = f.next) {
	      var e = f.anEdge;

	      if (e.winding <= 0) {
	        continue;
	      }

	      do {
	        area += (e.org.s - e.dst().s) * (e.org.t + e.dst().t);
	        e = e.lNext;
	      } while (e !== f.anEdge);
	    }

	    if (area < 0) {
	      // Reverse the orientation by flipping all the t-coordinates
	      var vHead = tess.mesh.vHead;

	      for (var v = vHead.next; v !== vHead; v = v.next) {
	        v.t = -v.t;
	      }

	      tess.tUnit[0] = -tess.tUnit[0];
	      tess.tUnit[1] = -tess.tUnit[1];
	      tess.tUnit[2] = -tess.tUnit[2];
	    }
	  };
	  /* global libtess */

	  /** @const */


	  libtess.render = {};
	  /**
	   * Takes a mesh, breaks it into separate triangles, and renders them. The
	   * rendering output is provided as callbacks (see the API). Set flagEdges to
	   * true to get edgeFlag callbacks (tess.flagBoundary in original libtess).
	   * @param {!libtess.GluTesselator} tess
	   * @param {!libtess.GluMesh} mesh
	   * @param {boolean} flagEdges
	   */

	  libtess.render.renderMesh = function (tess, mesh, flagEdges) {
	    var beginOrBeginDataCalled = false; // TODO(bckenny): edgeState needs to be boolean, but !== on first call
	    // force edge state output for first vertex

	    var edgeState = -1; // We examine all faces in an arbitrary order. Whenever we find
	    // an inside triangle f, we render f.
	    // NOTE(bckenny): go backwards through face list to match original libtess
	    // triangle order

	    for (var f = mesh.fHead.prev; f !== mesh.fHead; f = f.prev) {
	      if (f.inside) {
	        // We're going to emit a triangle, so call begin callback once
	        if (!beginOrBeginDataCalled) {
	          tess.callBeginOrBeginData(libtess.primitiveType.GL_TRIANGLES);
	          beginOrBeginDataCalled = true;
	        } // check that face has only three edges


	        var e = f.anEdge; // Loop once for each edge (there will always be 3 edges)

	        do {
	          if (flagEdges) {
	            // Set the "edge state" to true just before we output the
	            // first vertex of each edge on the polygon boundary.
	            var newState = !e.rFace().inside ? 1 : 0; // TODO(bckenny): total hack to get edgeState working. fix me.

	            if (edgeState !== newState) {
	              edgeState = newState; // TODO(bckenny): edgeState should be boolean now

	              tess.callEdgeFlagOrEdgeFlagData(!!edgeState);
	            }
	          } // emit vertex


	          tess.callVertexOrVertexData(e.org.data);
	          e = e.lNext;
	        } while (e !== f.anEdge);
	      }
	    } // only call end callback if begin was called


	    if (beginOrBeginDataCalled) {
	      tess.callEndOrEndData();
	    }
	  };
	  /**
	   * Takes a mesh, and outputs one contour for each face marked "inside". The
	   * rendering output is provided as callbacks (see the API).
	   * @param {!libtess.GluTesselator} tess
	   * @param {!libtess.GluMesh} mesh
	   */


	  libtess.render.renderBoundary = function (tess, mesh) {
	    for (var f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {
	      if (f.inside) {
	        tess.callBeginOrBeginData(libtess.primitiveType.GL_LINE_LOOP);
	        var e = f.anEdge;

	        do {
	          tess.callVertexOrVertexData(e.org.data);
	          e = e.lNext;
	        } while (e !== f.anEdge);

	        tess.callEndOrEndData();
	      }
	    }
	  };
	  /* global libtess */
	  // TODO(bckenny): a number of these never return null (as opposed to original) and should be typed appropriately

	  /*
	   * Invariants for the Edge Dictionary.
	   * - each pair of adjacent edges e2=succ(e1) satisfies edgeLeq_(e1,e2)
	   *   at any valid location of the sweep event
	   * - if edgeLeq_(e2,e1) as well (at any valid sweep event), then e1 and e2
	   *   share a common endpoint
	   * - for each e, e.dst() has been processed, but not e.org
	   * - each edge e satisfies vertLeq(e.dst(),event) && vertLeq(event,e.org)
	   *   where "event" is the current sweep line event.
	   * - no edge e has zero length
	   *
	   * Invariants for the Mesh (the processed portion).
	   * - the portion of the mesh left of the sweep line is a planar graph,
	   *   ie. there is *some* way to embed it in the plane
	   * - no processed edge has zero length
	   * - no two processed vertices have identical coordinates
	   * - each "inside" region is monotone, ie. can be broken into two chains
	   *   of monotonically increasing vertices according to VertLeq(v1,v2)
	   *   - a non-invariant: these chains may intersect (very slightly)
	   *
	   * Invariants for the Sweep.
	   * - if none of the edges incident to the event vertex have an activeRegion
	   *   (ie. none of these edges are in the edge dictionary), then the vertex
	   *   has only right-going edges.
	   * - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
	   *   by ConnectRightVertex), then it is the only right-going edge from
	   *   its associated vertex.  (This says that these edges exist only
	   *   when it is necessary.)
	   */

	  /** @const */


	  libtess.sweep = {};
	  /**
	   * Make the sentinel coordinates big enough that they will never be
	   * merged with real input features.  (Even with the largest possible
	   * input contour and the maximum tolerance of 1.0, no merging will be
	   * done with coordinates larger than 3 * libtess.GLU_TESS_MAX_COORD).
	   * @private
	   * @const
	   * @type {number}
	   */

	  libtess.sweep.SENTINEL_COORD_ = 4 * libtess.GLU_TESS_MAX_COORD;
	  /**
	   * Because vertices at exactly the same location are merged together
	   * before we process the sweep event, some degenerate cases can't occur.
	   * However if someone eventually makes the modifications required to
	   * merge features which are close together, the cases below marked
	   * TOLERANCE_NONZERO will be useful.  They were debugged before the
	   * code to merge identical vertices in the main loop was added.
	   * @private
	   * @const
	   * @type {boolean}
	   */

	  libtess.sweep.TOLERANCE_NONZERO_ = false;
	  /**
	   * computeInterior(tess) computes the planar arrangement specified
	   * by the given contours, and further subdivides this arrangement
	   * into regions. Each region is marked "inside" if it belongs
	   * to the polygon, according to the rule given by tess.windingRule.
	   * Each interior region is guaranteed be monotone.
	   *
	   * @param {libtess.GluTesselator} tess [description].
	   */

	  libtess.sweep.computeInterior = function (tess) {
	    tess.fatalError = false; // Each vertex defines an event for our sweep line. Start by inserting
	    // all the vertices in a priority queue. Events are processed in
	    // lexicographic order, ie.
	    // e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)

	    libtess.sweep.removeDegenerateEdges_(tess);
	    libtess.sweep.initPriorityQ_(tess);
	    libtess.sweep.initEdgeDict_(tess); // TODO(bckenny): don't need the cast if pq's key is better typed

	    var v;

	    while ((v =
	    /** @type {libtess.GluVertex} */
	    tess.pq.extractMin()) !== null) {
	      for (;;) {
	        var vNext =
	        /** @type {libtess.GluVertex} */
	        tess.pq.minimum();

	        if (vNext === null || !libtess.geom.vertEq(vNext, v)) {
	          break;
	        }
	        /* Merge together all vertices at exactly the same location.
	         * This is more efficient than processing them one at a time,
	         * simplifies the code (see connectLeftDegenerate), and is also
	         * important for correct handling of certain degenerate cases.
	         * For example, suppose there are two identical edges A and B
	         * that belong to different contours (so without this code they would
	         * be processed by separate sweep events).  Suppose another edge C
	         * crosses A and B from above.  When A is processed, we split it
	         * at its intersection point with C.  However this also splits C,
	         * so when we insert B we may compute a slightly different
	         * intersection point.  This might leave two edges with a small
	         * gap between them.  This kind of error is especially obvious
	         * when using boundary extraction (GLU_TESS_BOUNDARY_ONLY).
	         */


	        vNext =
	        /** @type {libtess.GluVertex} */
	        tess.pq.extractMin();
	        libtess.sweep.spliceMergeVertices_(tess, v.anEdge, vNext.anEdge);
	      }

	      libtess.sweep.sweepEvent_(tess, v);
	    } // TODO(bckenny): what does the next comment mean? can we eliminate event except when debugging?
	    // Set tess.event for debugging purposes


	    var minRegion = tess.dict.getMin().getKey();
	    tess.event = minRegion.eUp.org;
	    libtess.sweep.doneEdgeDict_(tess);
	    libtess.sweep.donePriorityQ_(tess);
	    libtess.sweep.removeDegenerateFaces_(tess.mesh);
	    tess.mesh.checkMesh();
	  };
	  /**
	   * When we merge two edges into one, we need to compute the combined
	   * winding of the new edge.
	   * @private
	   * @param {libtess.GluHalfEdge} eDst [description].
	   * @param {libtess.GluHalfEdge} eSrc [description].
	   */


	  libtess.sweep.addWinding_ = function (eDst, eSrc) {
	    // NOTE(bckenny): from AddWinding macro
	    eDst.winding += eSrc.winding;
	    eDst.sym.winding += eSrc.sym.winding;
	  };
	  /**
	   * Both edges must be directed from right to left (this is the canonical
	   * direction for the upper edge of each region).
	   *
	   * The strategy is to evaluate a "t" value for each edge at the
	   * current sweep line position, given by tess.event.  The calculations
	   * are designed to be very stable, but of course they are not perfect.
	   *
	   * Special case: if both edge destinations are at the sweep event,
	   * we sort the edges by slope (they would otherwise compare equally).
	   *
	   * @private
	   * @param {!libtess.GluTesselator} tess
	   * @param {!libtess.ActiveRegion} reg1
	   * @param {!libtess.ActiveRegion} reg2
	   * @return {boolean}
	   */


	  libtess.sweep.edgeLeq_ = function (tess, reg1, reg2) {
	    var event = tess.event;
	    var e1 = reg1.eUp;
	    var e2 = reg2.eUp;

	    if (e1.dst() === event) {
	      if (e2.dst() === event) {
	        // Two edges right of the sweep line which meet at the sweep event.
	        // Sort them by slope.
	        if (libtess.geom.vertLeq(e1.org, e2.org)) {
	          return libtess.geom.edgeSign(e2.dst(), e1.org, e2.org) <= 0;
	        }

	        return libtess.geom.edgeSign(e1.dst(), e2.org, e1.org) >= 0;
	      }

	      return libtess.geom.edgeSign(e2.dst(), event, e2.org) <= 0;
	    }

	    if (e2.dst() === event) {
	      return libtess.geom.edgeSign(e1.dst(), event, e1.org) >= 0;
	    } // General case - compute signed distance *from* e1, e2 to event


	    var t1 = libtess.geom.edgeEval(e1.dst(), event, e1.org);
	    var t2 = libtess.geom.edgeEval(e2.dst(), event, e2.org);
	    return t1 >= t2;
	  };
	  /**
	   * [deleteRegion_ description]
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.ActiveRegion} reg [description].
	   */


	  libtess.sweep.deleteRegion_ = function (tess, reg) {
	    if (reg.fixUpperEdge) ;

	    reg.eUp.activeRegion = null;
	    tess.dict.deleteNode(reg.nodeUp);
	    reg.nodeUp = null; // memFree( reg ); TODO(bckenny)
	    // TODO(bckenny): may need to null at callsite
	  };
	  /**
	   * Replace an upper edge which needs fixing (see connectRightVertex).
	   * @private
	   * @param {libtess.ActiveRegion} reg [description].
	   * @param {libtess.GluHalfEdge} newEdge [description].
	   */


	  libtess.sweep.fixUpperEdge_ = function (reg, newEdge) {
	    libtess.mesh.deleteEdge(reg.eUp);
	    reg.fixUpperEdge = false;
	    reg.eUp = newEdge;
	    newEdge.activeRegion = reg;
	  };
	  /**
	   * Find the region above the uppermost edge with the same origin.
	   * @private
	   * @param {libtess.ActiveRegion} reg [description].
	   * @return {libtess.ActiveRegion} [description].
	   */


	  libtess.sweep.topLeftRegion_ = function (reg) {
	    var org = reg.eUp.org; // Find the region above the uppermost edge with the same origin

	    do {
	      reg = reg.regionAbove();
	    } while (reg.eUp.org === org); // If the edge above was a temporary edge introduced by connectRightVertex,
	    // now is the time to fix it.


	    if (reg.fixUpperEdge) {
	      var e = libtess.mesh.connect(reg.regionBelow().eUp.sym, reg.eUp.lNext);
	      libtess.sweep.fixUpperEdge_(reg, e);
	      reg = reg.regionAbove();
	    }

	    return reg;
	  };
	  /**
	   * Find the region above the uppermost edge with the same destination.
	   * @private
	   * @param {libtess.ActiveRegion} reg [description].
	   * @return {libtess.ActiveRegion} [description].
	   */


	  libtess.sweep.topRightRegion_ = function (reg) {
	    var dst = reg.eUp.dst();

	    do {
	      reg = reg.regionAbove();
	    } while (reg.eUp.dst() === dst);

	    return reg;
	  };
	  /**
	   * Add a new active region to the sweep line, *somewhere* below "regAbove"
	   * (according to where the new edge belongs in the sweep-line dictionary).
	   * The upper edge of the new region will be "eNewUp".
	   * Winding number and "inside" flag are not updated.
	   *
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.ActiveRegion} regAbove [description].
	   * @param {libtess.GluHalfEdge} eNewUp [description].
	   * @return {libtess.ActiveRegion} regNew.
	   */


	  libtess.sweep.addRegionBelow_ = function (tess, regAbove, eNewUp) {
	    var regNew = new libtess.ActiveRegion();
	    regNew.eUp = eNewUp;
	    regNew.nodeUp = tess.dict.insertBefore(regAbove.nodeUp, regNew);
	    eNewUp.activeRegion = regNew;
	    return regNew;
	  };
	  /**
	   * [isWindingInside_ description]
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {number} n int.
	   * @return {boolean} [description].
	   */


	  libtess.sweep.isWindingInside_ = function (tess, n) {
	    switch (tess.windingRule) {
	      case libtess.windingRule.GLU_TESS_WINDING_ODD:
	        return (n & 1) !== 0;

	      case libtess.windingRule.GLU_TESS_WINDING_NONZERO:
	        return n !== 0;

	      case libtess.windingRule.GLU_TESS_WINDING_POSITIVE:
	        return n > 0;

	      case libtess.windingRule.GLU_TESS_WINDING_NEGATIVE:
	        return n < 0;

	      case libtess.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO:
	        return n >= 2 || n <= -2;
	    } // TODO(bckenny): not reached


	    return false;
	  };
	  /**
	   * [computeWinding_ description]
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.ActiveRegion} reg [description].
	   */


	  libtess.sweep.computeWinding_ = function (tess, reg) {
	    reg.windingNumber = reg.regionAbove().windingNumber + reg.eUp.winding;
	    reg.inside = libtess.sweep.isWindingInside_(tess, reg.windingNumber);
	  };
	  /**
	   * Delete a region from the sweep line. This happens when the upper
	   * and lower chains of a region meet (at a vertex on the sweep line).
	   * The "inside" flag is copied to the appropriate mesh face (we could
	   * not do this before -- since the structure of the mesh is always
	   * changing, this face may not have even existed until now).
	   *
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.ActiveRegion} reg [description].
	   */


	  libtess.sweep.finishRegion_ = function (tess, reg) {
	    // TODO(bckenny): may need to null reg at callsite
	    var e = reg.eUp;
	    var f = e.lFace;
	    f.inside = reg.inside;
	    f.anEdge = e; // optimization for tessmono.tessellateMonoRegion() // TODO(bckenny): how so?

	    libtess.sweep.deleteRegion_(tess, reg);
	  };
	  /**
	   * We are given a vertex with one or more left-going edges. All affected
	   * edges should be in the edge dictionary. Starting at regFirst.eUp,
	   * we walk down deleting all regions where both edges have the same
	   * origin vOrg. At the same time we copy the "inside" flag from the
	   * active region to the face, since at this point each face will belong
	   * to at most one region (this was not necessarily true until this point
	   * in the sweep). The walk stops at the region above regLast; if regLast
	   * is null we walk as far as possible. At the same time we relink the
	   * mesh if necessary, so that the ordering of edges around vOrg is the
	   * same as in the dictionary.
	   *
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.ActiveRegion} regFirst [description].
	   * @param {libtess.ActiveRegion} regLast [description].
	   * @return {libtess.GluHalfEdge} [description].
	   */


	  libtess.sweep.finishLeftRegions_ = function (tess, regFirst, regLast) {
	    var regPrev = regFirst;
	    var ePrev = regFirst.eUp;

	    while (regPrev !== regLast) {
	      // placement was OK
	      regPrev.fixUpperEdge = false;
	      var reg = regPrev.regionBelow();
	      var e = reg.eUp;

	      if (e.org !== ePrev.org) {
	        if (!reg.fixUpperEdge) {
	          /* Remove the last left-going edge. Even though there are no further
	           * edges in the dictionary with this origin, there may be further
	           * such edges in the mesh (if we are adding left edges to a vertex
	           * that has already been processed). Thus it is important to call
	           * finishRegion rather than just deleteRegion.
	           */
	          libtess.sweep.finishRegion_(tess, regPrev);
	          break;
	        } // If the edge below was a temporary edge introduced by
	        // connectRightVertex, now is the time to fix it.


	        e = libtess.mesh.connect(ePrev.lPrev(), e.sym);
	        libtess.sweep.fixUpperEdge_(reg, e);
	      } // Relink edges so that ePrev.oNext === e


	      if (ePrev.oNext !== e) {
	        libtess.mesh.meshSplice(e.oPrev(), e);
	        libtess.mesh.meshSplice(ePrev, e);
	      } // may change reg.eUp


	      libtess.sweep.finishRegion_(tess, regPrev);
	      ePrev = reg.eUp;
	      regPrev = reg;
	    }

	    return ePrev;
	  };
	  /**
	   * Purpose: insert right-going edges into the edge dictionary, and update
	   * winding numbers and mesh connectivity appropriately. All right-going
	   * edges share a common origin vOrg. Edges are inserted CCW starting at
	   * eFirst; the last edge inserted is eLast.oPrev. If vOrg has any
	   * left-going edges already processed, then eTopLeft must be the edge
	   * such that an imaginary upward vertical segment from vOrg would be
	   * contained between eTopLeft.oPrev and eTopLeft; otherwise eTopLeft
	   * should be null.
	   *
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.ActiveRegion} regUp [description].
	   * @param {libtess.GluHalfEdge} eFirst [description].
	   * @param {libtess.GluHalfEdge} eLast [description].
	   * @param {libtess.GluHalfEdge} eTopLeft [description].
	   * @param {boolean} cleanUp [description].
	   */


	  libtess.sweep.addRightEdges_ = function (tess, regUp, eFirst, eLast, eTopLeft, cleanUp) {
	    var firstTime = true; // Insert the new right-going edges in the dictionary

	    var e = eFirst;

	    do {
	      libtess.sweep.addRegionBelow_(tess, regUp, e.sym);
	      e = e.oNext;
	    } while (e !== eLast); // Walk *all* right-going edges from e.org, in the dictionary order,
	    // updating the winding numbers of each region, and re-linking the mesh
	    // edges to match the dictionary ordering (if necessary).


	    if (eTopLeft === null) {
	      eTopLeft = regUp.regionBelow().eUp.rPrev();
	    }

	    var regPrev = regUp;
	    var ePrev = eTopLeft;
	    var reg;

	    for (;;) {
	      reg = regPrev.regionBelow();
	      e = reg.eUp.sym;

	      if (e.org !== ePrev.org) {
	        break;
	      }

	      if (e.oNext !== ePrev) {
	        // Unlink e from its current position, and relink below ePrev
	        libtess.mesh.meshSplice(e.oPrev(), e);
	        libtess.mesh.meshSplice(ePrev.oPrev(), e);
	      } // Compute the winding number and "inside" flag for the new regions


	      reg.windingNumber = regPrev.windingNumber - e.winding;
	      reg.inside = libtess.sweep.isWindingInside_(tess, reg.windingNumber); // Check for two outgoing edges with same slope -- process these
	      // before any intersection tests (see example in libtess.sweep.computeInterior).

	      regPrev.dirty = true;

	      if (!firstTime && libtess.sweep.checkForRightSplice_(tess, regPrev)) {
	        libtess.sweep.addWinding_(e, ePrev);
	        libtess.sweep.deleteRegion_(tess, regPrev); // TODO(bckenny): need to null regPrev anywhere else?

	        libtess.mesh.deleteEdge(ePrev);
	      }

	      firstTime = false;
	      regPrev = reg;
	      ePrev = e;
	    }

	    regPrev.dirty = true;

	    if (cleanUp) {
	      // Check for intersections between newly adjacent edges.
	      libtess.sweep.walkDirtyRegions_(tess, regPrev);
	    }
	  };
	  /**
	   * [callCombine_ description]
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.GluVertex} isect [description].
	   * @param {Array.<Object>} data [description].
	   * @param {Array.<number>} weights [description].
	   * @param {boolean} needed [description].
	   */


	  libtess.sweep.callCombine_ = function (tess, isect, data, weights, needed) {
	    // Copy coord data in case the callback changes it.
	    var coords = [isect.coords[0], isect.coords[1], isect.coords[2]];
	    isect.data = null;
	    isect.data = tess.callCombineOrCombineData(coords, data, weights);

	    if (isect.data === null) {
	      if (!needed) {
	        // not needed, so just use data from first vertex
	        isect.data = data[0];
	      } else if (!tess.fatalError) {
	        // The only way fatal error is when two edges are found to intersect,
	        // but the user has not provided the callback necessary to handle
	        // generated intersection points.
	        tess.callErrorOrErrorData(libtess.errorType.GLU_TESS_NEED_COMBINE_CALLBACK);
	        tess.fatalError = true;
	      }
	    }
	  };
	  /**
	   * Two vertices with idential coordinates are combined into one.
	   * e1.org is kept, while e2.org is discarded.
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.GluHalfEdge} e1 [description].
	   * @param {libtess.GluHalfEdge} e2 [description].
	   */


	  libtess.sweep.spliceMergeVertices_ = function (tess, e1, e2) {
	    // TODO(bckenny): better way to init these? save them?
	    var data = [null, null, null, null];
	    var weights = [0.5, 0.5, 0, 0];
	    data[0] = e1.org.data;
	    data[1] = e2.org.data;
	    libtess.sweep.callCombine_(tess, e1.org, data, weights, false);
	    libtess.mesh.meshSplice(e1, e2);
	  };
	  /**
	   * Find some weights which describe how the intersection vertex is
	   * a linear combination of org and dst. Each of the two edges
	   * which generated "isect" is allocated 50% of the weight; each edge
	   * splits the weight between its org and dst according to the
	   * relative distance to "isect".
	   *
	   * @private
	   * @param {libtess.GluVertex} isect [description].
	   * @param {libtess.GluVertex} org [description].
	   * @param {libtess.GluVertex} dst [description].
	   * @param {Array.<number>} weights [description].
	   * @param {number} weightIndex Index into weights for first weight to supply.
	   */


	  libtess.sweep.vertexWeights_ = function (isect, org, dst, weights, weightIndex) {
	    // TODO(bckenny): think through how we can use L1dist here and be correct for coords
	    var t1 = libtess.geom.vertL1dist(org, isect);
	    var t2 = libtess.geom.vertL1dist(dst, isect); // TODO(bckenny): introduced weightIndex to mimic addressing in original
	    // 1) document (though it is private and only used from getIntersectData)
	    // 2) better way? manually inline into getIntersectData? supply two two-length tmp arrays?

	    var i0 = weightIndex;
	    var i1 = weightIndex + 1;
	    weights[i0] = 0.5 * t2 / (t1 + t2);
	    weights[i1] = 0.5 * t1 / (t1 + t2);
	    isect.coords[0] += weights[i0] * org.coords[0] + weights[i1] * dst.coords[0];
	    isect.coords[1] += weights[i0] * org.coords[1] + weights[i1] * dst.coords[1];
	    isect.coords[2] += weights[i0] * org.coords[2] + weights[i1] * dst.coords[2];
	  };
	  /**
	   * We've computed a new intersection point, now we need a "data" pointer
	   * from the user so that we can refer to this new vertex in the
	   * rendering callbacks.
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.GluVertex} isect [description].
	   * @param {libtess.GluVertex} orgUp [description].
	   * @param {libtess.GluVertex} dstUp [description].
	   * @param {libtess.GluVertex} orgLo [description].
	   * @param {libtess.GluVertex} dstLo [description].
	   */


	  libtess.sweep.getIntersectData_ = function (tess, isect, orgUp, dstUp, orgLo, dstLo) {
	    // TODO(bckenny): called for every intersection event, should these be from a pool?
	    // TODO(bckenny): better way to init these?
	    var weights = [0, 0, 0, 0];
	    var data = [orgUp.data, dstUp.data, orgLo.data, dstLo.data]; // TODO(bckenny): it appears isect is a reappropriated vertex, so does need to be zeroed.
	    // double check this.

	    isect.coords[0] = isect.coords[1] = isect.coords[2] = 0; // TODO(bckenny): see note in libtess.sweep.vertexWeights_ for explanation of weightIndex. fix?

	    libtess.sweep.vertexWeights_(isect, orgUp, dstUp, weights, 0);
	    libtess.sweep.vertexWeights_(isect, orgLo, dstLo, weights, 2);
	    libtess.sweep.callCombine_(tess, isect, data, weights, true);
	  };
	  /**
	   * Check the upper and lower edge of regUp, to make sure that the
	   * eUp.org is above eLo, or eLo.org is below eUp (depending on which
	   * origin is leftmost).
	   *
	   * The main purpose is to splice right-going edges with the same
	   * dest vertex and nearly identical slopes (ie. we can't distinguish
	   * the slopes numerically). However the splicing can also help us
	   * to recover from numerical errors. For example, suppose at one
	   * point we checked eUp and eLo, and decided that eUp.org is barely
	   * above eLo. Then later, we split eLo into two edges (eg. from
	   * a splice operation like this one). This can change the result of
	   * our test so that now eUp.org is incident to eLo, or barely below it.
	   * We must correct this condition to maintain the dictionary invariants.
	   *
	   * One possibility is to check these edges for intersection again
	   * (i.e. checkForIntersect). This is what we do if possible. However
	   * checkForIntersect requires that tess.event lies between eUp and eLo,
	   * so that it has something to fall back on when the intersection
	   * calculation gives us an unusable answer. So, for those cases where
	   * we can't check for intersection, this routine fixes the problem
	   * by just splicing the offending vertex into the other edge.
	   * This is a guaranteed solution, no matter how degenerate things get.
	   * Basically this is a combinatorial solution to a numerical problem.
	   *
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.ActiveRegion} regUp [description].
	   * @return {boolean} [description].
	   */


	  libtess.sweep.checkForRightSplice_ = function (tess, regUp) {
	    // TODO(bckenny): fully learn how these two checks work
	    var regLo = regUp.regionBelow();
	    var eUp = regUp.eUp;
	    var eLo = regLo.eUp;

	    if (libtess.geom.vertLeq(eUp.org, eLo.org)) {
	      if (libtess.geom.edgeSign(eLo.dst(), eUp.org, eLo.org) > 0) {
	        return false;
	      } // eUp.org appears to be below eLo


	      if (!libtess.geom.vertEq(eUp.org, eLo.org)) {
	        // Splice eUp.org into eLo
	        libtess.mesh.splitEdge(eLo.sym);
	        libtess.mesh.meshSplice(eUp, eLo.oPrev());
	        regUp.dirty = regLo.dirty = true;
	      } else if (eUp.org !== eLo.org) {
	        // merge the two vertices, discarding eUp.org
	        // TODO(bckenny): fix pqHandle null situation
	        tess.pq.remove(
	        /** @type {libtess.PQHandle} */
	        eUp.org.pqHandle);
	        libtess.sweep.spliceMergeVertices_(tess, eLo.oPrev(), eUp);
	      }
	    } else {
	      if (libtess.geom.edgeSign(eUp.dst(), eLo.org, eUp.org) < 0) {
	        return false;
	      } // eLo.org appears to be above eUp, so splice eLo.org into eUp


	      regUp.regionAbove().dirty = regUp.dirty = true;
	      libtess.mesh.splitEdge(eUp.sym);
	      libtess.mesh.meshSplice(eLo.oPrev(), eUp);
	    }

	    return true;
	  };
	  /**
	   * Check the upper and lower edge of regUp to make sure that the
	   * eUp.dst() is above eLo, or eLo.dst() is below eUp (depending on which
	   * destination is rightmost).
	   *
	   * Theoretically, this should always be true. However, splitting an edge
	   * into two pieces can change the results of previous tests. For example,
	   * suppose at one point we checked eUp and eLo, and decided that eUp.dst()
	   * is barely above eLo. Then later, we split eLo into two edges (eg. from
	   * a splice operation like this one). This can change the result of
	   * the test so that now eUp.dst() is incident to eLo, or barely below it.
	   * We must correct this condition to maintain the dictionary invariants
	   * (otherwise new edges might get inserted in the wrong place in the
	   * dictionary, and bad stuff will happen).
	   *
	   * We fix the problem by just splicing the offending vertex into the
	   * other edge.
	   *
	   * @private
	   * @param {libtess.GluTesselator} tess description].
	   * @param {libtess.ActiveRegion} regUp [description].
	   * @return {boolean} [description].
	   */


	  libtess.sweep.checkForLeftSplice_ = function (tess, regUp) {
	    var regLo = regUp.regionBelow();
	    var eUp = regUp.eUp;
	    var eLo = regLo.eUp;
	    var e;

	    if (libtess.geom.vertLeq(eUp.dst(), eLo.dst())) {
	      if (libtess.geom.edgeSign(eUp.dst(), eLo.dst(), eUp.org) < 0) {
	        return false;
	      } // eLo.dst() is above eUp, so splice eLo.dst() into eUp


	      regUp.regionAbove().dirty = regUp.dirty = true;
	      e = libtess.mesh.splitEdge(eUp);
	      libtess.mesh.meshSplice(eLo.sym, e);
	      e.lFace.inside = regUp.inside;
	    } else {
	      if (libtess.geom.edgeSign(eLo.dst(), eUp.dst(), eLo.org) > 0) {
	        return false;
	      } // eUp.dst() is below eLo, so splice eUp.dst() into eLo


	      regUp.dirty = regLo.dirty = true;
	      e = libtess.mesh.splitEdge(eLo);
	      libtess.mesh.meshSplice(eUp.lNext, eLo.sym);
	      e.rFace().inside = regUp.inside;
	    }

	    return true;
	  };
	  /**
	   * Check the upper and lower edges of the given region to see if
	   * they intersect. If so, create the intersection and add it
	   * to the data structures.
	   *
	   * Returns true if adding the new intersection resulted in a recursive
	   * call to addRightEdges_(); in this case all "dirty" regions have been
	   * checked for intersections, and possibly regUp has been deleted.
	   *
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.ActiveRegion} regUp [description].
	   * @return {boolean} [description].
	   */


	  libtess.sweep.checkForIntersect_ = function (tess, regUp) {
	    var regLo = regUp.regionBelow();
	    var eUp = regUp.eUp;
	    var eLo = regLo.eUp;
	    var orgUp = eUp.org;
	    var orgLo = eLo.org;
	    var dstUp = eUp.dst();
	    var dstLo = eLo.dst();
	    var isect = new libtess.GluVertex();

	    if (orgUp === orgLo) {
	      // right endpoints are the same
	      return false;
	    }

	    var tMinUp = Math.min(orgUp.t, dstUp.t);
	    var tMaxLo = Math.max(orgLo.t, dstLo.t);

	    if (tMinUp > tMaxLo) {
	      // t ranges do not overlap
	      return false;
	    }

	    if (libtess.geom.vertLeq(orgUp, orgLo)) {
	      if (libtess.geom.edgeSign(dstLo, orgUp, orgLo) > 0) {
	        return false;
	      }
	    } else {
	      if (libtess.geom.edgeSign(dstUp, orgLo, orgUp) < 0) {
	        return false;
	      }
	    } // At this point the edges intersect, at least marginally


	    libtess.geom.edgeIntersect(dstUp, orgUp, dstLo, orgLo, isect); // The following properties are guaranteed:

	    if (libtess.geom.vertLeq(isect, tess.event)) {
	      /* The intersection point lies slightly to the left of the sweep line,
	       * so move it until it's slightly to the right of the sweep line.
	       * (If we had perfect numerical precision, this would never happen
	       * in the first place). The easiest and safest thing to do is
	       * replace the intersection by tess.event.
	       */
	      isect.s = tess.event.s;
	      isect.t = tess.event.t;
	    } // TODO(bckenny): try to find test54.d

	    /* Similarly, if the computed intersection lies to the right of the
	     * rightmost origin (which should rarely happen), it can cause
	     * unbelievable inefficiency on sufficiently degenerate inputs.
	     * (If you have the test program, try running test54.d with the
	     * "X zoom" option turned on).
	     */


	    var orgMin = libtess.geom.vertLeq(orgUp, orgLo) ? orgUp : orgLo;

	    if (libtess.geom.vertLeq(orgMin, isect)) {
	      isect.s = orgMin.s;
	      isect.t = orgMin.t;
	    }

	    if (libtess.geom.vertEq(isect, orgUp) || libtess.geom.vertEq(isect, orgLo)) {
	      // Easy case -- intersection at one of the right endpoints
	      libtess.sweep.checkForRightSplice_(tess, regUp);
	      return false;
	    } // TODO(bckenny): clean this up; length is distracting


	    if (!libtess.geom.vertEq(dstUp, tess.event) && libtess.geom.edgeSign(dstUp, tess.event, isect) >= 0 || !libtess.geom.vertEq(dstLo, tess.event) && libtess.geom.edgeSign(dstLo, tess.event, isect) <= 0) {
	      /* Very unusual -- the new upper or lower edge would pass on the
	       * wrong side of the sweep event, or through it. This can happen
	       * due to very small numerical errors in the intersection calculation.
	       */
	      if (dstLo === tess.event) {
	        // Splice dstLo into eUp, and process the new region(s)
	        libtess.mesh.splitEdge(eUp.sym);
	        libtess.mesh.meshSplice(eLo.sym, eUp);
	        regUp = libtess.sweep.topLeftRegion_(regUp);
	        eUp = regUp.regionBelow().eUp;
	        libtess.sweep.finishLeftRegions_(tess, regUp.regionBelow(), regLo);
	        libtess.sweep.addRightEdges_(tess, regUp, eUp.oPrev(), eUp, eUp, true);
	        return true;
	      }

	      if (dstUp === tess.event) {
	        // Splice dstUp into eLo, and process the new region(s)
	        libtess.mesh.splitEdge(eLo.sym);
	        libtess.mesh.meshSplice(eUp.lNext, eLo.oPrev());
	        regLo = regUp;
	        regUp = libtess.sweep.topRightRegion_(regUp);
	        var e = regUp.regionBelow().eUp.rPrev();
	        regLo.eUp = eLo.oPrev();
	        eLo = libtess.sweep.finishLeftRegions_(tess, regLo, null);
	        libtess.sweep.addRightEdges_(tess, regUp, eLo.oNext, eUp.rPrev(), e, true);
	        return true;
	      }
	      /* Special case: called from connectRightVertex. If either
	       * edge passes on the wrong side of tess.event, split it
	       * (and wait for connectRightVertex to splice it appropriately).
	       */


	      if (libtess.geom.edgeSign(dstUp, tess.event, isect) >= 0) {
	        regUp.regionAbove().dirty = regUp.dirty = true;
	        libtess.mesh.splitEdge(eUp.sym);
	        eUp.org.s = tess.event.s;
	        eUp.org.t = tess.event.t;
	      }

	      if (libtess.geom.edgeSign(dstLo, tess.event, isect) <= 0) {
	        regUp.dirty = regLo.dirty = true;
	        libtess.mesh.splitEdge(eLo.sym);
	        eLo.org.s = tess.event.s;
	        eLo.org.t = tess.event.t;
	      } // leave the rest for connectRightVertex


	      return false;
	    }
	    /* General case -- split both edges, splice into new vertex.
	     * When we do the splice operation, the order of the arguments is
	     * arbitrary as far as correctness goes. However, when the operation
	     * creates a new face, the work done is proportional to the size of
	     * the new face. We expect the faces in the processed part of
	     * the mesh (ie. eUp.lFace) to be smaller than the faces in the
	     * unprocessed original contours (which will be eLo.oPrev.lFace).
	     */


	    libtess.mesh.splitEdge(eUp.sym);
	    libtess.mesh.splitEdge(eLo.sym);
	    libtess.mesh.meshSplice(eLo.oPrev(), eUp);
	    eUp.org.s = isect.s;
	    eUp.org.t = isect.t;
	    eUp.org.pqHandle = tess.pq.insert(eUp.org);
	    libtess.sweep.getIntersectData_(tess, eUp.org, orgUp, dstUp, orgLo, dstLo);
	    regUp.regionAbove().dirty = regUp.dirty = regLo.dirty = true;
	    return false;
	  };
	  /**
	   * When the upper or lower edge of any region changes, the region is
	   * marked "dirty". This routine walks through all the dirty regions
	   * and makes sure that the dictionary invariants are satisfied
	   * (see the comments at the beginning of this file). Of course,
	   * new dirty regions can be created as we make changes to restore
	   * the invariants.
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.ActiveRegion} regUp [description].
	   */


	  libtess.sweep.walkDirtyRegions_ = function (tess, regUp) {
	    var regLo = regUp.regionBelow();

	    for (;;) {
	      // Find the lowest dirty region (we walk from the bottom up).
	      while (regLo.dirty) {
	        regUp = regLo;
	        regLo = regLo.regionBelow();
	      }

	      if (!regUp.dirty) {
	        regLo = regUp;
	        regUp = regUp.regionAbove();

	        if (regUp === null || !regUp.dirty) {
	          // We've walked all the dirty regions
	          return;
	        }
	      }

	      regUp.dirty = false;
	      var eUp = regUp.eUp;
	      var eLo = regLo.eUp;

	      if (eUp.dst() !== eLo.dst()) {
	        // Check that the edge ordering is obeyed at the dst vertices.
	        if (libtess.sweep.checkForLeftSplice_(tess, regUp)) {
	          // If the upper or lower edge was marked fixUpperEdge, then
	          // we no longer need it (since these edges are needed only for
	          // vertices which otherwise have no right-going edges).
	          if (regLo.fixUpperEdge) {
	            libtess.sweep.deleteRegion_(tess, regLo);
	            libtess.mesh.deleteEdge(eLo);
	            regLo = regUp.regionBelow();
	            eLo = regLo.eUp;
	          } else if (regUp.fixUpperEdge) {
	            libtess.sweep.deleteRegion_(tess, regUp);
	            libtess.mesh.deleteEdge(eUp);
	            regUp = regLo.regionAbove();
	            eUp = regUp.eUp;
	          }
	        }
	      }

	      if (eUp.org !== eLo.org) {
	        if (eUp.dst() !== eLo.dst() && !regUp.fixUpperEdge && !regLo.fixUpperEdge && (eUp.dst() === tess.event || eLo.dst() === tess.event)) {
	          /* When all else fails in checkForIntersect(), it uses tess.event
	           * as the intersection location. To make this possible, it requires
	           * that tess.event lie between the upper and lower edges, and also
	           * that neither of these is marked fixUpperEdge (since in the worst
	           * case it might splice one of these edges into tess.event, and
	           * violate the invariant that fixable edges are the only right-going
	           * edge from their associated vertex).
	           */
	          if (libtess.sweep.checkForIntersect_(tess, regUp)) {
	            // walkDirtyRegions() was called recursively; we're done
	            return;
	          }
	        } else {
	          // Even though we can't use checkForIntersect(), the org vertices
	          // may violate the dictionary edge ordering. Check and correct this.
	          libtess.sweep.checkForRightSplice_(tess, regUp);
	        }
	      }

	      if (eUp.org === eLo.org && eUp.dst() === eLo.dst()) {
	        // A degenerate loop consisting of only two edges -- delete it.
	        libtess.sweep.addWinding_(eLo, eUp);
	        libtess.sweep.deleteRegion_(tess, regUp);
	        libtess.mesh.deleteEdge(eUp);
	        regUp = regLo.regionAbove();
	      }
	    }
	  };
	  /**
	   * Purpose: connect a "right" vertex vEvent (one where all edges go left)
	   * to the unprocessed portion of the mesh. Since there are no right-going
	   * edges, two regions (one above vEvent and one below) are being merged
	   * into one. regUp is the upper of these two regions.
	   *
	   * There are two reasons for doing this (adding a right-going edge):
	   *  - if the two regions being merged are "inside", we must add an edge
	   *    to keep them separated (the combined region would not be monotone).
	   *  - in any case, we must leave some record of vEvent in the dictionary,
	   *    so that we can merge vEvent with features that we have not seen yet.
	   *    For example, maybe there is a vertical edge which passes just to
	   *    the right of vEvent; we would like to splice vEvent into this edge.
	   *
	   * However, we don't want to connect vEvent to just any vertex. We don't
	   * want the new edge to cross any other edges; otherwise we will create
	   * intersection vertices even when the input data had no self-intersections.
	   * (This is a bad thing; if the user's input data has no intersections,
	   * we don't want to generate any false intersections ourselves.)
	   *
	   * Our eventual goal is to connect vEvent to the leftmost unprocessed
	   * vertex of the combined region (the union of regUp and regLo).
	   * But because of unseen vertices with all right-going edges, and also
	   * new vertices which may be created by edge intersections, we don't
	   * know where that leftmost unprocessed vertex is. In the meantime, we
	   * connect vEvent to the closest vertex of either chain, and mark the region
	   * as "fixUpperEdge". This flag says to delete and reconnect this edge
	   * to the next processed vertex on the boundary of the combined region.
	   * Quite possibly the vertex we connected to will turn out to be the
	   * closest one, in which case we won't need to make any changes.
	   *
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.ActiveRegion} regUp [description].
	   * @param {libtess.GluHalfEdge} eBottomLeft [description].
	   */


	  libtess.sweep.connectRightVertex_ = function (tess, regUp, eBottomLeft) {
	    var eTopLeft = eBottomLeft.oNext;
	    var regLo = regUp.regionBelow();
	    var eUp = regUp.eUp;
	    var eLo = regLo.eUp;
	    var degenerate = false;

	    if (eUp.dst() !== eLo.dst()) {
	      libtess.sweep.checkForIntersect_(tess, regUp);
	    } // Possible new degeneracies: upper or lower edge of regUp may pass
	    // through vEvent, or may coincide with new intersection vertex


	    if (libtess.geom.vertEq(eUp.org, tess.event)) {
	      libtess.mesh.meshSplice(eTopLeft.oPrev(), eUp);
	      regUp = libtess.sweep.topLeftRegion_(regUp);
	      eTopLeft = regUp.regionBelow().eUp;
	      libtess.sweep.finishLeftRegions_(tess, regUp.regionBelow(), regLo);
	      degenerate = true;
	    }

	    if (libtess.geom.vertEq(eLo.org, tess.event)) {
	      libtess.mesh.meshSplice(eBottomLeft, eLo.oPrev());
	      eBottomLeft = libtess.sweep.finishLeftRegions_(tess, regLo, null);
	      degenerate = true;
	    }

	    if (degenerate) {
	      libtess.sweep.addRightEdges_(tess, regUp, eBottomLeft.oNext, eTopLeft, eTopLeft, true);
	      return;
	    } // Non-degenerate situation -- need to add a temporary, fixable edge.
	    // Connect to the closer of eLo.org, eUp.org.


	    var eNew;

	    if (libtess.geom.vertLeq(eLo.org, eUp.org)) {
	      eNew = eLo.oPrev();
	    } else {
	      eNew = eUp;
	    }

	    eNew = libtess.mesh.connect(eBottomLeft.lPrev(), eNew); // Prevent cleanup, otherwise eNew might disappear before we've even
	    // had a chance to mark it as a temporary edge.

	    libtess.sweep.addRightEdges_(tess, regUp, eNew, eNew.oNext, eNew.oNext, false);
	    eNew.sym.activeRegion.fixUpperEdge = true;
	    libtess.sweep.walkDirtyRegions_(tess, regUp);
	  };
	  /**
	   * The event vertex lies exacty on an already-processed edge or vertex.
	   * Adding the new vertex involves splicing it into the already-processed
	   * part of the mesh.
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.ActiveRegion} regUp [description].
	   * @param {libtess.GluVertex} vEvent [description].
	   */


	  libtess.sweep.connectLeftDegenerate_ = function (tess, regUp, vEvent) {
	    var e = regUp.eUp;
	    /* istanbul ignore if */

	    if (libtess.geom.vertEq(e.org, vEvent)) {
	      // NOTE(bckenny): this code is unreachable but remains for a hypothetical
	      // future extension of libtess. See docs on libtess.sweep.TOLERANCE_NONZERO_
	      // for more information. Conditional on TOLERANCE_NONZERO_ to help Closure
	      // Compiler eliminate dead code.
	      // e.org is an unprocessed vertex - just combine them, and wait
	      // for e.org to be pulled from the queue
	      if (libtess.sweep.TOLERANCE_NONZERO_) {
	        libtess.sweep.spliceMergeVertices_(tess, e, vEvent.anEdge);
	      }

	      return;
	    }

	    if (!libtess.geom.vertEq(e.dst(), vEvent)) {
	      // General case -- splice vEvent into edge e which passes through it
	      libtess.mesh.splitEdge(e.sym);

	      if (regUp.fixUpperEdge) {
	        // This edge was fixable -- delete unused portion of original edge
	        libtess.mesh.deleteEdge(e.oNext);
	        regUp.fixUpperEdge = false;
	      }

	      libtess.mesh.meshSplice(vEvent.anEdge, e); // recurse

	      libtess.sweep.sweepEvent_(tess, vEvent);
	      return;
	    } // NOTE(bckenny): this code is unreachable but remains for a hypothetical
	    // future extension of libtess. See docs on libtess.sweep.TOLERANCE_NONZERO_
	    // for more information. Conditional on TOLERANCE_NONZERO_ to help Closure
	    // Compiler eliminate dead code.
	    // vEvent coincides with e.dst(), which has already been processed.
	    // Splice in the additional right-going edges.

	    /* istanbul ignore next */

	    /* istanbul ignore next */


	    if (libtess.sweep.TOLERANCE_NONZERO_) {
	      regUp = libtess.sweep.topRightRegion_(regUp);
	      var reg = regUp.regionBelow();
	      var eTopRight = reg.eUp.sym;
	      var eTopLeft = eTopRight.oNext;
	      var eLast = eTopLeft;

	      if (reg.fixUpperEdge) {
	        // Here e.dst() has only a single fixable edge going right.
	        // We can delete it since now we have some real right-going edges.
	        // there are some left edges too
	        libtess.sweep.deleteRegion_(tess, reg); // TODO(bckenny): something to null?

	        libtess.mesh.deleteEdge(eTopRight);
	        eTopRight = eTopLeft.oPrev();
	      }

	      libtess.mesh.meshSplice(vEvent.anEdge, eTopRight);

	      if (!libtess.geom.edgeGoesLeft(eTopLeft)) {
	        // e.dst() had no left-going edges -- indicate this to addRightEdges()
	        eTopLeft = null;
	      }

	      libtess.sweep.addRightEdges_(tess, regUp, eTopRight.oNext, eLast, eTopLeft, true);
	    }
	  };
	  /**
	   * Connect a "left" vertex (one where both edges go right)
	   * to the processed portion of the mesh. Let R be the active region
	   * containing vEvent, and let U and L be the upper and lower edge
	   * chains of R. There are two possibilities:
	   *
	   * - the normal case: split R into two regions, by connecting vEvent to
	   *   the rightmost vertex of U or L lying to the left of the sweep line
	   *
	   * - the degenerate case: if vEvent is close enough to U or L, we
	   *   merge vEvent into that edge chain. The subcases are:
	   *  - merging with the rightmost vertex of U or L
	   *  - merging with the active edge of U or L
	   *  - merging with an already-processed portion of U or L
	   *
	   * @private
	   * @param {libtess.GluTesselator} tess   [description].
	   * @param {libtess.GluVertex} vEvent [description].
	   */


	  libtess.sweep.connectLeftVertex_ = function (tess, vEvent) {
	    // TODO(bckenny): tmp only used for sweep. better to keep tmp across calls?
	    var tmp = new libtess.ActiveRegion(); // NOTE(bckenny): this was commented out in the original
	    // libtess.assert(vEvent.anEdge.oNext.oNext === vEvent.anEdge);
	    // Get a pointer to the active region containing vEvent

	    tmp.eUp = vEvent.anEdge.sym;
	    var regUp = tess.dict.search(tmp).getKey();
	    var regLo = regUp.regionBelow();
	    var eUp = regUp.eUp;
	    var eLo = regLo.eUp; // try merging with U or L first

	    if (libtess.geom.edgeSign(eUp.dst(), vEvent, eUp.org) === 0) {
	      libtess.sweep.connectLeftDegenerate_(tess, regUp, vEvent);
	      return;
	    } // Connect vEvent to rightmost processed vertex of either chain.
	    // e.dst() is the vertex that we will connect to vEvent.


	    var reg = libtess.geom.vertLeq(eLo.dst(), eUp.dst()) ? regUp : regLo;
	    var eNew;

	    if (regUp.inside || reg.fixUpperEdge) {
	      if (reg === regUp) {
	        eNew = libtess.mesh.connect(vEvent.anEdge.sym, eUp.lNext);
	      } else {
	        var tempHalfEdge = libtess.mesh.connect(eLo.dNext(), vEvent.anEdge);
	        eNew = tempHalfEdge.sym;
	      }

	      if (reg.fixUpperEdge) {
	        libtess.sweep.fixUpperEdge_(reg, eNew);
	      } else {
	        libtess.sweep.computeWinding_(tess, libtess.sweep.addRegionBelow_(tess, regUp, eNew));
	      }

	      libtess.sweep.sweepEvent_(tess, vEvent);
	    } else {
	      // The new vertex is in a region which does not belong to the polygon.
	      // We don''t need to connect this vertex to the rest of the mesh.
	      libtess.sweep.addRightEdges_(tess, regUp, vEvent.anEdge, vEvent.anEdge, null, true);
	    }
	  };
	  /**
	   * Does everything necessary when the sweep line crosses a vertex.
	   * Updates the mesh and the edge dictionary.
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {libtess.GluVertex} vEvent [description].
	   */


	  libtess.sweep.sweepEvent_ = function (tess, vEvent) {
	    tess.event = vEvent; // for access in edgeLeq_ // TODO(bckenny): wuh?

	    /* Check if this vertex is the right endpoint of an edge that is
	     * already in the dictionary.  In this case we don't need to waste
	     * time searching for the location to insert new edges.
	     */

	    var e = vEvent.anEdge;

	    while (e.activeRegion === null) {
	      e = e.oNext;

	      if (e === vEvent.anEdge) {
	        // All edges go right -- not incident to any processed edges
	        libtess.sweep.connectLeftVertex_(tess, vEvent);
	        return;
	      }
	    }
	    /* Processing consists of two phases: first we "finish" all the
	     * active regions where both the upper and lower edges terminate
	     * at vEvent (ie. vEvent is closing off these regions).
	     * We mark these faces "inside" or "outside" the polygon according
	     * to their winding number, and delete the edges from the dictionary.
	     * This takes care of all the left-going edges from vEvent.
	     */


	    var regUp = libtess.sweep.topLeftRegion_(e.activeRegion);
	    var reg = regUp.regionBelow();
	    var eTopLeft = reg.eUp;
	    var eBottomLeft = libtess.sweep.finishLeftRegions_(tess, reg, null);
	    /* Next we process all the right-going edges from vEvent. This
	     * involves adding the edges to the dictionary, and creating the
	     * associated "active regions" which record information about the
	     * regions between adjacent dictionary edges.
	     */

	    if (eBottomLeft.oNext === eTopLeft) {
	      // No right-going edges -- add a temporary "fixable" edge
	      libtess.sweep.connectRightVertex_(tess, regUp, eBottomLeft);
	    } else {
	      libtess.sweep.addRightEdges_(tess, regUp, eBottomLeft.oNext, eTopLeft, eTopLeft, true);
	    }
	  };
	  /**
	   * We add two sentinel edges above and below all other edges,
	   * to avoid special cases at the top and bottom.
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   * @param {number} t [description].
	   */


	  libtess.sweep.addSentinel_ = function (tess, t) {
	    var reg = new libtess.ActiveRegion();
	    var e = libtess.mesh.makeEdge(tess.mesh);
	    e.org.s = libtess.sweep.SENTINEL_COORD_;
	    e.org.t = t;
	    e.dst().s = -libtess.sweep.SENTINEL_COORD_;
	    e.dst().t = t;
	    tess.event = e.dst(); //initialize it

	    reg.eUp = e;
	    reg.windingNumber = 0;
	    reg.inside = false;
	    reg.fixUpperEdge = false;
	    reg.sentinel = true;
	    reg.dirty = false;
	    reg.nodeUp = tess.dict.insert(reg);
	  };
	  /**
	   * We maintain an ordering of edge intersections with the sweep line.
	   * This order is maintained in a dynamic dictionary.
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   */


	  libtess.sweep.initEdgeDict_ = function (tess) {
	    tess.dict = new libtess.Dict(tess, libtess.sweep.edgeLeq_);
	    libtess.sweep.addSentinel_(tess, -libtess.sweep.SENTINEL_COORD_);
	    libtess.sweep.addSentinel_(tess, libtess.sweep.SENTINEL_COORD_);
	  };
	  /**
	   * [doneEdgeDict_ description]
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   */


	  libtess.sweep.doneEdgeDict_ = function (tess) {
	    var reg;

	    while ((reg = tess.dict.getMin().getKey()) !== null) {
	      // At the end of all processing, the dictionary should contain
	      // only the two sentinel edges, plus at most one "fixable" edge
	      // created by connectRightVertex().
	      if (!reg.sentinel) ;

	      libtess.sweep.deleteRegion_(tess, reg);
	    } // NOTE(bckenny): see tess.dict.deleteDict_() for old delete dict function


	    tess.dict = null;
	  };
	  /**
	   * Remove zero-length edges, and contours with fewer than 3 vertices.
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   */


	  libtess.sweep.removeDegenerateEdges_ = function (tess) {
	    var eHead = tess.mesh.eHead;
	    var eNext;

	    for (var e = eHead.next; e !== eHead; e = eNext) {
	      eNext = e.next;
	      var eLNext = e.lNext;

	      if (libtess.geom.vertEq(e.org, e.dst()) && e.lNext.lNext !== e) {
	        // Zero-length edge, contour has at least 3 edges
	        libtess.sweep.spliceMergeVertices_(tess, eLNext, e); // deletes e.org

	        libtess.mesh.deleteEdge(e); // e is a self-loop TODO(bckenny): does this comment really apply here?

	        e = eLNext;
	        eLNext = e.lNext;
	      }

	      if (eLNext.lNext === e) {
	        // Degenerate contour (one or two edges)
	        if (eLNext !== e) {
	          if (eLNext === eNext || eLNext === eNext.sym) {
	            eNext = eNext.next;
	          }

	          libtess.mesh.deleteEdge(eLNext);
	        }

	        if (e === eNext || e === eNext.sym) {
	          eNext = eNext.next;
	        }

	        libtess.mesh.deleteEdge(e);
	      }
	    }
	  };
	  /**
	   * Construct priority queue and insert all vertices into it, which determines
	   * the order in which vertices cross the sweep line.
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   */


	  libtess.sweep.initPriorityQ_ = function (tess) {
	    // TODO(bckenny): libtess.geom.vertLeq needs cast?
	    var pq = new libtess.PriorityQ(
	    /** @type {function(Object, Object): boolean} */
	    libtess.geom.vertLeq);
	    tess.pq = pq;
	    var vHead = tess.mesh.vHead;
	    var v;

	    for (v = vHead.next; v !== vHead; v = v.next) {
	      v.pqHandle = pq.insert(v);
	    }

	    pq.init();
	  };
	  /**
	   * [donePriorityQ_ description]
	   * @private
	   * @param {libtess.GluTesselator} tess [description].
	   */


	  libtess.sweep.donePriorityQ_ = function (tess) {
	    // TODO(bckenny): probably don't need deleteQ. check that function for comment
	    tess.pq.deleteQ();
	    tess.pq = null;
	  };
	  /**
	   * Delete any degenerate faces with only two edges. walkDirtyRegions()
	   * will catch almost all of these, but it won't catch degenerate faces
	   * produced by splice operations on already-processed edges.
	   * The two places this can happen are in finishLeftRegions(), when
	   * we splice in a "temporary" edge produced by connectRightVertex(),
	   * and in checkForLeftSplice(), where we splice already-processed
	   * edges to ensure that our dictionary invariants are not violated
	   * by numerical errors.
	   *
	   * In both these cases it is *very* dangerous to delete the offending
	   * edge at the time, since one of the routines further up the stack
	   * will sometimes be keeping a pointer to that edge.
	   *
	   * @private
	   * @param {libtess.GluMesh} mesh [description].
	   */


	  libtess.sweep.removeDegenerateFaces_ = function (mesh) {
	    var fNext;

	    for (var f = mesh.fHead.next; f !== mesh.fHead; f = fNext) {
	      fNext = f.next;
	      var e = f.anEdge;

	      if (e.lNext.lNext === e) {
	        // A face with only two edges
	        libtess.sweep.addWinding_(e.oNext, e);
	        libtess.mesh.deleteEdge(e);
	      }
	    }
	  };
	  /* global libtess */

	  /** @const */


	  libtess.tessmono = {};
	  /**
	   * Tessellates a monotone region (what else would it do??). The region must
	   * consist of a single loop of half-edges (see mesh.js) oriented CCW. "Monotone"
	   * in this case means that any vertical line intersects the interior of the
	   * region in a single interval.
	   *
	   * Tessellation consists of adding interior edges (actually pairs of
	   * half-edges), to split the region into non-overlapping triangles.
	   * @private
	   * @param {!libtess.GluFace} face
	   */

	  libtess.tessmono.tessellateMonoRegion_ = function (face) {
	    /* The basic idea is explained in Preparata and Shamos (which I don't
	     * have handy right now), although their implementation is more
	     * complicated than this one. The are two edge chains, an upper chain
	     * and a lower chain. We process all vertices from both chains in order,
	     * from right to left.
	     *
	     * The algorithm ensures that the following invariant holds after each
	     * vertex is processed: the untessellated region consists of two
	     * chains, where one chain (say the upper) is a single edge, and
	     * the other chain is concave. The left vertex of the single edge
	     * is always to the left of all vertices in the concave chain.
	     *
	     * Each step consists of adding the rightmost unprocessed vertex to one
	     * of the two chains, and forming a fan of triangles from the rightmost
	     * of two chain endpoints. Determining whether we can add each triangle
	     * to the fan is a simple orientation test. By making the fan as large
	     * as possible, we restore the invariant (check it yourself).
	     *
	     * All edges are oriented CCW around the boundary of the region.
	     * First, find the half-edge whose origin vertex is rightmost.
	     * Since the sweep goes from left to right, face.anEdge should
	     * be close to the edge we want.
	     */
	    var up = face.anEdge;

	    for (; libtess.geom.vertLeq(up.dst(), up.org); up = up.lPrev()) {}

	    for (; libtess.geom.vertLeq(up.org, up.dst()); up = up.lNext) {}

	    var lo = up.lPrev();
	    var tempHalfEdge;

	    while (up.lNext !== lo) {
	      if (libtess.geom.vertLeq(up.dst(), lo.org)) {
	        // up.dst() is on the left. It is safe to form triangles from lo.org.
	        // The edgeGoesLeft test guarantees progress even when some triangles
	        // are CW, given that the upper and lower chains are truly monotone.
	        while (lo.lNext !== up && (libtess.geom.edgeGoesLeft(lo.lNext) || libtess.geom.edgeSign(lo.org, lo.dst(), lo.lNext.dst()) <= 0)) {
	          tempHalfEdge = libtess.mesh.connect(lo.lNext, lo);
	          lo = tempHalfEdge.sym;
	        }

	        lo = lo.lPrev();
	      } else {
	        // lo.org is on the left. We can make CCW triangles from up.dst().
	        while (lo.lNext !== up && (libtess.geom.edgeGoesRight(up.lPrev()) || libtess.geom.edgeSign(up.dst(), up.org, up.lPrev().org) >= 0)) {
	          tempHalfEdge = libtess.mesh.connect(up, up.lPrev());
	          up = tempHalfEdge.sym;
	        }

	        up = up.lNext;
	      }
	    } // Now lo.org == up.dst() == the leftmost vertex. The remaining region
	    // can be tessellated in a fan from this leftmost vertex.


	    while (lo.lNext.lNext !== up) {
	      tempHalfEdge = libtess.mesh.connect(lo.lNext, lo);
	      lo = tempHalfEdge.sym;
	    }
	  };
	  /**
	   * Tessellates each region of the mesh which is marked "inside" the polygon.
	   * Each such region must be monotone.
	   * @param {!libtess.GluMesh} mesh
	   */


	  libtess.tessmono.tessellateInterior = function (mesh) {
	    var next;

	    for (var f = mesh.fHead.next; f !== mesh.fHead; f = next) {
	      // Make sure we don't try to tessellate the new triangles.
	      next = f.next;

	      if (f.inside) {
	        libtess.tessmono.tessellateMonoRegion_(f);
	      }
	    }
	  };
	  /**
	   * Zaps (i.e. sets to null) all faces which are not marked "inside" the polygon.
	   * Since further mesh operations on null faces are not allowed, the main purpose
	   * is to clean up the mesh so that exterior loops are not represented in the
	   * data structure.
	   * @param {!libtess.GluMesh} mesh
	   */


	  libtess.tessmono.discardExterior = function (mesh) {
	    var next;

	    for (var f = mesh.fHead.next; f !== mesh.fHead; f = next) {
	      // Since f will be destroyed, save its next pointer.
	      next = f.next;

	      if (!f.inside) {
	        libtess.mesh.zapFace(f);
	      }
	    }
	  };
	  /**
	   * Resets the winding numbers on all edges so that regions marked "inside" the
	   * polygon have a winding number of "value", and regions outside have a winding
	   * number of 0.
	   *
	   * If keepOnlyBoundary is true, it also deletes all edges which do not separate
	   * an interior region from an exterior one.
	   *
	   * @param {!libtess.GluMesh} mesh
	   * @param {number} value
	   * @param {boolean} keepOnlyBoundary
	   */


	  libtess.tessmono.setWindingNumber = function (mesh, value, keepOnlyBoundary) {
	    var eNext;

	    for (var e = mesh.eHead.next; e !== mesh.eHead; e = eNext) {
	      eNext = e.next;

	      if (e.rFace().inside !== e.lFace.inside) {
	        // This is a boundary edge (one side is interior, one is exterior).
	        e.winding = e.lFace.inside ? value : -value;
	      } else {
	        // Both regions are interior, or both are exterior.
	        if (!keepOnlyBoundary) {
	          e.winding = 0;
	        } else {
	          libtess.mesh.deleteEdge(e);
	        }
	      }
	    }
	  };
	  /* global libtess */

	  /**
	   * A list of edges crossing the sweep line, sorted from top to bottom.
	   * Implementation is a doubly-linked list, sorted by the injected edgeLeq
	   * comparator function. Here it is a simple ordering, but see libtess.sweep for
	   * the list of invariants on the edge dictionary this ordering creates.
	   * @constructor
	   * @struct
	   * @param {!libtess.GluTesselator} frame
	   * @param {function(!libtess.GluTesselator, !libtess.ActiveRegion, !libtess.ActiveRegion): boolean} leq
	   */


	  libtess.Dict = function (frame, leq) {
	    /**
	     * The head of the doubly-linked DictNode list. At creation time, links back
	     * and forward only to itself.
	     * @private
	     */
	    this.head_ = new libtess.DictNode();
	    /**
	     * The GluTesselator used as the frame for edge/event comparisons.
	     * @private
	     */

	    this.frame_ = frame;
	    /**
	     * Comparison function to maintain the invariants of the Dict. See
	     * libtess.sweep.edgeLeq_ for source.
	     * @private
	     * @type {function(!libtess.GluTesselator, !libtess.ActiveRegion, !libtess.ActiveRegion): boolean}
	     */

	    this.leq_ = leq;
	  };
	  /* istanbul ignore next */

	  /**
	   * Formerly used to delete the dict.
	   * NOTE(bckenny): No longer called but left for memFree documentation. Nulled at
	   * former callsite instead (sweep.doneEdgeDict_)
	   * @private
	   */


	  libtess.Dict.prototype.deleteDict_ = function () {// for (var node = this.head_.next; node !== this.head_; node = node.next) {
	    //   memFree(node);
	    // }
	    // memFree(dict);
	  };
	  /**
	   * Insert the supplied key into the edge list and return its new node.
	   * @param {libtess.DictNode} node
	   * @param {!libtess.ActiveRegion} key
	   * @return {!libtess.DictNode}
	   */


	  libtess.Dict.prototype.insertBefore = function (node, key) {
	    do {
	      node = node.prev;
	    } while (node.key !== null && !this.leq_(this.frame_, node.key, key)); // insert the new node and update the surrounding nodes to point to it


	    var newNode = new libtess.DictNode(key, node.next, node);
	    node.next.prev = newNode;
	    node.next = newNode;
	    return newNode;
	  };
	  /**
	   * Insert key into the dict and return the new node that contains it.
	   * @param {!libtess.ActiveRegion} key
	   * @return {!libtess.DictNode}
	   */


	  libtess.Dict.prototype.insert = function (key) {
	    // NOTE(bckenny): from a macro in dict.h/dict-list.h
	    return this.insertBefore(this.head_, key);
	  };
	  /**
	   * Remove node from the list.
	   * @param {libtess.DictNode} node
	   */


	  libtess.Dict.prototype.deleteNode = function (node) {
	    node.next.prev = node.prev;
	    node.prev.next = node.next; // NOTE(bckenny): nulled at callsite (sweep.deleteRegion_)
	    // memFree( node );
	  };
	  /**
	   * Search returns the node with the smallest key greater than or equal
	   * to the given key. If there is no such key, returns a node whose
	   * key is null. Similarly, max(d).getSuccessor() has a null key, etc.
	   * @param {!libtess.ActiveRegion} key
	   * @return {!libtess.DictNode}
	   */


	  libtess.Dict.prototype.search = function (key) {
	    var node = this.head_;

	    do {
	      node = node.next;
	    } while (node.key !== null && !this.leq_(this.frame_, key, node.key));

	    return node;
	  };
	  /**
	   * Return the node with the smallest key.
	   * @return {!libtess.DictNode}
	   */


	  libtess.Dict.prototype.getMin = function () {
	    // NOTE(bckenny): from a macro in dict.h/dict-list.h
	    return this.head_.next;
	  }; // NOTE(bckenny): libtess.Dict.getMax isn't called within libtess and isn't part
	  // of the public API. For now, leaving in but ignoring for coverage.

	  /* istanbul ignore next */

	  /**
	   * Returns the node with the greatest key.
	   * @return {!libtess.DictNode}
	   */


	  libtess.Dict.prototype.getMax = function () {
	    // NOTE(bckenny): from a macro in dict.h/dict-list.h
	    return this.head_.prev;
	  };
	  /* global libtess */

	  /**
	   * A doubly-linked-list node with a libtess.ActiveRegion payload.
	   * The key for this node and the next and previous nodes in the parent Dict list
	   * can be provided to insert it into an existing list (or all can be omitted if
	   * this is to be the founding node of the list).
	   * @param {!libtess.ActiveRegion=} opt_key
	   * @param {!libtess.DictNode=} opt_nextNode
	   * @param {!libtess.DictNode=} opt_prevNode
	   * @constructor
	   * @struct
	   */


	  libtess.DictNode = function (opt_key, opt_nextNode, opt_prevNode) {
	    /**
	     * The ActiveRegion key for this node, or null if the head of the list.
	     * @type {libtess.ActiveRegion}
	     */
	    this.key = opt_key || null;
	    /**
	     * Link to next DictNode in parent list or to self if this is the first node.
	     * @type {!libtess.DictNode}
	     */

	    this.next = opt_nextNode || this;
	    /**
	     * Link to previous DictNode in parent list or to self if this is the first
	     * node.
	     * @type {!libtess.DictNode}
	     */

	    this.prev = opt_prevNode || this;
	  };
	  /**
	   * Get the key from this node.
	   * @return {libtess.ActiveRegion}
	   */


	  libtess.DictNode.prototype.getKey = function () {
	    return this.key;
	  };
	  /**
	   * Get the successor node to this one.
	   * @return {!libtess.DictNode}
	   */


	  libtess.DictNode.prototype.getSuccessor = function () {
	    return this.next;
	  };
	  /**
	   * Get the predecessor node to this one.
	   * @return {!libtess.DictNode}
	   */


	  libtess.DictNode.prototype.getPredecessor = function () {
	    return this.prev;
	  };
	  /* global libtess */

	  /**
	   * Cached vertex data for single-countour polygons for quick-and-dirty
	   * decomposition.
	   * @constructor
	   * @struct
	   */


	  libtess.CachedVertex = function () {
	    /**
	     * [coords description]
	     * @type {Array.<number>}
	     */
	    this.coords = [0, 0, 0]; // TODO(bckenny): better way to init?

	    /**
	     * [data description]
	     * @type {Object}
	     */

	    this.data = null;
	  };
	  /* global libtess */
	  // TODO(bckenny): create more javascript-y API, e.g. make gluTessEndPolygon
	  // async, don't require so many temp objects created

	  /**
	   * The tesselator main class, providing the public API.
	   * @constructor
	   * @struct
	   */


	  libtess.GluTesselator = function () {
	    // Only initialize fields which can be changed by the api. Other fields
	    // are initialized where they are used.
	    // TODO(bckenny): many of these can be made private
	    // TODO(bckenny): can we combine call* and call*Data functions?

	    /*** state needed for collecting the input data ***/

	    /**
	     * what begin/end calls have we seen?
	     * @type {libtess.GluTesselator.tessState_}
	     */
	    this.state = libtess.GluTesselator.tessState_.T_DORMANT;
	    /**
	     * lastEdge_.org is the most recent vertex
	     * @private
	     * @type {libtess.GluHalfEdge}
	     */

	    this.lastEdge_ = null;
	    /**
	     * stores the input contours, and eventually the tessellation itself
	     * @type {libtess.GluMesh}
	     */

	    this.mesh = null; // NOTE(bckenny): initialized in this.emptyCache_

	    /**
	     * Error callback.
	     * @private
	     * @type {?function((libtess.errorType|libtess.gluEnum))}
	     */

	    this.callError_ = null;
	    /*** state needed for projecting onto the sweep plane ***/

	    /**
	     * user-specified normal (if provided)
	     * @type {!Array.<number>}
	     */

	    this.normal = [0, 0, 0]; // TODO(bckenny): better way to init these arrays?

	    /**
	     * unit vector in s-direction (debugging)
	     * @type {!Array.<number>}
	     */

	    this.sUnit = [0, 0, 0];
	    /**
	     * unit vector in t-direction (debugging)
	     * @type {!Array.<number>}
	     */

	    this.tUnit = [0, 0, 0];
	    /*** state needed for the line sweep ***/
	    // TODO(bckenny): this could be moved to a sweep state object of some sort

	    /**
	     * tolerance for merging features
	     * @type {number}
	     */

	    this.relTolerance = libtess.GLU_TESS_DEFAULT_TOLERANCE;
	    /**
	     * rule for determining polygon interior
	     * @type {libtess.windingRule}
	     */

	    this.windingRule = libtess.windingRule.GLU_TESS_WINDING_ODD;
	    /**
	     * fatal error: needed combine callback
	     * @type {boolean}
	     */

	    this.fatalError = false;
	    /**
	     * edge dictionary for sweep line
	     * @type {libtess.Dict}
	     */

	    this.dict = null; // NOTE(bckenny): dict initialized in sweep.initEdgeDict_, removed in sweep.doneEdgeDict_

	    /**
	     * priority queue of vertex events
	     * @type {libtess.PriorityQ}
	     */

	    this.pq = null; // NOTE(bckenny): pq initialized in sweep.initPriorityQ

	    /**
	     * current sweep event being processed
	     * @type {libtess.GluVertex}
	     */

	    this.event = null;
	    /**
	     * Combine callback.
	     * @private
	     * @type {?function(Array.<number>, Array.<Object>, Array.<number>): Object}
	     */

	    this.callCombine_ = null;
	    /*** state needed for rendering callbacks (see render.js) ***/

	    /**
	     * Extract contours, not triangles
	     * @type {boolean}
	     */

	    this.boundaryOnly = false;
	    /**
	     * Begin callback.
	     * @private
	     * @type {?function(libtess.primitiveType)}
	     */

	    this.callBegin_ = null;
	    /**
	     * Edge flag callback.
	     * @private
	     * @type {?function(boolean)}
	     */

	    this.callEdgeFlag_ = null;
	    /**
	     * Vertex callback.
	     * @private
	     * @type {?function(Object)}
	     */

	    this.callVertex_ = null;
	    /**
	     * End callback.
	     * @private
	     * @type {?function()}
	     */

	    this.callEnd_ = null;
	    /**
	     * Mesh callback.
	     * @private
	     * @type {?function(libtess.GluMesh)}
	     */

	    this.callMesh_ = null;
	    /*** rendering callbacks that also pass polygon data  ***/

	    /**
	     * BeginData callback.
	     * @private
	     * @type {?function(libtess.primitiveType, Object)}
	     */

	    this.callBeginData_ = null;
	    /**
	     * EdgeFlagData callback.
	     * @private
	     * @type {?function(boolean, Object)}
	     */

	    this.callEdgeFlagData_ = null;
	    /**
	     * VertexData callback.
	     * @private
	     * @type {?function(Object, Object)}
	     */

	    this.callVertexData_ = null;
	    /**
	     * EndData callback.
	     * @private
	     * @type {?function(Object)}
	     */

	    this.callEndData_ = null;
	    /**
	     * ErrorData callback.
	     * @private
	     * @type {?function((libtess.errorType|libtess.gluEnum), Object)}
	     */

	    this.callErrorData_ = null;
	    /**
	     * CombineData callback.
	     * @private
	     * @type {?function(Array.<number>, Array.<Object>, Array.<number>, Object): Object}
	     */

	    this.callCombineData_ = null;
	    /**
	     * client data for current polygon
	     * @private
	     * @type {Object}
	     */

	    this.polygonData_ = null;
	    /*** state needed to cache single-contour polygons for renderCache() ***/

	    /**
	     * empty cache on next vertex() call
	     * @type {boolean}
	     */

	    this.emptyCache = false; // TODO(bckenny): possibly rename to be clear it's a boolean

	    /**
	     * number of cached vertices
	     * @type {number}
	     */

	    this.cacheCount = 0;
	    /**
	     * the vertex data
	     * @type {Array.<libtess.CachedVertex>}
	     */

	    this.cache = new Array(libtess.TESS_MAX_CACHE); // TODO(bckenny): fill now? or init on demand

	    for (var i = 0; i < libtess.TESS_MAX_CACHE; i++) {
	      this.cache[i] = new libtess.CachedVertex();
	    }
	  };
	  /**
	   * The begin/end calls must be properly nested. We keep track of the current
	   * state to enforce the ordering.
	   * @enum {number}
	   * @private
	   */


	  libtess.GluTesselator.tessState_ = {
	    T_DORMANT: 0,
	    T_IN_POLYGON: 1,
	    T_IN_CONTOUR: 2
	  };
	  /**
	   * Destory the tesselator object. See README.
	   */

	  libtess.GluTesselator.prototype.gluDeleteTess = function () {
	    // TODO(bckenny): This does nothing but assert that it isn't called while
	    // building the polygon since we rely on GC to handle memory. *If* the public
	    // API changes, this should go.
	    this.requireState_(libtess.GluTesselator.tessState_.T_DORMANT); // memFree(tess); TODO(bckenny)
	  };
	  /**
	   * Set properties for control over tesselation. See README.
	   * @param {libtess.gluEnum} which [description].
	   * @param {number|boolean} value [description].
	   */


	  libtess.GluTesselator.prototype.gluTessProperty = function (which, value) {
	    // TODO(bckenny): split into more setters?
	    // TODO(bckenny): in any case, we can do better than this switch statement
	    switch (which) {
	      case libtess.gluEnum.GLU_TESS_TOLERANCE:
	        if (value < 0 || value > 1) {
	          break;
	        } // TODO(bckenny): libtess doesn't support any tolerance but 0. This should
	        // reject any non-zero tolerance accordingly.


	        this.relTolerance =
	        /** @type {number} */
	        value;
	        return;

	      case libtess.gluEnum.GLU_TESS_WINDING_RULE:
	        var windingRule =
	        /** @type {libtess.windingRule} */
	        value;

	        switch (windingRule) {
	          case libtess.windingRule.GLU_TESS_WINDING_ODD:
	          case libtess.windingRule.GLU_TESS_WINDING_NONZERO:
	          case libtess.windingRule.GLU_TESS_WINDING_POSITIVE:
	          case libtess.windingRule.GLU_TESS_WINDING_NEGATIVE:
	          case libtess.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO:
	            this.windingRule = windingRule;
	            return;
	        }

	        break;

	      case libtess.gluEnum.GLU_TESS_BOUNDARY_ONLY:
	        // TODO(bckenny): added boolean param type. make sure ok.
	        this.boundaryOnly = !!value;
	        return;

	      default:
	        this.callErrorOrErrorData(libtess.gluEnum.GLU_INVALID_ENUM);
	        return;
	    }

	    this.callErrorOrErrorData(libtess.gluEnum.GLU_INVALID_VALUE);
	  };
	  /**
	   * Returns tessellator property
	   * @param {libtess.gluEnum} which [description].
	   * @return {number|boolean} [description].
	   */


	  libtess.GluTesselator.prototype.gluGetTessProperty = function (which) {
	    // TODO(bckenny): as above, split into more getters? and improve on switch statement
	    // why are these being asserted in getter but not setter?
	    switch (which) {
	      case libtess.gluEnum.GLU_TESS_TOLERANCE:
	        // tolerance should be in range [0..1]
	        return this.relTolerance;

	      case libtess.gluEnum.GLU_TESS_WINDING_RULE:
	        var rule = this.windingRule;
	        return rule;

	      case libtess.gluEnum.GLU_TESS_BOUNDARY_ONLY:
	        return this.boundaryOnly;

	      default:
	        this.callErrorOrErrorData(libtess.gluEnum.GLU_INVALID_ENUM);
	        break;
	    }

	    return false;
	  };
	  /**
	   * Lets the user supply the polygon normal, if known.  All input data
	   * is projected into a plane perpendicular to the normal before
	   * tesselation. All output triangles are oriented CCW with
	   * respect to the normal (CW orientation can be obtained by
	   * reversing the sign of the supplied normal). For example, if
	   * you know that all polygons lie in the x-y plane, call
	   * "tess.gluTessNormal(0.0, 0.0, 1.0)" before rendering any polygons.
	   *
	   * @param {number} x [description].
	   * @param {number} y [description].
	   * @param {number} z [description].
	   */


	  libtess.GluTesselator.prototype.gluTessNormal = function (x, y, z) {
	    this.normal[0] = x;
	    this.normal[1] = y;
	    this.normal[2] = z;
	  };
	  /**
	   * Specify callbacks. See README. A null or undefined opt_fn removes current callback.
	   *
	   * @param {libtess.gluEnum} which [description].
	   * @param {?Function=} opt_fn [description].
	   */


	  libtess.GluTesselator.prototype.gluTessCallback = function (which, opt_fn) {
	    var fn = !opt_fn ? null : opt_fn; // TODO(bckenny): better opt_fn typing?

	    switch (which) {
	      case libtess.gluEnum.GLU_TESS_BEGIN:
	        this.callBegin_ =
	        /** @type {function(libtess.primitiveType)} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_BEGIN_DATA:
	        this.callBeginData_ =
	        /** @type {function(libtess.primitiveType, Object)} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_EDGE_FLAG:
	        this.callEdgeFlag_ =
	        /** @type {function(boolean)} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_EDGE_FLAG_DATA:
	        this.callEdgeFlagData_ =
	        /** @type {function(boolean, Object)} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_VERTEX:
	        this.callVertex_ =
	        /** @type {function(Object)} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_VERTEX_DATA:
	        this.callVertexData_ =
	        /** @type {function(Object, Object)} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_END:
	        this.callEnd_ =
	        /** @type {function()} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_END_DATA:
	        this.callEndData_ =
	        /** @type {function(Object)} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_ERROR:
	        this.callError_ =
	        /** @type {function((libtess.errorType|libtess.gluEnum))} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_ERROR_DATA:
	        this.callErrorData_ =
	        /** @type {function((libtess.errorType|libtess.gluEnum), Object)} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_COMBINE:
	        this.callCombine_ =
	        /** @type {function(Array.<number>, Array.<Object>, Array.<number>): Object} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_COMBINE_DATA:
	        this.callCombineData_ =
	        /** @type {function(Array.<number>, Array.<Object>, Array.<number>, Object): Object} */
	        fn;
	        return;

	      case libtess.gluEnum.GLU_TESS_MESH:
	        this.callMesh_ =
	        /** @type {function(libtess.GluMesh)} */
	        fn;
	        return;

	      default:
	        this.callErrorOrErrorData(libtess.gluEnum.GLU_INVALID_ENUM);
	        return;
	    }
	  };
	  /**
	   * Specify a vertex and associated data. Must be within calls to
	   * beginContour/endContour. See README.
	   *
	   * @param {Array.<number>} coords [description].
	   * @param {Object} data [description].
	   */


	  libtess.GluTesselator.prototype.gluTessVertex = function (coords, data) {
	    var tooLarge = false; // TODO(bckenny): pool allocation?

	    var clamped = [0, 0, 0];
	    this.requireState_(libtess.GluTesselator.tessState_.T_IN_CONTOUR);

	    if (this.emptyCache) {
	      this.emptyCache_();
	      this.lastEdge_ = null;
	    }

	    for (var i = 0; i < 3; ++i) {
	      var x = coords[i];

	      if (x < -libtess.GLU_TESS_MAX_COORD) {
	        x = -libtess.GLU_TESS_MAX_COORD;
	        tooLarge = true;
	      }

	      if (x > libtess.GLU_TESS_MAX_COORD) {
	        x = libtess.GLU_TESS_MAX_COORD;
	        tooLarge = true;
	      }

	      clamped[i] = x;
	    }

	    if (tooLarge) {
	      this.callErrorOrErrorData(libtess.errorType.GLU_TESS_COORD_TOO_LARGE);
	    }

	    if (this.mesh === null) {
	      if (this.cacheCount < libtess.TESS_MAX_CACHE) {
	        this.cacheVertex_(clamped, data);
	        return;
	      } // cache is full, create mesh and add cached verts to it


	      this.emptyCache_();
	    }

	    this.addVertex_(clamped, data);
	  };
	  /**
	   * [gluTessBeginPolygon description]
	   * @param {Object} data Client data for current polygon.
	   */


	  libtess.GluTesselator.prototype.gluTessBeginPolygon = function (data) {
	    this.requireState_(libtess.GluTesselator.tessState_.T_DORMANT);
	    this.state = libtess.GluTesselator.tessState_.T_IN_POLYGON;
	    this.cacheCount = 0;
	    this.emptyCache = false;
	    this.mesh = null;
	    this.polygonData_ = data;
	  };
	  /**
	   * [gluTessBeginContour description]
	   */


	  libtess.GluTesselator.prototype.gluTessBeginContour = function () {
	    this.requireState_(libtess.GluTesselator.tessState_.T_IN_POLYGON);
	    this.state = libtess.GluTesselator.tessState_.T_IN_CONTOUR;
	    this.lastEdge_ = null;

	    if (this.cacheCount > 0) {
	      // Just set a flag so we don't get confused by empty contours
	      // -- these can be generated accidentally with the obsolete
	      // NextContour() interface.
	      // TODO(bckenny): we aren't implementing NextContour() interface.
	      this.emptyCache = true;
	    }
	  };
	  /**
	   * [gluTessEndContour description]
	   */


	  libtess.GluTesselator.prototype.gluTessEndContour = function () {
	    this.requireState_(libtess.GluTesselator.tessState_.T_IN_CONTOUR);
	    this.state = libtess.GluTesselator.tessState_.T_IN_POLYGON;
	  };
	  /**
	   * [gluTessEndPolygon description]
	   */


	  libtess.GluTesselator.prototype.gluTessEndPolygon = function () {
	    this.requireState_(libtess.GluTesselator.tessState_.T_IN_POLYGON);
	    this.state = libtess.GluTesselator.tessState_.T_DORMANT;

	    if (this.mesh === null) {
	      // TODO(bckenny): can we eliminate more cache functionality?
	      this.emptyCache_();
	    } // Determine the polygon normal and project vertices onto the plane
	    // of the polygon.


	    libtess.normal.projectPolygon(this); // computeInterior(tess) computes the planar arrangement specified
	    // by the given contours, and further subdivides this arrangement
	    // into regions. Each region is marked "inside" if it belongs
	    // to the polygon, according to the rule given by this.windingRule.
	    // Each interior region is guaranteed be monotone.

	    libtess.sweep.computeInterior(this);

	    if (!this.fatalError) {
	      // If the user wants only the boundary contours, we throw away all edges
	      // except those which separate the interior from the exterior.
	      // Otherwise we tessellate all the regions marked "inside".
	      // NOTE(bckenny): we know this.mesh has been initialized, so help closure out.
	      var mesh =
	      /** @type {!libtess.GluMesh} */
	      this.mesh;

	      if (this.boundaryOnly) {
	        libtess.tessmono.setWindingNumber(mesh, 1, true);
	      } else {
	        libtess.tessmono.tessellateInterior(mesh);
	      }

	      this.mesh.checkMesh();

	      if (this.callBegin_ || this.callEnd_ || this.callVertex_ || this.callEdgeFlag_ || this.callBeginData_ || this.callEndData_ || this.callVertexData_ || this.callEdgeFlagData_) {
	        if (this.boundaryOnly) {
	          // output boundary contours
	          libtess.render.renderBoundary(this, this.mesh);
	        } else {
	          // output triangles (with edge callback if one is set)
	          var flagEdges = !!(this.callEdgeFlag_ || this.callEdgeFlagData_);
	          libtess.render.renderMesh(this, this.mesh, flagEdges);
	        }
	      }

	      if (this.callMesh_) {
	        // Throw away the exterior faces, so that all faces are interior.
	        // This way the user doesn't have to check the "inside" flag,
	        // and we don't need to even reveal its existence. It also leaves
	        // the freedom for an implementation to not generate the exterior
	        // faces in the first place.
	        libtess.tessmono.discardExterior(this.mesh); // user wants the mesh itself

	        this.callMesh_(this.mesh);
	        this.mesh = null;
	        this.polygonData_ = null;
	        return;
	      }
	    }

	    libtess.mesh.deleteMesh(this.mesh);
	    this.polygonData_ = null;
	    this.mesh = null;
	  };
	  /**
	   * Return the tessellator to its original dormant state.
	   * @private
	   */


	  libtess.GluTesselator.prototype.makeDormant_ = function () {
	    if (this.mesh) {
	      libtess.mesh.deleteMesh(this.mesh);
	    }

	    this.state = libtess.GluTesselator.tessState_.T_DORMANT;
	    this.lastEdge_ = null;
	    this.mesh = null;
	  };
	  /**
	   * [requireState_ description]
	   * @private
	   * @param {libtess.GluTesselator.tessState_} state [description].
	   */


	  libtess.GluTesselator.prototype.requireState_ = function (state) {
	    if (this.state !== state) {
	      this.gotoState_(state);
	    }
	  };
	  /**
	   * [gotoState_ description]
	   * @private
	   * @param  {libtess.GluTesselator.tessState_} newState [description].
	   */


	  libtess.GluTesselator.prototype.gotoState_ = function (newState) {
	    while (this.state !== newState) {
	      // We change the current state one level at a time, to get to the desired
	      // state.
	      if (this.state < newState) {
	        switch (this.state) {
	          case libtess.GluTesselator.tessState_.T_DORMANT:
	            this.callErrorOrErrorData(libtess.errorType.GLU_TESS_MISSING_BEGIN_POLYGON);
	            this.gluTessBeginPolygon(null);
	            break;

	          case libtess.GluTesselator.tessState_.T_IN_POLYGON:
	            this.callErrorOrErrorData(libtess.errorType.GLU_TESS_MISSING_BEGIN_CONTOUR);
	            this.gluTessBeginContour();
	            break;
	        }
	      } else {
	        switch (this.state) {
	          case libtess.GluTesselator.tessState_.T_IN_CONTOUR:
	            this.callErrorOrErrorData(libtess.errorType.GLU_TESS_MISSING_END_CONTOUR);
	            this.gluTessEndContour();
	            break;

	          case libtess.GluTesselator.tessState_.T_IN_POLYGON:
	            this.callErrorOrErrorData(libtess.errorType.GLU_TESS_MISSING_END_POLYGON); // this.gluTessEndPolygon() is too much work!

	            this.makeDormant_();
	            break;
	        }
	      }
	    }
	  };
	  /**
	   * [addVertex_ description]
	   * @private
	   * @param {Array.<number>} coords [description].
	   * @param {Object} data [description].
	   */


	  libtess.GluTesselator.prototype.addVertex_ = function (coords, data) {
	    var e = this.lastEdge_;

	    if (e === null) {
	      // Make a self-loop (one vertex, one edge).
	      e = libtess.mesh.makeEdge(this.mesh);
	      libtess.mesh.meshSplice(e, e.sym);
	    } else {
	      // Create a new vertex and edge which immediately follow e
	      // in the ordering around the left face.
	      libtess.mesh.splitEdge(e);
	      e = e.lNext;
	    } // The new vertex is now e.org.


	    e.org.data = data;
	    e.org.coords[0] = coords[0];
	    e.org.coords[1] = coords[1];
	    e.org.coords[2] = coords[2]; // The winding of an edge says how the winding number changes as we
	    // cross from the edge''s right face to its left face.  We add the
	    // vertices in such an order that a CCW contour will add +1 to
	    // the winding number of the region inside the contour.

	    e.winding = 1;
	    e.sym.winding = -1;
	    this.lastEdge_ = e;
	  };
	  /**
	   * [cacheVertex_ description]
	   * @private
	   * @param {Array.<number>} coords [description].
	   * @param {Object} data [description].
	   */


	  libtess.GluTesselator.prototype.cacheVertex_ = function (coords, data) {
	    var v = this.cache[this.cacheCount];
	    v.data = data;
	    v.coords[0] = coords[0];
	    v.coords[1] = coords[1];
	    v.coords[2] = coords[2];
	    ++this.cacheCount;
	  };
	  /**
	   * [emptyCache_ description]
	   * @private
	   */


	  libtess.GluTesselator.prototype.emptyCache_ = function () {
	    // NOTE(bckenny): surprise!
	    this.mesh = new libtess.GluMesh();

	    for (var i = 0; i < this.cacheCount; i++) {
	      var v = this.cache[i];
	      this.addVertex_(v.coords, v.data);
	    }

	    this.cacheCount = 0;
	    this.emptyCache = false;
	  }; // TODO(bckenny): all following conditional callbacks could be simplified
	  // TODO(bckenny): using null for now, but may rework
	  // TODO(bckenny): should add documentation that references in callback are volatile (or make a copy)
	  // see README callback descriptions

	  /**
	   * [callBeginOrBeginData description]
	   * @param {libtess.primitiveType} type [description].
	   */


	  libtess.GluTesselator.prototype.callBeginOrBeginData = function (type) {
	    if (this.callBeginData_) {
	      this.callBeginData_(type, this.polygonData_);
	    } else if (this.callBegin_) {
	      this.callBegin_(type);
	    }
	  };
	  /**
	   * [callVertexOrVertexData description]
	   * @param {Object} data [description].
	   */


	  libtess.GluTesselator.prototype.callVertexOrVertexData = function (data) {
	    if (this.callVertexData_) {
	      this.callVertexData_(data, this.polygonData_);
	    } else if (this.callVertex_) {
	      this.callVertex_(data);
	    }
	  };
	  /**
	   * [callEdgeFlagOrEdgeFlagData description]
	   * @param {boolean} flag [description].
	   */


	  libtess.GluTesselator.prototype.callEdgeFlagOrEdgeFlagData = function (flag) {
	    if (this.callEdgeFlagData_) {
	      this.callEdgeFlagData_(flag, this.polygonData_);
	    } else if (this.callEdgeFlag_) {
	      this.callEdgeFlag_(flag);
	    }
	  };
	  /**
	   * [callEndOrEndData description]
	   */


	  libtess.GluTesselator.prototype.callEndOrEndData = function () {
	    if (this.callEndData_) {
	      this.callEndData_(this.polygonData_);
	    } else if (this.callEnd_) {
	      this.callEnd_();
	    }
	  };
	  /**
	   * [callCombineOrCombineData description]
	   * @param {Array.<number>} coords [description].
	   * @param {Array.<Object>} data [description].
	   * @param {Array.<number>} weight [description].
	   * @return {Object} Interpolated vertex.
	   */


	  libtess.GluTesselator.prototype.callCombineOrCombineData = function (coords, data, weight) {
	    var interpData;

	    if (this.callCombineData_) {
	      interpData = this.callCombineData_(coords, data, weight, this.polygonData_);
	    } else if (this.callCombine_) {
	      interpData = this.callCombine_(coords, data, weight);
	    } // TODO(bckenny): can't be undefined


	    if (interpData === undefined) {
	      interpData = null;
	    }

	    return interpData;
	  }; // TODO(bckenny): combine the enums in libtess

	  /**
	   * [callErrorOrErrorData description]
	   * @param {(libtess.errorType|libtess.gluEnum)} errno [description].
	   */


	  libtess.GluTesselator.prototype.callErrorOrErrorData = function (errno) {
	    if (this.callErrorData_) {
	      this.callErrorData_(errno, this.polygonData_);
	    } else if (this.callError_) {
	      this.callError_(errno);
	    }
	  };
	  /* global libtess */

	  /**
	   * Each face has a pointer to the next and previous faces in the
	   * circular list, and a pointer to a half-edge with this face as
	   * the left face (null if this is the dummy header). There is also
	   * a field "data" for client data.
	   *
	   * @param {libtess.GluFace=} opt_nextFace
	   * @param {libtess.GluFace=} opt_prevFace
	   * @constructor
	   * @struct
	   */


	  libtess.GluFace = function (opt_nextFace, opt_prevFace) {
	    // TODO(bckenny): reverse order of params?

	    /**
	     * next face (never null)
	     * @type {!libtess.GluFace}
	     */
	    this.next = opt_nextFace || this;
	    /**
	     * previous face (never NULL)
	     * @type {!libtess.GluFace}
	     */

	    this.prev = opt_prevFace || this;
	    /**
	     * A half edge with this left face.
	     * @type {libtess.GluHalfEdge}
	     */

	    this.anEdge = null;
	    /**
	     * room for client's data
	     * @type {Object}
	     */

	    this.data = null;
	    /**
	     * This face is in the polygon interior.
	     * @type {boolean}
	     */

	    this.inside = false;
	  };
	  /* global libtess */

	  /**
	   * The fundamental data structure is the "half-edge". Two half-edges
	   * go together to make an edge, but they point in opposite directions.
	   * Each half-edge has a pointer to its mate (the "symmetric" half-edge sym),
	   * its origin vertex (org), the face on its left side (lFace), and the
	   * adjacent half-edges in the CCW direction around the origin vertex
	   * (oNext) and around the left face (lNext). There is also a "next"
	   * pointer for the global edge list (see below).
	   *
	   * The notation used for mesh navigation:
	   *  sym   = the mate of a half-edge (same edge, but opposite direction)
	   *  oNext = edge CCW around origin vertex (keep same origin)
	   *  dNext = edge CCW around destination vertex (keep same dest)
	   *  lNext = edge CCW around left face (dest becomes new origin)
	   *  rNext = edge CCW around right face (origin becomes new dest)
	   *
	   * "prev" means to substitute CW for CCW in the definitions above.
	   *
	   * The circular edge list is special; since half-edges always occur
	   * in pairs (e and e.sym), each half-edge stores a pointer in only
	   * one direction. Starting at eHead and following the e.next pointers
	   * will visit each *edge* once (ie. e or e.sym, but not both).
	   * e.sym stores a pointer in the opposite direction, thus it is
	   * always true that e.sym.next.sym.next === e.
	   *
	   * @param {libtess.GluHalfEdge=} opt_nextEdge
	   * @constructor
	   * @struct
	   */


	  libtess.GluHalfEdge = function (opt_nextEdge) {
	    // TODO(bckenny): are these the right defaults? (from gl_meshNewMesh requirements)

	    /**
	     * doubly-linked list (prev==sym->next)
	     * @type {!libtess.GluHalfEdge}
	     */
	    this.next = opt_nextEdge || this; // TODO(bckenny): how can this be required if created in pairs? move to factory creation only?

	    /**
	     * same edge, opposite direction
	     * @type {libtess.GluHalfEdge}
	     */

	    this.sym = null;
	    /**
	     * next edge CCW around origin
	     * @type {libtess.GluHalfEdge}
	     */

	    this.oNext = null;
	    /**
	     * next edge CCW around left face
	     * @type {libtess.GluHalfEdge}
	     */

	    this.lNext = null;
	    /**
	     * origin vertex (oVertex too long)
	     * @type {libtess.GluVertex}
	     */

	    this.org = null;
	    /**
	     * left face
	     * @type {libtess.GluFace}
	     */

	    this.lFace = null; // Internal data (keep hidden)
	    // NOTE(bckenny): can't be private, though...

	    /**
	     * a region with this upper edge (see sweep.js)
	     * @type {libtess.ActiveRegion}
	     */

	    this.activeRegion = null;
	    /**
	     * change in winding number when crossing from the right face to the left face
	     * @type {number}
	     */

	    this.winding = 0;
	  }; // NOTE(bckenny): the following came from macros in mesh
	  // TODO(bckenny): using methods as aliases for sym connections for now.
	  // not sure about this approach. getters? renames?

	  /**
	   * [rFace description]
	   * @return {libtess.GluFace} [description].
	   */


	  libtess.GluHalfEdge.prototype.rFace = function () {
	    return this.sym.lFace;
	  };
	  /**
	   * [dst description]
	   * @return {libtess.GluVertex} [description].
	   */


	  libtess.GluHalfEdge.prototype.dst = function () {
	    return this.sym.org;
	  };
	  /**
	   * [oPrev description]
	   * @return {libtess.GluHalfEdge} [description].
	   */


	  libtess.GluHalfEdge.prototype.oPrev = function () {
	    return this.sym.lNext;
	  };
	  /**
	   * [lPrev description]
	   * @return {libtess.GluHalfEdge} [description].
	   */


	  libtess.GluHalfEdge.prototype.lPrev = function () {
	    return this.oNext.sym;
	  }; // NOTE(bckenny): libtess.GluHalfEdge.dPrev is called nowhere in libtess and
	  // isn't part of the current public API. It could be useful for mesh traversal
	  // and manipulation if made public, however.

	  /* istanbul ignore next */

	  /**
	   * The edge clockwise around destination vertex (keep same dest).
	   * @return {libtess.GluHalfEdge}
	   */


	  libtess.GluHalfEdge.prototype.dPrev = function () {
	    return this.lNext.sym;
	  };
	  /**
	   * [rPrev description]
	   * @return {libtess.GluHalfEdge} [description].
	   */


	  libtess.GluHalfEdge.prototype.rPrev = function () {
	    return this.sym.oNext;
	  };
	  /**
	   * [dNext description]
	   * @return {libtess.GluHalfEdge} [description].
	   */


	  libtess.GluHalfEdge.prototype.dNext = function () {
	    return this.rPrev().sym;
	  }; // NOTE(bckenny): libtess.GluHalfEdge.rNext is called nowhere in libtess and
	  // isn't part of the current public API. It could be useful for mesh traversal
	  // and manipulation if made public, however.

	  /* istanbul ignore next */

	  /**
	   * The edge CCW around the right face (origin of this becomes new dest).
	   * @return {libtess.GluHalfEdge}
	   */


	  libtess.GluHalfEdge.prototype.rNext = function () {
	    return this.oPrev().sym;
	  };
	  /* global libtess */

	  /**
	   * Creates a new mesh with no edges, no vertices,
	   * and no loops (what we usually call a "face").
	   *
	   * @constructor
	   * @struct
	   */


	  libtess.GluMesh = function () {
	    /**
	     * dummy header for vertex list
	     * @type {libtess.GluVertex}
	     */
	    this.vHead = new libtess.GluVertex();
	    /**
	     * dummy header for face list
	     * @type {libtess.GluFace}
	     */

	    this.fHead = new libtess.GluFace();
	    /**
	     * dummy header for edge list
	     * @type {libtess.GluHalfEdge}
	     */

	    this.eHead = new libtess.GluHalfEdge();
	    /**
	     * and its symmetric counterpart
	     * @type {libtess.GluHalfEdge}
	     */

	    this.eHeadSym = new libtess.GluHalfEdge(); // TODO(bckenny): better way to pair these?

	    this.eHead.sym = this.eHeadSym;
	    this.eHeadSym.sym = this.eHead;
	  }; // TODO(bckenny): #ifndef NDEBUG

	  /**
	   * Checks mesh for self-consistency.
	   */


	  libtess.GluMesh.prototype.checkMesh = function () {
	    if (!libtess.DEBUG) {
	      return;
	    }

	    var fHead = this.fHead;
	    var vHead = this.vHead;
	    var eHead = this.eHead;
	    var e; // faces

	    var f;
	    var fPrev = fHead;

	    for (fPrev = fHead; (f = fPrev.next) !== fHead; fPrev = f) {
	      e = f.anEdge;

	      do {
	        e = e.lNext;
	      } while (e !== f.anEdge);
	    } // vertices


	    var v;
	    var vPrev = vHead;

	    for (vPrev = vHead; (v = vPrev.next) !== vHead; vPrev = v) {
	      e = v.anEdge;

	      do {
	        e = e.oNext;
	      } while (e !== v.anEdge);
	    } // edges


	    var ePrev = eHead;

	    for (ePrev = eHead; (e = ePrev.next) !== eHead; ePrev = e) {}
	  };
	  /* global libtess */

	  /**
	   * Each vertex has a pointer to next and previous vertices in the
	   * circular list, and a pointer to a half-edge with this vertex as
	   * the origin (null if this is the dummy header). There is also a
	   * field "data" for client data.
	   *
	   * @param {libtess.GluVertex=} opt_nextVertex [description].
	   * @param {libtess.GluVertex=} opt_prevVertex [description].
	   * @constructor
	   * @struct
	   */


	  libtess.GluVertex = function (opt_nextVertex, opt_prevVertex) {
	    // TODO(bckenny): reverse order of params?

	    /**
	     * Next vertex (never null).
	     * @type {!libtess.GluVertex}
	     */
	    this.next = opt_nextVertex || this;
	    /**
	     * Previous vertex (never null).
	     * @type {!libtess.GluVertex}
	     */

	    this.prev = opt_prevVertex || this;
	    /**
	     * A half-edge with this origin.
	     * @type {libtess.GluHalfEdge}
	     */

	    this.anEdge = null;
	    /**
	     * The client's data.
	     * @type {Object}
	     */

	    this.data = null;
	    /**
	     * The vertex location in 3D.
	     * @type {!Array.<number>}
	     */

	    this.coords = [0, 0, 0]; // TODO(bckenny): we may want to rethink coords, either eliminate (using s
	    // and t and user data) or index into contiguous storage?

	    /**
	     * Component of projection onto the sweep plane.
	     * @type {number}
	     */

	    this.s = 0;
	    /**
	     * Component of projection onto the sweep plane.
	     * @type {number}
	     */

	    this.t = 0;
	    /**
	     * To allow deletion from priority queue.
	     * @type {?libtess.PQHandle}
	     */

	    this.pqHandle = null; // NOTE(bckenny): pqHandle inited in sweep
	    // TODO(bckenny): can we have a numeric default value? null may do bad things
	  };
	  /* global libtess */
	  // TODO(bckenny): more specific typing on key

	  /**
	   * [PQHandleElem description]
	   * @constructor
	   * @struct
	   */


	  libtess.PQHandleElem = function () {
	    // TODO(bckenny): if key could instead be an indexed into another store, makes heap storage a lot easier

	    /**
	     * [key description]
	     * @type {libtess.PQKey}
	     */
	    this.key = null;
	    /**
	     * [node description]
	     * @type {libtess.PQHandle}
	     */

	    this.node = 0;
	  };
	  /**
	   * Allocate a PQHandleElem array of size size. If oldArray is not null, its
	   * contents are copied to the beginning of the new array. The rest of the array
	   * is filled with new PQHandleElems.
	   *
	   * @param {?Array.<libtess.PQHandleElem>} oldArray [description].
	   * @param {number} size [description].
	   * @return {Array.<libtess.PQHandleElem>} [description].
	   */


	  libtess.PQHandleElem.realloc = function (oldArray, size) {
	    var newArray = new Array(size); // TODO(bckenny): better to reallocate array? or grow array?

	    var index = 0;

	    if (oldArray !== null) {
	      for (; index < oldArray.length; index++) {
	        newArray[index] = oldArray[index];
	      }
	    }

	    for (; index < size; index++) {
	      newArray[index] = new libtess.PQHandleElem();
	    }

	    return newArray;
	  };
	  /* global libtess */
	  // TODO(bckenny): maybe just have these created inline as literals
	  // (or unboxed directly - PQHandle is just an array index number)

	  /**
	   * [PQNode description]
	   * @constructor
	   * @struct
	   */


	  libtess.PQNode = function () {
	    /**
	     * [handle description]
	     * @type {libtess.PQHandle}
	     */
	    this.handle = 0;
	  };
	  /**
	   * Allocate a PQNode array of size size. If oldArray is not null, its contents
	   * are copied to the beginning of the new array. The rest of the array is
	   * filled with new PQNodes.
	   *
	   * @param {?Array.<libtess.PQNode>} oldArray [description].
	   * @param {number} size [description].
	   * @return {Array.<libtess.PQNode>} [description].
	   */


	  libtess.PQNode.realloc = function (oldArray, size) {
	    var newArray = new Array(size); // TODO(bckenny): better to reallocate array? or grow array?

	    var index = 0;

	    if (oldArray !== null) {
	      for (; index < oldArray.length; index++) {
	        newArray[index] = oldArray[index];
	      }
	    }

	    for (; index < size; index++) {
	      newArray[index] = new libtess.PQNode();
	    }

	    return newArray;
	  };
	  /* global libtess */
	  // TODO(bckenny): preallocating arrays may actually be hurting us in sort
	  // performance (esp if theres some undefs in there)

	  /**
	   * [PriorityQ description]
	   * @constructor
	   * @struct
	   * @param {function(Object, Object): boolean} leq [description].
	   */


	  libtess.PriorityQ = function (leq) {
	    /**
	     * [keys description]
	     * @private
	     * @type {Array.<libtess.PQKey>}
	     */
	    this.keys_ = libtess.PriorityQ.prototype.PQKeyRealloc_(null, libtess.PriorityQ.INIT_SIZE_);
	    /**
	     * Array of indexes into this.keys_
	     * @private
	     * @type {Array.<number>}
	     */

	    this.order_ = null;
	    /**
	     * [size description]
	     * @private
	     * @type {number}
	     */

	    this.size_ = 0;
	    /**
	     * [max_ description]
	     * @private
	     * @type {number}
	     */

	    this.max_ = libtess.PriorityQ.INIT_SIZE_;
	    /**
	     * [initialized description]
	     * @private
	     * @type {boolean}
	     */

	    this.initialized_ = false; // TODO(bckenny): leq was inlined by define in original, but appears to just
	    // be vertLeq, as passed. keep an eye on this as to why its not used.

	    /**
	     * [leq description]
	     * @private
	     * @type {function(libtess.PQKey, libtess.PQKey): boolean}
	     */

	    this.leq_ =
	    /** @type {function(libtess.PQKey, libtess.PQKey): boolean} */
	    leq;
	    /**
	     * [heap_ description]
	     * @private
	     * @type {libtess.PriorityQHeap}
	     */

	    this.heap_ = new libtess.PriorityQHeap(this.leq_);
	  };
	  /**
	   * [INIT_SIZE_ description]
	   * @private
	   * @const
	   * @type {number}
	   */


	  libtess.PriorityQ.INIT_SIZE_ = 32;
	  /**
	   * [deleteQ description]
	   */

	  libtess.PriorityQ.prototype.deleteQ = function () {
	    // TODO(bckenny): unnecessary, I think.
	    this.heap_.deleteHeap();
	    this.heap_ = null;
	    this.order_ = null;
	    this.keys_ = null; // NOTE(bckenny): nulled at callsite (sweep.donePriorityQ_)
	  };
	  /**
	   * [init description]
	   */


	  libtess.PriorityQ.prototype.init = function () {
	    // TODO(bckenny): reuse. in theory, we don't have to empty this, as access is
	    // dictated by this.size_, but array.sort doesn't know that
	    this.order_ = []; // Create an array of indirect pointers to the keys, so that
	    // the handles we have returned are still valid.
	    // TODO(bckenny): valid for when? it appears we can just store indexes into
	    // keys_, but what did this mean?

	    for (var i = 0; i < this.size_; i++) {
	      this.order_[i] = i;
	    } // sort the indirect pointers in descending order of the keys themselves
	    // TODO(bckenny): make sure it's ok that keys[a] === keys[b] returns 1
	    // TODO(bckenny): unstable sort means we may get slightly different polys in
	    // different browsers, but only when passing in equal points
	    // TODO(bckenny): make less awkward closure?


	    var comparator = function (keys, leq) {
	      return function (a, b) {
	        return leq(keys[a], keys[b]) ? 1 : -1;
	      };
	    }(this.keys_, this.leq_);

	    this.order_.sort(comparator);
	    this.max_ = this.size_;
	    this.initialized_ = true;
	    this.heap_.init(); // TODO(bckenny):
	    // #ifndef NDEBUG

	    if (libtess.DEBUG) {
	      var p = 0;
	      var r = p + this.size_ - 1;

	      for (i = p; i < r; ++i) {}
	    } // #endif

	  };
	  /**
	   * [insert description]
	   * @param {libtess.PQKey} keyNew [description].
	   * @return {libtess.PQHandle} [description].
	   */


	  libtess.PriorityQ.prototype.insert = function (keyNew) {
	    // NOTE(bckenny): originally returned LONG_MAX as alloc failure signal. no
	    // longer does.
	    if (this.initialized_) {
	      return this.heap_.insert(keyNew);
	    }

	    var curr = this.size_;

	    if (++this.size_ >= this.max_) {
	      // If the heap overflows, double its size.
	      this.max_ *= 2;
	      this.keys_ = libtess.PriorityQ.prototype.PQKeyRealloc_(this.keys_, this.max_);
	    }

	    this.keys_[curr] = keyNew; // Negative handles index the sorted array.

	    return -(curr + 1);
	  };
	  /**
	   * Allocate a PQKey array of size size. If oldArray is not null, its
	   * contents are copied to the beginning of the new array. The rest of the array
	   * is filled with nulls.
	   *
	   * @private
	   * @param {?Array.<libtess.PQKey>} oldArray [description].
	   * @param {number} size [description].
	   * @return {Array.<(?libtess.PQKey)>} [description].
	   */


	  libtess.PriorityQ.prototype.PQKeyRealloc_ = function (oldArray, size) {
	    // TODO(bckenny): double check return type. can we have ? there?
	    var newArray = new Array(size); // TODO(bckenny): better to reallocate array? or grow array?

	    var index = 0;

	    if (oldArray !== null) {
	      for (; index < oldArray.length; index++) {
	        newArray[index] = oldArray[index];
	      }
	    }

	    for (; index < size; index++) {
	      newArray[index] = null;
	    }

	    return newArray;
	  }; // NOTE(bckenny): libtess.PriorityQ.keyLessThan_ is called nowhere in libtess
	  // and isn't part of the public API.

	  /* istanbul ignore next */

	  /**
	   * Whether x is less than y according to this.leq_.
	   * @private
	   * @param {number} x
	   * @param {number} y
	   * @return {boolean}
	   */


	  libtess.PriorityQ.prototype.keyLessThan_ = function (x, y) {
	    // NOTE(bckenny): was macro LT
	    var keyX = this.keys_[x];
	    var keyY = this.keys_[y];
	    return !this.leq_(keyY, keyX);
	  }; // NOTE(bckenny): libtess.PriorityQ.keyGreaterThan_ is called nowhere in libtess
	  // and isn't part of the public API.

	  /* istanbul ignore next */

	  /**
	   * Whether x is greater than y according to this.leq_.
	   * @private
	   * @param {number} x
	   * @param {number} y
	   * @return {boolean}
	   */


	  libtess.PriorityQ.prototype.keyGreaterThan_ = function (x, y) {
	    // NOTE(bckenny): was macro GT
	    var keyX = this.keys_[x];
	    var keyY = this.keys_[y];
	    return !this.leq_(keyX, keyY);
	  };
	  /**
	   * [extractMin description]
	   * @return {libtess.PQKey} [description].
	   */


	  libtess.PriorityQ.prototype.extractMin = function () {
	    if (this.size_ === 0) {
	      return this.heap_.extractMin();
	    }

	    var sortMin = this.keys_[this.order_[this.size_ - 1]];

	    if (!this.heap_.isEmpty()) {
	      var heapMin = this.heap_.minimum();

	      if (this.leq_(heapMin, sortMin)) {
	        return this.heap_.extractMin();
	      }
	    }

	    do {
	      --this.size_;
	    } while (this.size_ > 0 && this.keys_[this.order_[this.size_ - 1]] === null);

	    return sortMin;
	  };
	  /**
	   * [minimum description]
	   * @return {libtess.PQKey} [description].
	   */


	  libtess.PriorityQ.prototype.minimum = function () {
	    if (this.size_ === 0) {
	      return this.heap_.minimum();
	    }

	    var sortMin = this.keys_[this.order_[this.size_ - 1]];

	    if (!this.heap_.isEmpty()) {
	      var heapMin = this.heap_.minimum();

	      if (this.leq_(heapMin, sortMin)) {
	        return heapMin;
	      }
	    }

	    return sortMin;
	  }; // NOTE(bckenny): libtess.PriorityQ.isEmpty_ isn't called within libtess and
	  // isn't part of the public API. For now, leaving in but ignoring for coverage.

	  /* istanbul ignore next */

	  /**
	   * Returns whether the priority queue is empty.
	   * @private
	   * @return {boolean}
	   */


	  libtess.PriorityQ.prototype.isEmpty_ = function () {
	    return this.size_ === 0 && this.heap_.isEmpty();
	  };
	  /**
	   * [remove description]
	   * @param {libtess.PQHandle} curr [description].
	   */


	  libtess.PriorityQ.prototype.remove = function (curr) {
	    if (curr >= 0) {
	      this.heap_.remove(curr);
	      return;
	    }

	    curr = -(curr + 1);
	    this.keys_[curr] = null;

	    while (this.size_ > 0 && this.keys_[this.order_[this.size_ - 1]] === null) {
	      --this.size_;
	    }
	  };
	  /* global libtess */
	  // TODO(bckenny): keys appear to always be GluVertex in this case?

	  /**
	   * [PriorityQHeap description]
	   * @constructor
	   * @struct
	   * @param {function(libtess.PQKey, libtess.PQKey): boolean} leq [description].
	   */


	  libtess.PriorityQHeap = function (leq) {
	    /**
	     * The heap itself. Active nodes are stored in the range 1..size. Each node
	     * stores only an index into handles.
	     * @private
	     * @type {Array.<libtess.PQNode>}
	     */
	    this.nodes_ = libtess.PQNode.realloc(null, libtess.PriorityQHeap.INIT_SIZE_ + 1);
	    /**
	     * Each handle stores a key, plus a pointer back to the node which currently
	     * represents that key (ie. nodes[handles[i].node].handle == i).
	     * @private
	     * @type {Array.<libtess.PQHandleElem>}
	     */

	    this.handles_ = libtess.PQHandleElem.realloc(null, libtess.PriorityQHeap.INIT_SIZE_ + 1); // TODO(bckenny): size and max should probably be libtess.PQHandle for correct
	    // typing (see PriorityQ.js)

	    /**
	     * The size of the queue.
	     * @private
	     * @type {number}
	     */

	    this.size_ = 0;
	    /**
	     * The queue's current allocated space.
	     * @private
	     * @type {number}
	     */

	    this.max_ = libtess.PriorityQHeap.INIT_SIZE_;
	    /**
	     * The index of the next free hole in the handles array. Handle in that slot
	     * has next item in freeList in its node propert. If there are no holes,
	     * freeList === 0 and one at the end of handles must be use.
	     * @private
	     * @type {libtess.PQHandle}
	     */

	    this.freeList_ = 0;
	    /**
	     * Indicates that the heap has been initialized via init. If false, inserts
	     * are fast insertions at the end of a list. If true, all inserts will now be
	     * correctly ordered in the queue before returning.
	     * @private
	     * @type {boolean}
	     */

	    this.initialized_ = false; // TODO(bckenny): leq was inlined by define in original, but appears to
	    // be vertLeq, as passed. Using injected version, but is it better just to
	    // manually inline?

	    /**
	     * [leq description]
	     * @private
	     * @type {function(libtess.PQKey, libtess.PQKey): boolean}
	     */

	    this.leq_ = leq; // so that minimum returns null

	    this.nodes_[1].handle = 1;
	  };
	  /**
	   * [INIT_SIZE_ description]
	   * @private
	   * @const
	   * @type {number}
	   */


	  libtess.PriorityQHeap.INIT_SIZE_ = 32;
	  /**
	   * [deleteHeap description]
	   */

	  libtess.PriorityQHeap.prototype.deleteHeap = function () {
	    // TODO(bckenny): unnecessary, I think.
	    this.handles_ = null;
	    this.nodes_ = null; // NOTE(bckenny): nulled at callsite in PriorityQ.deleteQ
	  };
	  /**
	   * Initializing ordering of the heap. Must be called before any method other
	   * than insert is called to ensure correctness when removing or querying.
	   */


	  libtess.PriorityQHeap.prototype.init = function () {
	    // This method of building a heap is O(n), rather than O(n lg n).
	    for (var i = this.size_; i >= 1; --i) {
	      this.floatDown_(i);
	    }

	    this.initialized_ = true;
	  };
	  /**
	   * Insert a new key into the heap.
	   * @param {libtess.PQKey} keyNew The key to insert.
	   * @return {libtess.PQHandle} A handle that can be used to remove the key.
	   */


	  libtess.PriorityQHeap.prototype.insert = function (keyNew) {
	    var curr = ++this.size_; // if the heap overflows, double its size.

	    if (curr * 2 > this.max_) {
	      this.max_ *= 2;
	      this.nodes_ = libtess.PQNode.realloc(this.nodes_, this.max_ + 1);
	      this.handles_ = libtess.PQHandleElem.realloc(this.handles_, this.max_ + 1);
	    }

	    var free;

	    if (this.freeList_ === 0) {
	      free = curr;
	    } else {
	      free = this.freeList_;
	      this.freeList_ = this.handles_[free].node;
	    }

	    this.nodes_[curr].handle = free;
	    this.handles_[free].node = curr;
	    this.handles_[free].key = keyNew;

	    if (this.initialized_) {
	      this.floatUp_(curr);
	    }

	    return free;
	  };
	  /**
	   * @return {boolean} Whether the heap is empty.
	   */


	  libtess.PriorityQHeap.prototype.isEmpty = function () {
	    return this.size_ === 0;
	  };
	  /**
	   * Returns the minimum key in the heap. If the heap is empty, null will be
	   * returned.
	   * @return {libtess.PQKey} [description].
	   */


	  libtess.PriorityQHeap.prototype.minimum = function () {
	    return this.handles_[this.nodes_[1].handle].key;
	  };
	  /**
	   * Removes the minimum key from the heap and returns it. If the heap is empty,
	   * null will be returned.
	   * @return {libtess.PQKey} [description].
	   */


	  libtess.PriorityQHeap.prototype.extractMin = function () {
	    var n = this.nodes_;
	    var h = this.handles_;
	    var hMin = n[1].handle;
	    var min = h[hMin].key;

	    if (this.size_ > 0) {
	      n[1].handle = n[this.size_].handle;
	      h[n[1].handle].node = 1;
	      h[hMin].key = null;
	      h[hMin].node = this.freeList_;
	      this.freeList_ = hMin;

	      if (--this.size_ > 0) {
	        this.floatDown_(1);
	      }
	    }

	    return min;
	  };
	  /**
	   * Remove key associated with handle hCurr (returned from insert) from heap.
	   * @param {libtess.PQHandle} hCurr [description].
	   */


	  libtess.PriorityQHeap.prototype.remove = function (hCurr) {
	    var n = this.nodes_;
	    var h = this.handles_;
	    var curr = h[hCurr].node;
	    n[curr].handle = n[this.size_].handle;
	    h[n[curr].handle].node = curr;

	    if (curr <= --this.size_) {
	      if (curr <= 1 || this.leq_(h[n[curr >> 1].handle].key, h[n[curr].handle].key)) {
	        this.floatDown_(curr);
	      } else {
	        this.floatUp_(curr);
	      }
	    }

	    h[hCurr].key = null;
	    h[hCurr].node = this.freeList_;
	    this.freeList_ = hCurr;
	  };
	  /**
	   * [floatDown_ description]
	   * @private
	   * @param {libtess.PQHandle} curr [description].
	   */


	  libtess.PriorityQHeap.prototype.floatDown_ = function (curr) {
	    var n = this.nodes_;
	    var h = this.handles_;
	    var hCurr = n[curr].handle;

	    for (;;) {
	      // The children of node i are nodes 2i and 2i+1.
	      // set child to the index of the child with the minimum key
	      var child = curr << 1;

	      if (child < this.size_ && this.leq_(h[n[child + 1].handle].key, h[n[child].handle].key)) {
	        ++child;
	      }

	      var hChild = n[child].handle;

	      if (child > this.size_ || this.leq_(h[hCurr].key, h[hChild].key)) {
	        n[curr].handle = hCurr;
	        h[hCurr].node = curr;
	        break;
	      }

	      n[curr].handle = hChild;
	      h[hChild].node = curr;
	      curr = child;
	    }
	  };
	  /**
	   * [floatUp_ description]
	   * @private
	   * @param {libtess.PQHandle} curr [description].
	   */


	  libtess.PriorityQHeap.prototype.floatUp_ = function (curr) {
	    var n = this.nodes_;
	    var h = this.handles_;
	    var hCurr = n[curr].handle;

	    for (;;) {
	      var parent = curr >> 1;
	      var hParent = n[parent].handle;

	      if (parent === 0 || this.leq_(h[hParent].key, h[hCurr].key)) {
	        n[curr].handle = hCurr;
	        h[hCurr].node = curr;
	        break;
	      }

	      n[curr].handle = hParent;
	      h[hParent].node = curr;
	      curr = parent;
	    }
	  };
	  /* global libtess */
	  // TODO(bckenny): apparently only visible outside of sweep for debugging routines.
	  // find out if we can hide

	  /**
	   * For each pair of adjacent edges crossing the sweep line, there is
	   * an ActiveRegion to represent the region between them. The active
	   * regions are kept in sorted order in a dynamic dictionary. As the
	   * sweep line crosses each vertex, we update the affected regions.
	   * @constructor
	   * @struct
	   */


	  libtess.ActiveRegion = function () {
	    // TODO(bckenny): I *think* eUp and nodeUp could be passed in as constructor params

	    /**
	     * The upper edge of the region, directed right to left
	     * @type {libtess.GluHalfEdge}
	     */
	    this.eUp = null;
	    /**
	     * Dictionary node corresponding to eUp edge.
	     * @type {libtess.DictNode}
	     */

	    this.nodeUp = null;
	    /**
	     * Used to determine which regions are inside the polygon.
	     * @type {number}
	     */

	    this.windingNumber = 0;
	    /**
	     * Whether this region is inside the polygon.
	     * @type {boolean}
	     */

	    this.inside = false;
	    /**
	     * Marks fake edges at t = +/-infinity.
	     * @type {boolean}
	     */

	    this.sentinel = false;
	    /**
	     * Marks regions where the upper or lower edge has changed, but we haven't
	     * checked whether they intersect yet.
	     * @type {boolean}
	     */

	    this.dirty = false;
	    /**
	     * marks temporary edges introduced when we process a "right vertex" (one
	     * without any edges leaving to the right)
	     * @type {boolean}
	     */

	    this.fixUpperEdge = false;
	  };
	  /**
	   * Returns the ActiveRegion below this one.
	   * @return {libtess.ActiveRegion}
	   */


	  libtess.ActiveRegion.prototype.regionBelow = function () {
	    return this.nodeUp.getPredecessor().getKey();
	  };
	  /**
	   * Returns the ActiveRegion above this one.
	   * @return {libtess.ActiveRegion}
	   */


	  libtess.ActiveRegion.prototype.regionAbove = function () {
	    return this.nodeUp.getSuccessor().getKey();
	  };
	  /* global libtess, module */

	  /**
	   * node.js export for non-compiled source
	   */


	  {
	    module.exports = libtess;
	  }
	});

	/**
	 * @exports AreaMeasurer
	 */
	/**
	 * Utility class to compute approximations of projected and surface (terrain following) area on a globe.
	 *
	 * <p>To properly compute surface area the measurer must be provided with a list of positions that describe a
	 * closed path - one which last position is equal to the first.</p>
	 *
	 * <p>Segments which are longer then the current maxSegmentLength will be subdivided along lines following the
	 * current pathType - WorldWind.LINEAR, WorldWind.RHUMB_LINE or WorldWind.GREAT_CIRCLE.</p>
	 *
	 * <p>Projected or non terrain following area is computed in a sinusoidal projection which is equivalent or
	 * equal area.
	 * Surface or terrain following area is approximated by sampling the path bounding sector with square cells
	 * along a grid. Cells which center is inside the path  have their area estimated and summed according to the
	 * overall slope at the cell south-west corner.</p>
	 *
	 * @alias AreaMeasurer
	 * @constructor
	 * @param {WorldWindow} wwd The WorldWindow associated with AreaMeasurer.
	 * @throws {ArgumentError} If the specified WorldWindow is null or undefined.
	 */

	function AreaMeasurer(wwd) {
	  if (!wwd) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AreaMeasurer", "constructor", "missingWorldWindow"));
	  }

	  this.wwd = wwd; // Private. Sampling grid max rows or cols

	  this.DEFAULT_AREA_SAMPLING_STEPS = 32; // Private. Documentation is with the defined property below.

	  this._areaTerrainSamplingSteps = this.DEFAULT_AREA_SAMPLING_STEPS; // Private. Documentation is with the defined property below.

	  this._maxSegmentLength = 100e3; // Private. A list of positions with no segment longer then maxLength and elevations following terrain or not.

	  this.subdividedPositions = null; // Private.

	  this.vecZ = new Vec3$1(0, 0, 1); // Private. Reusable Location.

	  this.scratchLocation = new Location(0, 0);
	}

	Object.defineProperties(AreaMeasurer.prototype, {
	  /**
	   * The sampling grid maximum number of rows or columns for terrain following surface area approximation.
	   * @type {Number}
	   * @memberof AreaMeasurer.prototype
	   */
	  areaTerrainSamplingSteps: {
	    get: function () {
	      return this._areaTerrainSamplingSteps;
	    },
	    set: function (value) {
	      this._areaTerrainSamplingSteps = value;
	    }
	  },

	  /**
	   * The maximum length a segment can have before being subdivided along a line following the current pathType.
	   * @type {Number}
	   * @memberof AreaMeasurer.prototype
	   */
	  maxSegmentLength: {
	    get: function () {
	      return this._maxSegmentLength;
	    },
	    set: function (value) {
	      this._maxSegmentLength = value;
	    }
	  }
	});
	/**
	 * Get the sampling grid maximum number of rows or columns for terrain following surface area approximation.
	 *
	 * @param {Position[]} positions A list of positions describing a polygon
	 * @param {Boolean} followTerrain If true, the computed length will account for terrain deformations as if
	 * someone was walking along that path
	 * @param {String} pathType One of WorldWind.LINEAR, WorldWind.RHUMB_LINE or WorldWind.GREAT_CIRCLE
	 *
	 * @return {Number} area in square meters
	 */

	AreaMeasurer.prototype.getArea = function (positions, followTerrain, pathType) {
	  var globe = this.wwd.globe;

	  if (followTerrain) {
	    return this.computeSurfaceAreaSampling(globe, positions, pathType);
	  }

	  return this.computeProjectedAreaGeometry(globe, positions, pathType);
	};
	/**
	 * Sample the path bounding sector with square cells which area are approximated according to the surface normal
	 * at the cell south-west corner.
	 *
	 * @param {Globe} globe
	 * @param {Position[]} positions
	 * @param {String} pathType One of WorldWind.LINEAR, WorldWind.RHUMB_LINE or WorldWind.GREAT_CIRCLE
	 *
	 * @return {Number} area in square meters
	 */


	AreaMeasurer.prototype.computeSurfaceAreaSampling = function (globe, positions, pathType) {
	  var sector = new Sector(0, 0, 0, 0);
	  sector.setToBoundingSector(positions); // Subdivide long segments if needed

	  this.subdividedPositions = MeasurerUtils.subdividePositions(globe, positions, true, pathType, this._maxSegmentLength); // Sample the bounding sector with cells about the same length in side - squares

	  var steps = Math.max(this.DEFAULT_AREA_SAMPLING_STEPS, this._areaTerrainSamplingSteps);
	  var deltaLatRadians = sector.deltaLatitude() * Angle.DEGREES_TO_RADIANS;
	  var deltaLonRadians = sector.deltaLongitude() * Angle.DEGREES_TO_RADIANS;
	  var stepsRadians = Math.max(deltaLatRadians / steps, deltaLonRadians / steps);
	  var latSteps = Math.round(deltaLatRadians / stepsRadians);
	  var lonSteps = Math.round(deltaLonRadians / stepsRadians * Math.cos(sector.centroidLatitude() * Angle.DEGREES_TO_RADIANS));
	  var latStepRadians = deltaLatRadians / latSteps;
	  var lonStepRadians = deltaLonRadians / lonSteps;
	  var area = 0;

	  for (var i = 0; i < latSteps; i++) {
	    var lat = sector.minLatitude * Angle.DEGREES_TO_RADIANS + latStepRadians * i; // Compute this latitude row cells area

	    var radius = globe.radiusAt((lat + latStepRadians / 2) * Angle.RADIANS_TO_DEGREES, sector.centroidLongitude());
	    var cellWidth = lonStepRadians * radius * Math.cos(lat + latStepRadians / 2);
	    var cellHeight = latStepRadians * radius;
	    var cellArea = cellWidth * cellHeight;

	    for (var j = 0; j < lonSteps; j++) {
	      var lon = sector.minLongitude * Angle.DEGREES_TO_RADIANS + lonStepRadians * j;
	      var minLat = lat * Angle.RADIANS_TO_DEGREES;
	      var maxLat = (lat + latStepRadians) * Angle.RADIANS_TO_DEGREES;
	      var minLon = lon * Angle.RADIANS_TO_DEGREES;
	      var maxLon = (lon + lonStepRadians) * Angle.RADIANS_TO_DEGREES;
	      var cellSector = new Sector(minLat, maxLat, minLon, maxLon);
	      var isLocationInside = MeasurerUtils.isLocationInside(cellSector.centroid(this.scratchLocation), this.subdividedPositions);

	      if (isLocationInside) {
	        // Compute suface area using terrain normal in SW corner
	        // Corners elevation
	        var eleSW = globe.elevationAtLocation(minLat, minLon);
	        var eleSE = globe.elevationAtLocation(minLat, maxLon);
	        var eleNW = globe.elevationAtLocation(maxLat, minLon); // Compute normal

	        var vx = new Vec3$1(cellWidth, 0, eleSE - eleSW);
	        var vy = new Vec3$1(0, cellHeight, eleNW - eleSW);
	        vx.normalize();
	        vy.normalize();
	        var normalSW = vx.cross(vy).normalize(); // point toward positive Z
	        // Compute slope factor

	        var tan = Math.tan(MeasurerUtils.angleBetweenVectors(this.vecZ, normalSW));
	        var slopeFactor = Math.sqrt(1 + tan * tan); // Add cell area

	        area += cellArea * slopeFactor;
	      }
	    }
	  }

	  return area;
	};
	/**
	 * Tessellate the path in lat-lon space, then sum each triangle area.
	 *
	 * @param {Globe} globe
	 * @param {Position[]} positions
	 * @param {String} pathType One of WorldWind.LINEAR, WorldWind.RHUMB_LINE or WorldWind.GREAT_CIRCLE
	 *
	 * @return {Number} area in square meters
	 */


	AreaMeasurer.prototype.computeProjectedAreaGeometry = function (globe, positions, pathType) {
	  // Subdivide long segments if needed
	  this.subdividedPositions = MeasurerUtils.subdividePositions(globe, positions, false, pathType, this._maxSegmentLength); // First: tessellate polygon

	  var verticesCount = this.subdividedPositions.length;
	  var firstPos = this.subdividedPositions[0];
	  var lastPos = this.subdividedPositions[verticesCount - 1];

	  if (firstPos.equals(lastPos)) {
	    verticesCount--;
	  }

	  var verts = [];
	  var idx = 0;

	  for (var i = 0; i < verticesCount; i++) {
	    var pos = this.subdividedPositions[i];
	    verts[idx++] = pos.longitude * Angle.DEGREES_TO_RADIANS;
	    verts[idx++] = pos.latitude * Angle.DEGREES_TO_RADIANS;
	    verts[idx++] = 0;
	  }

	  var triangles = this.tessellatePolygon(verticesCount, verts); // Second: sum triangles area

	  var area = 0;
	  var triangleCount = triangles.length / 9;

	  for (i = 0; i < triangleCount; i++) {
	    idx = i * 9;
	    var triangle = [triangles[idx + 0], triangles[idx + 1], triangles[idx + 2], triangles[idx + 3], triangles[idx + 4], triangles[idx + 5], triangles[idx + 6], triangles[idx + 7], triangles[idx + 8]];
	    area += this.computeTriangleProjectedArea(globe, triangle);
	  }

	  return area;
	};
	/**
	 * Compute triangle area in a sinusoidal projection centered at the triangle center.
	 * Note sinusoidal projection is equivalent or equal area.
	 *
	 * @param {Globe} globe
	 * @param {Number[]} verts A list of 9 positions in radians describing a triangle
	 *
	 * @return {Number} area in square meters
	 */


	AreaMeasurer.prototype.computeTriangleProjectedArea = function (globe, verts) {
	  // http://www.mathopenref.com/coordtrianglearea.html
	  var ax = verts[0];
	  var ay = verts[1];
	  var bx = verts[3];
	  var by = verts[4];
	  var cx = verts[6];
	  var cy = verts[7];
	  var area = Math.abs(ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
	  area /= 2;
	  var centerLon = (ax + bx + cx) / 3;
	  var centerLat = (ay + by + cy) / 3; // Apply globe radius at triangle center and scale down area according to center latitude cosine

	  var radius = globe.radiusAt(centerLat * Angle.RADIANS_TO_DEGREES, centerLon * Angle.RADIANS_TO_DEGREES);
	  area *= Math.cos(centerLat) * radius * radius; // Square meter

	  return area;
	};
	/**
	 * Tessellate a Polygon
	 *
	 * @param {Number} count the number of vertices
	 * @param {Number[]} vertices A list of positions in radians
	 *
	 * @return {Number[]} a list of tessellated vertices
	 */


	AreaMeasurer.prototype.tessellatePolygon = function (count, vertices) {
	  var tess = new libtess.GluTesselator();
	  var triangles = [];
	  var coords;
	  tess.gluTessCallback(libtess.gluEnum.GLU_TESS_BEGIN, function (prim) {
	    if (prim !== libtess.primitiveType.GL_TRIANGLES) {
	      Logger$1.logMessage(Logger$1.LEVEL_WARNING, "AreaMeasurer", "tessellatePolygon", "Tessellation error, primitive is not TRIANGLES.");
	    }
	  });
	  tess.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA, function (data, tris) {
	    tris.push(data[0]);
	    tris.push(data[1]);
	    tris.push(data[2]);
	  }); //prevents triangle fans and strips

	  tess.gluTessCallback(libtess.gluEnum.GLU_TESS_EDGE_FLAG, function () {});
	  tess.gluTessCallback(libtess.gluEnum.GLU_TESS_ERROR, function (errno) {
	    Logger$1.logMessage(Logger$1.LEVEL_WARNING, "AreaMeasurer", "tessellatePolygon", "Tessellation error " + errno + ".");
	  }); // Tessellate the polygon.

	  tess.gluTessBeginPolygon(triangles);
	  tess.gluTessBeginContour();

	  for (var i = 0; i < count; i++) {
	    coords = vertices.slice(3 * i, 3 * i + 3);
	    tess.gluTessVertex(coords, coords);
	  }

	  tess.gluTessEndContour();
	  tess.gluTessEndPolygon();
	  return triangles;
	};

	/**
	 * @exports AbsentResourceList
	 */

	/**
	 * Constructs an absent resource list.
	 * @alias AbsentResourceList
	 * @constructor
	 * @classdesc Provides a collection to keep track of resources whose retrieval failed and when retrieval
	 * may be tried again. Applications typically do not use this class directly.
	 * @param {Number} maxTrys The number of attempts to make before the resource is marked as absent.
	 * @param {Number} minCheckInterval The amount of time to wait between attempts, in milliseconds.
	 * @constructor
	 */
	function AbsentResourceList(maxTrys, minCheckInterval) {
	  /**
	   * The number  of attempts to make before the resource is marked as absent.
	   * @type {Number}
	   */
	  this.maxTrys = maxTrys;
	  /**
	   * The amount of time to wait before each attempt.
	   * @type {Number}
	   */

	  this.minCheckInterval = minCheckInterval;
	  /**
	   * The amount of time, in milliseconds, beyond which retrieval attempts should again be allowed.
	   * When this time has elapsed from the most recent failed attempt the number of trys attempted is
	   * reset to 0. This prevents the resource from being permanently blocked.
	   * @type {number}
	   * @default 60,000 milliseconds (one minute)
	   */

	  this.tryAgainInterval = 60e3; // 60 seconds

	  this.possiblyAbsent = {};
	}
	/**
	 * Indicates whether a specified resource is marked as absent.
	 * @param {String} resourceId The resource identifier.
	 * @returns {Boolean} true if the resource is marked as absent, otherwise false.
	 */


	AbsentResourceList.prototype.isResourceAbsent = function (resourceId) {
	  var entry = this.possiblyAbsent[resourceId];

	  if (!entry) {
	    return false;
	  }

	  if (entry.permanent) {
	    return true;
	  }

	  var timeSinceLastMark = Date.now() - entry.timeOfLastMark;

	  if (timeSinceLastMark > this.tryAgainInterval) {
	    delete this.possiblyAbsent[resourceId];
	    return false;
	  }

	  return timeSinceLastMark < this.minCheckInterval || entry.numTrys > this.maxTrys;
	};
	/**
	 * Marks a resource attempt as having failed. This increments the number-of-tries counter and sets the time
	 * of the last attempt. When this method has been called [this.maxTrys]{@link AbsentResourceList#maxTrys}
	 * times the resource is marked as absent until this absent resource list's
	 * [try-again-interval]{@link AbsentResourceList#tryAgainInterval} is reached.
	 * @param {String} resourceId The resource identifier.
	 */


	AbsentResourceList.prototype.markResourceAbsent = function (resourceId) {
	  var entry = this.possiblyAbsent[resourceId];

	  if (!entry) {
	    entry = {
	      timeOfLastMark: Date.now(),
	      numTrys: 0
	    };
	    this.possiblyAbsent[resourceId] = entry;
	  }

	  entry.numTrys = entry.numTrys + 1;
	  entry.timeOfLastMark = Date.now();
	};
	/**
	 * Marks a resource attempt as having failed permanently. No attempt will ever again be made to retrieve
	 * the resource.
	 * @param {String} resourceId The resource identifier.
	 */


	AbsentResourceList.prototype.markResourceAbsentPermanently = function (resourceId) {
	  var entry = this.possiblyAbsent[resourceId];

	  if (!entry) {
	    entry = {
	      timeOfLastMark: Date.now(),
	      numTrys: 0
	    };
	    this.possiblyAbsent[resourceId] = entry;
	  }

	  entry.numTrys = entry.numTrys + 1;
	  entry.timeOfLastMark = Date.now();
	  entry.permanent = true;
	};
	/**
	 * Removes the specified resource from this absent resource list. Call this method when retrieval attempts
	 * succeed.
	 * @param {String} resourceId The resource identifier.
	 */


	AbsentResourceList.prototype.unmarkResourceAbsent = function (resourceId) {
	  var entry = this.possiblyAbsent[resourceId];

	  if (entry) {
	    delete this.possiblyAbsent[resourceId];
	  }
	};

	/**
	 * @exports ElevationCoverage
	 */
	/**
	 * Constructs an ElevationCoverage
	 * @alias ElevationCoverage
	 * @constructor
	 * @classdesc When used directly and not through a subclass, this class represents an elevation coverage
	 * whose elevations are zero at all locations.
	 * @param {Number} resolution The resolution of the coverage, in degrees. (To compute degrees from
	 * meters, divide the number of meters by the globe's radius to obtain radians and convert the result to degrees.)
	 * @throws {ArgumentError} If the resolution argument is null, undefined, or zero.
	 */

	function ElevationCoverage(resolution) {
	  if (!resolution) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationCoverage", "constructor", "missingResolution"));
	  }
	  /**
	   * Indicates the last time this coverage changed, in milliseconds since midnight Jan 1, 1970.
	   * @type {Number}
	   * @readonly
	   * @default Date.now() at construction
	   */


	  this.timestamp = Date.now();
	  /**
	   * Indicates this coverage's display name.
	   * @type {String}
	   * @default "Coverage"
	   */

	  this.displayName = "Coverage";
	  /**
	   * Indicates whether or not to use this coverage.
	   * @type {Boolean}
	   * @default true
	   */

	  this._enabled = true;
	  /**
	   * The resolution of this coverage in degrees.
	   * @type {Number}
	   */

	  this.resolution = resolution;
	  /**
	   * The sector this coverage spans.
	   * @type {Sector}
	   * @readonly
	   */

	  this.coverageSector = Sector.FULL_SPHERE;
	}

	Object.defineProperties(ElevationCoverage.prototype, {
	  /**
	   * Indicates whether or not to use this coverage.
	   * @type {Boolean}
	   * @default true
	   */
	  enabled: {
	    get: function () {
	      return this._enabled;
	    },
	    set: function (value) {
	      this._enabled = value;
	      this.timestamp = Date.now();
	    }
	  }
	});
	/**
	 * Returns the minimum and maximum elevations within a specified sector.
	 * @param {Sector} sector The sector for which to determine extreme elevations.
	 * @param {Number[]} result An array in which to return the requested minimum and maximum elevations.
	 * @returns {Boolean} true if the coverage completely fills the sector with data, false otherwise.
	 * @throws {ArgumentError} If any argument is null or undefined
	 */

	ElevationCoverage.prototype.minAndMaxElevationsForSector = function (sector, result) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationCoverage", "minAndMaxElevationsForSector", "missingSector"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationCoverage", "minAndMaxElevationsForSector", "missingResult"));
	  }

	  if (result[0] > 0) {
	    // min elevation
	    result[0] = 0;
	  }

	  if (result[1] < 0) {
	    // max elevation
	    result[1] = 0;
	  }

	  return true;
	};
	/**
	 * Returns the elevation at a specified location.
	 * @param {Number} latitude The location's latitude in degrees.
	 * @param {Number} longitude The location's longitude in degrees.
	 * @returns {Number} The elevation at the specified location, in meters. Returns null if the location is
	 * outside the coverage area of this coverage.
	 */


	ElevationCoverage.prototype.elevationAtLocation = function (latitude, longitude) {
	  return 0;
	};
	/**
	 * Returns the elevations at locations within a specified sector.
	 * @param {Sector} sector The sector for which to determine the elevations.
	 * @param {Number} numLat The number of latitudinal sample locations within the sector.
	 * @param {Number} numLon The number of longitudinal sample locations within the sector.
	 * @param {Number[]} result An array in which to return the requested elevations.
	 * @returns {Boolean} true if the result array was completely filled with elevation data, false otherwise.
	 * @throws {ArgumentError} If the specified sector or result array is null or undefined, or if either of the
	 * specified numLat or numLon values is less than one.
	 */


	ElevationCoverage.prototype.elevationsForGrid = function (sector, numLat, numLon, result) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationCoverage", "elevationsForGrid", "missingSector"));
	  }

	  if (numLat <= 0 || numLon <= 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationCoverage", "elevationsForGrid", "numLat or numLon is less than 1"));
	  }

	  if (!result || result.length < numLat * numLon) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationCoverage", "elevationsForGrid", "missingArray"));
	  }

	  for (var i = 0, len = result.length; i < len; i++) {
	    result[i] = 0;
	  }

	  return true;
	};

	/**
	 * @exports ElevationImage
	 */
	/**
	 * Constructs an elevation image.
	 * @alias ElevationImage
	 * @constructor
	 * @classdesc Holds elevation values for an elevation tile.
	 * This class is typically not used directly by applications.
	 * @param {Sector} sector The sector spanned by this elevation image.
	 * @param {Number} imageWidth The number of longitudinal sample points in this elevation image.
	 * @param {Number} imageHeight The number of latitudinal sample points in this elevation image.
	 * @throws {ArgumentError} If the sector is null or undefined
	 */

	function ElevationImage(sector, imageWidth, imageHeight) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationImage", "constructor", "missingSector"));
	  }
	  /**
	   * The sector spanned by this elevation image.
	   * @type {Sector}
	   * @readonly
	   */


	  this.sector = sector;
	  /**
	   * The number of longitudinal sample points in this elevation image.
	   * @type {Number}
	   * @readonly
	   */

	  this.imageWidth = imageWidth;
	  /**
	   * The number of latitudinal sample points in this elevation image.
	   * @type {Number}
	   * @readonly
	   */

	  this.imageHeight = imageHeight;
	  /**
	   * The size in bytes of this elevation image.
	   * @type {number}
	   * @readonly
	   */

	  this.size = this.imageWidth * this.imageHeight;
	  /**
	   * Internal use only
	   * false if the entire image consists of NO_DATA values, true otherwise.
	   * @ignore
	   */

	  this.hasData = true;
	  /**
	   * Internal use only
	   * true if any pixel in the image has a NO_DATA value, false otherwise.
	   * @ignore
	   */

	  this.hasMissingData = false;
	}
	/**
	 * Internal use only
	 * The value that indicates a pixel contains no data.
	 * TODO: This will eventually need to become an instance property
	 * @ignore
	 */


	ElevationImage.NO_DATA = 0;
	/**
	 * Internal use only
	 * Returns true if a set of elevation pixels represents the NO_DATA value.
	 * @ignore
	 */

	ElevationImage.isNoData = function (x0y0, x1y0, x0y1, x1y1) {
	  // TODO: Change this logic once proper NO_DATA value handling is in place.
	  var v = ElevationImage.NO_DATA;
	  return x0y0 === v && x1y0 === v && x0y1 === v && x1y1 === v;
	};
	/**
	 * Returns the pixel value at a specified coordinate in this elevation image. The coordinate origin is the
	 * image's lower left corner, so (0, 0) indicates the lower left pixel and (imageWidth-1, imageHeight-1)
	 * indicates the upper right pixel. This returns 0 if the coordinate indicates a pixel outside of this elevation
	 * image.
	 * @param x The pixel's X coordinate.
	 * @param y The pixel's Y coordinate.
	 * @returns {Number} The pixel value at the specified coordinate in this elevation image.
	 * Returns 0 if the coordinate indicates a pixel outside of this elevation image.
	 */


	ElevationImage.prototype.pixel = function (x, y) {
	  if (x < 0 || x >= this.imageWidth) {
	    return 0;
	  }

	  if (y < 0 || y >= this.imageHeight) {
	    return 0;
	  }

	  y = this.imageHeight - y - 1; // flip the y coordinate origin to the lower left corner

	  return this.imageData[x + y * this.imageWidth];
	};
	/**
	 * Returns the elevation at a specified geographic location.
	 * @param {Number} latitude The location's latitude.
	 * @param {Number} longitude The location's longitude.
	 * @returns {Number} The elevation at the specified location.
	 */


	ElevationImage.prototype.elevationAtLocation = function (latitude, longitude) {
	  var maxLat = this.sector.maxLatitude,
	      minLon = this.sector.minLongitude,
	      deltaLat = this.sector.deltaLatitude(),
	      deltaLon = this.sector.deltaLongitude(),
	      x = (this.imageWidth - 1) * (longitude - minLon) / deltaLon,
	      y = (this.imageHeight - 1) * (maxLat - latitude) / deltaLat,
	      x0 = Math.floor(WWMath.clamp(x, 0, this.imageWidth - 1)),
	      x1 = Math.floor(WWMath.clamp(x0 + 1, 0, this.imageWidth - 1)),
	      y0 = Math.floor(WWMath.clamp(y, 0, this.imageHeight - 1)),
	      y1 = Math.floor(WWMath.clamp(y0 + 1, 0, this.imageHeight - 1)),
	      pixels = this.imageData,
	      x0y0 = pixels[x0 + y0 * this.imageWidth],
	      x1y0 = pixels[x1 + y0 * this.imageWidth],
	      x0y1 = pixels[x0 + y1 * this.imageWidth],
	      x1y1 = pixels[x1 + y1 * this.imageWidth],
	      xf = x - x0,
	      yf = y - y0;

	  if (ElevationImage.isNoData(x0y0, x1y0, x0y1, x1y1)) {
	    return NaN;
	  }

	  return (1 - xf) * (1 - yf) * x0y0 + xf * (1 - yf) * x1y0 + (1 - xf) * yf * x0y1 + xf * yf * x1y1;
	};
	/**
	 * Returns elevations for a specified sector.
	 * @param {Sector} sector The sector for which to return the elevations.
	 * @param {Number} numLat The number of sample points in the longitudinal direction.
	 * @param {Number} numLon The number of sample points in the latitudinal direction.
	 * @param {Number[]} result An array in which to return the computed elevations.
	 * @throws {ArgumentError} If either the specified sector or result argument is null or undefined, or if the
	 * specified number of sample points in either direction is less than 1.
	 */


	ElevationImage.prototype.elevationsForGrid = function (sector, numLat, numLon, result) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationImage", "elevationsForGrid", "missingSector"));
	  }

	  if (numLat < 1 || numLon < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationImage", "elevationsForGrid", "The specified number of sample points is less than 1."));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationImage", "elevationsForGrid", "missingResult"));
	  }

	  var minLatSelf = this.sector.minLatitude,
	      maxLatSelf = this.sector.maxLatitude,
	      minLonSelf = this.sector.minLongitude,
	      maxLonSelf = this.sector.maxLongitude,
	      deltaLatSelf = maxLatSelf - minLatSelf,
	      deltaLonSelf = maxLonSelf - minLonSelf,
	      minLat = sector.minLatitude,
	      maxLat = sector.maxLatitude,
	      minLon = sector.minLongitude,
	      maxLon = sector.maxLongitude,
	      deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
	      deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
	      lat,
	      lon,
	      i,
	      j,
	      index = 0,
	      pixels = this.imageData;

	  for (j = 0, lat = minLat; j < numLat; j += 1, lat += deltaLat) {
	    if (j === numLat - 1) {
	      lat = maxLat; // explicitly set the last lat to the max latitude to ensure alignment
	    }

	    if (lat >= minLatSelf && lat <= maxLatSelf) {
	      // Image y-coordinate of the specified location, given an image origin in the top-left corner.
	      var y = (this.imageHeight - 1) * (maxLatSelf - lat) / deltaLatSelf,
	          y0 = Math.floor(WWMath.clamp(y, 0, this.imageHeight - 1)),
	          y1 = Math.floor(WWMath.clamp(y0 + 1, 0, this.imageHeight - 1)),
	          yf = y - y0;

	      for (i = 0, lon = minLon; i < numLon; i += 1, lon += deltaLon) {
	        if (i === numLon - 1) {
	          lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
	        }

	        if (lon >= minLonSelf && lon <= maxLonSelf && isNaN(result[index])) {
	          // Image x-coordinate of the specified location, given an image origin in the top-left corner.
	          var x = (this.imageWidth - 1) * (lon - minLonSelf) / deltaLonSelf,
	              x0 = Math.floor(WWMath.clamp(x, 0, this.imageWidth - 1)),
	              x1 = Math.floor(WWMath.clamp(x0 + 1, 0, this.imageWidth - 1)),
	              xf = x - x0;
	          var x0y0 = pixels[x0 + y0 * this.imageWidth],
	              x1y0 = pixels[x1 + y0 * this.imageWidth],
	              x0y1 = pixels[x0 + y1 * this.imageWidth],
	              x1y1 = pixels[x1 + y1 * this.imageWidth];

	          if (ElevationImage.isNoData(x0y0, x1y0, x0y1, x1y1)) {
	            result[index] = NaN;
	          } else {
	            result[index] = (1 - xf) * (1 - yf) * x0y0 + xf * (1 - yf) * x1y0 + (1 - xf) * yf * x0y1 + xf * yf * x1y1;
	          }
	        }

	        index++;
	      }
	    } else {
	      index += numLon; // skip this row
	    }
	  }
	};
	/**
	 * Returns the minimum and maximum elevations within a specified sector.
	 * @param {Sector} sector The sector of interest. If null or undefined, the minimum and maximum elevations
	 * for the sector associated with this tile are returned.
	 * @returns {Number[]} An array containing the minimum and maximum elevations within the specified sector,
	 * or null if the specified sector does not include this elevation image's coverage sector or the image is filled with
	 * NO_DATA values.
	 */


	ElevationImage.prototype.minAndMaxElevationsForSector = function (sector) {
	  if (!this.hasData) {
	    return null;
	  }

	  var result = [];

	  if (!sector) {
	    // the sector is this sector
	    result[0] = this.minElevation;
	    result[1] = this.maxElevation;
	  } else if (sector.contains(this.sector)) {
	    // The specified sector completely contains this image; return the image min and max.
	    if (result[0] > this.minElevation) {
	      result[0] = this.minElevation;
	    }

	    if (result[1] < this.maxElevation) {
	      result[1] = this.maxElevation;
	    }
	  } else {
	    // The specified sector intersects a portion of this image; compute the min and max from intersecting pixels.
	    var maxLatSelf = this.sector.maxLatitude,
	        minLonSelf = this.sector.minLongitude,
	        deltaLatSelf = this.sector.deltaLatitude(),
	        deltaLonSelf = this.sector.deltaLongitude(),
	        minLatOther = sector.minLatitude,
	        maxLatOther = sector.maxLatitude,
	        minLonOther = sector.minLongitude,
	        maxLonOther = sector.maxLongitude; // Image coordinates of the specified sector, given an image origin in the top-left corner. We take the floor and
	    // ceiling of the min and max coordinates, respectively, in order to capture all pixels that would contribute to
	    // elevations computed for the specified sector in a call to elevationsForSector.

	    var minY = Math.floor((this.imageHeight - 1) * (maxLatSelf - maxLatOther) / deltaLatSelf),
	        maxY = Math.ceil((this.imageHeight - 1) * (maxLatSelf - minLatOther) / deltaLatSelf),
	        minX = Math.floor((this.imageWidth - 1) * (minLonOther - minLonSelf) / deltaLonSelf),
	        maxX = Math.ceil((this.imageWidth - 1) * (maxLonOther - minLonSelf) / deltaLonSelf);
	    minY = WWMath.clamp(minY, 0, this.imageHeight - 1);
	    maxY = WWMath.clamp(maxY, 0, this.imageHeight - 1);
	    minX = WWMath.clamp(minX, 0, this.imageWidth - 1);
	    maxX = WWMath.clamp(maxX, 0, this.imageWidth - 1);
	    var pixels = this.imageData,
	        min = Number.MAX_VALUE,
	        max = -min;

	    for (var y = minY; y <= maxY; y++) {
	      for (var x = minX; x <= maxX; x++) {
	        var p = pixels[Math.floor(x + y * this.imageWidth)];

	        if (min > p) {
	          min = p;
	        }

	        if (max < p) {
	          max = p;
	        }
	      }
	    }

	    if (result[0] > min) {
	      result[0] = min;
	    }

	    if (result[1] < max) {
	      result[1] = max;
	    }
	  }

	  return result;
	};
	/**
	 * Determines the minimum and maximum elevations within this elevation image and stores those values within
	 * this object. See [minAndMaxElevationsForSector]{@link ElevationImage#minAndMaxElevationsForSector}
	 */


	ElevationImage.prototype.findMinAndMaxElevation = function () {
	  this.hasData = false;
	  this.hasMissingData = false;

	  if (this.imageData && this.imageData.length > 0) {
	    this.minElevation = Number.MAX_VALUE;
	    this.maxElevation = -Number.MAX_VALUE;
	    var pixels = this.imageData,
	        pixelCount = this.imageWidth * this.imageHeight;

	    for (var i = 0; i < pixelCount; i++) {
	      var p = pixels[i];

	      if (p !== ElevationImage.NO_DATA) {
	        this.hasData = true;

	        if (this.minElevation > p) {
	          this.minElevation = p;
	        }

	        if (this.maxElevation < p) {
	          this.maxElevation = p;
	        }
	      } else {
	        this.hasMissingData = true;
	      }
	    }
	  }

	  if (!this.hasData) {
	    this.minElevation = 0;
	    this.maxElevation = 0;
	  }
	};

	/**
	 * @exports Level
	 */
	/**
	 * Constructs a Level within a [LevelSet]{@link LevelSet}. Applications typically do not interact with this
	 * class.
	 * @alias Level
	 * @constructor
	 * @classdesc Represents a level in a tile pyramid.
	 * @throws {ArgumentError} If either the specified tile delta or parent level set is null or undefined.
	 */

	function Level(levelNumber, tileDelta, parent) {
	  if (!tileDelta) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Level", "constructor", "The specified tile delta is null or undefined"));
	  }

	  if (!parent) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Level", "constructor", "The specified parent level set is null or undefined"));
	  }
	  /**
	   * The level's ordinal in its parent level set.
	   * @type {Number}
	   */


	  this.levelNumber = levelNumber;
	  /**
	   * The geographic size of tiles within this level.
	   * @type {Location}
	   */

	  this.tileDelta = tileDelta;
	  /**
	   * The level set that this level is a member of.
	   * @type {LevelSet}
	   */

	  this.parent = parent;
	  /**
	   * The size of pixels or elevation cells within this level, in radians per pixel or per cell.
	   * @type {Number}
	   */

	  this.texelSize = tileDelta.latitude * Angle.DEGREES_TO_RADIANS / parent.tileHeight;
	  /**
	   * The width in pixels or cells of the resource associated with tiles within this level.
	   * @type {Number}
	   */

	  this.tileWidth = parent.tileWidth;
	  /**
	   * The height in pixels or cells of the resource associated with tiles within this level.
	   * @type {Number}
	   */

	  this.tileHeight = parent.tileHeight;
	  /**
	   * The sector spanned by this level.
	   * @type {Sector}
	   */

	  this.sector = parent.sector;
	}
	/**
	 * Indicates whether this level is the lowest resolution level (level 0) within its parent's level set.
	 * @returns {Boolean} true If this tile is the lowest resolution in the parent level set,
	 * otherwise false.
	 */


	Level.prototype.isFirstLevel = function () {
	  return this.parent.firstLevel() == this;
	};
	/**
	 * Indicates whether this level is the highest resolution level within its parent's level set.
	 * @returns {Boolean} true If this tile is the highest resolution in the parent level set,
	 * otherwise false.
	 */


	Level.prototype.isLastLevel = function () {
	  return this.parent.lastLevel() == this;
	};
	/**
	 * Returns the level whose ordinal occurs immediately before this level's ordinal in the parent level set, or
	 * null if this is the fist level.
	 * @returns {Level} The previous level, or null if this is the first level.
	 */


	Level.prototype.previousLevel = function () {
	  return this.parent.level(this.levelNumber - 1);
	};
	/**
	 * Returns the level whose ordinal occurs immediately after this level's ordinal in the parent level set, or
	 * null if this is the last level.
	 * @returns {Level} The next level, or null if this is the last level.
	 */


	Level.prototype.nextLevel = function () {
	  return this.parent.level(this.levelNumber + 1);
	};
	/**
	 * Compare this level's ordinal to that of a specified level.
	 * @param {Level} that The level to compare this one to.
	 * @returns {Number} 0 if the two ordinals are equivalent. -1 if this level's ordinal is less than the specified
	 * level's ordinal. 1 if this level's ordinal is greater than the specified level's ordinal.
	 * @throws {ArgumentError} If the specified level is null or undefined.
	 */


	Level.prototype.compare = function (that) {
	  if (!that) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Level", "compare", "The specified level is null or undefined"));
	  }

	  if (this.levelNumber < that.levelNumber) return -1;
	  if (this.levelNumber > that.levelNumber) return 1;
	  return 0;
	};

	/**
	 * @exports LevelSet
	 */
	/**
	 * Constructs a level set.
	 * @alias Level
	 * @constructor
	 * @classdesc Represents a multi-resolution, hierarchical collection of tiles. Applications typically do not
	 * interact with this class.
	 * @param {Sector} sector The sector spanned by this level set.
	 * @param {Location} levelZeroDelta The geographic size of tiles in the lowest resolution level of this level set.
	 * @param {Number} numLevels The number of levels in the level set.
	 * @param {Number} tileWidth The height in pixels of images associated with tiles in this level set, or the number of sample
	 * points in the longitudinal direction of elevation tiles associate with this level set.
	 * @param {Number} tileHeight The height in pixels of images associated with tiles in this level set, or the number of sample
	 * points in the latitudinal direction of elevation tiles associate with this level set.
	 * @throws {ArgumentError} If the specified sector or level-zero-delta is null or undefined, the level zero
	 * delta values are less than or equal to zero, or any of the number-of-levels, tile-width or tile-height
	 * arguments are less than 1.
	 */

	function LevelSet(sector, levelZeroDelta, numLevels, tileWidth, tileHeight) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "LevelSet", "constructor", "missingSector"));
	  }

	  if (!levelZeroDelta) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "LevelSet", "constructor", "The specified level zero delta is null or undefined"));
	  }

	  if (levelZeroDelta.latitude <= 0 || levelZeroDelta.longitude <= 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "LevelSet", "constructor", "The specified level zero delta is less than or equal to zero."));
	  }

	  if (numLevels < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "LevelSet", "constructor", "The specified number of levels is less than one."));
	  }

	  if (tileWidth < 1 || tileHeight < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "LevelSet", "constructor", "The specified tile width or tile height is less than one."));
	  }
	  /**
	   * The sector spanned by this level set.
	   * @type {Sector}
	   * @readonly
	   */


	  this.sector = sector;
	  /**
	   * The geographic size of the lowest resolution (level 0) tiles in this level set.
	   * @type {Location}
	   * @readonly
	   */

	  this.levelZeroDelta = levelZeroDelta;
	  /**
	   * The number of levels in this level set.
	   * @type {Number}
	   * @readonly
	   */

	  this.numLevels = numLevels;
	  /**
	   *  The width in pixels of images associated with tiles in this level set, or the number of sample points
	   *  in the longitudinal direction of elevation tiles associated with this level set.
	   * @type {Number}
	   * @readonly
	   */

	  this.tileWidth = tileWidth;
	  /**
	   *  The height in pixels of images associated with tiles in this level set, or the number of sample points
	   *  in the latitudinal direction of elevation tiles associated with this level set.
	   * @type {Number}
	   * @readonly
	   */

	  this.tileHeight = tileHeight;
	  this.levels = [];

	  for (var i = 0; i < numLevels; i += 1) {
	    var n = Math.pow(2, i),
	        latDelta = levelZeroDelta.latitude / n,
	        lonDelta = levelZeroDelta.longitude / n,
	        tileDelta = new Location(latDelta, lonDelta),
	        level = new Level(i, tileDelta, this);
	    this.levels[i] = level;
	  }
	}
	/**
	 * Returns the number of levels that match the specified resolution. firstLevelResolution indicates the
	 * resolution of the first level's tiles, in degrees per pixel. This depends only on the LevelSet configuration,
	 * and is derived by evaluating {@code levelZeroDelta.latitude / tileHeight}. lastLevelResolution indicates the
	 * resolution of the data represented by the LevelSet.
	 *
	 * The returned level count is a fractional value. The dataset resolution is rarely an even multiple of the
	 * first level resolution, so the ideal last level is typically somewhere in between two levels. An integer
	 * level count can be computed depending on the desired behavior. If the last level should
	 * <i>match or exceed</i> the data resolution, take the ceiling of the returned value. Otherwise, if the last
	 * level should be <i>no more than<i/> the data resolution, take the floor of the returned value.
	 *
	 * @param {Number} firstLevelResolution the known resolution of the first level in degrees per pixel
	 * @param {Number} lastLevelResolution the desired resolution of the last level in degrees per pixel
	 *
	 * @return {Number} the number of levels as a fractional level count
	 *
	 * @throws {ArgumentError} If either resolution is null, undefined, or zero
	 */


	LevelSet.numLevelsForResolution = function (firstLevelResolution, lastLevelResolution) {
	  if (!firstLevelResolution || !lastLevelResolution) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "LevelSet", "numLevelsForResolution", "missingResolution"));
	  }

	  var lastLevel = Math.log(firstLevelResolution / lastLevelResolution) / Math.log(2); // fractional level address

	  if (lastLevel < 0) {
	    lastLevel = 0; // ensure at least one level is used, resolution can be less than the first level resolution
	  }

	  return lastLevel + 1; // convert level number to level count
	};
	/**
	 * Returns the {@link Level} for a specified level number.
	 * @param {Number} levelNumber The number of the desired level.
	 * @returns {Level} The requested level, or null if the level does not exist.
	 */


	LevelSet.prototype.level = function (levelNumber) {
	  if (levelNumber < 0 || levelNumber >= this.levels.length) {
	    return null;
	  } else {
	    return this.levels[levelNumber];
	  }
	};
	/**
	 * Returns the level with a specified texel size.
	 * This function returns the first level if the specified texel size is greater than the first level's texel
	 * size, and returns the last level if the delta is less than the last level's texel size.
	 * @param {Number} texelSize The size of pixels or elevation cells in the level, in radians per pixel or cell.
	 */


	LevelSet.prototype.levelForTexelSize = function (texelSize) {
	  // TODO: Replace this loop with a computation.
	  var lastLevel = this.lastLevel();

	  if (lastLevel.texelSize >= texelSize) {
	    return lastLevel; // Can't do any better than the last level.
	  }

	  for (var index = 0, length = this.levels.length; index < length; index += 1) {
	    var level = this.levels[index];

	    if (level.texelSize <= texelSize) {
	      return level;
	    }
	  }

	  return lastLevel;
	};
	/**
	 * Returns the first (lowest resolution) level of this level set.
	 * @returns {Level} The first level of this level set.
	 */


	LevelSet.prototype.firstLevel = function () {
	  return this.levels[0];
	};
	/**
	 * Returns the last (highest resolution) level of this level set.
	 * @returns {Level} The last level of this level set.
	 */


	LevelSet.prototype.lastLevel = function () {
	  return this.levels[this.levels.length - 1];
	};

	/**
	 * @exports MemoryCache
	 */
	/**
	 * Constructs a memory cache of a specified size.
	 * @alias MemoryCache
	 * @constructor
	 * @classdesc Provides a limited-size memory cache of key-value pairs. The meaning of size depends on usage.
	 * Some instances of this class work in bytes while others work in counts. See the documentation for the
	 * specific use to determine the size units.
	 * @param {Number} capacity The cache's capacity.
	 * @param {Number} lowWater The size to clear the cache to when its capacity is exceeded.
	 * @throws {ArgumentError} If either the capacity is 0 or negative or the low-water value is greater than
	 * or equal to the capacity or less than 1.
	 */

	function MemoryCache(capacity, lowWater) {
	  if (!capacity || capacity < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCache", "constructor", "The specified capacity is undefined, zero or negative"));
	  }

	  if (!lowWater || lowWater >= capacity || lowWater < 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCache", "constructor", "The specified low-water value is undefined, greater than or equal to the capacity, or less than 1"));
	  } // Documented with its property accessor below.


	  this._capacity = capacity; // Documented with its property accessor below.

	  this._lowWater = lowWater;
	  /**
	   * The size currently used by this cache.
	   * @type {Number}
	   * @readonly
	   */

	  this.usedCapacity = 0;
	  /**
	   * The size currently unused by this cache.
	   * @type {Number}
	   * @readonly
	   */

	  this.freeCapacity = capacity; // Private. The cache entries.

	  this.entries = {}; // Private. The cache listeners.

	  this.listeners = [];
	}

	Object.defineProperties(MemoryCache.prototype, {
	  /**
	   * The maximum this cache may hold. When the capacity is explicitly set via this property, and the current
	   * low-water value is greater than the specified capacity, the low-water value is adjusted to be 85% of
	   * the specified capacity. The specified capacity may not be less than or equal to 0.
	   * @type {Number}
	   * @memberof MemoryCache.prototype
	   */
	  capacity: {
	    get: function () {
	      return this._capacity;
	    },
	    set: function (value) {
	      if (!value || value < 1) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCache", "capacity", "Specified cache capacity is undefined, 0 or negative."));
	      }

	      var oldCapacity = this._capacity;
	      this._capacity = value;

	      if (this._capacity <= this.lowWater) {
	        this._lowWater = 0.85 * this._capacity;
	      } // Trim the cache to the low-water mark if it's less than the old capacity


	      if (this._capacity < oldCapacity) {
	        this.makeSpace(0);
	      }
	    }
	  },

	  /**
	   * The size to clear this cache to when its capacity is exceeded. It must be less than the current
	   * capacity and not negative.
	   * @type {Number}
	   * @memberof MemoryCache.prototype
	   */
	  lowWater: {
	    get: function () {
	      return this._lowWater;
	    },
	    set: function (value) {
	      if (!value || value >= this._capacity || value < 0) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCache", "lowWater", "Specified cache low-water value is undefined, negative or not less than the current capacity."));
	      }

	      this._lowWater = value;
	    }
	  }
	});
	/**
	 * Returns the entry for a specified key.
	 * @param {String} key The key of the entry to return.
	 * @returns {Object} The entry associated with the specified key, or null if the key is not in the cache or
	 * is null or undefined.
	 */

	MemoryCache.prototype.entryForKey = function (key) {
	  if (!key) return null;
	  var cacheEntry = this.entries[key];
	  if (!cacheEntry) return null;
	  cacheEntry.lastUsed = Date.now();
	  return cacheEntry.entry;
	};
	/**
	 * Adds a specified entry to this cache.
	 * @param {String} key The entry's key.
	 * @param {Object} entry The entry.
	 * @param {Number} size The entry's size.
	 * @throws {ArgumentError} If the specified key or entry is null or undefined or the specified size is less
	 * than 1.
	 */


	MemoryCache.prototype.putEntry = function (key, entry, size) {
	  if (!key) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCache", "putEntry", "missingKey."));
	  }

	  if (!entry) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCache", "putEntry", "missingEntry."));
	  }

	  if (size < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCache", "putEntry", "The specified entry size is less than 1."));
	  }

	  var existing = this.entries[key],
	      cacheEntry;

	  if (existing) {
	    this.removeEntry(key);
	  }

	  if (this.usedCapacity + size > this._capacity) {
	    this.makeSpace(size);
	  }

	  this.usedCapacity += size;
	  this.freeCapacity = this._capacity - this.usedCapacity;
	  cacheEntry = {
	    key: key,
	    entry: entry,
	    size: size,
	    lastUsed: Date.now(),
	    agingFactor: 1 // 1x = normal aging

	  };
	  this.entries[key] = cacheEntry;
	};
	/**
	 * Removes all resources from this cache.
	 * @param {Boolean} callListeners If true, the current cache listeners are called for each entry removed.
	 * If false, the cache listeners are not called.
	 */


	MemoryCache.prototype.clear = function (callListeners) {
	  if (callListeners) {
	    // Remove each entry individually so that the listeners can be called for each entry.
	    for (var key in this.entries) {
	      if (this.entries.hasOwnProperty(key)) {
	        this.removeCacheEntry(key);
	      }
	    }
	  }

	  this.entries = {};
	  this.freeCapacity = this._capacity;
	  this.usedCapacity = 0;
	};
	/**
	 * Remove an entry from this cache.
	 * @param {String} key The key of the entry to remove. If null or undefined, this cache is not modified.
	 */


	MemoryCache.prototype.removeEntry = function (key) {
	  if (!key) return;
	  var cacheEntry = this.entries[key];

	  if (cacheEntry) {
	    this.removeCacheEntry(cacheEntry);
	  }
	};
	/**
	 * Sets an entry's aging factor (multiplier) used to sort the entries for eviction.
	 * A value of one is normal aging; a value of two invokes 2x aging, causing
	 * the entry to become twice as old as a normal sibling with the same
	 * 'last used' timestamp. Setting a value of zero would be a "fountain
	 * of youth" for an entry as it wouldn't age and thus would sort to the
	 * bottom of the eviction queue.
	 * @param {String} key The key of the entry to modify. If null or undefined, the cache entry is not modified.
	 * @param {Number} agingFactor A multiplier applied to the age of the entry when sorting candidates for eviction.
	 *
	 */


	MemoryCache.prototype.setEntryAgingFactor = function (key, agingFactor) {
	  if (!key) return;
	  var cacheEntry = this.entries[key];

	  if (cacheEntry) {
	    cacheEntry.agingFactor = agingFactor;
	  }
	}; // Private. Removes a specified entry from this cache.


	MemoryCache.prototype.removeCacheEntry = function (cacheEntry) {
	  // All removal passes through this function.
	  delete this.entries[cacheEntry.key];
	  this.usedCapacity -= cacheEntry.size;
	  this.freeCapacity = this._capacity - this.usedCapacity;

	  for (var i = 0, len = this.listeners.length; i < len; i++) {
	    try {
	      this.listeners[i].entryRemoved(cacheEntry.key, cacheEntry.entry);
	    } catch (e) {
	      this.listeners[i].removalError(e, cacheEntry.key, cacheEntry.entry);
	    }
	  }
	};
	/**
	 * Indicates whether a specified entry is in this cache.
	 * @param {String} key The key of the entry to search for.
	 * @returns {Boolean} true if the entry exists, otherwise false.
	 */


	MemoryCache.prototype.containsKey = function (key) {
	  return key && this.entries[key];
	};
	/**
	 * Adds a cache listener to this cache.
	 * @param {MemoryCacheListener} listener The listener to add.
	 * @throws {ArgumentError} If the specified listener is null or undefined or does not implement both the
	 * entryRemoved and removalError functions.
	 */


	MemoryCache.prototype.addCacheListener = function (listener) {
	  if (!listener) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCache", "addCacheListener", "missingListener"));
	  }

	  if (typeof listener.entryRemoved !== "function" || typeof listener.removalError !== "function") {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCache", "addCacheListener", "The specified listener does not implement the required functions."));
	  }

	  this.listeners.push(listener);
	};
	/**
	 * Removes a cache listener from this cache.
	 * @param {MemoryCacheListener} listener The listener to remove.
	 * @throws {ArgumentError} If the specified listener is null or undefined.
	 */


	MemoryCache.prototype.removeCacheListener = function (listener) {
	  if (!listener) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCache", "removeCacheListener", "missingListener"));
	  }

	  var index = this.listeners.indexOf(listener);

	  if (index > -1) {
	    this.listeners.splice(index, 1);
	  }
	}; // Private. Clears this cache to that necessary to contain a specified amount of free space.


	MemoryCache.prototype.makeSpace = function (spaceRequired) {
	  var sortedEntries = [],
	      now = Date.now(); // Sort the entries from least recently used to most recently used, then remove the least recently used entries
	  // until the cache capacity reaches the low water and the cache has enough free capacity for the required
	  // space.

	  for (var key in this.entries) {
	    if (this.entries.hasOwnProperty(key)) {
	      sortedEntries.push(this.entries[key]);
	    }
	  }

	  sortedEntries.sort(function (a, b) {
	    var aAge = (now - a.lastUsed) * a.agingFactor,
	        bAge = (now - b.lastUsed) * b.agingFactor;
	    return bAge - aAge;
	  });

	  for (var i = 0, len = sortedEntries.length; i < len; i++) {
	    if (this.usedCapacity > this._lowWater || this.freeCapacity < spaceRequired) {
	      this.removeCacheEntry(sortedEntries[i]);
	    } else {
	      break;
	    }
	  }
	};

	var BasicVertex = "\r\nattribute vec4 vertexPoint;\r\n\r\nuniform mat4 mvpMatrix;\r\n\r\nvoid main() {\r\n    gl_Position = mvpMatrix * vertexPoint;\r\n}";

	var BasicFragment = "\r\nprecision mediump float;\r\n\r\nuniform vec4 color;\r\n\r\nvoid main() {\r\n    gl_FragColor = color;\r\n}";

	/**
	 * @exports BasicProgram
	 */
	/**
	 * Constructs a new program.
	 * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	 * <p>
	 * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program. This
	 * method then compiles the shaders and then links the program if compilation is successful. Use the bind method to make the
	 * program current during rendering.
	 *
	 * @alias BasicProgram
	 * @constructor
	 * @augments GpuProgram
	 * @classdesc BasicProgram is a GLSL program that draws geometry in a solid color.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
	 * the compiled shaders into a program fails.
	 */

	function BasicProgram(gl) {
	  var vertexShaderSource = BasicVertex,
	      fragmentShaderSource = BasicFragment; // Call to the superclass, which performs shader program compiling and linking.

	  GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource);
	  /**
	   * The WebGL location for this program's 'vertexPoint' attribute.
	   * @type {Number}
	   * @readonly
	   */

	  this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");
	  /**
	   * The WebGL location for this program's 'mvpMatrix' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");
	  /**
	   * The WebGL location for this program's 'color' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.colorLocation = this.uniformLocation(gl, "color");
	}
	/**
	 * A string that uniquely identifies this program.
	 * @type {string}
	 * @readonly
	 */


	BasicProgram.key = "WorldWindGpuBasicProgram"; // Inherit from GpuProgram.

	BasicProgram.prototype = Object.create(GpuProgram.prototype);
	/**
	 * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix} matrix The matrix to load.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */

	BasicProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BasicProgram", "loadModelviewProjection", "missingMatrix"));
	  }

	  this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	};
	/**
	 * Loads the specified color as the value of this program's 'color' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Color} color The color to load.
	 * @throws {ArgumentError} If the specified color is null or undefined.
	 */


	BasicProgram.prototype.loadColor = function (gl, color) {
	  if (!color) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BasicProgram", "loadColor", "missingColor"));
	  }

	  this.loadUniformColor(gl, color, this.colorLocation);
	};
	/**
	 * Loads the specified RGBA color components as the value of this program's 'color' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} red The red component, a number between 0 and 1.
	 * @param {Number} green The green component, a number between 0 and 1.
	 * @param {Number} blue The blue component, a number between 0 and 1.
	 * @param {Number} alpha The alpha component, a number between 0 and 1.
	 */


	BasicProgram.prototype.loadColorComponents = function (gl, red, green, blue, alpha) {
	  this.loadUniformColorComponents(gl, red, green, blue, alpha, this.colorLocation);
	};

	/**
	 * Provides math constants and functions.
	 * @exports WWUtil
	 */

	var WWUtil = {
	  // A regular expression that matches latitude followed by a comma and possible white space followed by
	  // longitude. Latitude and longitude ranges are not considered.
	  latLonRegex: /^(\-?\d+(\.\d+)?),\s*(\-?\d+(\.\d+)?)$/,

	  /**
	   * Returns the suffix for a specified mime type.
	   * @param {String} mimeType The mime type to determine a suffix for.
	   * @returns {String} The suffix for the specified mime type, or null if the mime type is not recognized.
	   */
	  suffixForMimeType: function (mimeType) {
	    if (mimeType === "image/png") return "png";
	    if (mimeType === "image/jpeg") return "jpg";
	    if (mimeType === "application/bil16") return "bil";
	    if (mimeType === "application/bil32") return "bil";
	    return null;
	  },

	  /**
	   * Returns the current location URL as obtained from window.location with the last path component
	   * removed.
	   * @returns {String} The current location URL with the last path component removed.
	   */
	  currentUrlSansFilePart: function () {
	    var protocol = window.location.protocol,
	        host = window.location.host,
	        path = window.location.pathname,
	        pathParts = path.split("/"),
	        newPath = "";

	    for (var i = 0, len = pathParts.length; i < len - 1; i++) {
	      if (pathParts[i].length > 0) {
	        newPath = newPath + "/" + pathParts[i];
	      }
	    }

	    return protocol + "//" + host + newPath;
	  },

	  /**
	   * Returns the URL of the directory containing the WorldWind library.
	   * @returns {String} The URL of the directory containing the WorldWind library, or null if that directory
	   * cannot be determined.
	   */
	  worldwindlibLocation: function () {
	    var scripts = document.getElementsByTagName("script"),
	        libraryName = "/worldwind.";

	    for (var i = 0; i < scripts.length; i++) {
	      var index = scripts[i].src.indexOf(libraryName);

	      if (index >= 0) {
	        return scripts[i].src.substring(0, index) + "/";
	      }
	    }

	    return null;
	  },

	  /**
	   * Returns the path component of a specified URL.
	   * @param {String} url The URL from which to determine the path component.
	   * @returns {String} The path component, or the empty string if the specified URL is null, undefined
	   * or empty.
	   */
	  urlPath: function (url) {
	    if (!url) return "";
	    var urlParts = url.split("/"),
	        newPath = "";

	    for (var i = 0, len = urlParts.length; i < len; i++) {
	      var part = urlParts[i];

	      if (!part || part.length === 0 || part.indexOf(":") != -1 || part === "." || part === ".." || part === "null" || part === "undefined") {
	        continue;
	      }

	      if (newPath.length !== 0) {
	        newPath = newPath + "/";
	      }

	      newPath = newPath + part;
	    }

	    return newPath;
	  },

	  /**
	   * Sets each element of an array to a specified value. This function is intentionally generic, and works
	   * with any data structure with a length property whose elements may be referenced using array index syntax.
	   * @param array The array to fill.
	   * @param {*} value The value to assign to each array element.
	   */
	  fillArray: function (array, value) {
	    if (!array) {
	      return;
	    }

	    for (var i = 0, len = array.length; i < len; i++) {
	      array[i] = value;
	    }
	  },

	  /**
	   * Multiplies each element of an array by a specified value and assigns each element to the result. This
	   * function is intentionally generic, and works with any data structure with a length property whose
	   * elements may be referenced using array index syntax.
	   * @param array The array to fill.
	   * @param {*} value The value to multiply by each array element.
	   */
	  multiplyArray: function (array, value) {
	    if (!array) {
	      return;
	    }

	    for (var i = 0, len = array.length; i < len; i++) {
	      array[i] *= value;
	    }
	  },
	  // Used to form unique function names for JSONP callback functions.
	  jsonpCounter: 0,

	  /**
	   * Request a resource using JSONP.
	   * @param {String} url The url to receive the request.
	   * @param {String} parameterName The JSONP callback function key required by the server. Typically
	   * "jsonp" or "callback".
	   * @param {Function} callback The function to invoke when the request succeeds. The function receives
	   * one argument, the JSON payload of the JSONP request.
	   */
	  jsonp: function (url, parameterName, callback) {
	    // Generate a unique function name for the JSONP callback.
	    var functionName = "gov_nasa_worldwind_jsonp_" + WWUtil.jsonpCounter++; // Define a JSONP callback function. Assign it to global scope the browser can find it.

	    window[functionName] = function (jsonData) {
	      // Remove the JSONP callback from global scope.
	      delete window[functionName]; // Call the client's callback function.

	      callback(jsonData);
	    }; // Append the callback query parameter to the URL.


	    var jsonpUrl = url + (url.indexOf('?') === -1 ? '?' : '&');
	    jsonpUrl += parameterName + "=" + functionName; // Create a script element for the browser to invoke.

	    var script = document.createElement('script');
	    script.async = true;
	    script.src = jsonpUrl; // Prepare to add the script to the document's head.

	    var head = document.getElementsByTagName('head')[0]; // Set up to remove the script element once it's invoked.

	    var cleanup = function () {
	      script.onload = undefined;
	      script.onerror = undefined;
	      head.removeChild(script);
	    };

	    script.onload = cleanup;
	    script.onerror = cleanup; // Add the script element to the document, causing the browser to invoke it.

	    head.appendChild(script);
	  },
	  arrayEquals: function (array1, array2) {
	    return array1.length == array2.length && array1.every(function (element, index) {
	      return element === array2[index] || element.equals && element.equals(array2[index]);
	    });
	  },

	  /**
	   * It transforms given item to the boolean. It respects that 0, "0" and "false" are percieved as false
	   * on top of the standard Boolean function.
	   * @param item {String} Item to transform
	   * @returns {boolean} Value transformed to the boolean.
	   */
	  transformToBoolean: function (item) {
	    if (item == 0 || item == "0" || item == "false") {
	      return false;
	    } else {
	      return Boolean(item);
	    }
	  },

	  /**
	   * It clones original object into the new one. It is necessary to retain the options information valid
	   * for all nodes.
	   * @param original Object to clone
	   * @returns {Object} Cloned object
	   */
	  clone: function (original) {
	    var clone = {};
	    var i,
	        keys = Object.keys(original);

	    for (i = 0; i < keys.length; i++) {
	      // copy each property into the clone
	      clone[keys[i]] = original[keys[i]];
	    }

	    return clone;
	  },

	  /**
	   * It returns unique GUID.
	   * @returns {string} String representing unique identifier in the application.
	   */
	  guid: function () {
	    function s4() {
	      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	    }

	    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
	  },

	  /**
	   * Transforms item to date. It accepts ISO-8601 format.
	   * @param item {String} To transform.
	   * @returns {Date} Date extracted from the current information.
	   */
	  date: function (item) {
	    return new Date(item);
	  },

	  /**
	   * Determines whether subjectString begins with the characters of searchString.
	   * @param {String} subjectString The string to analyse.
	   * @param {String} searchString The characters to be searched for at the start of subjectString.
	   * @param {Number} position The position in subjectString at which to begin searching for searchString; defaults to 0.
	   * @return {Boolean} true if the given characters are found at the beginning of the string; otherwise, false.
	   */
	  startsWith: function (subjectString, searchString, position) {
	    position = position || 0;
	    return subjectString.substr(position, searchString.length) === searchString;
	  },

	  /**
	   * Determines whether subjectString ends with the characters of searchString.
	   * @param {String} subjectString The string to analyse.
	   * @param {String} searchString The characters to be searched for at the end of subjectString.
	   * @param {Number} length Optional. If provided overwrites the considered length of the string to search in. If omitted, the default value is the length of the string.
	   * @return {Boolean} true if the given characters are found at the end of the string; otherwise, false.
	   */
	  endsWith: function (subjectString, searchString, length) {
	    if (typeof length !== 'number' || !isFinite(length) || Math.floor(length) !== length || length > subjectString.length) {
	      length = subjectString.length;
	    }

	    length -= searchString.length;
	    var lastIndex = subjectString.lastIndexOf(searchString, length);
	    return lastIndex !== -1 && lastIndex === length;
	  }
	};

	/**
	 * @exports BoundingBox
	 */
	/**
	 * Constructs a unit bounding box.
	 * The unit box has its R, S and T axes aligned with the X, Y and Z axes, respectively, and has its length,
	 * width and height set to 1.
	 * @alias BoundingBox
	 * @constructor
	 * @classdesc Represents a bounding box in Cartesian coordinates. Typically used as a bounding volume.
	 */

	function BoundingBox() {
	  /**
	   * The box's center point.
	   * @type {Vec3}
	   * @default (0, 0, 0)
	   */
	  this.center = new Vec3$1(0, 0, 0);
	  /**
	   * The center point of the box's bottom. (The origin of the R axis.)
	   * @type {Vec3}
	   * @default (-0.5, 0, 0)
	   */

	  this.bottomCenter = new Vec3$1(-0.5, 0, 0);
	  /**
	   * The center point of the box's top. (The end of the R axis.)
	   * @type {Vec3}
	   * @default (0.5, 0, 0)
	   */

	  this.topCenter = new Vec3$1(0.5, 0, 0);
	  /**
	   * The box's R axis, its longest axis.
	   * @type {Vec3}
	   * @default (1, 0, 0)
	   */

	  this.r = new Vec3$1(1, 0, 0);
	  /**
	   * The box's S axis, its mid-length axis.
	   * @type {Vec3}
	   * @default (0, 1, 0)
	   */

	  this.s = new Vec3$1(0, 1, 0);
	  /**
	   * The box's T axis, its shortest axis.
	   * @type {Vec3}
	   * @default (0, 0, 1)
	   */

	  this.t = new Vec3$1(0, 0, 1);
	  /**
	   * The box's radius. (The half-length of its diagonal.)
	   * @type {number}
	   * @default sqrt(3)
	   */

	  this.radius = Math.sqrt(3); // Internal use only. Intentionally not documented.

	  this.tmp1 = new Vec3$1(0, 0, 0);
	  this.tmp2 = new Vec3$1(0, 0, 0);
	  this.tmp3 = new Vec3$1(0, 0, 0); // Internal use only. Intentionally not documented.

	  this.scratchElevations = new Float64Array(9);
	  this.scratchPoints = new Float64Array(3 * this.scratchElevations.length);
	} // Internal use only. Intentionally not documented.


	BoundingBox.scratchMatrix = Matrix.fromIdentity();
	/**
	 * Returns the eight {@link Vec3} corners of the box.
	 *
	 * @returns {Array} the eight box corners in the order bottom-lower-left, bottom-lower-right, bottom-upper-right,
	 *         bottom-upper-left, top-lower-left, top-lower-right, top-upper-right, top-upper-left.
	 */

	BoundingBox.prototype.getCorners = function () {
	  var ll = new Vec3$1(this.s[0], this.s[1], this.s[2]);
	  var lr = new Vec3$1(this.t[0], this.t[1], this.t[2]);
	  var ur = new Vec3$1(this.s[0], this.s[1], this.s[2]);
	  var ul = new Vec3$1(this.s[0], this.s[1], this.s[2]);
	  ll.add(this.t).multiply(-0.5); // Lower left.

	  lr.subtract(this.s).multiply(0.5); // Lower right.

	  ur.add(this.t).multiply(0.5); // Upper right.

	  ul.subtract(this.t).multiply(0.5); // Upper left.

	  var corners = [];

	  for (var i = 0; i < 4; i++) {
	    corners.push(new Vec3$1(this.bottomCenter[0], this.bottomCenter[1], this.bottomCenter[2]));
	  }

	  for (i = 0; i < 4; i++) {
	    corners.push(new Vec3$1(this.topCenter[0], this.topCenter[1], this.topCenter[2]));
	  }

	  corners[0].add(ll);
	  corners[1].add(lr);
	  corners[2].add(ur);
	  corners[3].add(ul);
	  corners[4].add(ll);
	  corners[5].add(lr);
	  corners[6].add(ur);
	  corners[7].add(ul);
	  return corners;
	};
	/**
	 * Sets this bounding box such that it minimally encloses a specified collection of points.
	 * @param {Float32Array} points The points to contain.
	 * @returns {BoundingBox} This bounding box set to contain the specified points.
	 * @throws {ArgumentError} If the specified list of points is null, undefined or empty.
	 */


	BoundingBox.prototype.setToPoints = function (points) {
	  if (!points || points.length < 3) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BoundingBox", "setToPoints", "missingArray"));
	  }

	  var rMin = +Number.MAX_VALUE,
	      rMax = -Number.MAX_VALUE,
	      sMin = +Number.MAX_VALUE,
	      sMax = -Number.MAX_VALUE,
	      tMin = +Number.MAX_VALUE,
	      tMax = -Number.MAX_VALUE,
	      r = this.r,
	      s = this.s,
	      t = this.t,
	      p = new Vec3$1(0, 0, 0),
	      pdr,
	      pds,
	      pdt,
	      rLen,
	      sLen,
	      tLen,
	      rSum,
	      sSum,
	      tSum,
	      rx_2,
	      ry_2,
	      rz_2,
	      cx,
	      cy,
	      cz;
	  Matrix.principalAxesFromPoints(points, r, s, t);

	  for (var i = 0, len = points.length / 3; i < len; i++) {
	    p[0] = points[i * 3];
	    p[1] = points[i * 3 + 1];
	    p[2] = points[i * 3 + 2];
	    pdr = p.dot(r);
	    if (rMin > pdr) rMin = pdr;
	    if (rMax < pdr) rMax = pdr;
	    pds = p.dot(s);
	    if (sMin > pds) sMin = pds;
	    if (sMax < pds) sMax = pds;
	    pdt = p.dot(t);
	    if (tMin > pdt) tMin = pdt;
	    if (tMax < pdt) tMax = pdt;
	  }

	  if (rMax === rMin) rMax = rMin + 1;
	  if (sMax === sMin) sMax = sMin + 1;
	  if (tMax === tMin) tMax = tMin + 1;
	  rLen = rMax - rMin;
	  sLen = sMax - sMin;
	  tLen = tMax - tMin;
	  rSum = rMax + rMin;
	  sSum = sMax + sMin;
	  tSum = tMax + tMin;
	  rx_2 = 0.5 * r[0] * rLen;
	  ry_2 = 0.5 * r[1] * rLen;
	  rz_2 = 0.5 * r[2] * rLen;
	  cx = 0.5 * (r[0] * rSum + s[0] * sSum + t[0] * tSum);
	  cy = 0.5 * (r[1] * rSum + s[1] * sSum + t[1] * tSum);
	  cz = 0.5 * (r[2] * rSum + s[2] * sSum + t[2] * tSum);
	  this.center[0] = cx;
	  this.center[1] = cy;
	  this.center[2] = cz;
	  this.topCenter[0] = cx + rx_2;
	  this.topCenter[1] = cy + ry_2;
	  this.topCenter[2] = cz + rz_2;
	  this.bottomCenter[0] = cx - rx_2;
	  this.bottomCenter[1] = cy - ry_2;
	  this.bottomCenter[2] = cz - rz_2;
	  r.multiply(rLen);
	  s.multiply(sLen);
	  t.multiply(tLen);
	  this.radius = 0.5 * Math.sqrt(rLen * rLen + sLen * sLen + tLen * tLen);
	  return this;
	};
	/**
	 * Sets this bounding box such that it minimally encloses a specified collection of points.
	 * @param {Vec3} points The points to contain.
	 * @returns {BoundingBox} This bounding box set to contain the specified points.
	 * @throws {ArgumentError} If the specified list of points is null, undefined or empty.
	 */


	BoundingBox.prototype.setToVec3Points = function (points) {
	  if (!points || points.length === 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BoundingBox", "setToVec3Points", "missingArray"));
	  }

	  var pointList = new Float32Array(points.length * 3);

	  for (var i = 0; i < points.length; i++) {
	    var point = points[i];

	    for (var j = 0; j < 3; j++) {
	      pointList[i * 3 + j] = point[j];
	    }
	  }

	  return this.setToPoints(pointList);
	};
	/**
	 * Sets this bounding box such that it contains a specified sector on a specified globe with min and max elevation.
	 * <p>
	 * To create a bounding box that contains the sector at mean sea level, specify zero for the minimum and maximum
	 * elevations.
	 * To create a bounding box that contains the terrain surface in this sector, specify the actual minimum and maximum
	 * elevation values associated with the sector, multiplied by the model's vertical exaggeration.
	 * @param {Sector} sector The sector for which to create the bounding box.
	 * @param {Globe} globe The globe associated with the sector.
	 * @param {Number} minElevation The minimum elevation within the sector.
	 * @param {Number} maxElevation The maximum elevation within the sector.
	 * @returns {BoundingBox} This bounding box set to contain the specified sector.
	 * @throws {ArgumentError} If either the specified sector or globe is null or undefined.
	 */


	BoundingBox.prototype.setToSector = function (sector, globe, minElevation, maxElevation) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BoundingBox", "setToSector", "missingSector"));
	  }

	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BoundingBox", "setToSector", "missingGlobe"));
	  } // Compute the cartesian points for a 3x3 geographic grid. This grid captures enough detail to bound the
	  // sector. Use minimum elevation at the corners and max elevation everywhere else.


	  var elevations = this.scratchElevations,
	      points = this.scratchPoints;
	  WWUtil.fillArray(elevations, maxElevation);
	  elevations[0] = elevations[2] = elevations[6] = elevations[8] = minElevation;
	  globe.computePointsForGrid(sector, 3, 3, elevations, Vec3$1.ZERO, points); // Compute the local coordinate axes. Since we know this box is bounding a geographic sector, we use the
	  // local coordinate axes at its centroid as the box axes. Using these axes results in a box that has +-10%
	  // the volume of a box with axes derived from a principal component analysis, but is faster to compute.

	  var index = 12; // index to the center point's X coordinate

	  this.tmp1.set(points[index], points[index + 1], points[index + 2]);
	  WWMath.localCoordinateAxesAtPoint(this.tmp1, globe, this.r, this.s, this.t); // Find the extremes along each axis.

	  var rExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY],
	      sExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY],
	      tExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];

	  for (var i = 0, len = points.length; i < len; i += 3) {
	    this.tmp1.set(points[i], points[i + 1], points[i + 2]);
	    this.adjustExtremes(this.r, rExtremes, this.s, sExtremes, this.t, tExtremes, this.tmp1);
	  } // If the sector encompasses more than one hemisphere, the 3x3 grid does not capture enough detail to bound
	  // the sector. The antipodal points along the parallel through the sector's centroid represent its extremes
	  // in longitude. Incorporate those antipodal points into the extremes along each axis.


	  if (sector.deltaLongitude() > 180) {
	    globe.computePointFromPosition(sector.centroidLatitude(), sector.centroidLongitude() + 90, maxElevation, this.tmp1);
	    globe.computePointFromPosition(sector.centroidLatitude(), sector.centroidLongitude() - 90, maxElevation, this.tmp2);
	    this.adjustExtremes(this.r, rExtremes, this.s, sExtremes, this.t, tExtremes, this.tmp1);
	    this.adjustExtremes(this.r, rExtremes, this.s, sExtremes, this.t, tExtremes, this.tmp2);
	  } // Sort the axes from most prominent to least prominent. The frustum intersection methods in WWBoundingBox assume
	  // that the axes are defined in this way.


	  if (rExtremes[1] - rExtremes[0] < sExtremes[1] - sExtremes[0]) {
	    this.swapAxes(this.r, rExtremes, this.s, sExtremes);
	  }

	  if (sExtremes[1] - sExtremes[0] < tExtremes[1] - tExtremes[0]) {
	    this.swapAxes(this.s, sExtremes, this.t, tExtremes);
	  }

	  if (rExtremes[1] - rExtremes[0] < sExtremes[1] - sExtremes[0]) {
	    this.swapAxes(this.r, rExtremes, this.s, sExtremes);
	  } // Compute the box properties from its unit axes and the extremes along each axis.


	  var rLen = rExtremes[1] - rExtremes[0],
	      sLen = sExtremes[1] - sExtremes[0],
	      tLen = tExtremes[1] - tExtremes[0],
	      rSum = rExtremes[1] + rExtremes[0],
	      sSum = sExtremes[1] + sExtremes[0],
	      tSum = tExtremes[1] + tExtremes[0],
	      cx = 0.5 * (this.r[0] * rSum + this.s[0] * sSum + this.t[0] * tSum),
	      cy = 0.5 * (this.r[1] * rSum + this.s[1] * sSum + this.t[1] * tSum),
	      cz = 0.5 * (this.r[2] * rSum + this.s[2] * sSum + this.t[2] * tSum),
	      rx_2 = 0.5 * this.r[0] * rLen,
	      ry_2 = 0.5 * this.r[1] * rLen,
	      rz_2 = 0.5 * this.r[2] * rLen;
	  this.center.set(cx, cy, cz);
	  this.topCenter.set(cx + rx_2, cy + ry_2, cz + rz_2);
	  this.bottomCenter.set(cx - rx_2, cy - ry_2, cz - rz_2);
	  this.r.multiply(rLen);
	  this.s.multiply(sLen);
	  this.t.multiply(tLen);
	  this.radius = 0.5 * Math.sqrt(rLen * rLen + sLen * sLen + tLen * tLen);
	  return this;
	};
	/**
	 * Translates this bounding box by a specified translation vector.
	 * @param {Vec3} translation The translation vector.
	 * @returns {BoundingBox} This bounding box translated by the specified translation vector.
	 * @throws {ArgumentError} If the specified translation vector is null or undefined.
	 */


	BoundingBox.prototype.translate = function (translation) {
	  if (!translation) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BoundingBox", "translate", "missingVector"));
	  }

	  this.bottomCenter.add(translation);
	  this.topCenter.add(translation);
	  this.center.add(translation);
	  return this;
	};
	/**
	 * Computes the approximate distance between this bounding box and a specified point.
	 * <p>
	 * This calculation treats the bounding box as a sphere with the same radius as the box.
	 * @param {Vec3} point The point to compute the distance to.
	 * @returns {Number} The distance from the edge of this bounding box to the specified point.
	 * @throws {ArgumentError} If the specified point is null or undefined.
	 */


	BoundingBox.prototype.distanceTo = function (point) {
	  if (!point) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BoundingBox", "distanceTo", "missingPoint"));
	  }

	  var d = this.center.distanceTo(point) - this.radius;
	  return d >= 0 ? d : -d;
	};
	/**
	 * Computes the effective radius of this bounding box relative to a specified plane.
	 * @param {Plane} plane The plane of interest.
	 * @returns {Number} The effective radius of this bounding box to the specified plane.
	 * @throws {ArgumentError} If the specified plane is null or undefined.
	 */


	BoundingBox.prototype.effectiveRadius = function (plane) {
	  if (!plane) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BoundingBox", "effectiveRadius", "missingPlane"));
	  }

	  var n = plane.normal;
	  return 0.5 * (WWMath.fabs(this.r.dot(n)) + WWMath.fabs(this.s.dot(n)) + WWMath.fabs(this.t.dot(n)));
	};
	/**
	 * Indicates whether this bounding box intersects a specified frustum.
	 * @param {Frustum} frustum The frustum of interest.
	 * @returns {boolean} true if the specified frustum intersects this bounding box, otherwise false.
	 * @throws {ArgumentError} If the specified frustum is null or undefined.
	 */


	BoundingBox.prototype.intersectsFrustum = function (frustum) {
	  if (!frustum) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BoundingBox", "intersectsFrustum", "missingFrustum"));
	  }

	  this.tmp1.copy(this.bottomCenter);
	  this.tmp2.copy(this.topCenter);

	  if (this.intersectionPoint(frustum.near) < 0) {
	    return false;
	  }

	  if (this.intersectionPoint(frustum.far) < 0) {
	    return false;
	  }

	  if (this.intersectionPoint(frustum.left) < 0) {
	    return false;
	  }

	  if (this.intersectionPoint(frustum.right) < 0) {
	    return false;
	  }

	  if (this.intersectionPoint(frustum.top) < 0) {
	    return false;
	  }

	  if (this.intersectionPoint(frustum.bottom) < 0) {
	    return false;
	  }

	  return true;
	}; // Internal. Intentionally not documented.


	BoundingBox.prototype.intersectionPoint = function (plane) {
	  var n = plane.normal,
	      effectiveRadius = 0.5 * (Math.abs(this.s.dot(n)) + Math.abs(this.t.dot(n)));
	  return this.intersectsAt(plane, effectiveRadius, this.tmp1, this.tmp2);
	}; // Internal. Intentionally not documented.


	BoundingBox.prototype.intersectsAt = function (plane, effRadius, endPoint1, endPoint2) {
	  // Test the distance from the first end-point.
	  var dq1 = plane.dot(endPoint1);
	  var bq1 = dq1 <= -effRadius; // Test the distance from the second end-point.

	  var dq2 = plane.dot(endPoint2);
	  var bq2 = dq2 <= -effRadius;

	  if (bq1 && bq2) {
	    // endpoints more distant from plane than effective radius; box is on neg. side of plane
	    return -1;
	  }

	  if (bq1 == bq2) {
	    // endpoints less distant from plane than effective radius; can't draw any conclusions
	    return 0;
	  } // Compute and return the endpoints of the box on the positive side of the plane


	  this.tmp3.copy(endPoint1);
	  this.tmp3.subtract(endPoint2);
	  var t = (effRadius + dq1) / plane.normal.dot(this.tmp3);
	  this.tmp3.copy(endPoint2);
	  this.tmp3.subtract(endPoint1);
	  this.tmp3.multiply(t);
	  this.tmp3.add(endPoint1); // Truncate the line to only that in the positive halfspace, e.g., inside the frustum.

	  if (bq1) {
	    endPoint1.copy(this.tmp3);
	  } else {
	    endPoint2.copy(this.tmp3);
	  }

	  return t;
	}; // Internal. Intentionally not documented.


	BoundingBox.prototype.adjustExtremes = function (r, rExtremes, s, sExtremes, t, tExtremes, p) {
	  var pdr = p.dot(r);

	  if (rExtremes[0] > pdr) {
	    rExtremes[0] = pdr;
	  }

	  if (rExtremes[1] < pdr) {
	    rExtremes[1] = pdr;
	  }

	  var pds = p.dot(s);

	  if (sExtremes[0] > pds) {
	    sExtremes[0] = pds;
	  }

	  if (sExtremes[1] < pds) {
	    sExtremes[1] = pds;
	  }

	  var pdt = p.dot(t);

	  if (tExtremes[0] > pdt) {
	    tExtremes[0] = pdt;
	  }

	  if (tExtremes[1] < pdt) {
	    tExtremes[1] = pdt;
	  }
	}; // Internal. Intentionally not documented.


	BoundingBox.prototype.swapAxes = function (a, aExtremes, b, bExtremes) {
	  a.swap(b);
	  var tmp = aExtremes[0];
	  aExtremes[0] = bExtremes[0];
	  bExtremes[0] = tmp;
	  tmp = aExtremes[1];
	  aExtremes[1] = bExtremes[1];
	  bExtremes[1] = tmp;
	};
	/**
	 * Renders this bounding box in a semi-transparent color with a highlighted outline. This function is intended
	 * for diagnostic use only.
	 * @param dc {DrawContext} dc The current draw context.
	 */


	BoundingBox.prototype.render = function (dc) {
	  var gl = dc.currentGlContext,
	      matrix = BoundingBox.scratchMatrix,
	      program = dc.findAndBindProgram(BasicProgram);

	  try {
	    // Setup to transform unit cube coordinates to this bounding box's local coordinates, as viewed by the
	    // current navigator state.
	    matrix.copy(dc.modelviewProjection);
	    matrix.multiply(this.r[0], this.s[0], this.t[0], this.center[0], this.r[1], this.s[1], this.t[1], this.center[1], this.r[2], this.s[2], this.t[2], this.center[2], 0, 0, 0, 1);
	    matrix.multiplyByTranslation(-0.5, -0.5, -0.5);
	    program.loadModelviewProjection(gl, matrix); // Setup to draw the geometry when the eye point is inside or outside the box.

	    gl.disable(gl.CULL_FACE); // Bind the shared unit cube vertex buffer and element buffer.

	    gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitCubeBuffer());
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dc.unitCubeElements());
	    gl.enableVertexAttribArray(program.vertexPointLocation);
	    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0); // Draw bounding box fragments that are below the terrain.

	    program.loadColorComponents(gl, 0, 1, 0, 0.6);
	    gl.drawElements(gl.LINES, 24, gl.UNSIGNED_SHORT, 72);
	    program.loadColorComponents(gl, 1, 1, 1, 0.3);
	    gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
	  } finally {
	    // Restore WorldWind's default WebGL state.
	    gl.enable(gl.CULL_FACE);
	    gl.bindBuffer(gl.ARRAY_BUFFER, null);
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	  }
	};

	/**
	 * @exports Tile
	 */
	/**
	 * Constructs a tile for a specified sector, level, row and column.
	 * @alias Tile
	 * @constructor
	 * @classdesc Represents a tile of terrain or imagery.
	 * Provides a base class for texture tiles used by tiled image layers and elevation tiles used by elevation models.
	 * Applications typically do not interact with this class.
	 * @param {Sector} sector The sector represented by this tile.
	 * @param {Level} level This tile's level in a tile pyramid.
	 * @param {Number} row This tile's row in the specified level in a tile pyramid.
	 * @param {Number} column This tile's column in the specified level in a tile pyramid.
	 * @throws {ArgumentError} If the specified sector or level is null or undefined or the row or column arguments
	 * are less than zero.
	 */

	function Tile(sector, level, row, column) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "constructor", "missingSector"));
	  }

	  if (!level) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "constructor", "The specified level is null or undefined."));
	  }

	  if (row < 0 || column < 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "constructor", "The specified row or column is less than zero."));
	  }
	  /**
	   * The sector represented by this tile.
	   * @type {Sector}
	   * @readonly
	   */


	  this.sector = sector;
	  /**
	   * The level at which this tile lies in a tile pyramid.
	   * @type {Number}
	   * @readonly
	   */

	  this.level = level;
	  /**
	   * The row in this tile's level in which this tile lies in a tile pyramid.
	   * @type {Number}
	   * @readonly
	   */

	  this.row = row;
	  /**
	   * The column in this tile's level in which this tile lies in a tile pyramid.
	   * @type {Number}
	   * @readonly
	   */

	  this.column = column;
	  /**
	   * The width in pixels or cells of this tile's associated resource.
	   * @type {Number}
	   */

	  this.tileWidth = level.tileWidth;
	  /**
	   * The height in pixels or cells of this tile's associated resource.
	   * @type {Number}
	   */

	  this.tileHeight = level.tileHeight;
	  /**
	   * The size in radians of pixels or cells of this tile's associated resource.
	   * @type {Number}
	   */

	  this.texelSize = level.texelSize;
	  /**
	   * A key that uniquely identifies this tile within a level set.
	   * @type {String}
	   * @readonly
	   */

	  this.tileKey = Tile.computeTileKey(level.levelNumber, row, column);
	  /**
	   * The Cartesian bounding box of this tile.
	   * @type {BoundingBox}
	   */

	  this.extent = null;
	  /**
	   * The tile's local origin in model coordinates. Any model coordinate points associates with the tile
	   * should be relative to this point.
	   * @type {Vec3}
	   */

	  this.referencePoint = null;
	  /**
	   * This tile's opacity.
	   * @type {Number}
	   * @default 1
	   */

	  this.opacity = 1; // Internal use only. Intentionally not documented.

	  this.samplePoints = null; // Internal use only. Intentionally not documented.

	  this.sampleElevations = null; // Internal use only. Intentionally not documented.

	  this.updateTimestamp = null; // Internal use only. Intentionally not documented.

	  this.updateVerticalExaggeration = null; // Internal use only. Intentionally not documented.

	  this.updateGlobeStateKey = null;
	}
	/**
	 * Indicates whether this tile is equivalent to a specified tile.
	 * @param {Tile} that The tile to check equivalence with.
	 * @returns {boolean} true if this tile is equivalent to the specified one, false if
	 * they are not equivalent or the specified tile is null or undefined.
	 */


	Tile.prototype.isEqual = function (that) {
	  if (!that) return false;
	  if (!that.tileKey) return false;
	  return this.tileKey == that.tileKey;
	};
	/**
	 * Returns the size of this tile in bytes.
	 * @returns {Number} The size of this tile in bytes.
	 */


	Tile.prototype.size = function () {
	  return 4 // child pointer
	  + (4 + 32) // sector
	  + 4 //level pointer (the level is common to the layer or tessellator so is not included here)
	  + 8 // row and column
	  + 8 // texel size
	  + (4 + 32) // reference point
	  + (4 + 676) // bounding box
	  + 8 // min and max height
	  + (4 + 32) // nearest point
	  + 8; // extent timestamp and vertical exaggeration
	};
	/**
	 * Computes an approximate distance from this tile to a specified vector.
	 * @param {Vec3} vector The vector to compute the distance to.
	 * @returns {number} The distance between this tile and the vector.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	Tile.prototype.distanceTo = function (vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "distanceTo", "missingVector"));
	  }

	  var px = vector[0],
	      py = vector[1],
	      pz = vector[2],
	      dx,
	      dy,
	      dz,
	      points = this.samplePoints,
	      distance = Number.POSITIVE_INFINITY;

	  for (var i = 0, len = points.length; i < len; i += 3) {
	    dx = px - points[i];
	    dy = py - points[i + 1];
	    dz = pz - points[i + 2];
	    distance = Math.min(distance, dx * dx + dy * dy + dz * dz); // minimum squared distance
	  }

	  return Math.sqrt(distance);
	};
	/**
	 * Returns the four children formed by subdividing this tile.
	 * @param {Level} level The level of the children.
	 * @param {TileFactory} tileFactory The tile factory to use to create the children.
	 * @returns {Tile[]} An array containing the four child tiles.
	 * @throws {ArgumentError} If the specified tile factory or level is null or undefined.
	 */


	Tile.prototype.subdivide = function (level, tileFactory) {
	  if (!level) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "subdivide", "The specified level is null or undefined."));
	  }

	  if (!tileFactory) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "subdivide", "The specified tile factory is null or undefined."));
	  }

	  var latMin = this.sector.minLatitude,
	      latMax = this.sector.maxLatitude,
	      latMid = this.sector.centroidLatitude(),
	      lonMin = this.sector.minLongitude,
	      lonMax = this.sector.maxLongitude,
	      lonMid = this.sector.centroidLongitude(),
	      subRow,
	      subCol,
	      childSector,
	      children = [];
	  subRow = 2 * this.row;
	  subCol = 2 * this.column;
	  childSector = new Sector(latMin, latMid, lonMin, lonMid);
	  children.push(tileFactory.createTile(childSector, level, subRow, subCol));
	  subRow = 2 * this.row;
	  subCol = 2 * this.column + 1;
	  childSector = new Sector(latMin, latMid, lonMid, lonMax);
	  children.push(tileFactory.createTile(childSector, level, subRow, subCol));
	  subRow = 2 * this.row + 1;
	  subCol = 2 * this.column;
	  childSector = new Sector(latMid, latMax, lonMin, lonMid);
	  children.push(tileFactory.createTile(childSector, level, subRow, subCol));
	  subRow = 2 * this.row + 1;
	  subCol = 2 * this.column + 1;
	  childSector = new Sector(latMid, latMax, lonMid, lonMax);
	  children.push(tileFactory.createTile(childSector, level, subRow, subCol));
	  return children;
	};
	/**
	 * Returns the four children formed by subdividing this tile, drawing those children from a specified cache
	 * if they exist there.
	 * @param {Level} level The level of the children.
	 * @param {TileFactory} tileFactory The tile factory to use to create the children.
	 * @param {MemoryCache} cache A memory cache that may contain pre-existing child tiles. If non-null, the
	 * cache is checked for a child collection prior to creating that tile. If one exists
	 * in the cache it is returned rather than creating a new collection of children. If a new collection is
	 * created, it is added to the cache.
	 * @returns {Tile[]} An array containing the four tiles.
	 * @throws {ArgumentError} If the specified tile factory or level is null or undefined.
	 */


	Tile.prototype.subdivideToCache = function (level, tileFactory, cache) {
	  if (!level) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "subdivideToCache", "The specified level is null or undefined."));
	  }

	  if (!tileFactory) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "subdivideToCache", "The specified tile factory is null or undefined."));
	  }

	  var childList = cache ? cache.entryForKey(this.tileKey) : null;

	  if (!childList) {
	    childList = this.subdivide(level, tileFactory);

	    if (childList && cache) {
	      cache.putEntry(this.tileKey, childList, 4 * childList[0].size());
	    }
	  }

	  return childList;
	};
	/**
	 * Indicates whether this tile should be subdivided based on the current navigation state and a specified
	 * detail factor.
	 * @param {DrawContext} dc The current draw context.
	 * @param {Number} detailFactor The detail factor to consider.
	 * @returns {boolean} true If the tile should be subdivided, otherwise false.
	 */


	Tile.prototype.mustSubdivide = function (dc, detailFactor) {
	  // Split when the cell height (length of a texel) becomes greater than the specified fraction of the eye
	  // distance. The fraction is specified as a power of 10. For example, a detail factor of 3 means split when
	  // the cell height becomes more than one thousandth of the eye distance. Another way to say it is, use the
	  // current tile if the cell height is less than the specified fraction of the eye distance.
	  //
	  // Note: It's tempting to instead compare a screen pixel size to the texel size, but that calculation is
	  // window-size dependent and results in selecting an excessive number of tiles when the window is large.
	  var cellSize = dc.globe.equatorialRadius * this.texelSize,
	      distance = this.distanceTo(dc.eyePoint),
	      pixelSize = dc.pixelSizeAtDistance(distance);
	  return cellSize > Math.max(detailFactor * pixelSize, 0.5);
	};
	/**
	 * Updates this tile's frame-dependent properties as necessary, according to the specified draw context.
	 * <p>
	 * The tile's frame-dependent properties, include the extent (bounding volume). These properties are dependent
	 * on the tile's sector and the elevation values currently in memory, and change when those dependencies change.
	 * Therefore <code>update</code> must be called once per frame before the extent and any other frame-dependent
	 * properties are used. <code>update</code> intelligently determines when it is necessary to recompute these
	 * properties, and does nothing if the state of all dependencies has not changed since the last call.
	 * @param {DrawContext} dc The current draw context.
	 */


	Tile.prototype.update = function (dc) {
	  var elevationTimestamp = dc.globe.elevationTimestamp(),
	      verticalExaggeration = dc.verticalExaggeration,
	      globeStateKey = dc.globeStateKey;

	  if (this.updateTimestamp != elevationTimestamp || this.updateVerticalExaggeration != verticalExaggeration || this.updateGlobeStateKey != globeStateKey) {
	    this.doUpdate(dc);
	    dc.frameStatistics.incrementTileUpdateCount(1); // Set the geometry extent to the globe's elevation timestamp on which the geometry is based. This
	    // ensures that the geometry timestamp can be reliably compared to the elevation timestamp in subsequent
	    // frames.

	    this.updateTimestamp = elevationTimestamp;
	    this.updateVerticalExaggeration = verticalExaggeration;
	    this.updateGlobeStateKey = globeStateKey;
	  }
	};
	/**
	 * Updates this tile's frame-dependent properties according to the specified draw context.
	 * @param {DrawContext} dc The current draw context.
	 * @protected
	 */


	Tile.prototype.doUpdate = function (dc) {
	  // Compute the minimum and maximum world coordinate height for this tile's sector by multiplying the minimum
	  // and maximum elevations by the scene's vertical exaggeration. This ensures that the elevations to used
	  // build the terrain are contained by this tile's extent. Use zero if the globe as no elevations in this
	  // tile's sector.
	  var globe = dc.globe,
	      verticalExaggeration = dc.verticalExaggeration,
	      extremes = globe.minAndMaxElevationsForSector(this.sector),
	      minHeight = extremes[0] * verticalExaggeration,
	      maxHeight = extremes[1] * verticalExaggeration;

	  if (minHeight === maxHeight) {
	    minHeight = maxHeight + 10; // TODO: Determine if this is necessary.
	  } // Compute a bounding box for this tile that contains the terrain surface in the tile's coverage area.


	  if (!this.extent) {
	    this.extent = new BoundingBox();
	  }

	  this.extent.setToSector(this.sector, globe, minHeight, maxHeight); // Compute the cartesian points for a 3x3 geographic grid. This grid captures sufficiently close sample
	  // points in order to estimate the distance from the viewer to this tile.

	  if (!this.samplePoints) {
	    this.sampleElevations = new Float64Array(9);
	    this.samplePoints = new Float64Array(3 * this.sampleElevations.length);
	  }

	  WWUtil.fillArray(this.sampleElevations, 0.5 * (minHeight + maxHeight));
	  globe.computePointsForGrid(this.sector, 3, 3, this.sampleElevations, Vec3$1.ZERO, this.samplePoints); // Compute the reference point used as a local coordinate origin for the tile.

	  if (!this.referencePoint) {
	    this.referencePoint = new Vec3$1(0, 0, 0);
	  }

	  globe.computePointFromPosition(this.sector.centroidLatitude(), this.sector.centroidLongitude(), 0, this.referencePoint);
	};
	/**
	 * Computes a key that uniquely identifies a tile within its level set.
	 *
	 * @param {Number} levelNumber The tile's level number in a tile pyramid.
	 * @param {Number} row The tile's row in the specified level in a tile pyramid.
	 * @param {Number} column The tile's column in the specified level in a tile pyramid.
	 * @returns {String} A string key uniquely identifying a tile with the specified level, row, and column.
	 */


	Tile.computeTileKey = function (levelNumber, row, column) {
	  return levelNumber + "." + row + "." + column;
	};
	/**
	 * Computes a row number for a tile within a level given the tile's latitude.
	 * @param {Number} delta The level's latitudinal tile delta in degrees.
	 * @param {Number} latitude The tile's minimum latitude.
	 * @returns {Number} The computed row number.
	 */


	Tile.computeRow = function (delta, latitude) {
	  var row = Math.floor((latitude + 90) / delta); // If latitude is at the end of the grid, subtract 1 from the computed row to return the last row.

	  if (latitude == 90) {
	    row -= 1;
	  }

	  return row;
	};
	/**
	 * Computes a column number for a tile within a level given the tile's longitude.
	 * @param {Number} delta The level's longitudinal tile delta in degrees.
	 * @param {Number} longitude The tile's minimum longitude.
	 * @returns {Number} The computed column number.
	 */


	Tile.computeColumn = function (delta, longitude) {
	  var col = Math.floor((longitude + 180) / delta); // If longitude is at the end of the grid, subtract 1 from the computed column to return the last column.

	  if (longitude == 180) {
	    col -= 1;
	  }

	  return col;
	};
	/**
	 * Computes the last row number for a tile within a level given the tile's maximum latitude.
	 * @param {Number} delta The level's latitudinal tile delta in degrees.
	 * @param {Number} maxLatitude The tile's maximum latitude in degrees.
	 * @returns {Number} The computed row number.
	 */


	Tile.computeLastRow = function (delta, maxLatitude) {
	  var row = Math.ceil((maxLatitude + 90) / delta - 1); // If max latitude is in the first row, set the max row to 0.

	  if (maxLatitude + 90 < delta) {
	    row = 0;
	  }

	  return row;
	};
	/**
	 * Computes the last column number for a tile within a level given the tile's maximum longitude.
	 * @param {Number} delta The level's longitudinal tile delta in degrees.
	 * @param {Number} maxLongitude The tile's maximum longitude in degrees.
	 * @returns {Number} The computed column number.
	 */


	Tile.computeLastColumn = function (delta, maxLongitude) {
	  var col = Math.ceil((maxLongitude + 180) / delta - 1); // If max longitude is in the first column, set the max column to 0.

	  if (maxLongitude + 180 < delta) {
	    col = 0;
	  }

	  return col;
	};
	/**
	 * Computes a sector spanned by a tile with the specified level number, row and column.
	 * @param {Level} level The tile's level number.
	 * @param {Number} row The tile's row number.
	 * @param {Number} column The tile's column number.
	 * @returns {Sector} The sector spanned by the tile.
	 * @throws {ArgumentError} If the specified level is null or undefined or the row or column are less than zero.
	 */


	Tile.computeSector = function (level, row, column) {
	  if (!level) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "computeSector", "missingLevel"));
	  }

	  if (row < 0 || column < 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "computeSector", "The specified row or column is less than zero."));
	  }

	  var deltaLat = level.tileDelta.latitude,
	      deltaLon = level.tileDelta.longitude,
	      minLat = -90 + row * deltaLat,
	      minLon = -180 + column * deltaLon,
	      maxLat = minLat + deltaLat,
	      maxLon = minLon + deltaLon;
	  return new Sector(minLat, maxLat, minLon, maxLon);
	};
	/**
	 * Creates all tiles for a specified level number.
	 * @param {Level} level The level to create the tiles for.
	 * @param {TileFactory} tileFactory The tile factory to use for creating tiles.
	 * @param {Tile[]} result An array in which to return the results.
	 * @throws {ArgumentError} If any argument is null or undefined.
	 */


	Tile.createTilesForLevel = function (level, tileFactory, result) {
	  if (!level) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "createTilesForLevel", "missingLevel"));
	  }

	  if (!tileFactory) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "createTilesForLevel", "The specified tile factory is null or undefined"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "createTilesForLevel", "missingResult"));
	  }

	  var deltaLat = level.tileDelta.latitude,
	      deltaLon = level.tileDelta.longitude,
	      sector = level.sector,
	      firstRow = Tile.computeRow(deltaLat, sector.minLatitude),
	      lastRow = Tile.computeRow(deltaLat, sector.maxLatitude),
	      firstCol = Tile.computeColumn(deltaLon, sector.minLongitude),
	      lastCol = Tile.computeColumn(deltaLon, sector.maxLongitude),
	      firstRowLat = -90 + firstRow * deltaLat,
	      firstRowLon = -180 + firstCol * deltaLon,
	      minLat = firstRowLat,
	      minLon,
	      maxLat,
	      maxLon;

	  for (var row = firstRow; row <= lastRow; row += 1) {
	    maxLat = minLat + deltaLat;
	    minLon = firstRowLon;

	    for (var col = firstCol; col <= lastCol; col += 1) {
	      maxLon = minLon + deltaLon;
	      var tileSector = new Sector(minLat, maxLat, minLon, maxLon),
	          tile = tileFactory.createTile(tileSector, level, row, col);
	      result.push(tile);
	      minLon = maxLon;
	    }

	    minLat = maxLat;
	  }
	};

	/**
	 * @exports TiledElevationCoverage
	 */
	/**
	 * Constructs a TiledElevationCoverage
	 * @alias TiledElevationCoverage
	 * @constructor
	 * @classdesc Represents the elevations for an area, often but not necessarily the whole globe.
	 * @param {{}} config Configuration properties for the coverage:
	 * <ul>
	 *     <li>coverageSector: {Sector} The sector this coverage spans.</li>
	 *     <li>resolution: {Number} The resolution of the coverage, in degrees. (To compute degrees from meters, divide the number of meters by the globe's radius to obtain radians and convert the result to degrees.)</li>
	 *     <li>retrievalImageFormat: {String} The mime type of the elevation data retrieved by this coverage.</li>
	 *     <li>minElevation (optional): {Number} The coverage's minimum elevation in meters.</li>
	 *     <li>maxElevation (optional): {Number} Te coverage's maximum elevation in meters.</li>
	 *     <li>urlBuilder (optional): {UrlBuilder} The factory to create URLs for elevation data requests.</li>
	 * <ul>
	 * @throws {ArgumentError} If any required configuration parameter is null or undefined.
	 */

	function TiledElevationCoverage(config) {
	  if (!config) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledElevationCoverage", "constructor", "missingConfig"));
	  }

	  if (!config.coverageSector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledElevationCoverage", "constructor", "missingSector"));
	  }

	  if (!config.resolution) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledElevationCoverage", "constructor", "missingResolution"));
	  }

	  if (!config.retrievalImageFormat) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledElevationCoverage", "constructor", "missingImageFormat"));
	  }

	  ElevationCoverage.call(this, config.resolution);
	  var firstLevelDelta = 45,
	      tileWidth = 256,
	      lastLevel = LevelSet.numLevelsForResolution(firstLevelDelta / tileWidth, config.resolution),
	      numLevels = Math.ceil(lastLevel); // match or exceed the specified resolution

	  /**
	   * The sector this coverage spans.
	   * @type {Sector}
	   * @readonly
	   */

	  this.coverageSector = config.coverageSector;
	  /**
	   * The mime type to use when retrieving elevations.
	   * @type {String}
	   * @readonly
	   */

	  this.retrievalImageFormat = config.retrievalImageFormat;
	  /**
	   * This coverage's minimum elevation in meters.
	   * @type {Number}
	   * @default 0
	   */

	  this.minElevation = config.minElevation || 0;
	  /**
	   * This coverage's maximum elevation in meters.
	   * @type {Number}
	   */

	  this.maxElevation = config.maxElevation || 0;
	  /**
	   * Indicates whether the data associated with this coverage is point data. A value of false
	   * indicates that the data is area data (pixel is area).
	   * @type {Boolean}
	   * @default true
	   */

	  this.pixelIsPoint = false;
	  /**
	   * The {@link LevelSet} dividing this coverage's geographic domain into a multi-resolution, hierarchical
	   * collection of tiles.
	   * @type {LevelSet}
	   * @readonly
	   */

	  this.levels = new LevelSet(this.coverageSector, new Location(firstLevelDelta, firstLevelDelta), numLevels, tileWidth, tileWidth);
	  /**
	   * Internal use only
	   * The list of assembled tiles.
	   * @type {Array}
	   * @ignore
	   */

	  this.currentTiles = [];
	  /**
	   * Internal use only
	   * A scratch sector for use in computations.
	   * @type {Sector}
	   * @ignore
	   */

	  this.currentSector = new Sector(0, 0, 0, 0);
	  /**
	   * Internal use only
	   * A cache of elevation tiles.
	   * @type {MemoryCache}
	   * @ignore
	   */

	  this.tileCache = new MemoryCache(1000000, 800000);
	  /**
	   * Internal use only
	   * A cache of elevations.
	   * @type {MemoryCache}
	   * @ignore
	   */

	  this.imageCache = new MemoryCache(10000000, 8000000);
	  /**
	   * Controls how many concurrent tile requests are allowed for this coverage.
	   * @type {Number}
	   * @default WorldWind.configuration.coverageRetrievalQueueSize
	   */

	  this.retrievalQueueSize = WorldWind.configuration.coverageRetrievalQueueSize;
	  /**
	   * Internal use only
	   * The list of elevation retrievals in progress.
	   * @type {Array}
	   * @ignore
	   */

	  this.currentRetrievals = [];
	  /**
	   * Internal use only
	   * The list of resources pending acquisition.
	   * @type {Array}
	   * @ignore
	   */

	  this.absentResourceList = new AbsentResourceList(3, 5e3);
	  /**
	   * Internal use only
	   * The factory to create URLs for data requests. This property is typically set in the constructor of child
	   * classes. See {@link WcsUrlBuilder} for a concrete example.
	   * @type {UrlBuilder}
	   * @ignore
	   */
	  // this.urlBuilder = new UrlBuilder() || null;

	  this.urlBuilder = config.urlBuilder || null;
	  this.urlBuilder.serviceAddress = 'http://localhost:2020/api/Map/Elev';
	}

	TiledElevationCoverage.prototype = Object.create(ElevationCoverage.prototype); // Documented in super class

	TiledElevationCoverage.prototype.minAndMaxElevationsForSector = function (sector, result) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledElevationCoverage", "minAndMaxElevationsForSector", "missingSector"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledElevationCoverage", "minAndMaxElevationsForSector", "missingResult"));
	  }

	  var level = this.levels.levelForTexelSize(sector.deltaLatitude() * Angle.DEGREES_TO_RADIANS / 64);
	  this.assembleTiles(level, sector, false);

	  if (this.currentTiles.length === 0) {
	    return false; // Sector is outside the coverage's coverage area. Don't modify the result.
	  }

	  var hasCompleteCoverage = true;

	  for (var i = 0, len = this.currentTiles.length; i < len; i++) {
	    var image = this.imageCache.entryForKey(this.currentTiles[i].tileKey);

	    if (image && image.hasData) {
	      var imageMin = image.minElevation;

	      if (result[0] > imageMin) {
	        result[0] = imageMin;
	      }

	      var imageMax = image.maxElevation;

	      if (result[1] < imageMax) {
	        result[1] = imageMax;
	      }
	    }

	    if (!image || !image.hasData || image.hasMissingData) {
	      hasCompleteCoverage = false;
	    }
	  }

	  return hasCompleteCoverage;
	}; // Documented in super class


	TiledElevationCoverage.prototype.elevationAtLocation = function (latitude, longitude) {
	  if (!this.coverageSector.containsLocation(latitude, longitude)) {
	    return null; // location is outside the coverage's coverage
	  }

	  return this.pointElevationForLocation(latitude, longitude);
	}; // Documented in super class


	TiledElevationCoverage.prototype.elevationsForGrid = function (sector, numLat, numLon, result) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledElevationCoverage", "elevationsForGrid", "missingSector"));
	  }

	  if (!numLat || !numLon || numLat < 1 || numLon < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledElevationCoverage", "elevationsForGrid", "The specified number of latitudinal or longitudinal positions is less than one."));
	  }

	  var gridResolution = sector.deltaLatitude() / (numLat - 1) * Angle.DEGREES_TO_RADIANS;
	  var level = this.levels.levelForTexelSize(gridResolution);

	  if (this.pixelIsPoint) {
	    return this.pointElevationsForGrid(sector, numLat, numLon, level, result);
	  } else {
	    return this.areaElevationsForGrid(sector, numLat, numLon, level, result);
	  }
	}; // Intentionally not documented.


	TiledElevationCoverage.prototype.pointElevationForLocation = function (latitude, longitude) {
	  var level = this.levels.lastLevel(),
	      deltaLat = level.tileDelta.latitude,
	      deltaLon = level.tileDelta.longitude,
	      r = Tile.computeRow(deltaLat, latitude),
	      c = Tile.computeColumn(deltaLon, longitude),
	      tileKey,
	      image = null;

	  for (var i = level.levelNumber; i >= 0; i--) {
	    tileKey = Tile.computeTileKey(i, r, c);
	    image = this.imageCache.entryForKey(tileKey);

	    if (image) {
	      var elevation = image.elevationAtLocation(latitude, longitude);
	      return isNaN(elevation) ? null : elevation;
	    }

	    r = Math.floor(r / 2);
	    c = Math.floor(c / 2);
	  }

	  return null; // did not find a tile with an image
	}; // Intentionally not documented.


	TiledElevationCoverage.prototype.pointElevationsForGrid = function (sector, numLat, numLon, level, result) {
	  this.assembleTiles(level, sector, true);

	  if (this.currentTiles.length === 0) {
	    return false; // Sector is outside the coverage's coverage area. Do not modify the results array.
	  } // Sort from lowest resolution to highest so that higher resolutions override lower resolutions in the
	  // loop below.


	  this.currentTiles.sort(function (tileA, tileB) {
	    return tileA.level.levelNumber - tileB.level.levelNumber;
	  });

	  for (var i = 0, len = this.currentTiles.length; i < len; i++) {
	    var image = this.imageCache.entryForKey(this.currentTiles[i].tileKey);

	    if (image) {
	      image.elevationsForGrid(sector, numLat, numLon, result);
	    }
	  }

	  return !result.includes(NaN); // true if the result array is fully populated.
	}; // Internal. Returns elevations for a grid assuming pixel-is-area.


	TiledElevationCoverage.prototype.areaElevationsForGrid = function (sector, numLat, numLon, level, result) {
	  var minLat = sector.minLatitude,
	      maxLat = sector.maxLatitude,
	      minLon = sector.minLongitude,
	      maxLon = sector.maxLongitude,
	      deltaLat = sector.deltaLatitude() / (numLat > 1 ? numLat - 1 : 1),
	      deltaLon = sector.deltaLongitude() / (numLon > 1 ? numLon - 1 : 1),
	      lat,
	      lon,
	      s,
	      t,
	      latIndex,
	      lonIndex,
	      resultIndex = 0;

	  for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex += 1, lat += deltaLat) {
	    if (latIndex === numLat - 1) {
	      lat = maxLat; // explicitly set the last lat to the max latitude ensure alignment
	    }

	    for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex += 1, lon += deltaLon) {
	      if (lonIndex === numLon - 1) {
	        lon = maxLon; // explicitly set the last lon to the max longitude ensure alignment
	      }

	      if (isNaN(result[resultIndex])) {
	        if (this.coverageSector.containsLocation(lat, lon)) {
	          // ignore locations outside of the model
	          s = (lon + 180) / 360;
	          t = (lat + 90) / 180;
	          this.areaElevationForCoord(s, t, level.levelNumber, result, resultIndex);
	        }
	      }

	      resultIndex++;
	    }
	  }

	  return !result.includes(NaN); // true if the result array is fully populated.
	}; // Internal. Returns an elevation for a location assuming pixel-is-area.


	TiledElevationCoverage.prototype.areaElevationForCoord = function (s, t, levelNumber, result, resultIndex) {
	  var level,
	      levelWidth,
	      levelHeight,
	      tMin,
	      tMax,
	      vMin,
	      vMax,
	      u,
	      v,
	      x0,
	      x1,
	      y0,
	      y1,
	      xf,
	      yf,
	      retrieveTiles,
	      pixels = new Float64Array(4);

	  for (var i = levelNumber; i >= 0; i--) {
	    level = this.levels.level(i);
	    levelWidth = Math.round(level.tileWidth * 360 / level.tileDelta.longitude);
	    levelHeight = Math.round(level.tileHeight * 180 / level.tileDelta.latitude);
	    tMin = 1 / (2 * levelHeight);
	    tMax = 1 - tMin;
	    vMin = 0;
	    vMax = levelHeight - 1;
	    u = levelWidth * WWMath.fract(s); // wrap the horizontal coordinate

	    v = levelHeight * WWMath.clamp(t, tMin, tMax); // clamp the vertical coordinate to the level edge

	    x0 = WWMath.mod(Math.floor(u - 0.5), levelWidth);
	    x1 = WWMath.mod(x0 + 1, levelWidth);
	    y0 = WWMath.clamp(Math.floor(v - 0.5), vMin, vMax);
	    y1 = WWMath.clamp(y0 + 1, vMin, vMax);
	    xf = WWMath.fract(u - 0.5);
	    yf = WWMath.fract(v - 0.5);
	    retrieveTiles = i == levelNumber || i == 0;

	    if (this.lookupPixels(x0, x1, y0, y1, level, retrieveTiles, pixels)) {
	      if (ElevationImage.isNoData(pixels[0], pixels[1], pixels[2], pixels[3])) {
	        return false;
	      } else {
	        result[resultIndex] = (1 - xf) * (1 - yf) * pixels[0] + xf * (1 - yf) * pixels[1] + (1 - xf) * yf * pixels[2] + xf * yf * pixels[3];
	        return true;
	      }
	    }
	  }

	  return false;
	}; // Internal. Bilinearly interpolates tile-image elevations.


	TiledElevationCoverage.prototype.lookupPixels = function (x0, x1, y0, y1, level, retrieveTiles, result) {
	  var levelNumber = level.levelNumber,
	      tileWidth = level.tileWidth,
	      tileHeight = level.tileHeight,
	      row0 = Math.floor(y0 / tileHeight),
	      row1 = Math.floor(y1 / tileHeight),
	      col0 = Math.floor(x0 / tileWidth),
	      col1 = Math.floor(x1 / tileWidth),
	      r0c0,
	      r0c1,
	      r1c0,
	      r1c1;

	  if (row0 == row1 && row0 == this.cachedRow && col0 == col1 && col0 == this.cachedCol) {
	    r0c0 = r0c1 = r1c0 = r1c1 = this.cachedImage; // use results from previous lookup
	  } else if (row0 == row1 && col0 == col1) {
	    r0c0 = this.lookupImage(levelNumber, row0, col0, retrieveTiles); // only need to lookup one image

	    r0c1 = r1c0 = r1c1 = r0c0; // re-use the single image

	    this.cachedRow = row0;
	    this.cachedCol = col0;
	    this.cachedImage = r0c0; // note the results for subsequent lookups
	  } else {
	    r0c0 = this.lookupImage(levelNumber, row0, col0, retrieveTiles);
	    r0c1 = this.lookupImage(levelNumber, row0, col1, retrieveTiles);
	    r1c0 = this.lookupImage(levelNumber, row1, col0, retrieveTiles);
	    r1c1 = this.lookupImage(levelNumber, row1, col1, retrieveTiles);
	  }

	  if (r0c0 && r0c1 && r1c0 && r1c1) {
	    result[0] = r0c0.pixel(x0 % tileWidth, y0 % tileHeight);
	    result[1] = r0c1.pixel(x1 % tileWidth, y0 % tileHeight);
	    result[2] = r1c0.pixel(x0 % tileWidth, y1 % tileHeight);
	    result[3] = r1c1.pixel(x1 % tileWidth, y1 % tileHeight);
	    return true;
	  }

	  return false;
	}; // Internal. Intentionally not documented.


	TiledElevationCoverage.prototype.lookupImage = function (levelNumber, row, column, retrieveTiles) {
	  var tileKey = Tile.computeTileKey(levelNumber, row, column),
	      image = this.imageCache.entryForKey(tileKey);

	  if (image == null && retrieveTiles) {
	    var tile = this.tileForLevel(levelNumber, row, column);
	    this.retrieveTileImage(tile);
	  }

	  return image;
	}; // Intentionally not documented.


	TiledElevationCoverage.prototype.assembleTiles = function (level, sector, retrieveTiles) {
	  this.currentTiles = []; // Intersect the requested sector with the coverage's coverage area. This avoids attempting to assemble tiles
	  // that are outside the coverage area.

	  this.currentSector.copy(sector);
	  this.currentSector.intersection(this.coverageSector);
	  if (this.currentSector.isEmpty()) return; // sector is outside the coverage's coverage area

	  var deltaLat = level.tileDelta.latitude,
	      deltaLon = level.tileDelta.longitude,
	      firstRow = Tile.computeRow(deltaLat, this.currentSector.minLatitude),
	      lastRow = Tile.computeLastRow(deltaLat, this.currentSector.maxLatitude),
	      firstCol = Tile.computeColumn(deltaLon, this.currentSector.minLongitude),
	      lastCol = Tile.computeLastColumn(deltaLon, this.currentSector.maxLongitude);

	  for (var row = firstRow; row <= lastRow; row++) {
	    for (var col = firstCol; col <= lastCol; col++) {
	      this.addTileOrAncestor(level, row, col, retrieveTiles);
	    }
	  }
	}; // Intentionally not documented.


	TiledElevationCoverage.prototype.addTileOrAncestor = function (level, row, column, retrieveTiles) {
	  var tile = this.tileForLevel(level.levelNumber, row, column);

	  if (this.isTileImageInMemory(tile)) {
	    this.addToCurrentTiles(tile);
	  } else {
	    if (retrieveTiles) {
	      this.retrieveTileImage(tile);
	    }

	    if (level.isFirstLevel()) {
	      this.currentTiles.push(tile); // no ancestor tile to add
	    } else {
	      this.addAncestor(level, row, column, retrieveTiles);
	    }
	  }
	}; // Intentionally not documented.


	TiledElevationCoverage.prototype.addAncestor = function (level, row, column, retrieveTiles) {
	  var tile = null,
	      r = Math.floor(row / 2),
	      c = Math.floor(column / 2);

	  for (var i = level.levelNumber - 1; i >= 0; i--) {
	    tile = this.tileForLevel(i, r, c);

	    if (this.isTileImageInMemory(tile)) {
	      this.addToCurrentTiles(tile);
	      return;
	    }

	    r = Math.floor(r / 2);
	    c = Math.floor(c / 2);
	  } // No ancestor tiles have an in-memory image. Retrieve the ancestor tile corresponding for the first level, and
	  // add it. We add the necessary tiles to provide coverage over the requested sector in order to accurately return
	  // whether or not this coverage has data for the entire sector.


	  this.addToCurrentTiles(tile);

	  if (retrieveTiles) {
	    this.retrieveTileImage(tile);
	  }
	}; // Intentionally not documented.


	TiledElevationCoverage.prototype.addToCurrentTiles = function (tile) {
	  this.currentTiles.push(tile);
	}; // Intentionally not documented.


	TiledElevationCoverage.prototype.tileForLevel = function (levelNumber, row, column) {
	  var tileKey = Tile.computeTileKey(levelNumber, row, column),
	      tile = this.tileCache.entryForKey(tileKey);

	  if (tile) {
	    return tile;
	  }

	  var level = this.levels.level(levelNumber),
	      sector = Tile.computeSector(level, row, column);
	  tile = new Tile(sector, level, row, column);
	  this.tileCache.putEntry(tileKey, tile, tile.size());
	  return tile;
	}; // Intentionally not documented.


	TiledElevationCoverage.prototype.isTileImageInMemory = function (tile) {
	  return this.imageCache.containsKey(tile.tileKey);
	}; // Intentionally not documented.


	TiledElevationCoverage.prototype.resourceUrlForTile = function (tile) {
	  return this.urlBuilder.urlForTile(tile, this.retrievalImageFormat);
	}; // Intentionally not documented.


	TiledElevationCoverage.prototype.retrieveTileImage = function (tile) {
	  if (this.currentRetrievals.indexOf(tile.tileKey) < 0) {
	    if (this.currentRetrievals.length > this.retrievalQueueSize) {
	      return;
	    }

	    var url = this.resourceUrlForTile(tile, this.retrievalImageFormat),
	        xhr = new XMLHttpRequest(),
	        elevationCoverage = this;
	    if (!url) return;
	    xhr.open("GET", url + `&x=${tile.column}&y=${tile.row}&z=${tile.level.levelNumber + 1}`, true);
	    xhr.responseType = 'arraybuffer';

	    xhr.onreadystatechange = function () {
	      if (xhr.readyState === 4) {
	        elevationCoverage.removeFromCurrentRetrievals(tile.tileKey);
	        var contentType = xhr.getResponseHeader("content-type");

	        if (xhr.status === 200) {
	          if (contentType === elevationCoverage.retrievalImageFormat || contentType === "text/plain" || contentType === "application/octet-stream") {
	            Logger$1.log(Logger$1.LEVEL_INFO, "Elevations retrieval succeeded: " + url);
	            elevationCoverage.loadElevationImage(tile, xhr);
	            elevationCoverage.absentResourceList.unmarkResourceAbsent(tile.tileKey); // Send an event to request a redraw.

	            var e = document.createEvent('Event');
	            e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
	            window.dispatchEvent(e);
	          } else if (contentType === "text/xml") {
	            elevationCoverage.absentResourceList.markResourceAbsent(tile.tileKey);
	            Logger$1.log(Logger$1.LEVEL_WARNING, "Elevations retrieval failed (" + xhr.statusText + "): " + url + ".\n " + String.fromCharCode.apply(null, new Uint8Array(xhr.response)));
	          } else {
	            elevationCoverage.absentResourceList.markResourceAbsent(tile.tileKey);
	            Logger$1.log(Logger$1.LEVEL_WARNING, "Elevations retrieval failed: " + url + ". " + "Unexpected content type " + contentType);
	          }
	        } else {
	          elevationCoverage.absentResourceList.markResourceAbsent(tile.tileKey);
	          Logger$1.log(Logger$1.LEVEL_WARNING, "Elevations retrieval failed (" + xhr.statusText + "): " + url);
	        }
	      }
	    };

	    xhr.onerror = function () {
	      elevationCoverage.removeFromCurrentRetrievals(tile.tileKey);
	      elevationCoverage.absentResourceList.markResourceAbsent(tile.tileKey);
	      Logger$1.log(Logger$1.LEVEL_WARNING, "Elevations retrieval failed: " + url);
	    };

	    xhr.ontimeout = function () {
	      elevationCoverage.removeFromCurrentRetrievals(tile.tileKey);
	      elevationCoverage.absentResourceList.markResourceAbsent(tile.tileKey);
	      Logger$1.log(Logger$1.LEVEL_WARNING, "Elevations retrieval timed out: " + url);
	    };

	    xhr.send(null);
	    this.currentRetrievals.push(tile.tileKey);
	  }
	}; // Intentionally not documented


	TiledElevationCoverage.prototype.removeFromCurrentRetrievals = function (tileKey) {
	  var index = this.currentRetrievals.indexOf(tileKey);

	  if (index > -1) {
	    this.currentRetrievals.splice(index, 1);
	  }
	}; // Intentionally not documented.


	TiledElevationCoverage.prototype.loadElevationImage = function (tile, xhr) {
	  var elevationImage = new ElevationImage(tile.sector, tile.tileWidth, tile.tileHeight);

	  if (this.retrievalImageFormat === "application/bil16") {
	    elevationImage.imageData = new Int16Array(xhr.response);
	    elevationImage.size = elevationImage.imageData.length * 2;
	  } else if (this.retrievalImageFormat === "application/bil32") {
	    elevationImage.imageData = new Float32Array(xhr.response);
	    elevationImage.size = elevationImage.imageData.length * 4;
	  }

	  if (elevationImage.imageData) {
	    elevationImage.findMinAndMaxElevation();
	    this.imageCache.putEntry(tile.tileKey, elevationImage, elevationImage.size);
	    this.timestamp = Date.now();
	  }
	};

	/**
	 * @exports WmsUrlBuilder
	 */
	/**
	 * Constructs a WMS URL builder.
	 * @alias WmsUrlBuilder
	 * @constructor
	 * @classdesc Provides a factory to create URLs for WMS Get Map requests.
	 * @param {String} serviceAddress The address of the WMS server.
	 * @param {String} layerNames The comma-separated list of names of the layers to retrieve.
	 * @param {String} styleNames The comma-separated list of names of the styles to retrieve. May be null.
	 * @param {String} wmsVersion The version of the WMS server. May be null, in which case version 1.3.0 is
	 * assumed.
	 * @param {String} timeString The time parameter included in GetMap requests.
	 * May be null, in which case no time parameter is included in the request.
	 * @throws {ArgumentError} If the service address or layer names are null or empty.
	 *
	 */

	function WmsUrlBuilder(serviceAddress, layerNames, styleNames, wmsVersion, timeString) {
	  if (!serviceAddress || serviceAddress.length === 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WmsUrlBuilder", "constructor", "The WMS service address is missing."));
	  }

	  if (!layerNames || layerNames.length === 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WmsUrlBuilder", "constructor", "The WMS layer names are not specified."));
	  }
	  /**
	   * The address of the WMS server.
	   * @type {String}
	   */


	  this.serviceAddress = serviceAddress;
	  /**
	   * The comma-separated list of layer names to retrieve.
	   * @type {String}
	   */

	  this.layerNames = layerNames;
	  /**
	   * The comma-separated list of style names to retrieve.
	   * @type {String}
	   */

	  this.styleNames = styleNames ? styleNames : "";
	  /**
	   * Indicates whether the layer should be requested with transparency.
	   * @type {Boolean}
	   * @default true
	   */

	  this.transparent = true;
	  /**
	   * The WMS version to specify when requesting resources.
	   * @type {String}
	   * @default 1.3.0
	   */

	  this.wmsVersion = wmsVersion && wmsVersion.length > 0 ? wmsVersion : "1.3.0";
	  this.isWms130OrGreater = this.wmsVersion >= "1.3.0";
	  /**
	   * The coordinate reference system to use when requesting layers.
	   * @type {String}
	   * @default EPSG:4326
	   */

	  this.crs = "EPSG:4326";
	  /**
	   * The time parameter included in GetMap requests. If null, no time parameter is included in the requests.
	   * @type {String}
	   */

	  this.timeString = timeString;
	}
	/**
	 * Creates the URL string for a WMS Get Map request.
	 * @param {Tile} tile The tile for which to create the URL.
	 * @param {String} imageFormat The image format to request.
	 * @throws {ArgumentError} If the specified tile or image format are null or undefined.
	 */


	WmsUrlBuilder.prototype.urlForTile = function (tile, imageFormat) {
	  if (!tile) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WmsUrlBuilder", "urlForTile", "missingTile"));
	  }

	  if (!imageFormat) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WmsUrlBuilder", "urlForTile", "The image format is null or undefined."));
	  }

	  var sector = tile.sector;
	  var sb = WmsUrlBuilder.fixGetMapString(this.serviceAddress);

	  if (sb.search(/service=wms/i) < 0) {
	    sb = sb + "service=WMS";
	  }

	  sb = sb + "&request=GetMap";
	  sb = sb + "&version=" + this.wmsVersion;
	  sb = sb + "&transparent=" + (this.transparent ? "TRUE" : "FALSE");
	  sb = sb + "&layers=" + this.layerNames;
	  sb = sb + "&styles=" + this.styleNames;
	  sb = sb + "&format=" + imageFormat;
	  sb = sb + "&width=" + tile.tileWidth;
	  sb = sb + "&height=" + tile.tileHeight;

	  if (this.timeString) {
	    sb = sb + "&time=" + this.timeString;
	  }

	  if (this.isWms130OrGreater) {
	    sb = sb + "&crs=" + this.crs;
	    sb = sb + "&bbox=";

	    if (this.crs === "CRS:84") {
	      sb = sb + sector.minLongitude + "," + sector.minLatitude + ",";
	      sb = sb + sector.maxLongitude + "," + sector.maxLatitude;
	    } else {
	      sb = sb + sector.minLatitude + "," + sector.minLongitude + ",";
	      sb = sb + sector.maxLatitude + "," + sector.maxLongitude;
	    }
	  } else {
	    sb = sb + "&srs=" + this.crs;
	    sb = sb + "&bbox=";
	    sb = sb + sector.minLongitude + "," + sector.minLatitude + ",";
	    sb = sb + sector.maxLongitude + "," + sector.maxLatitude;
	  }

	  sb = sb.replace(" ", "%20");
	  return sb;
	}; // Intentionally not documented.


	WmsUrlBuilder.fixGetMapString = function (serviceAddress) {
	  if (!serviceAddress) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WmsUrlBuilder", "fixGetMapString", "The specified service address is null or undefined."));
	  }

	  var index = serviceAddress.indexOf("?");

	  if (index < 0) {
	    // if string contains no question mark
	    serviceAddress = serviceAddress + "?"; // add one
	  } else if (index !== serviceAddress.length - 1) {
	    // else if question mark not at end of string
	    index = serviceAddress.search(/&$/);

	    if (index < 0) {
	      serviceAddress = serviceAddress + "&"; // add a parameter separator
	    }
	  }

	  return serviceAddress;
	};

	/**
	 * @exports AsterV2ElevationCoverage
	 */
	/**
	 * Constructs an Earth elevation coverage using ASTER V2 data.
	 * @alias AsterV2ElevationCoverage
	 * @constructor
	 * @augments TiledElevationCoverage
	 * @classdesc Provides elevations for Earth. Elevations are drawn from the NASA WorldWind elevation service.
	 */

	function AsterV2ElevationCoverage() {
	  TiledElevationCoverage.call(this, {
	    coverageSector: new Sector(-83.0001, 83.0001, -180, 180),
	    resolution: 0.000277777777778,
	    retrievalImageFormat: "application/bil16",
	    minElevation: -11000,
	    maxElevation: 8850,
	    urlBuilder: new WmsUrlBuilder("https://worldwind26.arc.nasa.gov/elev", "aster_v2", "", "1.3.0")
	  });
	  this.displayName = "ASTER V2 Earth Elevation Coverage";
	}

	AsterV2ElevationCoverage.prototype = Object.create(TiledElevationCoverage.prototype);

	/**
	 * @exports AtmosphereProgram
	 */
	/**
	 * Constructs a new program.
	 * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	 * <p>
	 * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program.
	 * This method then compiles the shaders and then links the program if compilation is successful.
	 *
	 * @alias AtmosphereProgram
	 * @constructor
	 * @augments GpuProgram
	 * @classdesc AtmosphereProgram is a GLSL program that draws the atmosphere.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
	 * the compiled shaders into a program fails.
	 */

	function AtmosphereProgram(gl, vertexShaderSource, fragmentShaderSource, attribute) {
	  // Call to the superclass, which performs shader program compiling and linking.
	  GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, attribute); // Frag color mode indicates the atmospheric scattering color components written to the fragment color.

	  this.FRAGMODE_SKY = 1;
	  this.FRAGMODE_GROUND_PRIMARY = 2;
	  this.FRAGMODE_GROUND_SECONDARY = 3;
	  this.FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;
	  /**
	   * The globe's atmosphere altitude.
	   * @type {Number}
	   * @default 160000.0 meters
	   */

	  this.altitude = 160000;
	  /**
	   * This atmosphere's Rayleigh scale depth.
	   * @type {Number}
	   * @default 0.25
	   */

	  this.rayleighScaleDepth = 0.25;
	  /**
	   * The WebGL location for this program's 'fragMode' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.fragModeLocation = this.uniformLocation(gl, "fragMode");
	  /**
	   * The WebGL location for this program's 'mvpMatrix' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");
	  /**
	   * The WebGL location for this program's 'texCoordMatrix' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.texCoordMatrixLocation = this.uniformLocation(gl, "texCoordMatrix");
	  /**
	   * The WebGL location for this program's 'vertexOrigin' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.vertexOriginLocation = this.uniformLocation(gl, "vertexOrigin");
	  /**
	   * The WebGL location for this program's 'eyePoint' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.eyePointLocation = this.uniformLocation(gl, "eyePoint");
	  /**
	   * The WebGL location for this program's 'eyeMagnitude' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.eyeMagnitudeLocation = this.uniformLocation(gl, "eyeMagnitude");
	  /**
	   * The WebGL location for this program's 'eyeMagnitude2' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.eyeMagnitude2Location = this.uniformLocation(gl, "eyeMagnitude2");
	  /**
	   * The WebGL location for this program's 'lightDirection' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.lightDirectionLocation = this.uniformLocation(gl, "lightDirection");
	  /**
	   * The WebGL location for this program's 'atmosphereRadius' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.atmosphereRadiusLocation = this.uniformLocation(gl, "atmosphereRadius");
	  /**
	   * The WebGL location for this program's 'atmosphereRadius2' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.atmosphereRadius2Location = this.uniformLocation(gl, "atmosphereRadius2");
	  /**
	   * The WebGL location for this program's 'globeRadius' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.globeRadiusLocation = this.uniformLocation(gl, "globeRadius");
	  /**
	   * The WebGL location for this program's 'scale' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.scaleLocation = this.uniformLocation(gl, "scale");
	  /**
	   * The WebGL location for this program's 'scaleDepth' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.scaleDepthLocation = this.uniformLocation(gl, "scaleDepth");
	  /**
	   * The WebGL location for this program's 'scaleOverScaleDepth' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.scaleOverScaleDepthLocation = this.uniformLocation(gl, "scaleOverScaleDepth");
	  this.scratchArray9 = new Float32Array(9);
	}
	/**
	 * A string that uniquely identifies this program.
	 * @type {string}
	 * @readonly
	 */


	AtmosphereProgram.key = "WorldWindGpuAtmosphereProgram"; // Inherit from GpuProgram.

	AtmosphereProgram.prototype = Object.create(GpuProgram.prototype);
	/**
	 * Returns the atmosphere's altitude.
	 * @returns {Number} The atmosphere's altitude in meters.
	 */

	AtmosphereProgram.prototype.getAltitude = function () {
	  return this.altitude;
	};
	/**
	 * Loads the specified number as the value of this program's 'fragMode' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} fragMode The frag mode value.
	 * @throws {ArgumentError} If the specified number is null or undefined.
	 */


	AtmosphereProgram.prototype.loadFragMode = function (gl, fragMode) {
	  if (!fragMode) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AtmosphereProgram", "loadFragMode", "missingFragMode"));
	  }

	  gl.uniform1i(this.fragModeLocation, fragMode);
	};
	/**
	 * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix} matrix The matrix to load.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */


	AtmosphereProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AtmosphereProgram", "loadModelviewProjection", "missingMatrix"));
	  }

	  this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	};
	/**
	 * Loads the specified vector as the value of this program's 'vertexOrigin' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Vec3} vector The vector to load.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	AtmosphereProgram.prototype.loadVertexOrigin = function (gl, vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AtmosphereProgram", "loadVertexOrigin", "missingVector"));
	  }

	  gl.uniform3f(this.vertexOriginLocation, vector[0], vector[1], vector[2]);
	};
	/**
	 * Loads the specified vector as the value of this program's 'lightDirection' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Vec3} vector The vector to load.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	AtmosphereProgram.prototype.loadLightDirection = function (gl, vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AtmosphereProgram", "loadLightDirection", "missingVector"));
	  }

	  gl.uniform3f(this.lightDirectionLocation, vector[0], vector[1], vector[2]);
	};
	/**
	 * Loads the specified vector as the value of this program's 'lightDirection' uniform variable,
	 * the magnitude's specified vector as the value of this program's 'eyeMagnitude' uniform variable and
	 * the squared magnitude's specified vector as the value of this program's 'eyeMagnitude2' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Vec3} vector The vector to load.
	 * @throws {ArgumentError} If the specified vector is null or undefined.
	 */


	AtmosphereProgram.prototype.loadEyePoint = function (gl, vector) {
	  if (!vector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AtmosphereProgram", "loadEyePoint", "missingVector"));
	  }

	  gl.uniform3f(this.eyePointLocation, vector[0], vector[1], vector[2]);
	  gl.uniform1f(this.eyeMagnitudeLocation, vector.magnitude());
	  gl.uniform1f(this.eyeMagnitude2Location, vector.magnitudeSquared());
	};
	/**
	 * Loads the specified number as the value of this program's 'globeRadius' uniform variable and the specified
	 * number which add the altitude value as the value of this program's 'atmosphereRadius' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} globeRadius The globe radius value.
	 * @throws {ArgumentError} If the specified number is null or undefined.
	 */


	AtmosphereProgram.prototype.loadGlobeRadius = function (gl, globeRadius) {
	  if (!globeRadius) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AtmosphereProgram", "loadGlobeRadius", "missingGlobeRadius"));
	  }

	  var gr = globeRadius;
	  var ar = gr + this.altitude;
	  gl.uniform1f(this.globeRadiusLocation, gr);
	  gl.uniform1f(this.atmosphereRadiusLocation, ar);
	  gl.uniform1f(this.atmosphereRadius2Location, ar * ar);
	};
	/**
	 * Sets the program's 'scale', 'scaleDepth' and 'scaleOverScaleDepth' uniform variables.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 */


	AtmosphereProgram.prototype.setScale = function (gl) {
	  gl.uniform1f(this.scaleLocation, 1 / this.getAltitude());
	  gl.uniform1f(this.scaleDepthLocation, this.rayleighScaleDepth);
	  gl.uniform1f(this.scaleOverScaleDepthLocation, 1 / this.getAltitude() / this.rayleighScaleDepth);
	};
	/**
	 * Loads the specified matrix as the value of this program's 'texCoordMatrix' uniform variable.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix3} matrix The texture coordinate matrix.
	 */


	AtmosphereProgram.prototype.loadTexMatrix = function (gl, matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AtmosphereProgram", "loadTexMatrix", "missingMatrix"));
	  }

	  matrix.columnMajorComponents(this.scratchArray9);
	  gl.uniformMatrix3fv(this.texCoordMatrixLocation, false, this.scratchArray9);
	};

	var GroundVertex = "\r\nprecision mediump int;\r\n\r\nconst int FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;\r\nconst int SAMPLE_COUNT = 2;\r\nconst float SAMPLES = 2.0;\r\n\r\nconst float PI = 3.141592653589;\r\nconst float Kr = 0.0025;\r\nconst float Kr4PI = Kr * 4.0 * PI;\r\nconst float Km = 0.0015;\r\nconst float Km4PI = Km * 4.0 * PI;\r\nconst float ESun = 15.0;\r\nconst float KmESun = Km * ESun;\r\nconst float KrESun = Kr * ESun;\r\nconst vec3 invWavelength = vec3(5.60204474633241, 9.473284437923038, 19.643802610477206);\r\nconst float rayleighScaleDepth = 0.25;\r\n\r\nuniform int fragMode;\r\nuniform mat4 mvpMatrix;\r\nuniform mat3 texCoordMatrix;\r\nuniform vec3 vertexOrigin;\r\nuniform vec3 eyePoint;\r\nuniform float eyeMagnitude;\r\nuniform float eyeMagnitude2;\r\nuniform vec3 lightDirection;\r\nuniform float atmosphereRadius;\r\nuniform float atmosphereRadius2;\r\nuniform float globeRadius;\r\nuniform float scale;\r\nuniform float scaleDepth;\r\nuniform float scaleOverScaleDepth;\r\n\r\nattribute vec4 vertexPoint;\r\nattribute vec2 vertexTexCoord;\r\n\r\nvarying vec3 primaryColor;\r\nvarying vec3 secondaryColor;\r\nvarying vec2 texCoord;\r\n\r\nfloat scaleFunc(float cos) {\r\n    float x = 1.0 - cos;\r\n    return scaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\nvoid sampleGround() {\r\n\r\n    vec3 point = vertexPoint.xyz + vertexOrigin;\r\n    vec3 ray = point - eyePoint;\r\n    float far = length(ray);\r\n    ray /= far;\r\n    \r\n    vec3 start;\r\n    if (eyeMagnitude < atmosphereRadius) {\r\n        start = eyePoint;\r\n    } else {\r\n\r\n        float B = 2.0 * dot(eyePoint, ray);\r\n        float C = eyeMagnitude2 - atmosphereRadius2;\r\n        float det = max(0.0, B*B - 4.0 * C);\r\n        float near = 0.5 * (-B - sqrt(det));\r\n        \r\n\r\n        start = eyePoint + ray * near;\r\n        far -= near;\r\n    }\r\n    float depth = exp((globeRadius - atmosphereRadius) / scaleDepth);\r\n    float eyeAngle = dot(-ray, point) / length(point);\r\n    float lightAngle = dot(lightDirection, point) / length(point);\r\n    float eyeScale = scaleFunc(eyeAngle);\r\n    float lightScale = scaleFunc(lightAngle);\r\n    float eyeOffset = depth*eyeScale;\r\n    float temp = (lightScale + eyeScale);\r\n    \r\n\r\n    float sampleLength = far / SAMPLES;\r\n    float scaledLength = sampleLength * scale;\r\n    vec3 sampleRay = ray * sampleLength;\r\n    vec3 samplePoint = start + sampleRay * 0.5;\r\n    \r\n\r\n    vec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n    vec3 attenuate = vec3(0.0, 0.0, 0.0);\r\n    for(int i=0; i<SAMPLE_COUNT; i++) {\r\n        float height = length(samplePoint);\r\n        float depth = exp(scaleOverScaleDepth * (globeRadius - height));\r\n        float scatter = depth*temp - eyeOffset;\r\n        attenuate = exp(-scatter * (invWavelength * Kr4PI + Km4PI));\r\n        frontColor += attenuate * (depth * scaledLength);\r\n        samplePoint += sampleRay;\r\n    }\r\n    \r\n    primaryColor = frontColor * (invWavelength * KrESun + KmESun);\r\n    secondaryColor = attenuate;\r\n}\r\n\r\nvoid main() {\r\n    sampleGround();\r\n\r\n    gl_Position = mvpMatrix * vertexPoint;\r\n    if (fragMode == FRAGMODE_GROUND_PRIMARY_TEX_BLEND) {\r\n\r\n        texCoord = (texCoordMatrix * vec3(vertexTexCoord, 1.0)).st;\r\n    }\r\n}";

	var GroundFragment = "\r\nprecision mediump float;\r\nprecision mediump int;\r\n\r\nconst int FRAGMODE_GROUND_PRIMARY = 2;\r\nconst int FRAGMODE_GROUND_SECONDARY = 3;\r\nconst int FRAGMODE_GROUND_PRIMARY_TEX_BLEND = 4;\r\n\r\nuniform int fragMode;\r\nuniform sampler2D texSampler;\r\n\r\nvarying vec3 primaryColor;\r\nvarying vec3 secondaryColor;\r\nvarying vec2 texCoord;\r\n\r\nvoid main (void) {\r\n    if (fragMode == FRAGMODE_GROUND_PRIMARY) {\r\n        gl_FragColor = vec4(primaryColor, 1.0);\r\n    } else if (fragMode == FRAGMODE_GROUND_SECONDARY) {\r\n        gl_FragColor = vec4(secondaryColor, 1.0);\r\n    } else if (fragMode == FRAGMODE_GROUND_PRIMARY_TEX_BLEND) {\r\n        vec4 texColor = texture2D(texSampler, texCoord);\r\n        gl_FragColor = vec4(primaryColor + texColor.rgb * (1.0 - secondaryColor), 1.0);\r\n    }\r\n}";

	/**
	 * @exports GroundProgram
	 */
	/**
	 * Constructs a new program.
	 * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	 * <p>
	 * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program.
	 * This method then compiles the shaders and then links the program if compilation is successful. Use the bind
	 * method to make the program current during rendering.
	 *
	 * @alias GroundProgram
	 * @constructor
	 * @augments AtmosphereProgram
	 * @classdesc GroundProgram is a GLSL program that draws the ground component of the atmosphere.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
	 * the compiled shaders into a program fails.
	 */

	function GroundProgram(gl) {
	  var vertexShaderSource = GroundVertex,
	      fragmentShaderSource = GroundFragment; // Call to the superclass, which performs shader program compiling and linking.

	  AtmosphereProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, ["vertexPoint", "vertexTexCoord"]);
	}
	/**
	 * A string that uniquely identifies this program.
	 * @type {string}
	 * @readonly
	 */


	GroundProgram.key = "WorldWindGroundProgram"; // Inherit from AtmosphereProgram.

	GroundProgram.prototype = Object.create(AtmosphereProgram.prototype);

	/**
	 * @exports Layer
	 */

	/**
	 * Constructs a layer. This constructor is meant to be called by subclasses and not directly by an application.
	 * @alias Layer
	 * @constructor
	 * @classdesc Provides an abstract base class for layer implementations. This class is not meant to be instantiated
	 * directly.
	 */
	function Layer(displayName) {
	  /**
	   * This layer's display name.
	   * @type {String}
	   * @default "Layer"
	   */
	  this.displayName = displayName ? displayName : "Layer";
	  /**
	   * Indicates whether to display this layer.
	   * @type {Boolean}
	   * @default true
	   */

	  this.enabled = true;
	  /**
	   * Indicates whether this layer is pickable.
	   * @type {Boolean}
	   * @default true
	   */

	  this.pickEnabled = true;
	  /**
	   * This layer's opacity, which is combined with the opacity of shapes within layers.
	   * Opacity is in the range [0, 1], with 1 indicating fully opaque.
	   * @type {Number}
	   * @default 1
	   */

	  this.opacity = 1;
	  /**
	   * The eye altitude above which this layer is displayed, in meters.
	   * @type {Number}
	   * @default -Number.MAX_VALUE (always displayed)
	   */

	  this.minActiveAltitude = -Number.MAX_VALUE;
	  /**
	   * The eye altitude below which this layer is displayed, in meters.
	   * @type {Number}
	   * @default Number.MAX_VALUE (always displayed)
	   */

	  this.maxActiveAltitude = Number.MAX_VALUE;
	  /**
	   * Indicates whether elements of this layer were drawn in the most recently generated frame.
	   * @type {Boolean}
	   * @readonly
	   */

	  this.inCurrentFrame = false;
	  /**
	   * The time to display. This property selects the layer contents that represents the specified time.
	   * If null, layer-type dependent contents are displayed.
	   * @type {Date}
	   */

	  this.time = null;
	}
	/**
	 * Refreshes the data associated with this layer. The behavior of this function varies with the layer
	 * type. For image layers, it causes the images to be re-retrieved from their origin.
	 */


	Layer.prototype.refresh = function () {// Default implementation does nothing.
	};
	/**
	 * Displays this layer. Subclasses should generally not override this method but should instead override the
	 * [doRender]{@link Layer#doRender} method. This method calls that method after verifying that the layer is
	 * enabled, the eye point is within this layer's active altitudes and the layer is in view.
	 * @param {DrawContext} dc The current draw context.
	 */


	Layer.prototype.render = function (dc) {
	  this.inCurrentFrame = false;
	  if (!this.enabled) return;
	  if (dc.pickingMode && !this.pickEnabled) return;
	  if (!this.withinActiveAltitudes(dc)) return;
	  if (!this.isLayerInView(dc)) return;
	  this.doRender(dc);
	};
	/**
	 * Subclass method called to display this layer. Subclasses should implement this method rather than the
	 * [render]{@link Layer#render} method, which determines enable, pick and active altitude status and does not
	 * call this doRender method if the layer should not be displayed.
	 * @param {DrawContext} dc The current draw context.
	 * @protected
	 */


	Layer.prototype.doRender = function (dc) {// Default implementation does nothing.
	};
	/* INTENTIONALLY NOT DOCUMENTED
	 * Indicates whether the current eye distance is within this layer's active-altitude range.
	 * @param {DrawContext} dc The current draw context.
	 * @returns {boolean} true If the eye distance is greater than or equal to this layer's minimum active
	 * altitude and less than or equal to this layer's maximum active altitude, otherwise false.
	 * @protected
	 */


	Layer.prototype.withinActiveAltitudes = function (dc) {
	  var eyePosition = dc.eyePosition;
	  if (!eyePosition) return false;
	  return eyePosition.altitude >= this.minActiveAltitude && eyePosition.altitude <= this.maxActiveAltitude;
	};
	/**
	 * Indicates whether this layer is within the current view. Subclasses may override this method and
	 * when called determine whether the layer contents are visible in the current view frustum. The default
	 * implementation always returns true.
	 * @param {DrawContext} dc The current draw context.
	 * @returns {boolean} true If this layer is within the current view, otherwise false.
	 * @protected
	 */


	Layer.prototype.isLayerInView = function (dc) {
	  return true; // default implementation always returns true
	};

	/**
	 * @exports Matrix3
	 */
	/**
	 * Constructs a 3 x 3  matrix.
	 * @alias Matrix3
	 * @constructor
	 * @classdesc Represents a 3 x 3 double precision matrix stored in a Float64Array in row-major order.
	 * @param {Number} m11 matrix element at row 1, column 1.
	 * @param {Number} m12 matrix element at row 1, column 2.
	 * @param {Number} m13 matrix element at row 1, column 3.
	 * @param {Number} m21 matrix element at row 2, column 1.
	 * @param {Number} m22 matrix element at row 2, column 2.
	 * @param {Number} m23 matrix element at row 2, column 3.
	 * @param {Number} m31 matrix element at row 3, column 1.
	 * @param {Number} m32 matrix element at row 3, column 2.
	 * @param {Number} m33 matrix element at row 3, column 3.
	 */

	function Matrix3(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
	  this[0] = m11;
	  this[1] = m12;
	  this[2] = m13;
	  this[3] = m21;
	  this[4] = m22;
	  this[5] = m23;
	  this[6] = m31;
	  this[7] = m32;
	  this[8] = m33;
	} // Derives from Float64Array.


	Matrix3.prototype = new Float64Array(9);
	/**
	 * Creates an identity matrix.
	 * @returns {Matrix3} A new identity matrix.
	 */

	Matrix3.fromIdentity = function () {
	  return new Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1);
	};
	/**
	 * Sets this matrix to one that flips and shifts the y-axis.
	 * <p>
	 * The resultant matrix maps Y=0 to Y=1 and Y=1 to Y=0. All existing values are overwritten. This matrix is
	 * usually used to change the coordinate origin from an upper left coordinate origin to a lower left coordinate
	 * origin. This is typically necessary to align the coordinate system of images (top-left origin) with that of
	 * OpenGL (bottom-left origin).
	 * @returns {Matrix3} This matrix set to values described above.
	 */


	Matrix3.prototype.setToUnitYFlip = function () {
	  this[0] = 1;
	  this[1] = 0;
	  this[2] = 0;
	  this[3] = 0;
	  this[4] = -1;
	  this[5] = 1;
	  this[6] = 0;
	  this[7] = 0;
	  this[8] = 1;
	  return this;
	};
	/**
	 * Multiplies this matrix by a specified matrix.
	 *
	 * @param {Matrix3} matrix The matrix to multiply with this matrix.
	 * @returns {Matrix3} This matrix after multiplying it by the specified matrix.
	 * @throws {ArgumentError} if the specified matrix is null or undefined.
	 */


	Matrix3.prototype.multiplyMatrix = function (matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix3", "multiplyMatrix", "missingMatrix"));
	  }

	  var ma = this,
	      mb = matrix,
	      ma0,
	      ma1,
	      ma2; // Row 1

	  ma0 = ma[0];
	  ma1 = ma[1];
	  ma2 = ma[2];
	  ma[0] = ma0 * mb[0] + ma1 * mb[3] + ma2 * mb[6];
	  ma[1] = ma0 * mb[1] + ma1 * mb[4] + ma2 * mb[7];
	  ma[2] = ma0 * mb[2] + ma1 * mb[5] + ma2 * mb[8]; // Row 2

	  ma0 = ma[3];
	  ma1 = ma[4];
	  ma2 = ma[5];
	  ma[3] = ma0 * mb[0] + ma1 * mb[3] + ma2 * mb[6];
	  ma[4] = ma0 * mb[1] + ma1 * mb[4] + ma2 * mb[7];
	  ma[5] = ma0 * mb[2] + ma1 * mb[5] + ma2 * mb[8]; // Row 3

	  ma0 = ma[6];
	  ma1 = ma[7];
	  ma2 = ma[8];
	  ma[6] = ma0 * mb[0] + ma1 * mb[3] + ma2 * mb[6];
	  ma[7] = ma0 * mb[1] + ma1 * mb[4] + ma2 * mb[7];
	  ma[8] = ma0 * mb[2] + ma1 * mb[5] + ma2 * mb[8];
	  return this;
	};
	/**
	 * Multiplies this matrix by a matrix that transforms normalized coordinates from a source sector to a destination
	 * sector. Normalized coordinates within a sector range from 0 to 1, with (0, 0) indicating the lower left corner
	 * and (1, 1) indicating the upper right. The resultant matrix maps a normalized source coordinate (X, Y) to its
	 * corresponding normalized destination coordinate (X', Y').
	 * <p/>
	 * This matrix typically necessary to transform texture coordinates from one geographic region to another. For
	 * example, the texture coordinates for a terrain tile spanning one region must be transformed to coordinates
	 * appropriate for an image tile spanning a potentially different region.
	 *
	 * @param {Sector} src the source sector
	 * @param {Sector} dst the destination sector
	 *
	 * @returns {Matrix3} this matrix multiplied by the transform matrix implied by values described above
	 */


	Matrix3.prototype.multiplyByTileTransform = function (src, dst) {
	  var srcDeltaLat = src.deltaLatitude();
	  var srcDeltaLon = src.deltaLongitude();
	  var dstDeltaLat = dst.deltaLatitude();
	  var dstDeltaLon = dst.deltaLongitude();
	  var xs = srcDeltaLon / dstDeltaLon;
	  var ys = srcDeltaLat / dstDeltaLat;
	  var xt = (src.minLongitude - dst.minLongitude) / dstDeltaLon;
	  var yt = (src.minLatitude - dst.minLatitude) / dstDeltaLat; // This is equivalent to the following operation, but is potentially much faster:

	  /*var m = new Matrix3(
	      xs, 0, xt,
	      0, ys, yt,
	      0, 0, 1);
	  this.multiplyMatrix(m);*/
	  // This inline version eliminates unnecessary multiplication by 1 and 0 in the matrix's components, reducing
	  // the total number of primitive operations from 63 to 18.

	  var m = this; // Must be done before modifying m0, m1, etc. below.

	  m[2] += m[0] * xt + m[1] * yt;
	  m[5] += m[3] * xt + m[4] * yt;
	  m[8] += m[6] * xt + m[6] * yt;
	  m[0] *= xs;
	  m[1] *= ys;
	  m[3] *= xs;
	  m[4] *= ys;
	  m[6] *= xs;
	  m[7] *= ys;
	  return this;
	};
	/**
	 * Stores this matrix's components in column-major order in a specified array.
	 * <p>
	 * The array must have space for at least 9 elements. This matrix's components are stored in the array
	 * starting with row 0 column 0 in index 0, row 1 column 0 in index 1, row 2 column 0 in index 2, and so on.
	 *
	 * @param {Float32Array | Float64Array | Number[]} result An array of at least 9 elements. Upon return,
	 * contains this matrix's components in column-major.
	 * @returns {Float32Array} The specified result array.
	 * @throws {ArgumentError} If the specified result array in null or undefined.
	 */


	Matrix3.prototype.columnMajorComponents = function (result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Matrix3", "columnMajorComponents", "missingResult"));
	  } // Column 1


	  result[0] = this[0];
	  result[1] = this[3];
	  result[2] = this[6]; // Column 2

	  result[3] = this[1];
	  result[4] = this[4];
	  result[5] = this[7]; // Column 3

	  result[6] = this[2];
	  result[7] = this[5];
	  result[8] = this[8];
	  return result;
	};

	var SkyVertex = "\r\nprecision mediump int;\r\n\r\nconst int SAMPLE_COUNT = 2;\r\nconst float SAMPLES = 2.0;\r\n\r\nconst float PI = 3.141592653589;\r\nconst float Kr = 0.0025;\r\nconst float Kr4PI = Kr * 4.0 * PI;\r\nconst float Km = 0.0015;\r\nconst float Km4PI = Km * 4.0 * PI;\r\nconst float ESun = 15.0;\r\nconst float KmESun = Km * ESun;\r\nconst float KrESun = Kr * ESun;\r\nconst vec3 invWavelength = vec3(5.60204474633241, 9.473284437923038, 19.643802610477206);\r\nconst float rayleighScaleDepth = 0.25;\r\n\r\nuniform mat4 mvpMatrix;\r\nuniform vec3 vertexOrigin;\r\nuniform vec3 eyePoint;\r\nuniform float eyeMagnitude;\r\nuniform float eyeMagnitude2;\r\nuniform mediump vec3 lightDirection;\r\nuniform float atmosphereRadius;\r\nuniform float atmosphereRadius2;\r\nuniform float globeRadius;\r\nuniform float scale;\r\nuniform float scaleDepth;\r\nuniform float scaleOverScaleDepth;\r\n\r\nattribute vec4 vertexPoint;\r\n\r\nvarying vec3 primaryColor;\r\nvarying vec3 secondaryColor;\r\nvarying vec3 direction;\r\n\r\nfloat scaleFunc(float cos) {\r\n    float x = 1.0 - cos;\r\n    return scaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\nvoid sampleSky() {\r\n\r\n    vec3 point = vertexPoint.xyz + vertexOrigin;\r\n    vec3 ray = point - eyePoint;\r\n    float far = length(ray);\r\n    ray /= far;\r\n    \r\n    vec3 start;\r\n    float startOffset;\r\n    \r\n    if (eyeMagnitude < atmosphereRadius) {\r\n\r\n        start = eyePoint;\r\n        float height = length(start);\r\n        float depth = exp(scaleOverScaleDepth * (globeRadius - eyeMagnitude));\r\n        float startAngle = dot(ray, start) / height;\r\n        startOffset = depth*scaleFunc(startAngle);\r\n    } else {\r\n\r\n         float B = 2.0 * dot(eyePoint, ray);\r\n         float C = eyeMagnitude2 - atmosphereRadius2;\r\n         float det = max(0.0, B*B - 4.0 * C);\r\n         float near = 0.5 * (-B - sqrt(det));\r\n\r\n\r\n        start = eyePoint + ray * near;\r\n        far -= near;\r\n        float startAngle = dot(ray, start) / atmosphereRadius;\r\n        float startDepth = exp(-1.0 / scaleDepth);\r\n        startOffset = startDepth*scaleFunc(startAngle);\r\n    }\r\n    \r\n\r\n    float sampleLength = far / SAMPLES;\r\n    float scaledLength = sampleLength * scale;\r\n    vec3 sampleRay = ray * sampleLength;\r\n    vec3 samplePoint = start + sampleRay * 0.5;\r\n    \r\n\r\n    vec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n    for(int i=0; i<SAMPLE_COUNT; i++) {\r\n        float height = length(samplePoint);\r\n        float depth = exp(scaleOverScaleDepth * (globeRadius - height));\r\n        float lightAngle = dot(lightDirection, samplePoint) / height;\r\n        float cameraAngle = dot(ray, samplePoint) / height;\r\n        float scatter = (startOffset + depth*(scaleFunc(lightAngle) - scaleFunc(cameraAngle)));\r\n        vec3 attenuate = exp(-scatter * (invWavelength * Kr4PI + Km4PI));\r\n        frontColor += attenuate * (depth * scaledLength);\r\n        samplePoint += sampleRay;\r\n    }\r\n    \r\n\r\n    primaryColor = frontColor * (invWavelength * KrESun);\r\n    secondaryColor = frontColor * KmESun;\r\n    direction = eyePoint - point;\r\n}\r\n\r\nvoid main() {\r\n    sampleSky();\r\n    \r\n\r\n    gl_Position = mvpMatrix * vertexPoint;\r\n}";

	var SkyFragment = "\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nconst float g = -0.95;\r\nconst float g2 = g * g;\r\n\r\nuniform mediump vec3 lightDirection;\r\n\r\nvarying vec3 primaryColor;\r\nvarying vec3 secondaryColor;\r\nvarying vec3 direction;\r\n\r\nvoid main (void) {\r\n    float cos = dot(lightDirection, direction) / length(direction);\r\n    float rayleighPhase = 0.75 * (1.0 + cos * cos);\r\n    float miePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + cos*cos) /\r\n        pow(1.0 + g2 - 2.0*g*cos, 1.5);\r\n    const float exposure = 2.0;\r\n    vec3 color = primaryColor * rayleighPhase + secondaryColor * miePhase;\r\n    color = vec3(1.0) - exp(-exposure * color);\r\n    gl_FragColor = vec4(color, color.b);\r\n}";

	/**
	 * @exports SkyProgram
	 */
	/**
	 * Constructs a new program.
	 * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	 * <p>
	 * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program.
	 * This method then compiles the shaders and then links the program if compilation is successful. Use the bind
	 * method to make the program current during rendering.
	 *
	 * @alias SkyProgram
	 * @constructor
	 * @augments AtmosphereProgram
	 * @classdesc SkyProgram is a GLSL program that draws the sky component of the atmosphere.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @throws {ArgumentError} If the shaders cannot be compiled, or linking of
	 * the compiled shaders into a program fails.
	 */

	function SkyProgram(gl) {
	  var vertexShaderSource = SkyVertex,
	      fragmentShaderSource = SkyFragment; // Call to the superclass, which performs shader program compiling and linking.

	  AtmosphereProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, ["vertexPoint"]);
	}
	/**
	 * A string that uniquely identifies this program.
	 * @type {string}
	 * @readonly
	 */


	SkyProgram.key = "WorldWindSkyProgram"; // Inherit from AtmosphereProgram.

	SkyProgram.prototype = Object.create(AtmosphereProgram.prototype);

	/**
	 * Provides utilities for determining the Sun geographic and celestial location.
	 * @exports SunPosition
	 */

	var SunPosition = {
	  /**
	   * Computes the geographic location of the sun for a given date
	   * @param {Date} date
	   * @throws {ArgumentError} if the date is missing
	   * @return {{latitude: Number, longitude: Number}} the geographic location
	   */
	  getAsGeographicLocation: function (date) {
	    if (date instanceof Date === false) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SunPosition", "getAsGeographicLocation", "missingDate"));
	    }

	    var celestialLocation = this.getAsCelestialLocation(date);
	    return this.celestialToGeographic(celestialLocation, date);
	  },

	  /**
	   * Computes the celestial location of the sun for a given julianDate
	   * @param {Date} date
	   * @throws {ArgumentError} if the date is missing
	   * @return {{declination: Number, rightAscension: Number}} the celestial location
	   */
	  getAsCelestialLocation: function (date) {
	    if (date instanceof Date === false) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SunPosition", "getAsCelestialLocation", "missingDate"));
	    }

	    var julianDate = this.computeJulianDate(date); //number of days (positive or negative) since Greenwich noon, Terrestrial Time, on 1 January 2000 (J2000.0)

	    var numDays = julianDate - 2451545;
	    var meanLongitude = WWMath.normalizeAngle360(280.460 + 0.9856474 * numDays);
	    var meanAnomaly = WWMath.normalizeAngle360(357.528 + 0.9856003 * numDays) * Angle.DEGREES_TO_RADIANS;
	    var eclipticLongitude = meanLongitude + 1.915 * Math.sin(meanAnomaly) + 0.02 * Math.sin(2 * meanAnomaly);
	    var eclipticLongitudeRad = eclipticLongitude * Angle.DEGREES_TO_RADIANS;
	    var obliquityOfTheEcliptic = (23.439 - 0.0000004 * numDays) * Angle.DEGREES_TO_RADIANS;
	    var declination = Math.asin(Math.sin(obliquityOfTheEcliptic) * Math.sin(eclipticLongitudeRad)) * Angle.RADIANS_TO_DEGREES;
	    var rightAscension = Math.atan(Math.cos(obliquityOfTheEcliptic) * Math.tan(eclipticLongitudeRad)) * Angle.RADIANS_TO_DEGREES; //compensate for atan result

	    if (eclipticLongitude >= 90 && eclipticLongitude < 270) {
	      rightAscension += 180;
	    }

	    rightAscension = WWMath.normalizeAngle360(rightAscension);
	    return {
	      declination: declination,
	      rightAscension: rightAscension
	    };
	  },

	  /**
	   * Converts from celestial coordinates (declination and right ascension) to geographic coordinates
	   * (latitude, longitude) for a given julian date
	   * @param {{declination: Number, rightAscension: Number}} celestialLocation
	   * @param {Date} date
	   * @throws {ArgumentError} if celestialLocation or julianDate are missing
	   * @return {{latitude: Number, longitude: Number}} the geographic location
	   */
	  celestialToGeographic: function (celestialLocation, date) {
	    if (!celestialLocation) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SunPosition", "celestialToGeographic", "missingCelestialLocation"));
	    }

	    if (date instanceof Date === false) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SunPosition", "celestialToGeographic", "missingDate"));
	    }

	    var julianDate = this.computeJulianDate(date); //number of days (positive or negative) since Greenwich noon, Terrestrial Time, on 1 January 2000 (J2000.0)

	    var numDays = julianDate - 2451545; //Greenwich Mean Sidereal Time

	    var GMST = WWMath.normalizeAngle360(280.46061837 + 360.98564736629 * numDays); //Greenwich Hour Angle

	    var GHA = WWMath.normalizeAngle360(GMST - celestialLocation.rightAscension);
	    var longitude = Angle.normalizedDegreesLongitude(-GHA);
	    return {
	      latitude: celestialLocation.declination,
	      longitude: longitude
	    };
	  },

	  /**
	   * Computes the julian date from a javascript date object
	   * @param {Date} date
	   * @throws {ArgumentError} if the date is missing
	   * @return {Number} the julian date
	   */
	  computeJulianDate: function (date) {
	    if (date instanceof Date === false) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SunPosition", "computeJulianDate", "missingDate"));
	    }

	    var year = date.getUTCFullYear();
	    var month = date.getUTCMonth() + 1;
	    var day = date.getUTCDate();
	    var hour = date.getUTCHours();
	    var minute = date.getUTCMinutes();
	    var second = date.getUTCSeconds();
	    var dayFraction = (hour + minute / 60 + second / 3600) / 24;

	    if (month <= 2) {
	      year -= 1;
	      month += 12;
	    }

	    var A = Math.floor(year / 100);
	    var B = 2 - A + Math.floor(A / 4);
	    var JD0h = Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + B - 1524.5;
	    return JD0h + dayFraction;
	  }
	};

	/**
	 * @exports AtmosphereLayer
	 */
	/**
	 * Constructs a layer showing the Earth's atmosphere.
	 * @alias AtmosphereLayer
	 * @constructor
	 * @classdesc Provides a layer showing the Earth's atmosphere.
	 * @param {URL} nightImageSource optional url for the night texture.
	 * @augments Layer
	 */

	function AtmosphereLayer(nightImageSource) {
	  Layer.call(this, "Atmosphere"); // The atmosphere layer is not pickable.

	  this.pickEnabled = false; //Documented in defineProperties below.

	  this._nightImageSource = nightImageSource || WorldWind.configuration.baseUrl + 'images/dnb_land_ocean_ice_2012.png'; //Internal use only.
	  //The light direction in cartesian space, computed from the layer time or defaults to the eyePoint.

	  this._activeLightDirection = new Vec3$1(0, 0, 0);
	  this._fullSphereSector = Sector.FULL_SPHERE; //Internal use only. Intentionally not documented.

	  this._skyData = {}; //Internal use only. The number of longitudinal points in the grid for the sky geometry.

	  this._skyWidth = 128; //Internal use only. The number of latitudinal points in the grid for the sky geometry.

	  this._skyHeight = 128; //Internal use only. Number of indices for the sky geometry.

	  this._numIndices = 0; //Internal use only. Texture coordinate matrix used for the night texture.

	  this._texMatrix = Matrix3.fromIdentity(); //Internal use only. The night texture.

	  this._activeTexture = null;
	}

	AtmosphereLayer.prototype = Object.create(Layer.prototype);
	Object.defineProperties(AtmosphereLayer.prototype, {
	  /**
	   * Url for the night texture.
	   * @memberof AtmosphereLayer.prototype
	   * @type {URL}
	   */
	  nightImageSource: {
	    get: function () {
	      return this._nightImageSource;
	    },
	    set: function (value) {
	      this._nightImageSource = value;
	    }
	  }
	}); // Documented in superclass.

	AtmosphereLayer.prototype.doRender = function (dc) {
	  if (dc.globe.is2D()) {
	    return;
	  }

	  this.determineLightDirection(dc);
	  this.drawSky(dc);
	  this.drawGround(dc);
	}; // Internal. Intentionally not documented.


	AtmosphereLayer.prototype.applySkyVertices = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram,
	      skyData = this._skyData,
	      skyPoints,
	      vboId;

	  if (!skyData.verticesVboCacheKey) {
	    skyData.verticesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	  }

	  vboId = dc.gpuResourceCache.resourceForKey(skyData.verticesVboCacheKey);

	  if (!vboId) {
	    skyPoints = this.assembleVertexPoints(dc, this._skyHeight, this._skyWidth, program.getAltitude());
	    vboId = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	    gl.bufferData(gl.ARRAY_BUFFER, skyPoints, gl.STATIC_DRAW);
	    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
	    dc.gpuResourceCache.putResource(skyData.verticesVboCacheKey, vboId, skyPoints.length * 4);
	    dc.frameStatistics.incrementVboLoadCount(1);
	  } else {
	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	    gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
	  }
	}; // Internal. Intentionally not documented.


	AtmosphereLayer.prototype.applySkyIndices = function (dc) {
	  var gl = dc.currentGlContext,
	      skyData = this._skyData,
	      skyIndices,
	      vboId;

	  if (!skyData.indicesVboCacheKey) {
	    skyData.indicesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	  }

	  vboId = dc.gpuResourceCache.resourceForKey(skyData.indicesVboCacheKey);

	  if (!vboId) {
	    skyIndices = this.assembleTriStripIndices(this._skyWidth, this._skyHeight);
	    vboId = gl.createBuffer();
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);
	    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, skyIndices, gl.STATIC_DRAW);
	    dc.frameStatistics.incrementVboLoadCount(1);
	    dc.gpuResourceCache.putResource(skyData.indicesVboCacheKey, vboId, skyIndices.length * 2);
	  } else {
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);
	  }
	}; // Internal. Intentionally not documented.


	AtmosphereLayer.prototype.drawSky = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.findAndBindProgram(SkyProgram);
	  program.loadGlobeRadius(gl, dc.globe.equatorialRadius);
	  program.loadEyePoint(gl, dc.eyePoint);
	  program.loadVertexOrigin(gl, Vec3$1.ZERO);
	  program.loadModelviewProjection(gl, dc.modelviewProjection);
	  program.loadLightDirection(gl, this._activeLightDirection);
	  program.setScale(gl);
	  this.applySkyVertices(dc);
	  this.applySkyIndices(dc);
	  gl.depthMask(false);
	  gl.frontFace(gl.CW);
	  gl.enableVertexAttribArray(0);
	  gl.drawElements(gl.TRIANGLE_STRIP, this._numIndices, gl.UNSIGNED_SHORT, 0);
	  gl.depthMask(true);
	  gl.frontFace(gl.CCW);
	  gl.disableVertexAttribArray(0);
	}; // Internal. Intentionally not documented.


	AtmosphereLayer.prototype.drawGround = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.findAndBindProgram(GroundProgram),
	      terrain = dc.terrain,
	      textureBound;
	  program.loadGlobeRadius(gl, dc.globe.equatorialRadius);
	  program.loadEyePoint(gl, dc.eyePoint);
	  program.loadLightDirection(gl, this._activeLightDirection);
	  program.setScale(gl); // Use this layer's night image when the layer has time value defined

	  if (this.nightImageSource && this.time !== null) {
	    this._activeTexture = dc.gpuResourceCache.resourceForKey(this.nightImageSource);

	    if (!this._activeTexture) {
	      this._activeTexture = dc.gpuResourceCache.retrieveTexture(gl, this.nightImageSource);
	    }

	    textureBound = this._activeTexture && this._activeTexture.bind(dc);
	  }

	  terrain.beginRendering(dc);

	  for (var idx = 0, len = terrain.surfaceGeometry.length; idx < len; idx++) {
	    var currentTile = terrain.surfaceGeometry[idx]; // Use the vertex origin for the terrain tile.

	    var terrainOrigin = currentTile.referencePoint;
	    program.loadVertexOrigin(gl, terrainOrigin); // Use a tex coord matrix that registers the night texture correctly on each terrain.

	    if (textureBound) {
	      this._texMatrix.setToUnitYFlip();

	      this._texMatrix.multiplyByTileTransform(currentTile.sector, this._fullSphereSector);

	      program.loadTexMatrix(gl, this._texMatrix);
	    }

	    terrain.beginRenderingTile(dc, currentTile); // Draw the tile, multiplying the current fragment color by the program's secondary color.

	    program.loadFragMode(gl, program.FRAGMODE_GROUND_SECONDARY);
	    gl.blendFunc(gl.DST_COLOR, gl.ZERO);
	    terrain.renderTile(dc, currentTile); // Draw the terrain as triangles, adding the current fragment color to the program's primary color.

	    var fragMode = textureBound ? program.FRAGMODE_GROUND_PRIMARY_TEX_BLEND : program.FRAGMODE_GROUND_PRIMARY;
	    program.loadFragMode(gl, fragMode);
	    gl.blendFunc(gl.ONE, gl.ONE);
	    terrain.renderTile(dc, currentTile);
	    terrain.endRenderingTile(dc, currentTile);
	  } // Restore the default WorldWind OpenGL state.


	  terrain.endRendering(dc);
	  gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // Clear references to Gpu resources.

	  this._activeTexture = null;
	}; // Internal. Intentionally not documented.


	AtmosphereLayer.prototype.assembleVertexPoints = function (dc, numLat, numLon, altitude) {
	  var count = numLat * numLon;
	  var altitudes = new Array(count);
	  WWUtil.fillArray(altitudes, altitude);
	  var result = new Float32Array(count * 3);
	  return dc.globe.computePointsForGrid(this._fullSphereSector, numLat, numLon, altitudes, Vec3$1.ZERO, result);
	}; // Internal. Intentionally not documented.


	AtmosphereLayer.prototype.assembleTriStripIndices = function (numLat, numLon) {
	  var result = [];
	  var vertex = 0;

	  for (var latIndex = 0; latIndex < numLat - 1; latIndex++) {
	    // Create a triangle strip joining each adjacent column of vertices, starting in the bottom left corner and
	    // proceeding to the right. The first vertex starts with the left row of vertices and moves right to create
	    // a counterclockwise winding order.
	    for (var lonIndex = 0; lonIndex < numLon; lonIndex++) {
	      vertex = lonIndex + latIndex * numLon;
	      result.push(vertex + numLon);
	      result.push(vertex);
	    } // Insert indices to create 2 degenerate triangles:
	    // - one for the end of the current row, and
	    // - one for the beginning of the next row


	    if (latIndex < numLat - 2) {
	      result.push(vertex);
	      result.push((latIndex + 2) * numLon);
	    }
	  }

	  this._numIndices = result.length;
	  return new Uint16Array(result);
	}; // Internal. Intentionally not documented.


	AtmosphereLayer.prototype.determineLightDirection = function (dc) {
	  if (this.time !== null) {
	    var sunLocation = SunPosition.getAsGeographicLocation(this.time);
	    dc.globe.computePointFromLocation(sunLocation.latitude, sunLocation.longitude, this._activeLightDirection);
	  } else {
	    this._activeLightDirection.copy(dc.eyePoint);
	  }

	  this._activeLightDirection.normalize();
	};

	/**
	 * @exports BasicTimeSequence
	 */
	/**
	 * Constructs a time sequence from an array of Dates.
	 * @alias BasicTimeSequence
	 * @constructor
	 * @classdesc Represents a time sequence described as an array of Date objects as required by WMS.
	 * This class provides iteration over the sequence in steps
	 * specified by the period. If the start and end dates are different, iteration will start at the start
	 * date and end at the end date.
	 * @param {Date[]} dates An array of Date objects.
	 * @throws {ArgumentError} If the specified dates array is null, undefined or has a length less than two.
	 */

	function BasicTimeSequence(dates) {
	  if (!dates && dates.length < 2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "BasicTimeSequence", "constructor", "missingDates"));
	  }
	  /**
	   * This sequence's list of Dates.
	   * @type {Date[]}
	   */


	  this.dates = dates;
	  /**
	   * This sequence's current index.
	   * @type {Number}
	   * @default 0.
	   */

	  this.currentIndex = 0;
	  /**
	   * This sequence's current time.
	   * @type {Date}
	   * @default This sequence's start time.
	   */

	  this.currentTime = dates[0];
	}

	Object.defineProperties(BasicTimeSequence.prototype, {
	  /**
	   * Indicates the position of this sequence's current time relative to the sequence's total interval,
	   * in the range [0, 1]. A value of 0 indicates this sequence's start time. A value of 1 indicates
	   * this sequence's end time. A value of 0.5 indicates a current time that's exactly mid-way between
	   * this sequence's start time and end time.
	   * @type {Number}
	   * @memberof BasicTimeSequence.prototype
	   */
	  scaleForCurrentTime: {
	    get: function () {
	      if (!this.currentTime) {
	        return 1;
	      } else {
	        return this.currentIndex / this.dates.length;
	      }
	    }
	  }
	});
	/**
	 * Sets this sequence's current time to the next time in the sequence and returns that time.
	 * @returns {Date|null} The next time of this sequence, or null if no more times are in the sequence.
	 * Use [reset]{@link BasicTimeSequence#reset} to re-start this sequence.
	 * Use [previous]{@link BasicTimeSequence#previous} to step backwards through this sequence.
	 */

	BasicTimeSequence.prototype.next = function () {
	  if (this.currentIndex >= this.dates.length - 1) {
	    return null;
	  }

	  this.currentIndex++;
	  this.currentTime = this.dates[this.currentIndex];
	  return this.currentTime;
	};
	/**
	 * Sets this sequence's current time to the previous time in the sequence and returns that time.
	 * @returns {Date|null} The previous time of this sequence, or null if the sequence is currently at its start
	 * time.
	 * Use [next]{@link BasicTimeSequence#next} to step forwards through this sequence.
	 */


	BasicTimeSequence.prototype.previous = function () {
	  if (this.currentIndex <= 0) {
	    return null;
	  }

	  this.currentIndex--;
	  this.currentTime = this.dates[this.currentIndex];
	  return this.currentTime;
	};
	/**
	 * Resets this sequence's current time to its start time.
	 * Use [next]{@link BasicTimeSequence#next} to step forwards through this sequence.
	 * Use [previous]{@link BasicTimeSequence#previous} to step backwards through this sequence.
	 */


	BasicTimeSequence.prototype.reset = function () {
	  this.currentIndex = -1;
	  this.currentTime = null;
	};
	/**
	 * Returns the time associated with a specified value in the range [0, 1]. A value of 0 returns this
	 * sequence's start time. A value of 1 returns this sequence's end time. A value of 0.5 returs a time
	 * mid-way between this sequence's start and end times.
	 * @param scale The scale value. This value is clamped to the range [0, 1] before the time is determined.
	 * @returns {Date}
	 */


	BasicTimeSequence.prototype.getTimeForScale = function (scale) {
	  if (scale <= 0) {
	    this.currentIndex = 0;
	  } else if (scale >= 1) {
	    this.currentIndex = this.dates.length - 1;
	  } else {
	    this.currentIndex = Math.floor(this.dates.length * scale);
	  }

	  this.currentTime = this.dates[this.currentIndex];
	  return this.currentTime;
	};

	/**
	 * @exports Touch
	 */

	/**
	 * Constructs a touch point.
	 * @alias Touch
	 * @constructor
	 * @classdesc Represents a touch point.
	 * @param {Color} identifier A number uniquely identifying the touch point
	 * @param {Number} clientX The X coordinate of the touch point's location.
	 * @param {Number} clientY The Y coordinate of the touch point's location.
	 */
	function Touch(identifier, clientX, clientY) {
	  /**
	   * A number uniquely identifying this touch point.
	   * @type {Number}
	   * @readonly
	   */
	  this.identifier = identifier; // Intentionally not documented.

	  this._clientX = clientX; // Intentionally not documented.

	  this._clientY = clientY; // Intentionally not documented.

	  this._clientStartX = clientX; // Intentionally not documented.

	  this._clientStartY = clientY;
	}

	Object.defineProperties(Touch.prototype, {
	  /**
	   * Indicates the X coordinate of this touch point's location.
	   * @type {Number}
	   * @memberof Touch.prototype
	   */
	  clientX: {
	    get: function () {
	      return this._clientX;
	    },
	    set: function (value) {
	      this._clientX = value;
	    }
	  },

	  /**
	   * Indicates the Y coordinate of this touch point's location.
	   * @type {Number}
	   * @memberof Touch.prototype
	   */
	  clientY: {
	    get: function () {
	      return this._clientY;
	    },
	    set: function (value) {
	      this._clientY = value;
	    }
	  },

	  /**
	   * Indicates this touch point's translation along the X axis since the touch started.
	   * @type {Number}
	   * @memberof Touch.prototype
	   */
	  translationX: {
	    get: function () {
	      return this._clientX - this._clientStartX;
	    },
	    set: function (value) {
	      this._clientStartX = this._clientX - value;
	    }
	  },

	  /**
	   * Indicates this touch point's translation along the Y axis since the touch started.
	   * @type {Number}
	   * @memberof Touch.prototype
	   */
	  translationY: {
	    get: function () {
	      return this._clientY - this._clientStartY;
	    },
	    set: function (value) {
	      this._clientStartY = this._clientY - value;
	    }
	  }
	});

	/**
	 * @exports GestureRecognizer
	 */
	/**
	 * Constructs a base gesture recognizer. This is an abstract base class and not intended to be instantiated
	 * directly.
	 * @alias GestureRecognizer
	 * @constructor
	 * @classdesc Gesture recognizers translate user input event streams into higher level actions. A gesture
	 * recognizer is associated with an event target, which dispatches mouse and keyboard events to the gesture
	 * recognizer. When a gesture recognizer has received enough information from the event stream to interpret the
	 * action, it calls its callback functions. Callback functions may be specified at construction or added to the
	 * [gestureCallbacks]{@link GestureRecognizer#gestureCallbacks} list after construction.
	 * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	 * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	 * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	 * e.g., <code>gestureCallback(recognizer)</code>.
	 * @throws {ArgumentError} If the specified target is null or undefined.
	 */
	// TODO: evaluate target usage

	function GestureRecognizer(target, callback) {
	  if (!target) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GestureRecognizer", "constructor", "missingTarget"));
	  }
	  /**
	   * Indicates the document element this gesture recognizer observes for UI events.
	   * @type {EventTarget}
	   * @readonly
	   */


	  this.target = target;
	  /**
	   * Indicates whether or not this gesture recognizer is enabled. When false, this gesture recognizer will
	   * ignore any events dispatched by its target.
	   * @type {Boolean}
	   * @default true
	   */

	  this.enabled = true; // Documented with its property accessor below.

	  this._state = WorldWind.POSSIBLE; // Intentionally not documented.

	  this._nextState = null; // Documented with its property accessor below.

	  this._clientX = 0; // Documented with its property accessor below.

	  this._clientY = 0; // Intentionally not documented.

	  this._clientStartX = 0; // Intentionally not documented.

	  this._clientStartY = 0; // Documented with its property accessor below.

	  this._translationX = 0; // Documented with its property accessor below.

	  this._translationY = 0; // Intentionally not documented.

	  this._translationWeight = 0.4; // Documented with its property accessor below.

	  this._mouseButtonMask = 0; // Intentionally not documented.

	  this._touches = []; // Intentionally not documented.

	  this._touchCentroidShiftX = 0; // Intentionally not documented.

	  this._touchCentroidShiftY = 0; // Documented with its property accessor below.

	  this._gestureCallbacks = []; // Intentionally not documented.

	  this._canRecognizeWith = []; // Intentionally not documented.

	  this._requiresFailureOf = []; // Intentionally not documented.

	  this._requiredToFailBy = []; // Add the optional gesture callback.

	  if (callback) {
	    this._gestureCallbacks.push(callback);
	  } // Intentionally not documented.


	  this.listenerList = []; // Add this recognizer to the list of all recognizers.

	  GestureRecognizer.allRecognizers.push(this);
	} // Intentionally not documented.


	GestureRecognizer.allRecognizers = [];
	Object.defineProperties(GestureRecognizer.prototype, {
	  /**
	   * Indicates this gesture's current state. Possible values are WorldWind.POSSIBLE, WorldWind.FAILED,
	   * WorldWind.RECOGNIZED, WorldWind.BEGAN, WorldWind.CHANGED, WorldWind.CANCELLED and WorldWind.ENDED.
	   * @type {String}
	   * @default WorldWind.POSSIBLE
	   * @memberof GestureRecognizer.prototype
	   */
	  state: {
	    get: function () {
	      return this._state;
	    },
	    set: function (value) {
	      this.transitionToState(value);
	    }
	  },

	  /**
	   * Indicates the X coordinate of this gesture.
	   * @type {Number}
	   * @memberof GestureRecognizer.prototype
	   */
	  clientX: {
	    get: function () {
	      return this._clientX;
	    },
	    set: function (value) {
	      this._clientX = value;
	    }
	  },

	  /**
	   * Returns the Y coordinate of this gesture.
	   * @type {Number}
	   * @memberof GestureRecognizer.prototype
	   */
	  clientY: {
	    get: function () {
	      return this._clientY;
	    },
	    set: function (value) {
	      this._clientY = value;
	    }
	  },

	  /**
	   * Indicates this gesture's translation along the X axis since the gesture started.
	   * @type {Number}
	   * @memberof GestureRecognizer.prototype
	   */
	  translationX: {
	    get: function () {
	      return this._translationX;
	    },
	    set: function (value) {
	      this._translationX = value;
	      this._clientStartX = this._clientX;
	      this._touchCentroidShiftX = 0;
	    }
	  },

	  /**
	   * Indicates this gesture's translation along the Y axis since the gesture started.
	   * @type {Number}
	   * @memberof GestureRecognizer.prototype
	   */
	  translationY: {
	    get: function () {
	      return this._translationY;
	    },
	    set: function (value) {
	      this._translationY = value;
	      this._clientStartY = this._clientY;
	      this._touchCentroidShiftY = 0;
	    }
	  },

	  /**
	   * Indicates the currently pressed mouse buttons as a bitmask. A value of 0 indicates that no buttons are
	   * pressed. A nonzero value indicates that one or more buttons are pressed as follows: bit 1 indicates the
	   * primary button, bit 2 indicates the the auxiliary button, bit 3 indicates the secondary button.
	   * @type {Number}
	   * @readonly
	   * @memberof GestureRecognizer.prototype
	   */
	  mouseButtonMask: {
	    get: function () {
	      return this._mouseButtonMask;
	    }
	  },

	  /**
	   * Indicates the number of active touches.
	   * @type {Number}
	   * @readonly
	   * @memberof GestureRecognizer.prototype
	   */
	  touchCount: {
	    get: function () {
	      return this._touches.length;
	    }
	  },

	  /**
	   * The list of functions to call when this gesture is recognized. The functions have a single argument:
	   * this gesture recognizer, e.g., <code>gestureCallback(recognizer)</code>. Applications may
	   * add functions to this array or remove them.
	   * @type {Function[]}
	   * @readonly
	   * @memberof GestureRecognizer.prototype
	   */
	  gestureCallbacks: {
	    get: function () {
	      return this._gestureCallbacks;
	    }
	  }
	});
	/**
	 *
	 * @param index
	 * @returns {Touch}
	 * @throws {ArgumentError} If the index is out of range.
	 */

	GestureRecognizer.prototype.touch = function (index) {
	  if (index < 0 || index >= this._touches.length) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GestureRecognizer", "touch", "indexOutOfRange"));
	  }

	  return this._touches[index];
	};
	/**
	 *
	 * @param recognizer
	 */


	GestureRecognizer.prototype.recognizeSimultaneouslyWith = function (recognizer) {
	  if (!recognizer) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GestureRecognizer", "recognizeSimultaneouslyWith", "The specified gesture recognizer is null or undefined."));
	  }

	  var index = this._canRecognizeWith.indexOf(recognizer);

	  if (index == -1) {
	    this._canRecognizeWith.push(recognizer);

	    recognizer._canRecognizeWith.push(this);
	  }
	};
	/**
	 *
	 * @param recognizer
	 * @returns {Boolean}
	 */


	GestureRecognizer.prototype.canRecognizeSimultaneouslyWith = function (recognizer) {
	  var index = this._canRecognizeWith.indexOf(recognizer);

	  return index != -1;
	};
	/**
	 *
	 * @param recognizer
	 */


	GestureRecognizer.prototype.requireRecognizerToFail = function (recognizer) {
	  if (!recognizer) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GestureRecognizer", "requireRecognizerToFail", "The specified gesture recognizer is null or undefined"));
	  }

	  var index = this._requiresFailureOf.indexOf(recognizer);

	  if (index == -1) {
	    this._requiresFailureOf.push(recognizer);

	    recognizer._requiredToFailBy.push(this);
	  }
	};
	/**
	 *
	 * @param recognizer
	 * @returns {Boolean}
	 */


	GestureRecognizer.prototype.requiresRecognizerToFail = function (recognizer) {
	  var index = this._requiresFailureOf.indexOf(recognizer);

	  return index != -1;
	};
	/**
	 *
	 * @param recognizer
	 * @returns {Boolean}
	 */


	GestureRecognizer.prototype.requiredToFailByRecognizer = function (recognizer) {
	  var index = this._requiredToFailBy.indexOf(recognizer);

	  return index != -1;
	};
	/**
	 * @protected
	 */


	GestureRecognizer.prototype.reset = function () {
	  this._state = WorldWind.POSSIBLE;
	  this._nextState = null;
	  this._clientX = 0;
	  this._clientY = 0;
	  this._clientStartX = 0;
	  this._clientStartY = 0;
	  this._translationX = 0;
	  this._translationY = 0;
	  this._mouseButtonMask = 0;
	  this._touches = [];
	  this._touchCentroidShiftX = 0;
	  this._touchCentroidShiftY = 0;
	};
	/**
	 * @protected
	 */


	GestureRecognizer.prototype.prepareToRecognize = function () {};
	/**
	 *
	 * @param event
	 * @protected
	 */


	GestureRecognizer.prototype.mouseDown = function (event) {};
	/**
	 *
	 * @param event
	 * @protected
	 */


	GestureRecognizer.prototype.mouseMove = function (event) {};
	/**
	 *
	 * @param event
	 * @protected
	 */


	GestureRecognizer.prototype.mouseUp = function (event) {};
	/**
	 *
	 * @param touch
	 * @protected
	 */


	GestureRecognizer.prototype.touchStart = function (touch) {};
	/**
	 *
	 * @param touch
	 * @protected
	 */


	GestureRecognizer.prototype.touchMove = function (touch) {};
	/**
	 *
	 * @param touch
	 * @protected
	 */


	GestureRecognizer.prototype.touchCancel = function (touch) {};
	/**
	 *
	 * @param touch
	 * @protected
	 */


	GestureRecognizer.prototype.touchEnd = function (touch) {}; // Intentionally not documented.


	GestureRecognizer.prototype.transitionToState = function (newState) {
	  this._nextState = null; // clear any pending state transition

	  if (newState === WorldWind.FAILED) {
	    this._state = newState;
	    this.updateRecognizersWaitingForFailure();
	    this.resetIfEventsEnded();
	  } else if (newState === WorldWind.RECOGNIZED) {
	    this.tryToRecognize(newState); // may prevent the transition to Recognized

	    if (this._state === newState) {
	      this.prepareToRecognize();
	      this.notifyListeners();
	      this.callGestureCallbacks();
	      this.resetIfEventsEnded();
	    }
	  } else if (newState === WorldWind.BEGAN) {
	    this.tryToRecognize(newState); // may prevent the transition to Began

	    if (this._state === newState) {
	      this.prepareToRecognize();
	      this.notifyListeners();
	      this.callGestureCallbacks();
	    }
	  } else if (newState === WorldWind.CHANGED) {
	    this._state = newState;
	    this.notifyListeners();
	    this.callGestureCallbacks();
	  } else if (newState === WorldWind.CANCELLED) {
	    this._state = newState;
	    this.notifyListeners();
	    this.callGestureCallbacks();
	    this.resetIfEventsEnded();
	  } else if (newState === WorldWind.ENDED) {
	    this._state = newState;
	    this.notifyListeners();
	    this.callGestureCallbacks();
	    this.resetIfEventsEnded();
	  }
	}; // Intentionally not documented.


	GestureRecognizer.prototype.updateRecognizersWaitingForFailure = function () {
	  // Transition gestures that are waiting for this gesture to transition to Failed.
	  for (var i = 0, len = this._requiredToFailBy.length; i < len; i++) {
	    var recognizer = this._requiredToFailBy[i];

	    if (recognizer._nextState != null) {
	      recognizer.transitionToState(recognizer._nextState);
	    }
	  }
	}; // Intentionally not documented.


	GestureRecognizer.prototype.tryToRecognize = function (newState) {
	  // Transition to Failed if another gesture can prevent this gesture from recognizing.
	  if (GestureRecognizer.allRecognizers.some(this.canBePreventedByRecognizer, this)) {
	    this.transitionToState(WorldWind.FAILED);
	    return;
	  } // Delay the transition to Recognized/Began if this gesture is waiting for a gesture in the Possible state.


	  if (GestureRecognizer.allRecognizers.some(this.isWaitingForRecognizerToFail, this)) {
	    this._nextState = newState;
	    return;
	  } // Transition to Failed all other gestures that can be prevented from recognizing by this gesture.


	  var prevented = GestureRecognizer.allRecognizers.filter(this.canPreventRecognizer, this);

	  for (var i = 0, len = prevented.length; i < len; i++) {
	    prevented[i].transitionToState(WorldWind.FAILED);
	  }

	  this._state = newState;
	}; // Intentionally not documented.


	GestureRecognizer.prototype.canPreventRecognizer = function (that) {
	  return this != that && this.target == that.target && that.state == WorldWind.POSSIBLE && (this.requiredToFailByRecognizer(that) || !this.canRecognizeSimultaneouslyWith(that));
	}; // Intentionally not documented.


	GestureRecognizer.prototype.canBePreventedByRecognizer = function (that) {
	  return this != that && this.target == that.target && that.state == WorldWind.RECOGNIZED && (this.requiresRecognizerToFail(that) || !this.canRecognizeSimultaneouslyWith(that));
	}; // Intentionally not documented.


	GestureRecognizer.prototype.isWaitingForRecognizerToFail = function (that) {
	  return this != that && this.target == that.target && that.state == WorldWind.POSSIBLE && this.requiresRecognizerToFail(that);
	};
	/**
	 * Registers a gesture state listener on this GestureRecognizer. Registering state listeners using this function
	 * enables applications to receive notifications of gesture recognition.
	 *
	 * Listeners must implement a gestureStateChanged method to receive notifications. The gestureStateChanged method will
	 * receive one parameter containing a reference to the recognizer that changed state.
	 *
	 * @param listener The function to call when the event occurs.
	 * @throws {ArgumentError} If any argument is null or undefined.
	 */


	GestureRecognizer.prototype.addListener = function (listener) {
	  if (!listener) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GestureRecognizer", "addListener", "missingListener"));
	  }

	  this.listenerList.push(listener);
	};
	/**
	 * Removes a gesture state listener from this GestureRecognizer. The listener must be the same object passed to
	 * addListener. Calling removeListener with arguments that do not identify a currently registered
	 * listener has no effect.
	 *
	 * @param listener The listener to remove. Must be the same object passed to addListener.
	 * @throws {ArgumentError} If any argument is null or undefined.
	 */


	GestureRecognizer.prototype.removeListener = function (listener) {
	  if (!listener) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GestureRecognizer", "removeListener", "missingListener"));
	  }

	  var index = this.listenerList.indexOf(listener);

	  if (index !== -1) {
	    this.listenerList.splice(index, 1); // remove the listener from the list
	  }
	}; // Intentionally not documented.


	GestureRecognizer.prototype.notifyListeners = function () {
	  for (var i = 0; i < this.listenerList.length; i++) {
	    this.listenerList[i].gestureStateChanged(this);
	  }
	}; // Intentionally not documented.


	GestureRecognizer.prototype.callGestureCallbacks = function () {
	  for (var i = 0, len = this._gestureCallbacks.length; i < len; i++) {
	    this._gestureCallbacks[i](this);
	  }
	}; // Intentionally not documented.


	GestureRecognizer.prototype.onGestureEvent = function (event) {
	  if (!this.enabled) {
	    return;
	  }

	  if (event.defaultPrevented && this.state === WorldWind.POSSIBLE) {
	    return; // ignore cancelled events while in the Possible state
	  }

	  var i, len;

	  try {
	    if (event.type === "mousedown") {
	      this.handleMouseDown(event);
	    } else if (event.type === "mousemove") {
	      this.handleMouseMove(event);
	    } else if (event.type === "mouseup") {
	      this.handleMouseUp(event);
	    } else if (event.type === "touchstart") {
	      for (i = 0, len = event.changedTouches.length; i < len; i++) {
	        this.handleTouchStart(event.changedTouches.item(i));
	      }
	    } else if (event.type === "touchmove") {
	      for (i = 0, len = event.changedTouches.length; i < len; i++) {
	        this.handleTouchMove(event.changedTouches.item(i));
	      }
	    } else if (event.type === "touchcancel") {
	      for (i = 0, len = event.changedTouches.length; i < len; i++) {
	        this.handleTouchCancel(event.changedTouches.item(i));
	      }
	    } else if (event.type === "touchend") {
	      for (i = 0, len = event.changedTouches.length; i < len; i++) {
	        this.handleTouchEnd(event.changedTouches.item(i));
	      }
	    } else if (event.type === "pointerdown" && event.pointerType === "mouse") {
	      this.handleMouseDown(event);
	    } else if (event.type === "pointermove" && event.pointerType === "mouse") {
	      this.handleMouseMove(event);
	    } else if (event.type === "pointercancel" && event.pointerType === "mouse") {// Intentionally left blank. The W3C Pointer Events specification is ambiguous on what cancel means
	      // for mouse input, and there is no evidence that this event is actually generated (6/19/2015).
	    } else if (event.type === "pointerup" && event.pointerType === "mouse") {
	      this.handleMouseUp(event);
	    } else if (event.type === "pointerdown" && event.pointerType === "touch") {
	      this.handleTouchStart(event);
	    } else if (event.type === "pointermove" && event.pointerType === "touch") {
	      this.handleTouchMove(event);
	    } else if (event.type === "pointercancel" && event.pointerType === "touch") {
	      this.handleTouchCancel(event);
	    } else if (event.type === "pointerup" && event.pointerType === "touch") {
	      this.handleTouchEnd(event);
	    } else {
	      Logger$1.logMessage(Logger$1.LEVEL_INFO, "GestureRecognizer", "handleEvent", "Unrecognized event type: " + event.type);
	    }
	  } catch (e) {
	    Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GestureRecognizer", "handleEvent", "Error handling event.\n" + e.toString());
	  }
	}; // Intentionally not documented.


	GestureRecognizer.prototype.handleMouseDown = function (event) {
	  if (event.type == "mousedown" && this._touches.length > 0) {
	    return; // ignore synthesized mouse down events on Android Chrome
	  }

	  var buttonBit = 1 << event.button;

	  if (buttonBit & this._mouseButtonMask != 0) {
	    return; // ignore redundant mouse down events
	  }

	  if (this._mouseButtonMask == 0) {
	    // first button down
	    this._clientX = event.clientX;
	    this._clientY = event.clientY;
	    this._clientStartX = event.clientX;
	    this._clientStartY = event.clientY;
	    this._translationX = 0;
	    this._translationY = 0;
	  }

	  this._mouseButtonMask |= buttonBit;
	  this.mouseDown(event);
	}; // Intentionally not documented.


	GestureRecognizer.prototype.handleMouseMove = function (event) {
	  if (this._mouseButtonMask == 0) {
	    return; // ignore mouse move events when this recognizer does not consider any button to be down
	  }

	  if (this._clientX == event.clientX && this._clientY == event._clientY) {
	    return; // ignore redundant mouse move events
	  }

	  var dx = event.clientX - this._clientStartX,
	      dy = event.clientY - this._clientStartY,
	      w = this._translationWeight;
	  this._clientX = event.clientX;
	  this._clientY = event.clientY;
	  this._translationX = this._translationX * (1 - w) + dx * w;
	  this._translationY = this._translationY * (1 - w) + dy * w;
	  this.mouseMove(event);
	}; // Intentionally not documented.


	GestureRecognizer.prototype.handleMouseUp = function (event) {
	  var buttonBit = 1 << event.button;

	  if (buttonBit & this._mouseButtonMask == 0) {
	    return; // ignore mouse up events for buttons this recognizer does not consider to be down
	  }

	  this._mouseButtonMask &= ~buttonBit;
	  this.mouseUp(event);

	  if (this._mouseButtonMask == 0) {
	    this.resetIfEventsEnded(); // last button up
	  }
	}; // Intentionally not documented.


	GestureRecognizer.prototype.handleTouchStart = function (event) {
	  var touch = new Touch(event.identifier || event.pointerId, event.clientX, event.clientY); // touch events or pointer events

	  this._touches.push(touch);

	  if (this._touches.length == 1) {
	    // first touch
	    this._clientX = event.clientX;
	    this._clientY = event.clientY;
	    this._clientStartX = event.clientX;
	    this._clientStartY = event.clientY;
	    this._translationX = 0;
	    this._translationY = 0;
	    this._touchCentroidShiftX = 0;
	    this._touchCentroidShiftY = 0;
	  } else {
	    this.touchesAddedOrRemoved();
	  }

	  this.touchStart(touch);
	}; // Intentionally not documented.


	GestureRecognizer.prototype.handleTouchMove = function (event) {
	  var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events

	  if (index == -1) {
	    return; // ignore events for touches that did not start in this recognizer's target
	  }

	  var touch = this._touches[index];

	  if (touch.clientX == event.clientX && touch.clientY == event.clientY) {
	    return; // ignore redundant touch move events, which we've encountered on Android Chrome
	  }

	  touch.clientX = event.clientX;
	  touch.clientY = event.clientY;
	  var centroid = this.touchCentroid(),
	      dx = centroid.clientX - this._clientStartX + this._touchCentroidShiftX,
	      dy = centroid.clientY - this._clientStartY + this._touchCentroidShiftY,
	      w = this._translationWeight;
	  this._clientX = centroid.clientX;
	  this._clientY = centroid.clientY;
	  this._translationX = this._translationX * (1 - w) + dx * w;
	  this._translationY = this._translationY * (1 - w) + dy * w;
	  this.touchMove(touch);
	}; // Intentionally not documented.


	GestureRecognizer.prototype.handleTouchCancel = function (event) {
	  var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events

	  if (index == -1) {
	    return; // ignore events for touches that did not start in this recognizer's target
	  }

	  var touch = this._touches[index];

	  this._touches.splice(index, 1);

	  this.touchesAddedOrRemoved();
	  this.touchCancel(touch);
	  this.resetIfEventsEnded();
	}; // Intentionally not documented.


	GestureRecognizer.prototype.handleTouchEnd = function (event) {
	  var index = this.indexOfTouchWithId(event.identifier || event.pointerId); // touch events or pointer events

	  if (index == -1) {
	    return; // ignore events for touches that did not start in this recognizer's target
	  }

	  var touch = this._touches[index];

	  this._touches.splice(index, 1);

	  this.touchesAddedOrRemoved();
	  this.touchEnd(touch);
	  this.resetIfEventsEnded();
	}; // Intentionally not documented.


	GestureRecognizer.prototype.resetIfEventsEnded = function () {
	  if (this._state != WorldWind.POSSIBLE && this._mouseButtonMask == 0 && this._touches.length == 0) {
	    this.reset();
	  }
	}; // Intentionally not documented.


	GestureRecognizer.prototype.touchesAddedOrRemoved = function () {
	  this._touchCentroidShiftX += this._clientX;
	  this._touchCentroidShiftY += this._clientY;
	  var centroid = this.touchCentroid();
	  this._clientX = centroid.clientX;
	  this._clientY = centroid.clientY;
	  this._touchCentroidShiftX -= this._clientX;
	  this._touchCentroidShiftY -= this._clientY;
	}; // Intentionally not documented.


	GestureRecognizer.prototype.touchCentroid = function () {
	  var x = 0,
	      y = 0;

	  for (var i = 0, len = this._touches.length; i < len; i++) {
	    var touch = this._touches[i];
	    x += touch.clientX / len;
	    y += touch.clientY / len;
	  }

	  return {
	    clientX: x,
	    clientY: y
	  };
	}; // Intentionally not documented.


	GestureRecognizer.prototype.indexOfTouchWithId = function (identifier) {
	  for (var i = 0, len = this._touches.length; i < len; i++) {
	    if (this._touches[i].identifier == identifier) {
	      return i;
	    }
	  }

	  return -1;
	};

	/**
	 * @exports DragRecognizer
	 */
	/**
	 * Constructs a mouse drag gesture recognizer.
	 * @alias DragRecognizer
	 * @constructor
	 * @augments GestureRecognizer
	 * @classdesc A concrete gesture recognizer subclass that looks for mouse drag gestures.
	 * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	 * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	 * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	 * e.g., <code>gestureCallback(recognizer)</code>.
	 * @throws {ArgumentError} If the specified target is null or undefined.
	 */

	function DragRecognizer(target, callback) {
	  GestureRecognizer.call(this, target, callback);
	  /**
	   *
	   * @type {Number}
	   */

	  this.button = 0; // Intentionally not documented.

	  this.interpretDistance = 5;
	}

	DragRecognizer.prototype = Object.create(GestureRecognizer.prototype); // Documented in superclass.

	DragRecognizer.prototype.mouseMove = function (event) {
	  if (this.state == WorldWind.POSSIBLE) {
	    if (this.shouldInterpret()) {
	      if (this.shouldRecognize()) {
	        this.translationX = 0; // set translation to zero when the drag begins

	        this.translationY = 0;
	        this.state = WorldWind.BEGAN;
	      } else {
	        this.state = WorldWind.FAILED;
	      }
	    }
	  } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	    this.state = WorldWind.CHANGED;
	  }
	}; // Documented in superclass.


	DragRecognizer.prototype.mouseUp = function (event) {
	  if (this.mouseButtonMask == 0) {
	    // last button up
	    if (this.state == WorldWind.POSSIBLE) {
	      this.state = WorldWind.FAILED;
	    } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	      this.state = WorldWind.ENDED;
	    }
	  }
	}; // Documented in superclass.


	DragRecognizer.prototype.touchStart = function (touch) {
	  if (this.state == WorldWind.POSSIBLE) {
	    this.state = WorldWind.FAILED; // mouse gestures fail upon receiving a touch event
	  }
	};
	/**
	 *
	 * @returns {Boolean}
	 * @protected
	 */


	DragRecognizer.prototype.shouldInterpret = function () {
	  var dx = this.translationX,
	      dy = this.translationY,
	      distance = Math.sqrt(dx * dx + dy * dy);
	  return distance > this.interpretDistance; // interpret mouse movement when the cursor moves far enough
	};
	/**
	 *
	 * @returns {Boolean}
	 * @protected
	 */


	DragRecognizer.prototype.shouldRecognize = function () {
	  var buttonBit = 1 << this.button;
	  return buttonBit == this.mouseButtonMask; // true when the specified button is the only button down
	};

	/**
	 * @exports PanRecognizer
	 */
	/**
	 * Constructs a pan gesture recognizer.
	 * @alias PanRecognizer
	 * @constructor
	 * @augments GestureRecognizer
	 * @classdesc A concrete gesture recognizer subclass that looks for touch panning gestures.
	 * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	 * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	 * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	 * e.g., <code>gestureCallback(recognizer)</code>.
	 * @throws {ArgumentError} If the specified target is null or undefined.
	 */

	function PanRecognizer(target, callback) {
	  GestureRecognizer.call(this, target, callback);
	  /**
	   *
	   * @type {Number}
	   */

	  this.minNumberOfTouches = 1;
	  /**
	   *
	   * @type {Number}
	   */

	  this.maxNumberOfTouches = Number.MAX_VALUE; // Intentionally not documented.

	  this.interpretDistance = 20;
	}

	PanRecognizer.prototype = Object.create(GestureRecognizer.prototype); // Documented in superclass.

	PanRecognizer.prototype.mouseDown = function (event) {
	  if (this.state == WorldWind.POSSIBLE) {
	    this.state = WorldWind.FAILED; // touch gestures fail upon receiving a mouse event
	  }
	}; // Documented in superclass.


	PanRecognizer.prototype.touchMove = function (touch) {
	  if (this.state == WorldWind.POSSIBLE) {
	    if (this.shouldInterpret()) {
	      if (this.shouldRecognize()) {
	        this.state = WorldWind.BEGAN;
	      } else {
	        this.state = WorldWind.FAILED;
	      }
	    }
	  } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	    this.state = WorldWind.CHANGED;
	  }
	}; // Documented in superclass.


	PanRecognizer.prototype.touchEnd = function (touch) {
	  if (this.touchCount == 0) {
	    // last touch ended
	    if (this.state == WorldWind.POSSIBLE) {
	      this.state = WorldWind.FAILED;
	    } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	      this.state = WorldWind.ENDED;
	    }
	  }
	}; // Documented in superclass.


	PanRecognizer.prototype.touchCancel = function (touch) {
	  if (this.touchCount == 0) {
	    // last touch cancelled
	    if (this.state == WorldWind.POSSIBLE) {
	      this.state = WorldWind.FAILED;
	    } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	      this.state = WorldWind.CANCELLED;
	    }
	  }
	}; // Documented in superclass.


	PanRecognizer.prototype.prepareToRecognize = function () {
	  // set translation to zero when the pan begins
	  this.translationX = 0;
	  this.translationY = 0;
	};
	/**
	 *
	 * @returns {boolean}
	 * @protected
	 */


	PanRecognizer.prototype.shouldInterpret = function () {
	  var dx = this.translationX,
	      dy = this.translationY,
	      distance = Math.sqrt(dx * dx + dy * dy);
	  return distance > this.interpretDistance; // interpret touches when the touch centroid moves far enough
	};
	/**
	 *
	 * @returns {boolean}
	 * @protected
	 */


	PanRecognizer.prototype.shouldRecognize = function () {
	  var touchCount = this.touchCount;
	  return touchCount != 0 && touchCount >= this.minNumberOfTouches && touchCount <= this.maxNumberOfTouches;
	};

	/**
	 * @exports PinchRecognizer
	 */
	/**
	 * Constructs a pinch gesture recognizer.
	 * @alias PinchRecognizer
	 * @constructor
	 * @augments GestureRecognizer
	 * @classdesc A concrete gesture recognizer subclass that looks for two finger pinch gestures.
	 * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	 * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	 * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	 * e.g., <code>gestureCallback(recognizer)</code>.
	 * @throws {ArgumentError} If the specified target is null or undefined.
	 */

	function PinchRecognizer(target, callback) {
	  GestureRecognizer.call(this, target, callback); // Intentionally not documented.

	  this._scale = 1; // Intentionally not documented.

	  this._offsetScale = 1; // Intentionally not documented.

	  this.referenceDistance = 0; // Intentionally not documented.

	  this.interpretThreshold = 20; // Intentionally not documented.

	  this.weight = 0.4; // Intentionally not documented.

	  this.pinchTouches = [];
	}

	PinchRecognizer.prototype = Object.create(GestureRecognizer.prototype);
	Object.defineProperties(PinchRecognizer.prototype, {
	  scale: {
	    get: function () {
	      return this._scale * this._offsetScale;
	    }
	  }
	}); // Documented in superclass.

	PinchRecognizer.prototype.reset = function () {
	  GestureRecognizer.prototype.reset.call(this);
	  this._scale = 1;
	  this._offsetScale = 1;
	  this.referenceDistance = 0;
	  this.pinchTouches = [];
	}; // Documented in superclass.


	PinchRecognizer.prototype.mouseDown = function (event) {
	  if (this.state == WorldWind.POSSIBLE) {
	    this.state = WorldWind.FAILED; // touch gestures fail upon receiving a mouse event
	  }
	}; // Documented in superclass.


	PinchRecognizer.prototype.touchStart = function (touch) {
	  if (this.pinchTouches.length < 2) {
	    if (this.pinchTouches.push(touch) == 2) {
	      this.referenceDistance = this.currentPinchDistance();
	      this._offsetScale *= this._scale;
	      this._scale = 1;
	    }
	  }
	}; // Documented in superclass.


	PinchRecognizer.prototype.touchMove = function (touch) {
	  if (this.pinchTouches.length == 2) {
	    if (this.state == WorldWind.POSSIBLE) {
	      if (this.shouldRecognize()) {
	        this.state = WorldWind.BEGAN;
	      }
	    } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	      var distance = this.currentPinchDistance(),
	          newScale = Math.abs(distance / this.referenceDistance),
	          w = this.weight;
	      this._scale = this._scale * (1 - w) + newScale * w;
	      this.state = WorldWind.CHANGED;
	    }
	  }
	}; // Documented in superclass.


	PinchRecognizer.prototype.touchEnd = function (touch) {
	  var index = this.pinchTouches.indexOf(touch);

	  if (index != -1) {
	    this.pinchTouches.splice(index, 1);
	  } // Transition to the ended state if this was the last touch.


	  if (this.touchCount == 0) {
	    // last touch ended
	    if (this.state == WorldWind.POSSIBLE) {
	      this.state = WorldWind.FAILED;
	    } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	      this.state = WorldWind.ENDED;
	    }
	  }
	}; // Documented in superclass.


	PinchRecognizer.prototype.touchCancel = function (touch) {
	  var index = this.pinchTouches.indexOf(touch);

	  if (index != -1) {
	    this.pinchTouches.splice(index, 1);
	  } // Transition to the cancelled state if this was the last touch.


	  if (this.touchCount == 0) {
	    if (this.state == WorldWind.POSSIBLE) {
	      this.state = WorldWind.FAILED;
	    } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	      this.state = WorldWind.CANCELLED;
	    }
	  }
	}; // Documented in superclass.


	PinchRecognizer.prototype.prepareToRecognize = function () {
	  this.referenceDistance = this.currentPinchDistance();
	  this._scale = 1;
	}; // Intentionally not documented.


	PinchRecognizer.prototype.shouldRecognize = function () {
	  var distance = this.currentPinchDistance();
	  return Math.abs(distance - this.referenceDistance) > this.interpretThreshold;
	}; // Intentionally not documented.


	PinchRecognizer.prototype.currentPinchDistance = function () {
	  var touch0 = this.pinchTouches[0],
	      touch1 = this.pinchTouches[1],
	      dx = touch0.clientX - touch1.clientX,
	      dy = touch0.clientY - touch1.clientY;
	  return Math.sqrt(dx * dx + dy * dy);
	};

	/**
	 * @exports RotationRecognizer
	 */
	/**
	 * Constructs a rotation gesture recognizer.
	 * @alias RotationRecognizer
	 * @constructor
	 * @augments GestureRecognizer
	 * @classdesc A concrete gesture recognizer subclass that looks for two finger rotation gestures.
	 * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	 * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	 * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	 * e.g., <code>gestureCallback(recognizer)</code>.
	 * @throws {ArgumentError} If the specified target is null or undefined.
	 */

	function RotationRecognizer(target, callback) {
	  GestureRecognizer.call(this, target, callback); // Intentionally not documented.

	  this._rotation = 0; // Intentionally not documented.

	  this._offsetRotation = 0; // Intentionally not documented.

	  this.referenceAngle = 0; // Intentionally not documented.

	  this.interpretThreshold = 20; // Intentionally not documented.

	  this.weight = 0.4; // Intentionally not documented.

	  this.rotationTouches = [];
	}

	RotationRecognizer.prototype = Object.create(GestureRecognizer.prototype);
	Object.defineProperties(RotationRecognizer.prototype, {
	  rotation: {
	    get: function () {
	      return this._rotation + this._offsetRotation;
	    }
	  }
	}); // Documented in superclass.

	RotationRecognizer.prototype.reset = function () {
	  GestureRecognizer.prototype.reset.call(this);
	  this._rotation = 0;
	  this._offsetRotation = 0;
	  this.referenceAngle = 0;
	  this.rotationTouches = [];
	}; // Documented in superclass.


	RotationRecognizer.prototype.mouseDown = function (event) {
	  if (this.state == WorldWind.POSSIBLE) {
	    this.state = WorldWind.FAILED; // touch gestures fail upon receiving a mouse event
	  }
	}; // Documented in superclass.


	RotationRecognizer.prototype.touchStart = function (touch) {
	  if (this.rotationTouches.length < 2) {
	    if (this.rotationTouches.push(touch) == 2) {
	      this.referenceAngle = this.currentTouchAngle();
	      this._offsetRotation += this._rotation;
	      this._rotation = 0;
	    }
	  }
	}; // Documented in superclass.


	RotationRecognizer.prototype.touchMove = function (touch) {
	  if (this.rotationTouches.length == 2) {
	    if (this.state == WorldWind.POSSIBLE) {
	      if (this.shouldRecognize()) {
	        this.state = WorldWind.BEGAN;
	      }
	    } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	      var angle = this.currentTouchAngle(),
	          newRotation = Angle.normalizedDegrees(angle - this.referenceAngle),
	          w = this.weight;
	      this._rotation = this._rotation * (1 - w) + newRotation * w;
	      this.state = WorldWind.CHANGED;
	    }
	  }
	}; // Documented in superclass.


	RotationRecognizer.prototype.touchEnd = function (touch) {
	  var index = this.rotationTouches.indexOf(touch);

	  if (index != -1) {
	    this.rotationTouches.splice(index, 1);
	  } // Transition to the ended state if this was the last touch.


	  if (this.touchCount == 0) {
	    // last touch ended
	    if (this.state == WorldWind.POSSIBLE) {
	      this.state = WorldWind.FAILED;
	    } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	      this.state = WorldWind.ENDED;
	    }
	  }
	}; // Documented in superclass.


	RotationRecognizer.prototype.touchCancel = function (touch) {
	  var index = this.rotationTouches.indexOf(touch);

	  if (index != -1) {
	    this.rotationTouches.splice(index, 1); // Transition to the cancelled state if this was the last touch.

	    if (this.touchCount == 0) {
	      if (this.state == WorldWind.POSSIBLE) {
	        this.state = WorldWind.FAILED;
	      } else if (this.state == WorldWind.BEGAN || this.state == WorldWind.CHANGED) {
	        this.state = WorldWind.CANCELLED;
	      }
	    }
	  }
	}; // Documented in superclass.


	RotationRecognizer.prototype.prepareToRecognize = function () {
	  this.referenceAngle = this.currentTouchAngle();
	  this._rotation = 0;
	}; // Intentionally not documented.


	RotationRecognizer.prototype.shouldRecognize = function () {
	  var angle = this.currentTouchAngle(),
	      rotation = Angle.normalizedDegrees(angle - this.referenceAngle);
	  return Math.abs(rotation) > this.interpretThreshold;
	}; // Intentionally not documented.


	RotationRecognizer.prototype.currentTouchAngle = function () {
	  var touch0 = this.rotationTouches[0],
	      touch1 = this.rotationTouches[1],
	      dx = touch0.clientX - touch1.clientX,
	      dy = touch0.clientY - touch1.clientY;
	  return Math.atan2(dy, dx) * Angle.RADIANS_TO_DEGREES;
	};

	/**
	 * @exports TiltRecognizer
	 */
	/**
	 * Constructs a tilt gesture recognizer.
	 * @alias TiltRecognizer
	 * @constructor
	 * @augments PanRecognizer
	 * @classdesc A concrete gesture recognizer subclass that looks for two finger tilt gestures.
	 * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	 * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	 * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	 * e.g., <code>gestureCallback(recognizer)</code>.
	 * @throws {ArgumentError} If the specified target is null or undefined.
	 */

	function TiltRecognizer(target, callback) {
	  PanRecognizer.call(this, target, callback); // Intentionally not documented.

	  this.maxTouchDistance = 250; // Intentionally not documented.

	  this.maxTouchDivergence = 50;
	} // Intentionally not documented.


	TiltRecognizer.LEFT = 1 << 0; // Intentionally not documented.

	TiltRecognizer.RIGHT = 1 << 1; // Intentionally not documented.

	TiltRecognizer.UP = 1 << 2; // Intentionally not documented.

	TiltRecognizer.DOWN = 1 << 3;
	TiltRecognizer.prototype = Object.create(PanRecognizer.prototype); // Documented in superclass.

	TiltRecognizer.prototype.shouldInterpret = function () {
	  for (var i = 0, count = this.touchCount; i < count; i++) {
	    var touch = this.touch(i),
	        dx = touch.translationX,
	        dy = touch.translationY,
	        distance = Math.sqrt(dx * dx + dy * dy);

	    if (distance > this.interpretDistance) {
	      return true; // interpret touches when any touch moves far enough
	    }
	  }

	  return false;
	}; // Documented in superclass.


	TiltRecognizer.prototype.shouldRecognize = function () {
	  var touchCount = this.touchCount;

	  if (touchCount < 2) {
	    return false;
	  }

	  var touch0 = this.touch(0),
	      touch1 = this.touch(1),
	      dx = touch0.clientX - touch1.clientX,
	      dy = touch0.clientY - touch1.clientY,
	      distance = Math.sqrt(dx * dx + dy * dy);

	  if (distance > this.maxTouchDistance) {
	    return false; // touches must be close together
	  }

	  var tx = touch0.translationX - touch1.translationX,
	      ty = touch0.translationY - touch1.translationY,
	      divergence = Math.sqrt(tx * tx + ty * ty);

	  if (divergence > this.maxTouchDivergence) {
	    return false; // touches must be moving in a mostly parallel direction
	  }

	  var verticalMask = TiltRecognizer.UP | TiltRecognizer.DOWN,
	      dirMask0 = this.touchDirection(touch0) & verticalMask,
	      dirMask1 = this.touchDirection(touch1) & verticalMask;
	  return (dirMask0 & dirMask1) != 0; // touches must move in the same vertical direction
	}; // Intentionally not documented.


	TiltRecognizer.prototype.touchDirection = function (touch) {
	  var dx = touch.translationX,
	      dy = touch.translationY,
	      dirMask = 0;

	  if (Math.abs(dx) > Math.abs(dy)) {
	    dirMask |= dx < 0 ? TiltRecognizer.LEFT : 0;
	    dirMask |= dx > 0 ? TiltRecognizer.RIGHT : 0;
	  } else {
	    dirMask |= dy < 0 ? TiltRecognizer.UP : 0;
	    dirMask |= dy > 0 ? TiltRecognizer.DOWN : 0;
	  }

	  return dirMask;
	};

	/**
	 * @exports WorldWindowController
	 */
	/**
	 * Constructs a root window controller.
	 * @alias WorldWindowController
	 * @constructor
	 * @abstract
	 * @classDesc This class provides a base window controller with required properties and methods which sub-classes may
	 * inherit from to create custom window controllers for controlling the globe via user interaction.
	 * @param {WorldWindow} worldWindow The WorldWindow associated with this layer.
	 * @throws {ArgumentError} If the specified WorldWindow is null or undefined.
	 */

	function WorldWindowController(worldWindow) {
	  if (!worldWindow) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindowController", "constructor", "missingWorldWindow"));
	  }
	  /**
	   * The WorldWindow associated with this controller.
	   * @type {WorldWindow}
	   * @readonly
	   */


	  this.wwd = worldWindow; // Intentionally not documented.

	  this.allGestureListeners = [];
	} // Intentionally not documented.


	WorldWindowController.prototype.onGestureEvent = function (event) {
	  var handled = false;

	  for (var i = 0; i < this.allGestureListeners.length && !handled; i++) {
	    handled |= this.allGestureListeners[i].onGestureEvent(event);
	  }

	  return handled;
	}; // Intentionally not documented.


	WorldWindowController.prototype.gestureStateChanged = function (recognizer) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindowController", "gestureStateChanged", "abstractInvocation"));
	};
	/**
	 * Registers a gesture event listener on this controller. Registering event listeners using this function
	 * enables applications to prevent the controller's default behavior.
	 *
	 * Listeners must implement an onGestureEvent method to receive event notifications. The onGestureEvent method will
	 * receive one parameter containing the information about the gesture event. Returning true from onGestureEvent
	 * indicates that the event was processed and will prevent any further handling of the event.
	 *
	 * When an event occurs, application event listeners are called before WorldWindowController event listeners.
	 *
	 * @param listener The function to call when the event occurs.
	 * @throws {ArgumentError} If any argument is null or undefined.
	 */


	WorldWindowController.prototype.addGestureListener = function (listener) {
	  if (!listener) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindowController", "addGestureListener", "missingListener"));
	  }

	  this.allGestureListeners.push(listener);
	};
	/**
	 * Removes a gesture event listener from this controller. The listener must be the same object passed to
	 * addGestureListener. Calling removeGestureListener with arguments that do not identify a currently registered
	 * listener has no effect.
	 *
	 * @param listener The listener to remove. Must be the same object passed to addGestureListener.
	 * @throws {ArgumentError} If any argument is null or undefined.
	 */


	WorldWindowController.prototype.removeGestureListener = function (listener) {
	  if (!listener) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindowController", "removeGestureListener", "missingListener"));
	  }

	  var index = this.allGestureListeners.indexOf(listener);

	  if (index !== -1) {
	    this.allGestureListeners.splice(index, 1); // remove the listener from the list
	  }
	};
	/**
	 * Called by WorldWindow to allow the controller to enforce navigation limits. Implementation is not required by
	 * sub-classes.
	 */


	WorldWindowController.prototype.applyLimits = function () {};

	/**
	 * @exports BasicWorldWindowController
	 */
	/**
	 * Constructs a window controller with basic capabilities.
	 * @alias BasicWorldWindowController
	 * @constructor
	 * @augments WorldWindowController
	 * @classDesc This class provides the default window controller for WorldWind for controlling the globe via user interaction.
	 * @param {WorldWindow} worldWindow The WorldWindow associated with this layer.
	 */

	function BasicWorldWindowController(worldWindow) {
	  WorldWindowController.call(this, worldWindow); // base class checks for a valid worldWindow
	  // Intentionally not documented.

	  this.primaryDragRecognizer = new DragRecognizer(this.wwd, null);
	  this.primaryDragRecognizer.addListener(this); // Intentionally not documented.

	  this.secondaryDragRecognizer = new DragRecognizer(this.wwd, null);
	  this.secondaryDragRecognizer.addListener(this);
	  this.secondaryDragRecognizer.button = 2; // secondary mouse button
	  // Intentionally not documented.

	  this.panRecognizer = new PanRecognizer(this.wwd, null);
	  this.panRecognizer.addListener(this); // Intentionally not documented.

	  this.pinchRecognizer = new PinchRecognizer(this.wwd, null);
	  this.pinchRecognizer.addListener(this); // Intentionally not documented.

	  this.rotationRecognizer = new RotationRecognizer(this.wwd, null);
	  this.rotationRecognizer.addListener(this); // Intentionally not documented.

	  this.tiltRecognizer = new TiltRecognizer(this.wwd, null);
	  this.tiltRecognizer.addListener(this); // Establish the dependencies between gesture recognizers. The pan, pinch and rotate gesture may recognize
	  // simultaneously with each other.

	  this.panRecognizer.recognizeSimultaneouslyWith(this.pinchRecognizer);
	  this.panRecognizer.recognizeSimultaneouslyWith(this.rotationRecognizer);
	  this.pinchRecognizer.recognizeSimultaneouslyWith(this.rotationRecognizer); // Since the tilt gesture is a subset of the pan gesture, pan will typically recognize before tilt,
	  // effectively suppressing tilt. Establish a dependency between the other touch gestures and tilt to provide
	  // tilt an opportunity to recognize.

	  this.panRecognizer.requireRecognizerToFail(this.tiltRecognizer);
	  this.pinchRecognizer.requireRecognizerToFail(this.tiltRecognizer);
	  this.rotationRecognizer.requireRecognizerToFail(this.tiltRecognizer); // Intentionally not documented.
	  // this.tapRecognizer = new TapRecognizer(this.wwd, null);
	  // this.tapRecognizer.addListener(this);
	  // Intentionally not documented.
	  // this.clickRecognizer = new ClickRecognizer(this.wwd, null);
	  // this.clickRecognizer.addListener(this);
	  // Intentionally not documented.

	  this.beginPoint = new Vec2(0, 0);
	  this.lastPoint = new Vec2(0, 0);
	  this.beginHeading = 0;
	  this.beginTilt = 0;
	  this.beginRange = 0;
	  this.lastRotation = 0;
	}

	BasicWorldWindowController.prototype = Object.create(WorldWindowController.prototype); // Intentionally not documented.

	BasicWorldWindowController.prototype.onGestureEvent = function (e) {
	  var handled = WorldWindowController.prototype.onGestureEvent.call(this, e);

	  if (!handled) {
	    if (e.type === "wheel") {
	      handled = true;
	      this.handleWheelEvent(e);
	    } else {
	      for (var i = 0, len = GestureRecognizer.allRecognizers.length; i < len; i++) {
	        var recognizer = GestureRecognizer.allRecognizers[i];

	        if (recognizer.target === this.wwd) {
	          handled |= recognizer.onGestureEvent(e); // use or-assignment to indicate if any recognizer handled the event
	        }
	      }
	    }
	  }

	  return handled;
	}; // Intentionally not documented.


	BasicWorldWindowController.prototype.gestureStateChanged = function (recognizer) {
	  if (recognizer === this.primaryDragRecognizer || recognizer === this.panRecognizer) {
	    this.handlePanOrDrag(recognizer);
	  } else if (recognizer === this.secondaryDragRecognizer) {
	    this.handleSecondaryDrag(recognizer);
	  } else if (recognizer === this.pinchRecognizer) {
	    this.handlePinch(recognizer);
	  } else if (recognizer === this.rotationRecognizer) {
	    this.handleRotation(recognizer);
	  } else if (recognizer === this.tiltRecognizer) {
	    this.handleTilt(recognizer);
	  } // else if (recognizer === this.clickRecognizer || recognizer === this.tapRecognizer) {
	  //     this.handleClickOrTap(recognizer);
	  // }

	}; // Intentionally not documented.
	// BasicWorldWindowController.prototype.handleClickOrTap = function (recognizer) {
	//     if (recognizer.state === WorldWind.RECOGNIZED) {
	//         var pickPoint = this.wwd.canvasCoordinates(recognizer.clientX, recognizer.clientY);
	//
	//         // Identify if the top picked object contains a URL for hyperlinking
	//         var pickList = this.wwd.pick(pickPoint);
	//         var topObject = pickList.topPickedObject();
	//         // If the url object was appended, open the hyperlink
	//         if (topObject &&
	//             topObject.userObject &&
	//             topObject.userObject.userProperties &&
	//             topObject.userObject.userProperties.url) {
	//             window.open(topObject.userObject.userProperties.url, "_blank");
	//         }
	//     }
	// };
	// Intentionally not documented.


	BasicWorldWindowController.prototype.handlePanOrDrag = function (recognizer) {
	  if (this.wwd.globe.is2D()) {
	    this.handlePanOrDrag2D(recognizer);
	  } else {
	    this.handlePanOrDrag3D(recognizer);
	  }
	}; // Intentionally not documented.


	BasicWorldWindowController.prototype.handlePanOrDrag3D = function (recognizer) {
	  var state = recognizer.state,
	      tx = recognizer.translationX,
	      ty = recognizer.translationY;
	  var navigator = this.wwd.navigator;

	  if (state === WorldWind.BEGAN) {
	    this.lastPoint.set(0, 0);
	  } else if (state === WorldWind.CHANGED) {
	    // Convert the translation from screen coordinates to arc degrees. Use this navigator's range as a
	    // metric for converting screen pixels to meters, and use the globe's radius for converting from meters
	    // to arc degrees.
	    var canvas = this.wwd.canvas,
	        globe = this.wwd.globe,
	        globeRadius = WWMath.max(globe.equatorialRadius, globe.polarRadius),
	        distance = WWMath.max(1, navigator.range),
	        metersPerPixel = WWMath.perspectivePixelSize(canvas.clientWidth, canvas.clientHeight, distance),
	        forwardMeters = (ty - this.lastPoint[1]) * metersPerPixel,
	        sideMeters = -(tx - this.lastPoint[0]) * metersPerPixel,
	        forwardDegrees = forwardMeters / globeRadius * Angle.RADIANS_TO_DEGREES,
	        sideDegrees = sideMeters / globeRadius * Angle.RADIANS_TO_DEGREES; // Apply the change in latitude and longitude to this navigator, relative to the current heading.

	    var sinHeading = Math.sin(navigator.heading * Angle.DEGREES_TO_RADIANS),
	        cosHeading = Math.cos(navigator.heading * Angle.DEGREES_TO_RADIANS);
	    navigator.lookAtLocation.latitude += forwardDegrees * cosHeading - sideDegrees * sinHeading;
	    navigator.lookAtLocation.longitude += forwardDegrees * sinHeading + sideDegrees * cosHeading;
	    this.lastPoint.set(tx, ty);
	    this.applyLimits();
	    this.wwd.redraw();
	  }
	}; // Intentionally not documented.


	BasicWorldWindowController.prototype.handlePanOrDrag2D = function (recognizer) {
	  var state = recognizer.state,
	      x = recognizer.clientX,
	      y = recognizer.clientY,
	      tx = recognizer.translationX,
	      ty = recognizer.translationY;
	  var navigator = this.wwd.navigator;

	  if (state === WorldWind.BEGAN) {
	    this.beginPoint.set(x, y);
	    this.lastPoint.set(x, y);
	  } else if (state === WorldWind.CHANGED) {
	    var x1 = this.lastPoint[0],
	        y1 = this.lastPoint[1],
	        x2 = this.beginPoint[0] + tx,
	        y2 = this.beginPoint[1] + ty;
	    this.lastPoint.set(x2, y2);
	    var globe = this.wwd.globe,
	        ray = this.wwd.rayThroughScreenPoint(this.wwd.canvasCoordinates(x1, y1)),
	        point1 = new Vec3$1(0, 0, 0),
	        point2 = new Vec3$1(0, 0, 0),
	        origin = new Vec3$1(0, 0, 0);

	    if (!globe.intersectsLine(ray, point1)) {
	      return;
	    }

	    ray = this.wwd.rayThroughScreenPoint(this.wwd.canvasCoordinates(x2, y2));

	    if (!globe.intersectsLine(ray, point2)) {
	      return;
	    } // Transform the original navigator state's modelview matrix to account for the gesture's change.


	    var modelview = Matrix.fromIdentity();
	    this.wwd.computeViewingTransform(null, modelview);
	    modelview.multiplyByTranslation(point2[0] - point1[0], point2[1] - point1[1], point2[2] - point1[2]); // Compute the globe point at the screen center from the perspective of the transformed navigator state.

	    modelview.extractEyePoint(ray.origin);
	    modelview.extractForwardVector(ray.direction);

	    if (!globe.intersectsLine(ray, origin)) {
	      return;
	    } // Convert the transformed modelview matrix to a set of navigator properties, then apply those
	    // properties to this navigator.


	    var params = modelview.extractViewingParameters(origin, navigator.roll, globe, {});
	    navigator.lookAtLocation.copy(params.origin);
	    navigator.range = params.range;
	    navigator.heading = params.heading;
	    navigator.tilt = params.tilt;
	    navigator.roll = params.roll;
	    this.applyLimits();
	    this.wwd.redraw();
	  }
	}; // Intentionally not documented.


	BasicWorldWindowController.prototype.handleSecondaryDrag = function (recognizer) {
	  var state = recognizer.state,
	      tx = recognizer.translationX,
	      ty = recognizer.translationY;
	  var navigator = this.wwd.navigator;

	  if (state === WorldWind.BEGAN) {
	    this.beginHeading = navigator.heading;
	    this.beginTilt = navigator.tilt;
	  } else if (state === WorldWind.CHANGED) {
	    // Compute the current translation from screen coordinates to degrees. Use the canvas dimensions as a
	    // metric for converting the gesture translation to a fraction of an angle.
	    var headingDegrees = 180 * tx / this.wwd.canvas.clientWidth,
	        tiltDegrees = 90 * ty / this.wwd.canvas.clientHeight; // Apply the change in heading and tilt to this navigator's corresponding properties.

	    navigator.heading = this.beginHeading + headingDegrees;
	    navigator.tilt = this.beginTilt - tiltDegrees;
	    this.applyLimits();
	    this.wwd.redraw();
	  }
	}; // Intentionally not documented.


	BasicWorldWindowController.prototype.handlePinch = function (recognizer) {
	  var navigator = this.wwd.navigator;
	  var state = recognizer.state,
	      scale = recognizer.scale;

	  if (state === WorldWind.BEGAN) {
	    this.beginRange = navigator.range;
	  } else if (state === WorldWind.CHANGED) {
	    if (scale !== 0) {
	      // Apply the change in pinch scale to this navigator's range, relative to the range when the gesture
	      // began.
	      navigator.range = this.beginRange / scale;
	      this.applyLimits();
	      this.wwd.redraw();
	    }
	  }
	}; // Intentionally not documented.


	BasicWorldWindowController.prototype.handleRotation = function (recognizer) {
	  var navigator = this.wwd.navigator;
	  var state = recognizer.state,
	      rotation = recognizer.rotation;

	  if (state === WorldWind.BEGAN) {
	    this.lastRotation = 0;
	  } else if (state === WorldWind.CHANGED) {
	    // Apply the change in gesture rotation to this navigator's current heading. We apply relative to the
	    // current heading rather than the heading when the gesture began in order to work simultaneously with
	    // pan operations that also modify the current heading.
	    navigator.heading -= rotation - this.lastRotation;
	    this.lastRotation = rotation;
	    this.applyLimits();
	    this.wwd.redraw();
	  }
	}; // Intentionally not documented.


	BasicWorldWindowController.prototype.handleTilt = function (recognizer) {
	  var navigator = this.wwd.navigator;
	  var state = recognizer.state,
	      ty = recognizer.translationY;

	  if (state === WorldWind.BEGAN) {
	    this.beginTilt = navigator.tilt;
	  } else if (state === WorldWind.CHANGED) {
	    // Compute the gesture translation from screen coordinates to degrees. Use the canvas dimensions as a
	    // metric for converting the translation to a fraction of an angle.
	    var tiltDegrees = -90 * ty / this.wwd.canvas.clientHeight; // Apply the change in heading and tilt to this navigator's corresponding properties.

	    navigator.tilt = this.beginTilt + tiltDegrees;
	    this.applyLimits();
	    this.wwd.redraw();
	  }
	}; // Intentionally not documented.


	BasicWorldWindowController.prototype.handleWheelEvent = function (event) {
	  var navigator = this.wwd.navigator; // Normalize the wheel delta based on the wheel delta mode. This produces a roughly consistent delta across
	  // browsers and input devices.

	  var normalizedDelta;

	  if (event.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
	    normalizedDelta = event.deltaY;
	  } else if (event.deltaMode === WheelEvent.DOM_DELTA_LINE) {
	    normalizedDelta = event.deltaY * 40;
	  } else if (event.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
	    normalizedDelta = event.deltaY * 400;
	  } // Compute a zoom scale factor by adding a fraction of the normalized delta to 1. When multiplied by the
	  // navigator's range, this has the effect of zooming out or zooming in depending on whether the delta is
	  // positive or negative, respectfully.


	  var scale = 1 + normalizedDelta / 1000; // Apply the scale to this navigator's properties.

	  navigator.range *= scale;
	  this.applyLimits();
	  this.wwd.redraw();
	}; // Documented in super-class.


	BasicWorldWindowController.prototype.applyLimits = function () {
	  var navigator = this.wwd.navigator; // Clamp latitude to between -90 and +90, and normalize longitude to between -180 and +180.

	  navigator.lookAtLocation.latitude = WWMath.clamp(navigator.lookAtLocation.latitude, -90, 90);
	  navigator.lookAtLocation.longitude = Angle.normalizedDegreesLongitude(navigator.lookAtLocation.longitude); // Clamp range to values greater than 1 in order to prevent degenerating to a first-person navigator when
	  // range is zero.

	  navigator.range = WWMath.clamp(navigator.range, 1, Number.MAX_VALUE); // Normalize heading to between -180 and +180.

	  navigator.heading = Angle.normalizedDegrees(navigator.heading); // Clamp tilt to between 0 and +90 to prevent the viewer from going upside down.

	  navigator.tilt = WWMath.clamp(navigator.tilt, 0, 90); // Normalize heading to between -180 and +180.

	  navigator.roll = Angle.normalizedDegrees(navigator.roll); // Apply 2D limits when the globe is 2D.

	  if (this.wwd.globe.is2D() && navigator.enable2DLimits) {
	    // Clamp range to prevent more than 360 degrees of visible longitude. Assumes a 45 degree horizontal
	    // field of view.
	    var maxRange = 2 * Math.PI * this.wwd.globe.equatorialRadius;
	    navigator.range = WWMath.clamp(navigator.range, 1, maxRange); // Force tilt to 0 when in 2D mode to keep the viewer looking straight down.

	    navigator.tilt = 0;
	  }
	};

	/**
	 * @exports ClickRecognizer
	 */
	/**
	 * Constructs a mouse click gesture recognizer.
	 * @alias ClickRecognizer
	 * @constructor
	 * @augments GestureRecognizer
	 * @classdesc A concrete gesture recognizer subclass that looks for single or multiple mouse clicks.
	 * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	 * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	 * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	 * e.g., <code>gestureCallback(recognizer)</code>.
	 * @throws {ArgumentError} If the specified target is null or undefined.
	 */

	function ClickRecognizer(target, callback) {
	  GestureRecognizer.call(this, target, callback);
	  /**
	   *
	   * @type {Number}
	   */

	  this.numberOfClicks = 1;
	  /**
	   *
	   * @type {Number}
	   */

	  this.button = 0; // Intentionally not documented.

	  this.maxMouseMovement = 5; // Intentionally not documented.

	  this.maxClickDuration = 500; // Intentionally not documented.

	  this.maxClickInterval = 400; // Intentionally not documented.

	  this.clicks = []; // Intentionally not documented.

	  this.timeout = null;
	}

	ClickRecognizer.prototype = Object.create(GestureRecognizer.prototype); // Documented in superclass.

	ClickRecognizer.prototype.reset = function () {
	  GestureRecognizer.prototype.reset.call(this);
	  this.clicks = [];
	  this.cancelFailAfterDelay();
	}; // Documented in superclass.


	ClickRecognizer.prototype.mouseDown = function (event) {
	  if (this.state != WorldWind.POSSIBLE) {
	    return;
	  }

	  if (this.button != event.button) {
	    this.state = WorldWind.FAILED;
	  } else {
	    var click = {
	      clientX: this.clientX,
	      clientY: this.clientY
	    };
	    this.clicks.push(click);
	    this.failAfterDelay(this.maxClickDuration); // fail if the click is down too long
	  }
	}; // Documented in superclass.


	ClickRecognizer.prototype.mouseMove = function (event) {
	  if (this.state != WorldWind.POSSIBLE) {
	    return;
	  }

	  var dx = this.translationX,
	      dy = this.translationY,
	      distance = Math.sqrt(dx * dx + dy * dy);

	  if (distance > this.maxMouseMovement) {
	    this.state = WorldWind.FAILED;
	  }
	}; // Documented in superclass.


	ClickRecognizer.prototype.mouseUp = function (event) {
	  if (this.state != WorldWind.POSSIBLE) {
	    return;
	  }

	  if (this.mouseButtonMask != 0) {
	    return; // wait until the last button is up
	  }

	  var clickCount = this.clicks.length;

	  if (clickCount == this.numberOfClicks) {
	    this.clientX = this.clicks[0].clientX;
	    this.clientY = this.clicks[0].clientY;
	    this.state = WorldWind.RECOGNIZED;
	  } else {
	    this.failAfterDelay(this.maxClickInterval); // fail if the interval between clicks is too long
	  }
	}; // Documented in superclass.


	ClickRecognizer.prototype.touchStart = function (touch) {
	  if (this.state != WorldWind.POSSIBLE) {
	    return;
	  }

	  this.state = WorldWind.FAILED; // mouse gestures fail upon receiving a touch event
	}; // Intentionally not documented.


	ClickRecognizer.prototype.failAfterDelay = function (delay) {
	  var self = this;

	  if (self.timeout) {
	    window.clearTimeout(self.timeout);
	  }

	  self.timeout = window.setTimeout(function () {
	    self.timeout = null;

	    if (self.state == WorldWind.POSSIBLE) {
	      self.state = WorldWind.FAILED; // fail if we haven't already reached a terminal state
	    }
	  }, delay);
	}; // Intentionally not documented.


	ClickRecognizer.prototype.cancelFailAfterDelay = function () {
	  var self = this;

	  if (self.timeout) {
	    window.clearTimeout(self.timeout);
	    self.timeout = null;
	  }
	};

	/**
	 * @exports ImageSource
	 */
	/**
	 * Constructs an image source.
	 * @alias ImageSource
	 * @constructor
	 * @classdesc Holds an Image with an associated key that uniquely identifies that image. The key is
	 * automatically generated but may be reassigned after construction. Instances of this class are used to
	 * specify dynamically created image sources for {@link Placemark}, {@link SurfaceImage},
	 * {@link Polygon} textures and other shapes that display imagery.
	 * @param {Image} image The image for this image source.
	 * @throws {ArgumentError} If the specified image is null or undefined.
	 */

	function ImageSource(image) {
	  if (!image) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ImageSource", "constructor", "missingImage"));
	  }
	  /**
	   * This image source's image
	   * @type {Image}
	   * @readonly
	   */


	  this.image = image;
	  /**
	   * This image source's key. A unique key is automatically generated and assigned during construction.
	   * Applications may assign a different key after construction.
	   * @type {String}
	   * @default A unique string for this image source.
	   */

	  this.key = "ImageSource " + ++ImageSource.keyPool;
	} // Internal. Intentionally not documented.


	ImageSource.keyPool = 0; // source of unique ids

	/**
	 * @exports ScreenImage
	 */
	/**
	 * Constructs a screen image.
	 * @alias ScreenImage
	 * @constructor
	 * @augments Renderable
	 * @classdesc Displays an image at a specified screen location in the WorldWindow.
	 * The image location is specified by an offset, which causes the image to maintain its relative position
	 * when the window size changes.
	 * @param {Offset} screenOffset The offset indicating the image's placement on the screen.
	 * Use [the image offset property]{@link ScreenImage#imageOffset} to position the image relative to the
	 * specified screen offset.
	 * @param {String|ImageSource} imageSource The source of the image to display.
	 * May be either a string identifying the URL of the image, or an {@link ImageSource} object identifying a
	 * dynamically created image.
	 * @throws {ArgumentError} If the specified screen offset or image source is null or undefined.
	 */

	function ScreenImage(screenOffset, imageSource) {
	  if (!screenOffset) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ScreenImage", "constructor", "missingOffset"));
	  }

	  if (!imageSource) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ScreenImage", "constructor", "missingImage"));
	  }

	  Renderable.call(this);
	  /**
	   * The offset indicating this screen image's placement on the screen.
	   * @type {Offset}
	   */

	  this.screenOffset = screenOffset; // Documented with its property accessor below.

	  this._imageSource = imageSource;
	  /**
	   * The image color. When displayed, this shape's image is multiplied by this image color to achieve the
	   * final image color. The color white, the default, causes the image to be drawn in its native colors.
	   * @type {Color}
	   * @default White (1, 1, 1, 1)
	   */

	  this.imageColor = Color.WHITE;
	  /**
	   * Indicates the location within the image at which to align with the specified screen location.
	   * May be null, in which case the image's bottom-left corner is placed at the screen location.
	   * @type {Offset}
	   * @default 0.5, 0.5, both fractional (Centers the image on the screen location.)
	   */

	  this.imageOffset = new Offset(WorldWind.OFFSET_FRACTION, 0.5, WorldWind.OFFSET_FRACTION, 0.5);
	  /**
	   * Indicates the amount to scale the image.
	   * @type {Number}
	   * @default 1
	   */

	  this.imageScale = 1;
	  /**
	   * The amount of rotation to apply to the image, measured in degrees clockwise from the top of the window.
	   * @type {Number}
	   * @default 0
	   */

	  this.imageRotation = 0;
	  /**
	   * The amount of tilt to apply to the image, measured in degrees.
	   * @type {Number}
	   * @default 0
	   */

	  this.imageTilt = 0;
	  /**
	   * Indicates whether to draw this screen image.
	   * @type {Boolean}
	   * @default true
	   */

	  this.enabled = true;
	  /**
	   * This image's opacity. When this screen image is drawn, the actual opacity is the product of
	   * this opacity and the opacity of the layer containing this screen image.
	   * @type {Number}
	   */

	  this.opacity = 1;
	  /**
	   * Indicates the object to return as the userObject of this shape when picked. If null,
	   * then this shape is returned as the userObject.
	   * @type {Object}
	   * @default null
	   * @see  [PickedObject.userObject]{@link PickedObject#userObject}
	   */

	  this.pickDelegate = null; // Internal use only. Intentionally not documented.

	  this.activeTexture = null; // Internal use only. Intentionally not documented.

	  this.imageTransform = Matrix.fromIdentity(); // Internal use only. Intentionally not documented.

	  this.texCoordMatrix = Matrix.fromIdentity(); // Internal use only. Intentionally not documented.

	  this.imageBounds = null; // Internal use only. Intentionally not documented.

	  this.layer = null;
	} // Internal use only. Intentionally not documented.


	ScreenImage.matrix = Matrix.fromIdentity(); // scratch variable

	ScreenImage.prototype = Object.create(Renderable.prototype);
	Object.defineProperties(ScreenImage.prototype, {
	  /**
	   * The source of the image to display.
	   * May be either a string identifying the URL of the image, or an {@link ImageSource} object identifying a
	   * dynamically created image.
	   * @type {String|ImageSource}
	   * @default null
	   * @memberof ScreenImage.prototype
	   */
	  imageSource: {
	    get: function () {
	      return this._imageSource;
	    },
	    set: function (imageSource) {
	      if (!imageSource) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ScreenImage", "imageSource", "missingImage"));
	      }

	      this._imageSource = imageSource;
	      this.imageSourceWasUpdated = true;
	    }
	  }
	});
	/**
	 * Renders this screen image. This method is typically not called by applications but is called by
	 * {@link RenderableLayer} during rendering. For this shape this method creates and
	 * enques an ordered renderable with the draw context and does not actually draw the image.
	 * @param {DrawContext} dc The current draw context.
	 */

	ScreenImage.prototype.render = function (dc) {
	  if (!this.enabled) {
	    return;
	  }

	  if (!dc.accumulateOrderedRenderables) {
	    return;
	  } // Create an ordered renderable, but don't create more than one per frame.


	  var orderedScreenImage = null;

	  if (this.lastFrameTime !== dc.timestamp) {
	    orderedScreenImage = this.makeOrderedRenderable(dc);
	  }

	  if (!orderedScreenImage) {
	    return;
	  }

	  if (!orderedScreenImage.isVisible(dc)) {
	    return;
	  }

	  orderedScreenImage.layer = dc.currentLayer;
	  this.lastFrameTime = dc.timestamp;
	  dc.addOrderedRenderable(orderedScreenImage);
	};
	/**
	 * Draws this shape as an ordered renderable. Applications do not call this function. It is called by
	 * [WorldWindow]{@link WorldWindow} during rendering.
	 * @param {DrawContext} dc The current draw context.
	 */


	ScreenImage.prototype.renderOrdered = function (dc) {
	  this.drawOrderedScreenImage(dc);

	  if (dc.pickingMode) {
	    var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this, null, this.layer, false);
	    dc.resolvePick(po);
	  }
	}; // Internal. Intentionally not documented.


	ScreenImage.prototype.makeOrderedRenderable = function (dc) {
	  var w, h, s, ws, hs, iOffset, sOffset;
	  this.activeTexture = this.getActiveTexture(dc);

	  if (!this.activeTexture || this.imageSourceWasUpdated) {
	    this.activeTexture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this._imageSource);

	    if (!this.activeTexture) {
	      return null;
	    }
	  }

	  this.eyeDistance = 0; // Compute the image's transform matrix and texture coordinate matrix according to its screen point, image size,
	  // image offset and image scale. The image offset is defined with its origin at the image's bottom-left corner and
	  // axes that extend up and to the right from the origin point.

	  w = this.activeTexture.imageWidth;
	  h = this.activeTexture.imageHeight;
	  s = this.imageScale;
	  iOffset = this.imageOffset.offsetForSize(w, h);
	  ws = dc.viewport.width;
	  hs = dc.viewport.height;
	  sOffset = this.screenOffset.offsetForSize(ws, hs);
	  this.imageTransform.setTranslation(sOffset[0] - iOffset[0] * s, sOffset[1] - iOffset[1] * s, 0);
	  this.imageTransform.setScale(w * s, h * s, 1);
	  this.imageBounds = WWMath.boundingRectForUnitQuad(this.imageTransform);
	  return this;
	};

	ScreenImage.prototype.getActiveTexture = function (dc) {
	  return dc.gpuResourceCache.resourceForKey(this._imageSource);
	}; // Internal. Intentionally not documented.


	ScreenImage.prototype.isVisible = function (dc) {
	  if (dc.pickingMode) {
	    return dc.pickRectangle && this.imageBounds.intersects(dc.pickRectangle);
	  } else {
	    return this.imageBounds.intersects(dc.viewport);
	  }
	}; // Internal. Intentionally not documented.


	ScreenImage.prototype.drawOrderedScreenImage = function (dc) {
	  this.beginDrawing(dc);

	  try {
	    this.doDrawOrderedScreenImage(dc);
	  } finally {
	    this.endDrawing(dc);
	  }
	}; // Internal. Intentionally not documented.


	ScreenImage.prototype.beginDrawing = function (dc) {
	  var gl = dc.currentGlContext,
	      program;
	  dc.findAndBindProgram(BasicTextureProgram); // Configure GL to use the draw context's unit quad VBOs for both model coordinates and texture coordinates.
	  // Most browsers can share the same buffer for vertex and texture coordinates, but Internet Explorer requires
	  // that they be in separate buffers, so the code below uses the 3D buffer for vertex coords and the 2D
	  // buffer for texture coords.

	  program = dc.currentProgram;
	  gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer());
	  gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	  gl.enableVertexAttribArray(program.vertexPointLocation);
	  gl.enableVertexAttribArray(program.vertexTexCoordLocation); // Tell the program which texture unit to use.

	  program.loadTextureUnit(gl, gl.TEXTURE0);
	  program.loadModulateColor(gl, dc.pickingMode); // Turn off depth testing.

	  gl.disable(gl.DEPTH_TEST);
	}; // Internal. Intentionally not documented.


	ScreenImage.prototype.endDrawing = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram; // Clear the vertex attribute state.

	  gl.disableVertexAttribArray(program.vertexPointLocation);
	  gl.disableVertexAttribArray(program.vertexTexCoordLocation); // Clear GL bindings.

	  gl.bindBuffer(gl.ARRAY_BUFFER, null);
	  gl.bindTexture(gl.TEXTURE_2D, null); // Re-enable depth testing.

	  gl.enable(gl.DEPTH_TEST);
	}; // Internal. Intentionally not documented.


	ScreenImage.prototype.doDrawOrderedScreenImage = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram;
	  gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer3());
	  gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0); // Compute and specify the MVP matrix.

	  ScreenImage.matrix.copy(dc.screenProjection);
	  ScreenImage.matrix.multiplyMatrix(this.imageTransform);
	  ScreenImage.matrix.multiplyByTranslation(0.5, 0.5, 0.5); // shift Z to prevent image clipping

	  ScreenImage.matrix.multiplyByRotation(1, 0, 0, this.imageTilt);
	  ScreenImage.matrix.multiplyByRotation(0, 0, 1, this.imageRotation);
	  ScreenImage.matrix.multiplyByTranslation(-0.5, -0.5, 0);
	  program.loadModelviewProjection(gl, ScreenImage.matrix); // Enable texture for both normal display and for picking. If picking is enabled in the shader (set in
	  // beginDrawing() above) then the texture's alpha component is still needed in order to modulate the
	  // pick color to mask off transparent pixels.

	  program.loadTextureEnabled(gl, true); // Set the pick color for picking or the color and opacity if not picking.

	  if (dc.pickingMode) {
	    this.pickColor = dc.uniquePickColor();
	    program.loadColor(gl, this.pickColor);
	    program.loadOpacity(gl, 1);
	  } else {
	    program.loadColor(gl, this.imageColor);
	    program.loadOpacity(gl, this.opacity * this.layer.opacity);
	  }

	  this.texCoordMatrix.setToIdentity();
	  this.texCoordMatrix.multiplyByTextureTransform(this.activeTexture);
	  program.loadTextureMatrix(gl, this.texCoordMatrix);

	  if (this.activeTexture.bind(dc)) {
	    // returns false if active texture cannot be bound
	    // Draw the placemark's image quad.
	    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	  }
	};

	/**
	 * @exports Compass
	 */
	/**
	 * Constructs a compass.
	 * @alias Compass
	 * @constructor
	 * @augments ScreenImage
	 * @classdesc Displays a compass image at a specified location in the WorldWindow. The compass image rotates
	 * and tilts to reflect the current navigator's heading and tilt.
	 * @param {Offset} screenOffset The offset indicating the image's placement on the screen. If null or undefined
	 * the compass is placed at the upper-right corner of the WorldWindow.
	 * Use [the image offset property]{@link ScreenImage#imageOffset} to position the image relative to the
	 * screen point.
	 * @param {String} imagePath The URL of the image to display. If null or undefined, a default compass image is used.
	 */

	function Compass(screenOffset, imagePath) {
	  var sOffset = screenOffset ? screenOffset : new Offset(WorldWind.OFFSET_FRACTION, 1, WorldWind.OFFSET_FRACTION, 1),
	      // upper-right placement
	  iPath = imagePath ? imagePath : WorldWind.configuration.baseUrl + "images/notched-compass.png";
	  ScreenImage.call(this, sOffset, iPath); // Must set the default image offset after calling the constructor above.

	  if (!screenOffset) {
	    // Align the upper right corner of the image with the screen point, and give the image some padding.
	    this.imageOffset = new Offset(WorldWind.OFFSET_FRACTION, 1.1, WorldWind.OFFSET_FRACTION, 1.1);
	  }
	  /**
	   * Specifies the size of the compass as a fraction of the WorldWindow width.
	   * @type {number}
	   * @default 0.15
	   */


	  this.size = 0.15;
	}

	Compass.prototype = Object.create(ScreenImage.prototype);
	/**
	 * Capture the navigator's heading and tilt and apply it to the compass' screen image.
	 * @param {DrawContext} dc The current draw context.
	 */

	Compass.prototype.render = function (dc) {
	  // Capture the navigator's heading and tilt and apply it to the compass' screen image.
	  this.imageRotation = dc.navigator.heading;
	  this.imageTilt = dc.navigator.tilt;
	  var t = this.getActiveTexture(dc);

	  if (t) {
	    this.imageScale = this.size * dc.currentGlContext.drawingBufferWidth / t.imageWidth;
	  }

	  ScreenImage.prototype.render.call(this, dc);
	};

	/**
	 * Descendant of Date.
	 * @param dateInFormat {String} Any format of date accepted by the Date constructor.
	 * @constructor
	 * @alias DateWW
	 */
	function DateWW(dateInFormat) {
	  if (dateInFormat) {
	    this._date = new Date(dateInFormat);
	  } else {
	    this._date = new Date();
	  }
	}

	DateWW.prototype = Object.create(Date.prototype);

	DateWW.prototype.isAfter = function (date) {
	  return this.compare(date) == -1;
	};

	DateWW.prototype.isBefore = function (date) {
	  return this.compare(date) == 1;
	};

	DateWW.prototype.valueOf = function () {
	  return this._date.valueOf();
	};

	DateWW.prototype.getTime = function () {
	  return this._date.getTime();
	};

	DateWW.prototype.compare = function (date) {
	  var currentDate = this._date.valueOf();

	  var comparedDate = date.valueOf();

	  if (currentDate > comparedDate) {
	    return -1;
	  } else if (currentDate < comparedDate) {
	    return 1;
	  } else {
	    return 0;
	  }
	};

	/**
	 * @exports FrameStatistics
	 */

	/**
	 * Constructs a performance statistics instance. This is performed internally by the {@link WorldWindow}.
	 * Applications do not construct instances of this class.
	 * @alias FrameStatistics
	 * @constructor
	 * @classdesc Captures performance statistics.
	 */
	function FrameStatistics() {
	  // Internal: intentionally not documented
	  this.frameCount = 0; // Internal: intentionally not documented

	  this.frameTimeCumulative = 0; // Internal: intentionally not documented

	  this.frameTimeBase = 0; // Internal: intentionally not documented

	  this.frameTimeExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
	  /**
	   * The number of milliseconds required to render the most recent frame.
	   * @type {Number}
	   */

	  this.frameTime = 0;
	  /**
	   * The number of milliseconds spent tessellating the terrain during the most recent frame.
	   * @type {Number}
	   */

	  this.tessellationTime = 0;
	  /**
	   * The number of milliseconds spent rendering the active layers during the most recent frame.
	   * @type {Number}
	   */

	  this.layerRenderingTime = 0;
	  /**
	   * The number of milliseconds spent rendering ordered renderables during the most recent frame.
	   * @type {Number}
	   */

	  this.orderedRenderingTime = 0;
	  /**
	   * The number of terrain tiles in the most recent frame.
	   * @type {Number}
	   */

	  this.terrainTileCount = 0;
	  /**
	   * The number of image tiles in the most recent frame.
	   * @type {Number}
	   */

	  this.imageTileCount = 0;
	  /**
	   * The number of terrain tile renderings. Since terrain tiles are generally rendered more than once per
	   * frame, this count will be greater than the number of terrain tiles created for the frame.
	   * @type {Number}
	   */

	  this.renderedTileCount = 0;
	  /**
	   * The number of calls to [Tile.update()]{@link Tile#update} during the most recent frame.
	   * @type {Number}
	   */

	  this.tileUpdateCount = 0;
	  /**
	   * The number of texture bind calls during the most recent frame.
	   * @type {Number}
	   */

	  this.textureLoadCount = 0;
	  /**
	   * The number of WebGL VBO loads during the most recent frame.
	   * @type {Number}
	   */

	  this.vboLoadCount = 0;
	  /**
	   * The average frame time over the most recent two seconds.
	   * @type {Number}
	   */

	  this.frameTimeAverage = 0;
	  /**
	   * The average frame rate over the most recent two seconds.
	   * @type {Number}
	   */

	  this.frameRateAverage = 0;
	  /**
	   * The minimum frame time over the most recent two seconds.
	   * @type {Number}
	   */

	  this.frameTimeMin = 0;
	  /**
	   * The maximum frame time over the most recent two seconds.
	   * @type {Number}
	   */

	  this.frameTimeMax = 0;
	}
	/**
	 * Initializes this frame statistics with initial values.
	 */


	FrameStatistics.prototype.beginFrame = function () {
	  this.frameTime = Date.now();
	  this.tessellationTime = 0;
	  this.layerRenderingTime = 0;
	  this.orderedRenderingTime = 0;
	  this.terrainTileCount = 0;
	  this.imageTileCount = 0;
	  this.renderedTileCount = 0;
	  this.tileUpdateCount = 0;
	  this.textureLoadCount = 0;
	  this.vboLoadCount = 0;
	  ++this.frameCount;
	};
	/**
	 * Computes the statistics for the most recent frame.
	 */


	FrameStatistics.prototype.endFrame = function () {
	  var now = Date.now();
	  this.frameTime = now - this.frameTime;
	  this.frameTimeCumulative += this.frameTime;
	  this.frameTimeExtremes[0] = Math.min(this.frameTimeExtremes[0], this.frameTime);
	  this.frameTimeExtremes[1] = Math.max(this.frameTimeExtremes[1], this.frameTime); // Compute averages every 2 seconds.

	  if (now - this.frameTimeBase > 2000) {
	    this.frameTimeAverage = this.frameTimeCumulative / this.frameCount;
	    this.frameRateAverage = 1000 * this.frameCount / (now - this.frameTimeBase);
	    this.frameTimeMin = this.frameTimeExtremes[0];
	    this.frameTimeMax = this.frameTimeExtremes[1];
	    this.frameCount = 0;
	    this.frameTimeCumulative = 0;
	    this.frameTimeBase = now;
	    this.frameTimeExtremes = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]; //console.log(this.frameTimeAverage.toString() + ", " + this.frameRateAverage.toString());
	  }
	};
	/**
	 * Increments the rendered tile count.
	 * @param {Number} tileCount The amount to increment the counter.
	 */


	FrameStatistics.prototype.incrementRenderedTileCount = function (tileCount) {
	  this.renderedTileCount += tileCount;
	};
	/**
	 * Sets the terrain tile count.
	 * @param {Number} tileCount The amount to set the counter to.
	 */


	FrameStatistics.prototype.setTerrainTileCount = function (tileCount) {
	  this.terrainTileCount = tileCount;
	};
	/**
	 * Increments the image tile count.
	 * @param {Number} tileCount The amount to increment the counter.
	 */


	FrameStatistics.prototype.incrementImageTileCount = function (tileCount) {
	  this.imageTileCount = tileCount;
	};
	/**
	 * Increments the tile update count.
	 * @param {Number} count The amount to increment the counter.
	 */


	FrameStatistics.prototype.incrementTileUpdateCount = function (count) {
	  this.tileUpdateCount += count;
	};
	/**
	 * Increments the texture load count.
	 * @param {Number} count The amount to increment the counter.
	 */


	FrameStatistics.prototype.incrementTextureLoadCount = function (count) {
	  this.textureLoadCount += count;
	};
	/**
	 * Increments the VBO load count.
	 * @param {Number} count The amount to increment the counter.
	 */


	FrameStatistics.prototype.incrementVboLoadCount = function (count) {
	  this.vboLoadCount += count;
	};

	/**
	 * @exports FramebufferTexture
	 */
	/**
	 * Constructs a framebuffer texture with the specified dimensions and an optional depth buffer. Use the
	 * [DrawContext.bindFramebuffer]{@link DrawContext#bindFramebuffer} function to make the program current during rendering.
	 *
	 * @alias FramebufferTexture
	 * @constructor
	 * @classdesc Represents an off-screen WebGL framebuffer. The framebuffer has color buffer stored in a 32
	 * bit RGBA texture, and has an optional depth buffer of at least 16 bits. Applications typically do not
	 * interact with this class. WebGL framebuffers are created by instances of this class and made current when the
	 * DrawContext.bindFramebuffer function is invoked.
	 * @param {WebGLRenderingContext} gl The current WebGL rendering context.
	 * @param {Number} width The width of the framebuffer, in pixels.
	 * @param {Number} height The height of the framebuffer, in pixels.
	 * @param {Boolean} depth true to configure the framebuffer with a depth buffer of at least 16 bits, false to
	 * disable depth buffering.
	 * @throws {ArgumentError} If the specified draw context is null or undefined, or if the width or height is less
	 * than zero.
	 */

	function FramebufferTexture(gl, width, height, depth) {
	  if (!gl) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "FramebufferTexture", "constructor", "missingGlContext"));
	  }

	  if (width < 0 || height < 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "FramebufferTexture", "constructor", "The framebuffer width or height is less than zero."));
	  }
	  /**
	   * The width of this framebuffer, in pixels.
	   * @type {Number}
	   * @readonly
	   */


	  this.width = width;
	  /**
	   * The height of this framebuffer, in pixels.
	   * @type {Number}
	   * @readonly
	   */

	  this.height = height;
	  /**
	   * Indicates whether or not this framebuffer has a depth buffer.
	   * @type {Boolean}
	   * @readonly
	   */

	  this.depth = depth;
	  /**
	   * Indicates the size of this framebuffer's WebGL resources, in bytes.
	   * @type {Number}
	   * @readonly
	   */

	  this.size = width * height * 4 + (depth ? width * height * 2 : 0);
	  /**
	   * Indicates the WebGL framebuffer object object associated with this framebuffer texture.
	   * @type {WebGLFramebuffer}
	   * @readonly
	   */

	  this.framebufferId = gl.createFramebuffer();
	  gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebufferId); // Internal. Intentionally not documented. Configure this framebuffer's color buffer.

	  this.texture = gl.createTexture();
	  gl.bindTexture(gl.TEXTURE_2D, this.texture);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0); // Internal. Intentionally not documented. Configure this framebuffer's optional depth buffer.

	  this.depthBuffer = null;

	  if (depth) {
	    this.depthBuffer = gl.createRenderbuffer();
	    gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthBuffer);
	    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
	    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthBuffer);
	  }

	  var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

	  if (e != gl.FRAMEBUFFER_COMPLETE) {
	    Logger$1.logMessage(Logger$1.LEVEL_WARNING, "FramebufferTexture", "constructor", "Error creating framebuffer: " + e);
	    this.framebufferId = null;
	    this.texture = null;
	    this.depthBuffer = null;
	  }

	  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	  gl.bindTexture(gl.TEXTURE_2D, null);
	}
	/**
	 * Binds this off-screen framebuffer's texture in the current WebGL graphics context. This texture contains
	 * color fragments resulting from WebGL operations executed when this framebuffer is bound by a call to
	 * [FramebufferTexture.bindFramebuffer]{@link FramebufferTexture#bindFramebuffer}.
	 *
	 * @param {DrawContext} dc The current draw context.
	 * @returns {Boolean} true if this framebuffer's texture was bound successfully, otherwise false.
	 */


	FramebufferTexture.prototype.bind = function (dc) {
	  if (this.texture) {
	    dc.currentGlContext.bindTexture(gl.TEXTURE_2D, this.texture);
	  }

	  return !!this.texture;
	};

	/**
	 * @exports TextureTile
	 */
	/**
	 * Constructs a texture tile.
	 * @alias TextureTile
	 * @constructor
	 * @augments Tile
	 * @classdesc Represents an image applied to a portion of a globe's terrain. Applications typically do not
	 * interact with this class.
	 * @param {Sector} sector The sector this tile covers.
	 * @param {Level} level The level this tile is associated with.
	 * @param {Number} row This tile's row in the associated level.
	 * @param {Number} column This tile's column in the associated level.
	 * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
	 * are less than zero, or the specified image path is null, undefined or empty.
	 *
	 */

	function TextureTile(sector, level, row, column) {
	  Tile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

	  /**
	   * GPU cache key
	   * @type {string}
	   */

	  this.gpuCacheKey = null;
	}

	TextureTile.prototype = Object.create(Tile.prototype);
	/**
	 * Returns the size of the this tile in bytes.
	 * @returns {Number} The size of this tile in bytes, not including the associated texture size.
	 */

	TextureTile.prototype.size = function () {
	  return Tile.prototype.size.call(this);
	};
	/**
	 * Causes this tile's texture to be active. Implements [SurfaceTile.bind]{@link SurfaceTile#bind}.
	 * @param {DrawContext} dc The current draw context.
	 * @returns {Boolean} true if the texture was bound successfully, otherwise false.
	 */


	TextureTile.prototype.bind = function (dc) {
	  var texture = dc.gpuResourceCache.resourceForKey(this.gpuCacheKey);

	  if (texture) {
	    return texture.bind(dc);
	  }

	  return false;
	};
	/**
	 * If this tile's fallback texture is used, applies the appropriate texture transform to a specified matrix.
	 * Otherwise, this is a no-op.
	 * @param {DrawContext} dc The current draw context.
	 * @param {Matrix} matrix The matrix to apply the transform to.
	 */


	TextureTile.prototype.applyInternalTransform = function (dc, matrix) {// Override this method if the tile has a fallback texture.
	};

	/**
	 * @exports FramebufferTile
	 */
	/**
	 * Constructs a framebuffer tile.
	 * @alias FramebufferTile
	 * @constructor
	 * @augments TextureTile
	 * @classdesc Represents a WebGL framebuffer applied to a portion of a globe's terrain. The framebuffer's width
	 * and height in pixels are equal to this tile's [tileWidth]{@link FramebufferTile#tileWidth} and
	 * [tileHeight]{@link FramebufferTile#tileHeight}, respectively. The framebuffer can be made active by calling
	 * [bindFramebuffer]{@link FramebufferTile#bindFramebuffer}. Color fragments written to this
	 * tile's framebuffer can then be drawn on the terrain surface using a
	 * [SurfaceTileRenderer]{@link SurfaceTileRenderer}.
	 * <p>
	 * This class is meant to be used internally. Applications typically do not interact with this class.
	 * @param {Sector} sector The sector this tile covers.
	 * @param {Level} level The level this tile is associated with.
	 * @param {Number} row This tile's row in the associated level.
	 * @param {Number} column This tile's column in the associated level.
	 * @param {String} cacheKey A string uniquely identifying this tile relative to other tiles.
	 * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
	 * are less than zero, or the cache name is null, undefined or empty.
	 */

	function FramebufferTile(sector, level, row, column, cacheKey) {
	  if (!cacheKey || cacheKey.length < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "FramebufferTile", "constructor", "The specified cache name is null, undefined or zero length."));
	  }

	  TextureTile.call(this, sector, level, row, column); // args are checked in the superclass' constructor
	  // Assign the cacheKey as the gpuCacheKey (inherited from TextureTile).

	  this.gpuCacheKey = cacheKey; // Internal. Intentionally not documented.

	  this.textureTransform = Matrix.fromIdentity().setToUnitYFlip(); // Internal. Intentionally not documented.

	  this.mustClear = true;
	}

	FramebufferTile.prototype = Object.create(TextureTile.prototype);
	/**
	 * Causes this tile to clear any color fragments written to its off-screen framebuffer.
	 * @param dc The current draw context.
	 */

	FramebufferTile.prototype.clearFramebuffer = function (dc) {
	  this.mustClear = true;
	};
	/**
	 * Causes this tile's off-screen framebuffer as the current WebGL framebuffer. WebGL operations that affect the
	 * framebuffer now affect this tile's framebuffer, rather than the default WebGL framebuffer.
	 * Color fragments are written to this tile's WebGL texture, which can be made active by calling
	 * [SurfaceTile.bind]{@link SurfaceTile#bind}.
	 *
	 * @param {DrawContext} dc The current draw context.
	 * @returns {Boolean} true if the framebuffer was bound successfully, otherwise false.
	 */


	FramebufferTile.prototype.bindFramebuffer = function (dc) {
	  var framebuffer = dc.gpuResourceCache.resourceForKey(this.gpuCacheKey);

	  if (!framebuffer) {
	    framebuffer = this.createFramebuffer(dc);
	  }

	  dc.bindFramebuffer(framebuffer);

	  if (this.mustClear) {
	    this.doClearFramebuffer(dc);
	    this.mustClear = false;
	  }

	  return true;
	}; // Internal. Intentionally not documented.


	FramebufferTile.prototype.createFramebuffer = function (dc) {
	  var framebuffer = new FramebufferTexture(dc.currentGlContext, this.tileWidth, this.tileHeight, false);
	  dc.gpuResourceCache.putResource(this.gpuCacheKey, framebuffer, framebuffer.size);
	  return framebuffer;
	}; // Internal. Intentionally not documented.


	FramebufferTile.prototype.doClearFramebuffer = function (dc) {
	  var gl = dc.currentGlContext;
	  gl.clearColor(0, 0, 0, 0);
	  gl.clear(gl.COLOR_BUFFER_BIT);
	};
	/**
	 * Applies the appropriate texture transform to display this tile's WebGL texture.
	 * @param {DrawContext} dc The current draw context.
	 * @param {Matrix} matrix The matrix to apply the transform to.
	 */


	FramebufferTile.prototype.applyInternalTransform = function (dc, matrix) {
	  matrix.multiplyMatrix(this.textureTransform);
	};

	/**
	 * @exports FramebufferTileController
	 */
	/**
	 * Constructs a framebuffer tile controller.
	 * @alias FramebufferTileController
	 * @constructor
	 * @classdesc Provides access to a multi-resolution WebGL framebuffer arranged as adjacent tiles in a pyramid.
	 * WorldWind shapes use this class internally to draw on the terrain surface. Applications typically do not
	 * interact with this class.
	 */

	function FramebufferTileController() {
	  /**
	   * The width in pixels of framebuffers associated with this controller's tiles.
	   * @type {Number}
	   * @readonly
	   */
	  this.tileWidth = 256;
	  /**
	   * The height in pixels of framebuffers associated with this controller's tiles.
	   * @type {Number}
	   * @readonly
	   */

	  this.tileHeight = 256;
	  /**
	   * Controls the level of detail switching for this controller. The next highest resolution level is
	   * used when an image's texel size is greater than this number of pixels.
	   * @type {Number}
	   * @default 1.75
	   */

	  this.detailControl = 1.75; // Internal. Intentionally not documented.

	  this.levels = new LevelSet(Sector.FULL_SPHERE, new Location(45, 45), 16, this.tileWidth, this.tileHeight); // Internal. Intentionally not documented.

	  this.topLevelTiles = []; // Internal. Intentionally not documented.

	  this.currentTiles = []; // Internal. Intentionally not documented.

	  this.currentTimestamp = null; // Internal. Intentionally not documented.

	  this.currentGlobeStateKey = null; // Internal. Intentionally not documented.

	  this.tileCache = new MemoryCache(500000, 400000); // Internal. Intentionally not documented.

	  this.key = "FramebufferTileController " + ++FramebufferTileController.keyPool;
	} // Internal. Intentionally not documented.


	FramebufferTileController.keyPool = 0; // source of unique ids

	/**
	 * Returns a set of multi-resolution [FramebufferTile]{@link FramebufferTile} instances appropriate for the
	 * current draw context that overlap a specified sector.
	 * @param {DrawContext} dc The current draw context.
	 * @param {Sector} sector The geographic region of interest.
	 * @returns {Array} The set of multi-resolution framebuffer tiles that overlap the sector.
	 * @throws {ArgumentError} If the specified sector is null.
	 */

	FramebufferTileController.prototype.selectTiles = function (dc, sector) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "FramebufferTileController", "selectTiles", "missingSector"));
	  } // Assemble a set of global tiles appropriate for the draw context.


	  this.assembleTiles(dc); // Collect the tiles that overlap the specified sector and mark them as selected.

	  var tiles = [];

	  for (var i = 0, len = this.currentTiles.length; i < len; i++) {
	    var tile = this.currentTiles[i];

	    if (tile.sector.overlaps(sector)) {
	      tile.selected = true;
	      tiles.push(tile);
	    }
	  }

	  return tiles;
	};
	/**
	 * Draws this multi-resolution framebuffer on the terrain surface then clears the framebuffer. This has no
	 * effect if the framebuffer is unchanged since the last call to render.
	 * @param {DrawContext} dc The current draw context.
	 */


	FramebufferTileController.prototype.render = function (dc) {
	  // Exit immediately if there are no framebuffer tiles. This can happen when there ar eno surface shapes in
	  // the scene, for example.
	  if (this.currentTiles.length == 0) {
	    return;
	  } // Collect the tiles that have changed since the last call to render.


	  var tiles = [];

	  for (var i = 0, len = this.currentTiles.length; i < len; i++) {
	    var tile = this.currentTiles[i];

	    if (tile.selected) {
	      tiles.push(tile);
	    }
	  } // Draw the changed tiles on the terrain surface.


	  dc.surfaceTileRenderer.renderTiles(dc, tiles, 1); // Clear the changed tile's WebGL framebuffers.

	  var gl = dc.currentGlContext,
	      framebuffer = dc.currentFramebuffer;

	  try {
	    gl.clearColor(0, 0, 0, 0);

	    for (i = 0, len = tiles.length; i < len; i++) {
	      tile = tiles[i];
	      tile.selected = false;
	      tile.bindFramebuffer(dc);
	      gl.clear(gl.COLOR_BUFFER_BIT);
	    }
	  } finally {
	    dc.bindFramebuffer(framebuffer);
	  }
	}; // Internal. Intentionally not documented.


	FramebufferTileController.prototype.assembleTiles = function (dc) {
	  var timestamp = dc.timestamp,
	      globeStateKey = dc.globeStateKey;

	  if (this.currentTimestamp != timestamp || this.currentGlobeStateKey != globeStateKey) {
	    this.doAssembleTiles(dc);
	    this.currentTimestamp = timestamp;
	    this.currentGlobeStateKey = globeStateKey;
	  }
	}; // Internal. Intentionally not documented.


	FramebufferTileController.prototype.doAssembleTiles = function (dc) {
	  this.currentTiles = [];

	  if (!dc.terrain) {
	    return;
	  }

	  if (this.topLevelTiles.length == 0) {
	    this.createTopLevelTiles();
	  }

	  for (var i = 0, len = this.topLevelTiles.length; i < len; i++) {
	    var tile = this.topLevelTiles[i];
	    tile.update(dc);

	    if (this.isTileVisible(dc, tile)) {
	      this.addTileOrDescendants(dc, tile);
	    }
	  }
	}; // Internal. Intentionally not documented.


	FramebufferTileController.prototype.createTile = function (sector, level, row, column) {
	  var tileKey = this.key + " " + level.levelNumber + "." + row + "." + column;
	  return new FramebufferTile(sector, level, row, column, tileKey);
	}; // Internal. Intentionally not documented.


	FramebufferTileController.prototype.createTopLevelTiles = function () {
	  Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles);
	}; // Internal. Intentionally not documented.


	FramebufferTileController.prototype.addTileOrDescendants = function (dc, tile) {
	  if (this.tileMeetsRenderingCriteria(dc, tile)) {
	    this.addTile(tile);
	    return;
	  }

	  var subTiles = tile.subdivideToCache(tile.level.nextLevel(), this, this.tileCache);

	  for (var i = 0, len = subTiles.length; i < len; i++) {
	    var child = subTiles[i];
	    child.update(dc);

	    if (this.isTileVisible(dc, child)) {
	      this.addTileOrDescendants(dc, child);
	    }
	  }
	}; // Internal. Intentionally not documented.


	FramebufferTileController.prototype.addTile = function (tile) {
	  this.currentTiles.push(tile);
	}; // Internal. Intentionally not documented.


	FramebufferTileController.prototype.isTileVisible = function (dc, tile) {
	  if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
	    return false;
	  }

	  if (dc.pickingMode) {
	    return tile.extent.intersectsFrustum(dc.pickFrustum);
	  }

	  return tile.extent.intersectsFrustum(dc.frustumInModelCoordinates);
	}; // Internal. Intentionally not documented.


	FramebufferTileController.prototype.tileMeetsRenderingCriteria = function (dc, tile) {
	  var s = this.detailControl;

	  if (tile.sector.minLatitude >= 75 || tile.sector.maxLatitude <= -75) {
	    s *= 1.2;
	  }

	  return tile.level.isLastLevel() || !tile.mustSubdivide(dc, s);
	};

	/**
	 * @exports Frustum
	 */
	/**
	 * Constructs a frustum.
	 * @alias Frustum
	 * @constructor
	 * @classdesc Represents a six-sided view frustum in Cartesian coordinates.
	 * @param {Plane} left The frustum's left plane.
	 * @param {Plane} right The frustum's right plane.
	 * @param {Plane} bottom The frustum's bottom plane.
	 * @param {Plane} top The frustum's top plane.
	 * @param {Plane} near The frustum's near plane.
	 * @param {Plane} far The frustum's far plane.
	 * @throws {ArgumentError} If any specified plane is null or undefined.
	 */

	function Frustum(left, right, bottom, top, near, far) {
	  if (!left || !right || !bottom || !top || !near || !far) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Frustum", "constructor", "missingPlane"));
	  } // Internal. Intentionally not documented. See property accessors below for public interface.


	  this._left = left;
	  this._right = right;
	  this._bottom = bottom;
	  this._top = top;
	  this._near = near;
	  this._far = far; // Internal. Intentionally not documented.

	  this._planes = [this._left, this._right, this._top, this._bottom, this._near, this._far];
	} // These accessors are defined in order to prevent changes that would make the properties inconsistent with the
	// planes array.


	Object.defineProperties(Frustum.prototype, {
	  /**
	   * This frustum's left plane.
	   * @memberof Frustum.prototype
	   * @type {Plane}
	   * @readonly
	   */
	  left: {
	    get: function () {
	      return this._left;
	    }
	  },

	  /**
	   * This frustum's right plane.
	   * @memberof Frustum.prototype
	   * @type {Plane}
	   * @readonly
	   */
	  right: {
	    get: function () {
	      return this._right;
	    }
	  },

	  /**
	   * This frustum's bottom plane.
	   * @memberof Frustum.prototype
	   * @type {Plane}
	   * @readonly
	   */
	  bottom: {
	    get: function () {
	      return this._bottom;
	    }
	  },

	  /**
	   * This frustum's top plane.
	   * @memberof Frustum.prototype
	   * @type {Plane}
	   * @readonly
	   */
	  top: {
	    get: function () {
	      return this._top;
	    }
	  },

	  /**
	   * This frustum's near plane.
	   * @memberof Frustum.prototype
	   * @type {Plane}
	   * @readonly
	   */
	  near: {
	    get: function () {
	      return this._near;
	    }
	  },

	  /**
	   * This frustum's far plane.
	   * @memberof Frustum.prototype
	   * @type {Plane}
	   * @readonly
	   */
	  far: {
	    get: function () {
	      return this._far;
	    }
	  }
	});
	/**
	 * Transforms this frustum by a specified matrix.
	 * @param {Matrix} matrix The matrix to apply to this frustum.
	 * @returns {Frustum} This frustum set to its original value multiplied by the specified matrix.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */

	Frustum.prototype.transformByMatrix = function (matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Frustum", "transformByMatrix", "missingMatrix"));
	  }

	  this._left.transformByMatrix(matrix);

	  this._right.transformByMatrix(matrix);

	  this._bottom.transformByMatrix(matrix);

	  this._top.transformByMatrix(matrix);

	  this._near.transformByMatrix(matrix);

	  this._far.transformByMatrix(matrix);

	  return this;
	};
	/**
	 * Normalizes the plane vectors of the planes composing this frustum.
	 * @returns {Frustum} This frustum with its planes normalized.
	 */


	Frustum.prototype.normalize = function () {
	  this._left.normalize();

	  this._right.normalize();

	  this._bottom.normalize();

	  this._top.normalize();

	  this._near.normalize();

	  this._far.normalize();

	  return this;
	};
	/**
	 * Returns a new frustum with each of its planes 1 meter from the center.
	 * @returns {Frustum} The new frustum.
	 */


	Frustum.unitFrustum = function () {
	  return new Frustum(new Plane(1, 0, 0, 1), // left
	  new Plane(-1, 0, 0, 1), // right
	  new Plane(0, 1, 1, 1), // bottom
	  new Plane(0, -1, 0, 1), // top
	  new Plane(0, 0, -1, 1), // near
	  new Plane(0, 0, 1, 1) // far
	  );
	};
	/**
	 * Extracts a frustum from a projection matrix.
	 * <p>
	 * This method assumes that the specified matrix represents a projection matrix. If it does not represent a projection matrix
	 * the results are undefined.
	 * <p>
	 * A projection matrix's view frustum is a Cartesian volume that contains everything visible in a scene displayed
	 * using that projection matrix.
	 *
	 * @param {Matrix} matrix The projection matrix to extract the frustum from.
	 * @return {Frustum} A new frustum containing the projection matrix's view frustum, in eye coordinates.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */


	Frustum.fromProjectionMatrix = function (matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Frustum", "fromProjectionMatrix", "missingMatrix"));
	  }

	  var x, y, z, w, d, left, right, top, bottom, near, far; // Left Plane = row 4 + row 1:

	  x = matrix[12] + matrix[0];
	  y = matrix[13] + matrix[1];
	  z = matrix[14] + matrix[2];
	  w = matrix[15] + matrix[3];
	  d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates

	  left = new Plane(x / d, y / d, z / d, w / d); // Right Plane = row 4 - row 1:

	  x = matrix[12] - matrix[0];
	  y = matrix[13] - matrix[1];
	  z = matrix[14] - matrix[2];
	  w = matrix[15] - matrix[3];
	  d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates

	  right = new Plane(x / d, y / d, z / d, w / d); // Bottom Plane = row 4 + row 2:

	  x = matrix[12] + matrix[4];
	  y = matrix[13] + matrix[5];
	  z = matrix[14] + matrix[6];
	  w = matrix[15] + matrix[7];
	  d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates

	  bottom = new Plane(x / d, y / d, z / d, w / d); // Top Plane = row 4 - row 2:

	  x = matrix[12] - matrix[4];
	  y = matrix[13] - matrix[5];
	  z = matrix[14] - matrix[6];
	  w = matrix[15] - matrix[7];
	  d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates

	  top = new Plane(x / d, y / d, z / d, w / d); // Near Plane = row 4 + row 3:

	  x = matrix[12] + matrix[8];
	  y = matrix[13] + matrix[9];
	  z = matrix[14] + matrix[10];
	  w = matrix[15] + matrix[11];
	  d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates

	  near = new Plane(x / d, y / d, z / d, w / d); // Far Plane = row 4 - row 3:

	  x = matrix[12] - matrix[8];
	  y = matrix[13] - matrix[9];
	  z = matrix[14] - matrix[10];
	  w = matrix[15] - matrix[11];
	  d = Math.sqrt(x * x + y * y + z * z); // for normalizing the coordinates

	  far = new Plane(x / d, y / d, z / d, w / d);
	  return new Frustum(left, right, bottom, top, near, far);
	};

	Frustum.prototype.containsPoint = function (point) {
	  if (!point) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Frustum", "containsPoint", "missingPoint"));
	  } // See if the point is entirely within the frustum. The dot product of the point with each plane's vector
	  // provides a distance to each plane. If this distance is less than 0, the point is clipped by that plane and
	  // neither intersects nor is contained by the space enclosed by this Frustum.


	  if (this._far.dot(point) <= 0) return false;
	  if (this._left.dot(point) <= 0) return false;
	  if (this._right.dot(point) <= 0) return false;
	  if (this._top.dot(point) <= 0) return false;
	  if (this._bottom.dot(point) <= 0) return false;
	  if (this._near.dot(point) <= 0) return false;
	  return true;
	};
	/**
	 * Determines whether a line segment intersects this frustum.
	 *
	 * @param {Vec3} pointA One end of the segment.
	 * @param {Vec3} pointB The other end of the segment.
	 *
	 * @return {boolean} <code>true</code> if the segment intersects or is contained in this frustum,
	 * otherwise <code>false</code>.
	 *
	 * @throws {ArgumentError} If either point is null or undefined.
	 */


	Frustum.prototype.intersectsSegment = function (pointA, pointB) {
	  if (!pointA || !pointB) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Frustum", "containsPoint", "missingPoint"));
	  } // First do a trivial accept test.


	  if (this.containsPoint(pointA) || this.containsPoint(pointB)) return true;
	  if (pointA.equals(pointB)) return false;

	  for (var i = 0, len = this._planes.length; i < len; i++) {
	    // See if both points are behind the plane and therefore not in the frustum.
	    if (this._planes[i].onSameSide(pointA, pointB) < 0) return false; // See if the segment intersects the plane.

	    if (this._planes[i].clip(pointA, pointB) != null) return true;
	  }

	  return false; // segment does not intersect frustum
	};

	/**
	 * @exports ElevationModel
	 */
	/**
	 * Constructs an elevation model.
	 * @alias ElevationModel
	 * @constructor
	 * @classdesc Represents the elevations for an area, often but not necessarily the whole globe.
	 */

	function ElevationModel() {
	  /**
	   * Internal use only
	   * The unique ID of this model.
	   * @type {Array}
	   * @ignore
	   */
	  this.id = 0;
	  /**
	   * A string identifying this elevation model's current state. Used to compare states during rendering to
	   * determine whether globe-state dependent cached values must be updated. Applications typically do not
	   * interact with this property. It is primarily used by shapes and terrain generators.
	   * @memberof ElevationModel.prototype
	   * @readonly
	   * @type {String}
	   */

	  this.stateKey = "";
	  /**
	   * The list of all elevation coverages usable by this model.
	   * @type {Array}
	   */

	  this.coverages = [];
	  this.scratchLocation = new Location(0, 0);
	  this.computeStateKey();
	}

	Object.defineProperties(ElevationModel.prototype, {
	  /**
	   * Indicates the last time the coverages changed, in milliseconds since midnight Jan 1, 1970.
	   * @type {Number}
	   * @readonly
	   */
	  timestamp: {
	    get: function () {
	      var maxTimestamp = 0;
	      var i, len;

	      for (i = 0, len = this.coverages.length; i < len; i++) {
	        var coverage = this.coverages[i];

	        if (maxTimestamp < coverage.timestamp) {
	          maxTimestamp = coverage.timestamp;
	        }
	      }

	      return maxTimestamp;
	    }
	  },

	  /**
	   * This model's minimum elevation in meters across all enabled coverages.
	   * @type {Number}
	   * @readonly
	   */
	  minElevation: {
	    get: function () {
	      var minElevation = Number.MAX_VALUE;

	      for (var i = 0, len = this.coverages.length; i < len; i++) {
	        var coverage = this.coverages[i];

	        if (coverage.enabled && coverage.minElevation < minElevation) {
	          minElevation = coverage.minElevation;
	        }
	      }

	      return minElevation !== Number.MAX_VALUE ? minElevation : 0; // no coverages or all coverages disabled
	    }
	  },

	  /**
	   * This model's maximum elevation in meters across all enabled coverages.
	   * @type {Number}
	   * @readonly
	   */
	  maxElevation: {
	    get: function () {
	      var maxElevation = -Number.MAX_VALUE;

	      for (var i = 0, len = this.coverages.length; i < len; i++) {
	        var coverage = this.coverages[i];

	        if (coverage.enabled && coverage.maxElevation > maxElevation) {
	          maxElevation = coverage.maxElevation;
	        }
	      }

	      return maxElevation !== -Number.MAX_VALUE ? maxElevation : 0; // no coverages or all coverages disabled
	    }
	  }
	});
	/**
	 * Internal use only
	 * Used to assign unique IDs to elevation models for use in their state key.
	 * @type {Number}
	 * @ignore
	 */

	ElevationModel.idPool = 0;
	/**
	 * Internal use only
	 * Sets the state key to a new unique value.
	 * @ignore
	 */

	ElevationModel.prototype.computeStateKey = function () {
	  this.id = ++ElevationModel.idPool;
	  this.stateKey = "elevationModel " + this.id.toString() + " ";
	};
	/**
	 * Internal use only
	 * The comparison function used for sorting elevation coverages.
	 * @ignore
	 */


	ElevationModel.prototype.coverageComparator = function (coverage1, coverage2) {
	  var res1 = coverage1.resolution;
	  var res2 = coverage2.resolution; // sort from lowest resolution to highest

	  return res1 > res2 ? -1 : res1 === res2 ? 0 : 1;
	};
	/**
	 * Internal use only
	 * Perform common actions required when the list of available coverages changes.
	 * @ignore
	 */


	ElevationModel.prototype.performCoverageListChangedActions = function () {
	  if (this.coverages.length > 1) {
	    this.coverages.sort(this.coverageComparator);
	  }

	  this.computeStateKey();
	};
	/**
	 * Adds an elevation coverage to this elevation model and sorts the list. Duplicate coverages will be ignored.
	 *
	 * @param coverage The elevation coverage to add.
	 * @return {Boolean} true if the ElevationCoverage as added; false if the coverage was a duplicate.
	 * @throws ArgumentError if the specified elevation coverage is null.
	 */


	ElevationModel.prototype.addCoverage = function (coverage) {
	  if (!coverage) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationModel", "addCoverage", "missingCoverage"));
	  }

	  if (!this.containsCoverage(coverage)) {
	    this.coverages.push(coverage);
	    this.performCoverageListChangedActions();
	    return true;
	  }

	  return false;
	};
	/**
	 * Removes all elevation coverages from this elevation model.
	 */


	ElevationModel.prototype.removeAllCoverages = function () {
	  if (this.coverages.length > 0) {
	    this.coverages = [];
	    this.performCoverageListChangedActions();
	  }
	};
	/**
	 * Removes a specific elevation coverage from this elevation model.
	 *
	 * @param coverage The elevation model to remove.
	 *
	 * @throws ArgumentError if the specified elevation coverage is null.
	 */


	ElevationModel.prototype.removeCoverage = function (coverage) {
	  if (!coverage) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationModel", "removeCoverage", "missingCoverage"));
	  }

	  var index = this.coverages.indexOf(coverage);

	  if (index >= 0) {
	    this.coverages.splice(index, 1);
	    this.performCoverageListChangedActions();
	  }
	};
	/**
	 * Returns true if this ElevationModel contains the specified ElevationCoverage, and false otherwise.
	 *
	 * @param coverage the ElevationCoverage to test.
	 * @return {Boolean} true if the ElevationCoverage is in this ElevationModel; false otherwise.
	 * @throws ArgumentError if the ElevationCoverage is null.
	 */


	ElevationModel.prototype.containsCoverage = function (coverage) {
	  if (!coverage) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationModel", "containsCoverage", "missingCoverage"));
	  }

	  var index = this.coverages.indexOf(coverage);
	  return index >= 0;
	};
	/**
	 * Returns the minimum and maximum elevations within a specified sector.
	 * @param {Sector} sector The sector for which to determine extreme elevations.
	 * @returns {Number[]} An array containing the minimum and maximum elevations within the specified sector. If no coverage
	 * can satisfy the request, a min and max of zero is returned.
	 * @throws {ArgumentError} If the specified sector is null or undefined.
	 */


	ElevationModel.prototype.minAndMaxElevationsForSector = function (sector) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationModel", "minAndMaxElevationsForSector", "missingSector"));
	  } // Initialize the min and max elevations to the largest and smallest numbers, respectively. This has the
	  // effect of moving the extremes with each subsequent coverage as needed, without unintentionally capturing
	  // zero elevation. If we initialized this array with zeros the result would always contain zero, even when
	  // elevations in the sector are all above or below zero. This is critical for tile bounding boxes.


	  var result = [Number.MAX_VALUE, -Number.MAX_VALUE];

	  for (var i = this.coverages.length - 1; i >= 0; i--) {
	    var coverage = this.coverages[i];

	    if (coverage.enabled && coverage.coverageSector.intersects(sector)) {
	      if (coverage.minAndMaxElevationsForSector(sector, result)) {
	        break; // coverage completely fills the sector, ignore the remaining coverages
	      }
	    }
	  }

	  return result[0] !== Number.MAX_VALUE ? result : [0, 0]; // no coverages, all coverages disabled, or no coverages intersect the sector
	};
	/**
	 * Returns the elevation at a specified location.
	 * @param {Number} latitude The location's latitude in degrees.
	 * @param {Number} longitude The location's longitude in degrees.
	 * @returns {Number} The elevation at the specified location, in meters. Returns zero if the location is
	 * outside the coverage area of this model.
	 */


	ElevationModel.prototype.elevationAtLocation = function (latitude, longitude) {
	  var i,
	      n = this.coverages.length;

	  for (i = n - 1; i >= 0; i--) {
	    var coverage = this.coverages[i];

	    if (coverage.enabled && coverage.coverageSector.containsLocation(latitude, longitude)) {
	      var elevation = coverage.elevationAtLocation(latitude, longitude);

	      if (elevation !== null) {
	        return elevation;
	      }
	    }
	  }

	  return 0;
	};
	/**
	 * Internal use only
	 * Returns the index of the coverage most closely matching the supplied resolution and overlapping the supplied
	 * sector or point area of interest. At least one area of interest parameter must be non-null.
	 * @param {Sector} sector An optional sector area of interest. Setting this parameter to null will cause it to be ignored.
	 * @param {Location} location An optional point area of interest. Setting this parameter to null will cause it to be ignored.
	 * @param {Number} targetResolution The desired elevation resolution, in degrees. (To compute degrees from
	 * meters, divide the number of meters by the globe's radius to obtain radians and convert the result to degrees.)
	 * @returns {Number} The index of the coverage most closely matching the requested resolution.
	 * @ignore
	 */


	ElevationModel.prototype.preferredCoverageIndex = function (sector, location, targetResolution) {
	  var i,
	      n = this.coverages.length,
	      minResDiff = Number.MAX_VALUE,
	      minDiffIdx = -1;

	  for (i = 0; i < n; i++) {
	    var coverage = this.coverages[i],
	        validCoverage = coverage.enabled && (sector !== null && coverage.coverageSector.intersects(sector) || location !== null && coverage.coverageSector.containsLocation(location.latitude, location.longitude));

	    if (validCoverage) {
	      var resDiff = Math.abs(coverage.resolution - targetResolution);

	      if (resDiff > minResDiff) {
	        return minDiffIdx;
	      }

	      minResDiff = resDiff;
	      minDiffIdx = i;
	    }
	  }

	  return minDiffIdx;
	};
	/**
	 * Returns the best coverage available for a particular resolution,
	 * @param {Number} latitude The location's latitude in degrees.
	 * @param {Number} longitude The location's longitude in degrees.
	 * @param {Number} targetResolution The desired elevation resolution, in degrees. (To compute degrees from
	 * meters, divide the number of meters by the globe's radius to obtain radians and convert the result to degrees.)
	 * @returns {ElevationCoverage} The coverage most closely matching the requested resolution. Returns null if no coverage is available at this
	 * location.
	 * @throws {ArgumentError} If the specified resolution is not positive.
	 */


	ElevationModel.prototype.bestCoverageAtLocation = function (latitude, longitude, targetResolution) {
	  if (!targetResolution || targetResolution < 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationModel", "bestCoverageAtLocation", "invalidResolution"));
	  }

	  this.scratchLocation.set(latitude, longitude);
	  var preferredIndex = this.preferredCoverageIndex(null, this.scratchLocation, targetResolution);

	  if (preferredIndex >= 0) {
	    return this.coverages[preferredIndex];
	  }

	  return null;
	};
	/**
	 * Returns the elevations at locations within a specified sector.
	 * @param {Sector} sector The sector for which to determine the elevations.
	 * @param {Number} numLat The number of latitudinal sample locations within the sector.
	 * @param {Number} numLon The number of longitudinal sample locations within the sector.
	 * @param {Number} targetResolution The desired elevation resolution, in degrees. (To compute degrees from
	 * meters, divide the number of meters by the globe's radius to obtain radians and convert the result to degrees.)
	 * @param {Number[]} result An array in which to return the requested elevations.
	 * @returns {Number} The resolution actually achieved, which may be greater than that requested if the
	 * elevation data for the requested resolution is not currently available.
	 * @throws {ArgumentError} If the specified sector, targetResolution, or result array is null or undefined, or if either of the
	 * specified numLat or numLon values is less than one.
	 */


	ElevationModel.prototype.elevationsForGrid = function (sector, numLat, numLon, targetResolution, result) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationModel", "elevationsForGrid", "missingSector"));
	  }

	  if (!numLat || !numLon || numLat < 1 || numLon < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationModel", "elevationsForGrid", "The specified number of latitudinal or longitudinal positions is less than one."));
	  }

	  if (!targetResolution) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationModel", "elevationsForGrid", "missingTargetResolution"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ElevationModel", "elevationsForGrid", "missingResult"));
	  }

	  result.fill(NaN);
	  var resolution = Number.MAX_VALUE,
	      resultFilled = false,
	      preferredIndex = this.preferredCoverageIndex(sector, null, targetResolution);

	  if (preferredIndex >= 0) {
	    for (var i = preferredIndex; !resultFilled && i >= 0; i--) {
	      var coverage = this.coverages[i];

	      if (coverage.enabled && coverage.coverageSector.intersects(sector)) {
	        resultFilled = coverage.elevationsForGrid(sector, numLat, numLon, result);

	        if (resultFilled) {
	          resolution = coverage.resolution;
	        }
	      }
	    }
	  }

	  if (!resultFilled) {
	    var n = result.length;

	    for (i = 0; i < n; i++) {
	      if (isNaN(result[i])) {
	        result[i] = 0;
	      }
	    }
	  }

	  return resolution;
	};

	/**
	 * @exports GeographicProjection
	 */
	/**
	 * Constructs a base geographic projection.
	 * @alias GeographicProjection
	 * @constructor
	 * @classdesc Represents a geographic projection.
	 * This is an abstract class and is meant to be instantiated only by subclasses.
	 * See the following projections:
	 * <ul>
	 *     <li>{@link ProjectionEquirectangular}</li>
	 *     <li>{@link ProjectionMercator}</li>
	 *     <li>{@link ProjectionPolarEquidistant}</li>
	 *     <li>{@link ProjectionUPS}</li>
	 </ul>
	 * @param {String} displayName The projection's display name.
	 * @param {boolean} continuous Indicates whether this projection is continuous.
	 * @param {Sector} projectionLimits This projection's projection limits. May be null to indicate the full
	 * range of latitude and longitude, +/- 90 degrees latitude, +/- 180 degrees longitude.
	 */

	function GeographicProjection(displayName, continuous, projectionLimits) {
	  /**
	   * This projection's display name.
	   * @type {string}
	   */
	  this.displayName = displayName || "Geographic Projection";
	  /**
	   * Indicates whether this projection should be treated as continuous with itself. If true, the 2D map
	   * will appear to scroll continuously horizontally.
	   * @type {boolean}
	   * @readonly
	   */

	  this.continuous = continuous;
	  /**
	   * Indicates the geographic limits of this projection.
	   * @type {Sector}
	   * @readonly
	   */

	  this.projectionLimits = projectionLimits;
	  /**
	   * Indicates whether this projection is a 2D projection.
	   * @type {boolean}
	   * @readonly
	   */

	  this.is2D = true;
	}
	/**
	 * Converts a geographic position to Cartesian coordinates.
	 *
	 * @param {Globe} globe The globe this projection is applied to.
	 * @param {number} latitude The latitude of the position, in degrees.
	 * @param {number} longitude The longitude of the position, in degrees.
	 * @param {number} elevation The elevation of the position, in meters.
	 * @param {Vec3} offset An offset to apply to the Cartesian output. Typically only projections that are
	 * continuous (see [continuous]{@link GeographicProjection#continuous}) apply to this offset. Others ignore
	 * it. May be null to indicate no offset is applied.
	 * @param {Vec3} result A variable in which to store the computed Cartesian point.
	 *
	 * @returns {Vec3} The specified result argument containing the computed point.
	 * @throws {ArgumentError} If the specified globe or result is null or undefined.
	 */


	GeographicProjection.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation, offset, result) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicProjection", "geographicToCartesian", "abstractInvocation"));
	};
	/**
	 * Computes a grid of Cartesian points within a specified sector and relative to a specified Cartesian
	 * reference point.
	 * <p>
	 * This method is used to compute a collection of points within a sector. It is used by tessellators to
	 * efficiently generate a tile's interior points. The number of points to generate is indicated by the tileWidth
	 * and tileHeight parameters but is one more in each direction. Width refers to the longitudinal direction,
	 * height to the latitudinal.
	 * <p>
	 * For each implied position within the sector, an elevation value is specified via an array of elevations. The
	 * calculation at each position incorporates the associated elevation.
	 * There must be (tileWidth + 1) x (tileHeight + 1) elevations in the array.
	 *
	 * @param {Globe} globe The globe this projection applies to.
	 * @param {Sector} sector The sector in which to compute the points.
	 * @param {Number} numLat The number of latitudinal sections a tile is divided into.
	 * @param {Number} numLon The number of longitudinal sections a tile is divided into.
	 * @param {Number[]} elevations An array of elevations to incorporate in the point calculations. There must be
	 * one elevation value in the array for each generated point. Elevations are in meters.
	 * There must be (tileWidth + 1) x (tileHeight + 1) elevations in the array.
	 * @param {Vec3} referencePoint The X, Y and Z Cartesian coordinates to subtract from the computed coordinates.
	 * This makes the computed coordinates relative to the specified point. May be null.
	 * @param {Vec3} offset An offset to apply to the Cartesian output points. Typically only projections that
	 * are continuous (see [continuous]{@link GeographicProjection#continuous}) apply this offset. Others ignore it.
	 * May be null to indicate that no offset is applied.
	 * @param {Float32Array} result A typed array to hold the computed coordinates. It must be at least of
	 * size (tileWidth + 1) x (tileHeight + 1) * 3.
	 * The points are returned in row major order, beginning with the row of minimum latitude.
	 * @returns {Float32Array} The specified result argument, populated with the computed Cartesian coordinates.
	 * @throws {ArgumentError} if any of the specified globe, sector, elevations array or results arrays is null or
	 * undefined.
	 */


	GeographicProjection.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations, referencePoint, offset, result) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicProjection", "geographicToCartesianGrid", "abstractInvocation"));
	};
	/**
	 * Converts a Cartesian point to a geographic position.
	 * @param {Globe} globe The globe this projection is applied to.
	 * @param {number} x The X component of the Cartesian point.
	 * @param {number} y The Y component of the Cartesian point.
	 * @param {number} z The Z component of the Cartesian point.
	 * @param {Vec3} offset An offset to apply to the Cartesian output points. Typically only projections that
	 * are continuous (see [continuous]{@link GeographicProjection#continuous}) apply this offset. Others ignore it.
	 * May be null to indicate that no offset is applied.
	 * @param {Position} result A variable in which to return the computed position.
	 *
	 * @returns {Position} The specified result argument containing the computed position.
	 * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
	 */


	GeographicProjection.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicProjection", "cartesianToGeographic", "abstractInvocation"));
	};
	/**
	 * Computes a Cartesian vector that points north and is tangent to the meridian at a specified geographic
	 * location.
	 *
	 * @param {Globe} globe The globe this projection is applied to.
	 * @param {number} latitude The latitude of the location, in degrees.
	 * @param {number} longitude The longitude of the location, in degrees.
	 * @param {Vec3} result A variable in which to return the computed vector.
	 *
	 * @returns{Vec3} The specified result argument containing the computed vector.
	 * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
	 */


	GeographicProjection.prototype.northTangentAtLocation = function (globe, latitude, longitude, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionEquirectangular", "northTangentAtLocation", "missingResult"));
	  }

	  result[0] = 0;
	  result[1] = 1;
	  result[2] = 0;
	  return result;
	};
	/**
	 * Computes a Cartesian vector that points north and is tangent to the meridian at a specified Cartesian
	 * point.
	 *
	 * @param {Globe} globe The globe this projection is applied to.
	 * @param {number} x The X component of the Cartesian point.
	 * @param {number} y The Y component of the Cartesian point.
	 * @param {number} z The Z component of the Cartesian point.
	 * @param {Vec3} offset An offset to apply to the Cartesian point. Typically only projections that
	 * are continuous (see [continuous]{@link GeographicProjection#continuous}) apply this offset. Others ignore it.
	 * May be null to indicate that no offset is applied.
	 * @param {Vec3} result A variable in which to return the computed vector.
	 *
	 * @returns{Vec3} The specified result argument containing the computed vector.
	 * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
	 */


	GeographicProjection.prototype.northTangentAtPoint = function (globe, x, y, z, offset, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionEquirectangular", "northTangentAtPoint", "missingResult"));
	  }

	  result[0] = 0;
	  result[1] = 1;
	  result[2] = 0;
	  return result;
	};
	/**
	 * Computes the Cartesian surface normal vector at a specified geographic location.
	 *
	 * @param {Globe} globe The globe this projection is applied to.
	 * @param {number} latitude The latitude of the location, in degrees.
	 * @param {number} longitude The longitude of the location, in degrees.
	 * @param {Vec3} result A variable in which to return the computed vector.
	 *
	 * @returns{Vec3} The specified result argument containing the computed vector.
	 * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
	 */


	GeographicProjection.prototype.surfaceNormalAtLocation = function (globe, latitude, longitude, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicProjection", "surfaceNormalAtLocation", "missingResult"));
	  }

	  result[0] = 0;
	  result[1] = 0;
	  result[2] = 1;
	  return result;
	};
	/**
	 * Computes the Cartesian surface normal vector at a specified Cartesian point.
	 *
	 * @param {Globe} globe The globe this projection is applied to.
	 * @param {number} x The X component of the Cartesian point.
	 * @param {number} y The Y component of the Cartesian point.
	 * @param {number} z The Z component of the Cartesian point.
	 * @param {Vec3} result A variable in which to return the computed vector.
	 *
	 * @returns{Vec3} The specified result argument containing the computed vector.
	 * @throws {ArgumentError} If either the specified globe or result argument is null or undefined.
	 */


	GeographicProjection.prototype.surfaceNormalAtPoint = function (globe, x, y, z, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicProjection", "surfaceNormalAtPoint", "missingResult"));
	  }

	  result[0] = 0;
	  result[1] = 0;
	  result[2] = 1;
	  return result;
	};

	/**
	 * @exports ProjectionWgs84
	 */
	/**
	 * Constructs a WGS84 ellipsoid
	 * @alias ProjectionWgs84
	 * @constructor
	 * @augments GeographicProjection
	 * @classdesc Represents a WGS84 ellipsoid.
	 */

	function ProjectionWgs84() {
	  GeographicProjection.call(this, "WGS84", false, null);
	  this.is2D = false;
	  this.scratchPosition = new Position(0, 0, 0);
	}

	ProjectionWgs84.prototype = Object.create(GeographicProjection.prototype);
	Object.defineProperties(ProjectionWgs84.prototype, {
	  /**
	   * A string identifying this projection's current state. Used to compare states during rendering to
	   * determine whether globe-state dependent cached values must be updated. Applications typically do not
	   * interact with this property.
	   * @memberof ProjectionEquirectangular.prototype
	   * @readonly
	   * @type {String}
	   */
	  stateKey: {
	    get: function () {
	      return "projection wgs84 ";
	    }
	  }
	}); // Documented in base class.

	ProjectionWgs84.prototype.geographicToCartesian = function (globe, latitude, longitude, altitude, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionWgs84", "geographicToCartesian", "missingGlobe"));
	  }

	  var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),
	      sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
	      cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),
	      sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS),
	      rpm = globe.equatorialRadius / Math.sqrt(1.0 - globe.eccentricitySquared * sinLat * sinLat);
	  result[0] = (rpm + altitude) * cosLat * sinLon;
	  result[1] = (rpm * (1.0 - globe.eccentricitySquared) + altitude) * sinLat;
	  result[2] = (rpm + altitude) * cosLat * cosLon;
	  return result;
	}; // Documented in base class.


	ProjectionWgs84.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations, referencePoint, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionWgs84", "geographicToCartesianGrid", "missingGlobe"));
	  }

	  var minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,
	      maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,
	      minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,
	      maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,
	      deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
	      deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
	      refCenter = referencePoint ? referencePoint : new Vec3$1(0, 0, 0),
	      latIndex,
	      lonIndex,
	      elevIndex = 0,
	      resultIndex = 0,
	      lat,
	      lon,
	      rpm,
	      elev,
	      cosLat,
	      sinLat,
	      cosLon = new Float64Array(numLon),
	      sinLon = new Float64Array(numLon); // Compute and save values that are a function of each unique longitude value in the specified sector. This
	  // eliminates the need to re-compute these values for each column of constant longitude.

	  for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {
	    if (lonIndex === numLon - 1) {
	      lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
	    }

	    cosLon[lonIndex] = Math.cos(lon);
	    sinLon[lonIndex] = Math.sin(lon);
	  } // Iterate over the latitude and longitude coordinates in the specified sector, computing the Cartesian
	  // point corresponding to each latitude and longitude.


	  for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {
	    if (latIndex === numLat - 1) {
	      lat = maxLat; // explicitly set the last lat to the max longitude to ensure alignment
	    } // Latitude is constant for each row. Values that are a function of latitude can be computed once per row.


	    cosLat = Math.cos(lat);
	    sinLat = Math.sin(lat);
	    rpm = globe.equatorialRadius / Math.sqrt(1.0 - globe.eccentricitySquared * sinLat * sinLat);

	    for (lonIndex = 0; lonIndex < numLon; lonIndex++) {
	      elev = elevations[elevIndex++];
	      result[resultIndex++] = (rpm + elev) * cosLat * sinLon[lonIndex] - refCenter[0];
	      result[resultIndex++] = (rpm * (1.0 - globe.eccentricitySquared) + elev) * sinLat - refCenter[1];
	      result[resultIndex++] = (rpm + elev) * cosLat * cosLon[lonIndex] - refCenter[2];
	    }
	  }

	  return result;
	}; // Documented in base class.


	ProjectionWgs84.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionWgs84", "cartesianToGeographic", "missingGlobe"));
	  } // According to H. Vermeille, "An analytical method to transform geocentric into geodetic coordinates"
	  // http://www.springerlink.com/content/3t6837t27t351227/fulltext.pdf
	  // Journal of Geodesy, accepted 10/2010, not yet published


	  var X = z,
	      Y = x,
	      Z = y,
	      XXpYY = X * X + Y * Y,
	      sqrtXXpYY = Math.sqrt(XXpYY),
	      a = globe.equatorialRadius,
	      ra2 = 1 / (a * a),
	      e2 = globe.eccentricitySquared,
	      e4 = e2 * e2,
	      p = XXpYY * ra2,
	      q = Z * Z * (1 - e2) * ra2,
	      r = (p + q - e4) / 6,
	      h,
	      phi,
	      u,
	      evoluteBorderTest = 8 * r * r * r + e4 * p * q,
	      rad1,
	      rad2,
	      rad3,
	      atan,
	      v,
	      w,
	      k,
	      D,
	      sqrtDDpZZ,
	      e,
	      lambda,
	      s2;

	  if (evoluteBorderTest > 0 || q != 0) {
	    if (evoluteBorderTest > 0) {
	      // Step 2: general case
	      rad1 = Math.sqrt(evoluteBorderTest);
	      rad2 = Math.sqrt(e4 * p * q); // 10*e2 is my arbitrary decision of what Vermeille means by "near... the cusps of the evolute".

	      if (evoluteBorderTest > 10 * e2) {
	        rad3 = WWMath.cbrt((rad1 + rad2) * (rad1 + rad2));
	        u = r + 0.5 * rad3 + 2 * r * r / rad3;
	      } else {
	        u = r + 0.5 * WWMath.cbrt((rad1 + rad2) * (rad1 + rad2)) + 0.5 * WWMath.cbrt((rad1 - rad2) * (rad1 - rad2));
	      }
	    } else {
	      // Step 3: near evolute
	      rad1 = Math.sqrt(-evoluteBorderTest);
	      rad2 = Math.sqrt(-8 * r * r * r);
	      rad3 = Math.sqrt(e4 * p * q);
	      atan = 2 * Math.atan2(rad3, rad1 + rad2) / 3;
	      u = -4 * r * Math.sin(atan) * Math.cos(Math.PI / 6 + atan);
	    }

	    v = Math.sqrt(u * u + e4 * q);
	    w = e2 * (u + v - q) / (2 * v);
	    k = (u + v) / (Math.sqrt(w * w + u + v) + w);
	    D = k * sqrtXXpYY / (k + e2);
	    sqrtDDpZZ = Math.sqrt(D * D + Z * Z);
	    h = (k + e2 - 1) * sqrtDDpZZ / k;
	    phi = 2 * Math.atan2(Z, sqrtDDpZZ + D);
	  } else {
	    // Step 4: singular disk
	    rad1 = Math.sqrt(1 - e2);
	    rad2 = Math.sqrt(e2 - p);
	    e = Math.sqrt(e2);
	    h = -a * rad1 * rad2 / e;
	    phi = rad2 / (e * rad2 + rad1 * Math.sqrt(p));
	  } // Compute lambda


	  s2 = Math.sqrt(2);

	  if ((s2 - 1) * Y < sqrtXXpYY + X) {
	    // case 1 - -135deg < lambda < 135deg
	    lambda = 2 * Math.atan2(Y, sqrtXXpYY + X);
	  } else if (sqrtXXpYY + Y < (s2 + 1) * X) {
	    // case 2 - -225deg < lambda < 45deg
	    lambda = -Math.PI * 0.5 + 2 * Math.atan2(X, sqrtXXpYY - Y);
	  } else {
	    // if (sqrtXXpYY-Y<(s2=1)*X) {  // is the test, if needed, but it's not
	    // case 3: - -45deg < lambda < 225deg
	    lambda = Math.PI * 0.5 - 2 * Math.atan2(X, sqrtXXpYY + Y);
	  }

	  result.latitude = Angle.RADIANS_TO_DEGREES * phi;
	  result.longitude = Angle.RADIANS_TO_DEGREES * lambda;
	  result.altitude = h;
	  return result;
	};

	ProjectionWgs84.prototype.northTangentAtLocation = function (globe, latitude, longitude, result) {
	  // The north-pointing tangent is derived by rotating the vector (0, 1, 0) about the Y-axis by longitude degrees,
	  // then rotating it about the X-axis by -latitude degrees. The latitude angle must be inverted because latitude
	  // is a clockwise rotation about the X-axis, and standard rotation matrices assume counter-clockwise rotation.
	  // The combined rotation can be represented by a combining two rotation matrices Rlat, and Rlon, then
	  // transforming the vector (0, 1, 0) by the combined transform:
	  //
	  // NorthTangent = (Rlon * Rlat) * (0, 1, 0)
	  //
	  // This computation can be simplified and encoded inline by making two observations:
	  // - The vector's X and Z coordinates are always 0, and its Y coordinate is always 1.
	  // - Inverting the latitude rotation angle is equivalent to inverting sinLat. We know this by the
	  //  trigonometric identities cos(-x) = cos(x), and sin(-x) = -sin(x).
	  var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),
	      cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),
	      sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
	      sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS);
	  result[0] = -sinLat * sinLon;
	  result[1] = cosLat;
	  result[2] = -sinLat * cosLon;
	  return result.normalize();
	};

	ProjectionWgs84.prototype.northTangentAtPoint = function (globe, x, y, z, offset, result) {
	  this.cartesianToGeographic(globe, x, y, z, Vec3$1.ZERO, this.scratchPosition);
	  return this.northTangentAtLocation(globe, this.scratchPosition.latitude, this.scratchPosition.longitude, result);
	};

	ProjectionWgs84.prototype.surfaceNormalAtLocation = function (globe, latitude, longitude, result) {
	  var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),
	      cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),
	      sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
	      sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS);
	  result[0] = cosLat * sinLon;
	  result[1] = sinLat;
	  result[2] = cosLat * cosLon;
	  return result.normalize();
	};

	ProjectionWgs84.prototype.surfaceNormalAtPoint = function (globe, x, y, z, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionWgs84", "surfaceNormalAtPoint", "missingGlobe"));
	  }

	  var a2 = globe.equatorialRadius * globe.equatorialRadius,
	      b2 = globe.polarRadius * globe.polarRadius;
	  result[0] = x / a2;
	  result[1] = y / b2;
	  result[2] = z / a2;
	  return result.normalize();
	};

	/**
	 * @exports Terrain
	 */
	/**
	 * Constructs a Terrain object.
	 * @alias Terrain
	 * @constructor
	 * @classdesc Represents terrain and provides functions for computing points on or relative to the terrain.
	 * Applications do not typically interact directly with this class.
	 */

	function Terrain(globe, tessellator, terrainTiles, verticalExaggeration) {
	  /**
	   * The globe associated with this terrain.
	   * @type {Globe}
	   */
	  this.globe = globe;
	  /**
	   * The vertical exaggeration of this terrain.
	   * @type {Number}
	   */

	  this.verticalExaggeration = verticalExaggeration;
	  /**
	   * The sector spanned by this terrain.
	   * @type {Sector}
	   */

	  this.sector = terrainTiles.sector;
	  /**
	   * The tessellator used to generate this terrain.
	   * @type {Tessellator}
	   */

	  this.tessellator = tessellator;
	  /**
	   * The surface geometry for this terrain
	   * @type {TerrainTile[]}
	   */

	  this.surfaceGeometry = terrainTiles.tileArray;
	  /**
	   * A string identifying this terrain's current state. Used to compare states during rendering to
	   * determine whether state dependent cached values must be updated. Applications typically do not
	   * interact with this property.
	   * @readonly
	   * @type {String}
	   */

	  this.stateKey = globe.stateKey + " ve " + verticalExaggeration.toString();
	}

	Terrain.scratchPoint = new Vec3$1(0, 0, 0);
	/**
	 * Computes a Cartesian point at a location on the surface of this terrain.
	 * @param {Number} latitude The location's latitude.
	 * @param {Number} longitude The location's longitude.
	 * @param {Number} offset Distance above the terrain, in meters, at which to compute the point.
	 * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
	 * @returns {Vec3} The specified result parameter, set to the coordinates of the computed point. If the
	 * specfied location is not within this terrain, the associated globe is used to compute the point.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */

	Terrain.prototype.surfacePoint = function (latitude, longitude, offset, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Terrain", "surfacePoint", "missingResult"));
	  }

	  for (var i = 0, len = this.surfaceGeometry.length; i < len; i++) {
	    if (this.surfaceGeometry[i].sector.containsLocation(latitude, longitude)) {
	      this.surfaceGeometry[i].surfacePoint(latitude, longitude, result);

	      if (offset) {
	        var normal = this.globe.surfaceNormalAtPoint(result[0], result[1], result[2], Terrain.scratchPoint);
	        result[0] += normal[0] * offset;
	        result[1] += normal[1] * offset;
	        result[2] += normal[2] * offset;
	      }

	      return result;
	    }
	  } // No tile was found that contains the location, so approximate one using the globe.


	  var h = offset + this.globe.elevationAtLocation(latitude, longitude) * this.verticalExaggeration;
	  this.globe.computePointFromPosition(latitude, longitude, h, result);
	  return result;
	};
	/**
	 * Computes a Cartesian point at a location on the surface of this terrain according to a specified
	 * altitude mode.
	 * @param {Number} latitude The location's latitude.
	 * @param {Number} longitude The location's longitude.
	 * @param {Number} offset Distance above the terrain, in meters relative to the specified altitude mode, at
	 * which to compute the point.
	 * @param {String} altitudeMode The altitude mode to use to compute the point. Recognized values are
	 * WorldWind.ABSOLUTE, WorldWind.CLAMP_TO_GROUND and
	 * WorldWind.RELATIVE_TO_GROUND. The mode WorldWind.ABSOLUTE is used if the
	 * specified mode is null, undefined or unrecognized, or if the specified location is outside this terrain.
	 * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
	 * @returns {Vec3} The specified result parameter, set to the coordinates of the computed point.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Terrain.prototype.surfacePointForMode = function (latitude, longitude, offset, altitudeMode, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Terrain", "surfacePointForMode", "missingResult"));
	  }

	  if (!altitudeMode) altitudeMode = WorldWind.ABSOLUTE;

	  if (altitudeMode === WorldWind.CLAMP_TO_GROUND) {
	    return this.surfacePoint(latitude, longitude, 0, result);
	  } else if (altitudeMode === WorldWind.RELATIVE_TO_GROUND) {
	    return this.surfacePoint(latitude, longitude, offset, result);
	  } else {
	    var height = offset * this.verticalExaggeration;
	    this.globe.computePointFromPosition(latitude, longitude, height, result);
	    return result;
	  }
	};
	/**
	 * Initializes rendering state to draw a succession of terrain tiles.
	 * @param {DrawContext} dc The current draw context.
	 */


	Terrain.prototype.beginRendering = function (dc) {
	  if (this.globe && this.globe.tessellator) {
	    this.globe.tessellator.beginRendering(dc);
	  }
	};
	/**
	 * Restores rendering state after drawing a succession of terrain tiles.
	 * @param {DrawContext} dc The current draw context.
	 */


	Terrain.prototype.endRendering = function (dc) {
	  if (this.globe && this.globe.tessellator) {
	    this.globe.tessellator.endRendering(dc);
	  }
	};
	/**
	 * Initializes rendering state for drawing a specified terrain tile.
	 * @param {DrawContext} dc The current draw context.
	 * @param {TerrainTile} terrainTile The terrain tile subsequently drawn via this tessellator's render function.
	 * @throws {ArgumentError} If the specified tile is null or undefined.
	 */


	Terrain.prototype.beginRenderingTile = function (dc, terrainTile) {
	  if (!terrainTile) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Terrain", "beginRenderingTile", "missingTile"));
	  }

	  if (this.globe && this.globe.tessellator) {
	    this.globe.tessellator.beginRenderingTile(dc, terrainTile);
	  }
	};
	/**
	 * Restores rendering state after drawing the most recent tile specified to
	 * [beginRenderingTile]{@link Terrain#beginRenderingTile}.
	 * @param {DrawContext} dc The current draw context.
	 * @param {TerrainTile} terrainTile The terrain tile most recently rendered.
	 * @throws {ArgumentError} If the specified tile is null or undefined.
	 */


	Terrain.prototype.endRenderingTile = function (dc, terrainTile) {// Intentionally empty.
	};
	/**
	 * Renders a specified terrain tile.
	 * @param {DrawContext} dc The current draw context.
	 * @param {TerrainTile} terrainTile The terrain tile to render.
	 * @throws {ArgumentError} If the specified tile is null or undefined.
	 */


	Terrain.prototype.renderTile = function (dc, terrainTile) {
	  if (!terrainTile) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Terrain", "renderTile", "missingTile"));
	  }

	  if (this.globe && this.globe.tessellator) {
	    this.globe.tessellator.renderTile(dc, terrainTile);
	  }
	};
	/**
	 * Causes this terrain to perform the picking operations appropriate for the draw context's pick settings.
	 * Normally, this draws the terrain in a unique pick color and computes the picked terrain position. When the
	 * draw context is set to region picking mode this omits the computation of a picked terrain position.
	 * @param {DrawContext} dc The current draw context.
	 */


	Terrain.prototype.pick = function (dc) {
	  if (this.globe && this.globe.tessellator) {
	    this.globe.tessellator.pick(dc, this.surfaceGeometry, this); // use this terrain as the userObject
	  }
	};

	/**
	 * @exports TerrainTile
	 */
	/**
	 * Constructs a terrain tile.
	 * @alias TerrainTile
	 * @constructor
	 * @augments Tile
	 * @classdesc Represents a portion of a globe's terrain. Applications typically do not interact directly with
	 * this class.
	 * @param {Sector} sector The sector this tile covers.
	 * @param {Level} level The level this tile is associated with.
	 * @param {Number} row This tile's row in the associated level.
	 * @param {Number} column This tile's column in the associated level.
	 * @throws {ArgumentError} If the specified sector or level is null or undefined or the row or column arguments
	 * are less than zero.
	 */

	function TerrainTile(sector, level, row, column) {
	  Tile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

	  /**
	   * The transformation matrix that maps tile local coordinates to model coordinates.
	   * @type {Matrix}
	   */

	  this.transformationMatrix = Matrix.fromIdentity();
	  /**
	   * The tile's model coordinate points.
	   * @type {Float32Array}
	   */

	  this.points = null;
	  /**
	   * Indicates the state of this tile when the model coordinate points were last updated. This is used to
	   * invalidate the points when this tile's state changes.
	   * @type {String}
	   */

	  this.pointsStateKey = null;
	  /**
	   * Indicates the state of this tile when the model coordinate VBO was last uploaded to GL. This is used to
	   * invalidate the VBO when the tile's state changes.
	   * @type {String}
	   */

	  this.pointsVboStateKey = null; // Internal use. Intentionally not documented.

	  this.neighborMap = {};
	  this.neighborMap[WorldWind.NORTH] = null;
	  this.neighborMap[WorldWind.SOUTH] = null;
	  this.neighborMap[WorldWind.EAST] = null;
	  this.neighborMap[WorldWind.WEST] = null; // Internal use. Intentionally not documented.

	  this._stateKey = null; // Internal use. Intentionally not documented.

	  this._elevationTimestamp = null; // Internal use. Intentionally not documented.

	  this.scratchArray = [];
	}

	TerrainTile.prototype = Object.create(Tile.prototype);
	Object.defineProperties(TerrainTile.prototype, {
	  /**
	   * A string identifying the state of this tile as a function of the elevation model's timestamp and this
	   * tile's neighbors. Used to compare states during rendering to determine whether cached values must be
	   * updated. Applications typically do not interact with this property.
	   * @type {String}
	   * @memberof TerrainTile.prototype
	   * @readonly
	   */
	  stateKey: {
	    get: function () {
	      if (!this._stateKey) {
	        this._stateKey = this.computeStateKey();
	      }

	      return this._stateKey;
	    }
	  }
	});
	/**
	 * Indicates the level of the tile adjacent to this tile in a specified direction. This returns null when this
	 * tile has no neighbor in that direction.
	 * @param {String} direction The cardinal direction. Must be one of WorldWind.NORTH, WorldWind.SOUTH,
	 * WorldWind.EAST or WorldWind.WEST.
	 * @returns {Level} The neighbor tile's level in the specified direction, or null if there is no neighbor.
	 */

	TerrainTile.prototype.neighborLevel = function (direction) {
	  return this.neighborMap[direction];
	};
	/**
	 * Specifies the level of the tile adjacent to this tile in a specified direction.
	 * @param {String} direction The cardinal direction. Must be one of WorldWind.NORTH, WorldWind.SOUTH,
	 * WorldWind.EAST or WorldWind.WEST.
	 * @param {Level} level The neighbor tile's level in the specified direction, or null to indicate that there is
	 * no neighbor in that direction.
	 */


	TerrainTile.prototype.setNeighborLevel = function (direction, level) {
	  this.neighborMap[direction] = level;
	  this._stateKey = null; // cause updates to any neighbor-dependent cached state
	};
	/**
	 * Computes a point on the terrain at a specified location.
	 * @param {Number} latitude The location's latitude.
	 * @param {Number} longitude The location's longitude.
	 * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
	 * @returns {Vec3} The result argument set to the computed point.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	TerrainTile.prototype.surfacePoint = function (latitude, longitude, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TerrainTile", "surfacePoint", "missingResult"));
	  }

	  var tileSector = this.sector,
	      minLat = tileSector.minLatitude,
	      maxLat = tileSector.maxLatitude,
	      minLon = tileSector.minLongitude,
	      maxLon = tileSector.maxLongitude,
	      tileWidth = this.tileWidth,
	      tileHeight = this.tileHeight,
	      s,
	      t,
	      si,
	      ti,
	      rowStride,
	      vertices,
	      points,
	      k,
	      sf,
	      tf;
	 // Compute the location's horizontal (s) and vertical (t) parameterized coordinates within the tiles 2D grid of
	  // points as a floating-point value in the range [0, tileWidth] and [0, tileHeight]. These coordinates indicate
	  // which cell contains the location, as well as the location's placement within the cell. Note that this method
	  // assumes that the caller has tested whether the location is contained within the tile's sector.

	  s = (longitude - minLon) / (maxLon - minLon) * tileWidth;
	  t = (latitude - minLat) / (maxLat - minLat) * tileHeight; // Get the coordinates for the four vertices defining the cell this point is in. Tile vertices start in the lower
	  // left corner and proceed in row major order across the tile. The tile contains one more vertex per row or
	  // column than the tile width or height. Vertices in the points array are organized in the
	  // following order: lower-left, lower-right, upper-left, upper-right. The cell's diagonal starts at the
	  // lower-left vertex and ends at the upper-right vertex.

	  si = s < tileWidth ? Math.floor(s) : tileWidth - 1;
	  ti = t < tileHeight ? Math.floor(t) : tileHeight - 1;
	  rowStride = tileWidth + 1;
	  vertices = this.points;
	  points = this.scratchArray; // temporary working buffer

	  k = 3 * (si + ti * rowStride); // lower-left and lower-right vertices

	  for (var i = 0; i < 6; i++) {
	    points[i] = vertices[k + i];
	  }

	  k = 3 * (si + (ti + 1) * rowStride); // upper-left and upper-right vertices

	  for (var j = 6; j < 12; j++) {
	    points[j] = vertices[k + (j - 6)];
	  } // Compute the location's corresponding point on the cell in tile local coordinates,
	  // given the fractional portion of the parameterized s and t coordinates. These values indicate the location's
	  // relative placement within the cell. The cell's vertices are defined in the following order: lower-left,
	  // lower-right, upper-left, upper-right. The cell's diagonal starts at the lower-right vertex and ends at the
	  // upper-left vertex.


	  sf = s < tileWidth ? s - Math.floor(s) : 1;
	  tf = t < tileHeight ? t - Math.floor(t) : 1;

	  if (sf > tf) {
	    result[0] = points[0] + sf * (points[3] - points[0]) + tf * (points[6] - points[0]);
	    result[1] = points[1] + sf * (points[4] - points[1]) + tf * (points[7] - points[1]);
	    result[2] = points[2] + sf * (points[5] - points[2]) + tf * (points[8] - points[2]);
	  } else {
	    result[0] = points[9] + (1 - sf) * (points[6] - points[9]) + (1 - tf) * (points[3] - points[9]);
	    result[1] = points[10] + (1 - sf) * (points[7] - points[10]) + (1 - tf) * (points[4] - points[10]);
	    result[2] = points[11] + (1 - sf) * (points[8] - points[11]) + (1 - tf) * (points[5] - points[11]);
	  }

	  result[0] += this.referencePoint[0];
	  result[1] += this.referencePoint[1];
	  result[2] += this.referencePoint[2];
	  return result;
	};

	TerrainTile.prototype.update = function (dc) {
	  Tile.prototype.update.call(this, dc);
	  var elevationTimestamp = dc.globe.elevationTimestamp();

	  if (this._elevationTimestamp != elevationTimestamp) {
	    this._elevationTimestamp = elevationTimestamp;
	    this._stateKey = null; // cause updates to any elevation-dependent cached state
	  }
	}; // Intentionally not documented.


	TerrainTile.prototype.computeStateKey = function () {
	  var array = [];
	  array.push(this._elevationTimestamp);
	  array.push(this.neighborMap[WorldWind.NORTH] ? this.neighborMap[WorldWind.NORTH].compare(this.level) : 0);
	  array.push(this.neighborMap[WorldWind.SOUTH] ? this.neighborMap[WorldWind.SOUTH].compare(this.level) : 0);
	  array.push(this.neighborMap[WorldWind.EAST] ? this.neighborMap[WorldWind.EAST].compare(this.level) : 0);
	  array.push(this.neighborMap[WorldWind.WEST] ? this.neighborMap[WorldWind.WEST].compare(this.level) : 0);
	  return array.join(".");
	};

	/**
	 * @exports TerrainTileList
	 */
	/**
	 * Constructs a terrain tile list, a container for terrain tiles that also has a tessellator and a sector
	 * associated with it.
	 * @alias TerrainTileList
	 * @constructor
	 * @classdesc Represents a portion of a globe's terrain.
	 * @param {Tessellator} tessellator The tessellator that created this terrain tile list.
	 *
	 */

	function TerrainTileList(tessellator) {
	  if (!tessellator) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TerrainTileList", "TerrainTileList", "missingTessellator"));
	  }

	  this.tessellator = tessellator;
	  this.sector = null;
	  this.tileArray = [];
	}

	Object.defineProperties(TerrainTileList.prototype, {
	  /**
	   * The number of terrain tiles in this terrain tile list.
	   * @memberof TerrainTileList.prototype
	   * @readonly
	   * @type {Number}
	   */
	  length: {
	    get: function () {
	      return this.tileArray.length;
	    }
	  }
	});

	TerrainTileList.prototype.addTile = function (tile) {
	  if (!tile) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TerrainTileList", "addTile", "missingTile"));
	  }

	  if (this.tileArray.indexOf(tile) == -1) {
	    this.tileArray.push(tile);

	    if (!this.sector) {
	      this.sector = new Sector(0, 0, 0, 0);
	      this.sector.copy(tile.sector);
	    } else {
	      this.sector.union(tile.sector);
	    }
	  }
	};

	TerrainTileList.prototype.removeAllTiles = function () {
	  this.tileArray = [];
	  this.sector = null;
	};

	/**
	 * @exports Tessellator
	 */
	/**
	 * Constructs a Tessellator.
	 * @alias Tessellator
	 * @constructor
	 * @classdesc Provides terrain tessellation for a globe.
	 */

	function Tessellator() {
	  // Parameterize top level subdivision in one place.
	  // TilesInTopLevel describes the most coarse tile structure.
	  this.numRowsTilesInTopLevel = 4; // baseline: 4

	  this.numColumnsTilesInTopLevel = 8; // baseline: 8
	  // The maximum number of levels that will ever be tessellated.

	  this.maximumSubdivisionDepth = 15; // baseline: 15
	  // tileWidth, tileHeight - the number of subdivisions a single tile has; this determines the sampling grid.

	  this.tileWidth = 32; // baseline: 32

	  this.tileHeight = 32; // baseline: 32

	  /**
	   * Controls the level of detail switching for this layer. The next highest resolution level is
	   * used when an elevation tile's cell size is greater than this number of pixels, up to the maximum
	   * resolution of the elevation model.
	   * @type {Number}
	   * @default 1.75
	   */

	  this.detailControl = 40;
	  this.levels = new LevelSet(Sector.FULL_SPHERE, new Location(180 / this.numRowsTilesInTopLevel, 360 / this.numColumnsTilesInTopLevel), this.maximumSubdivisionDepth, this.tileWidth, this.tileHeight);
	  this.topLevelTiles = {};
	  this.currentTiles = new TerrainTileList(this);
	  this.tileCache = new MemoryCache(5000000, 4000000); // Holds 316 32x32 tiles.

	  this.elevationTimestamp = undefined;
	  this.lastModelViewProjection = Matrix.fromIdentity();
	  this.vertexPointLocation = -1;
	  this.vertexTexCoordLocation = -1;
	  this.texCoords = null;
	  this.texCoordVboCacheKey = 'global_tex_coords';
	  this.indices = null;
	  this.indicesVboCacheKey = 'global_indices';
	  this.baseIndices = null;
	  this.baseIndicesOffset = null;
	  this.numBaseIndices = null;
	  this.indicesNorth = null;
	  this.indicesNorthOffset = null;
	  this.numIndicesNorth = null;
	  this.indicesSouth = null;
	  this.indicesSouthOffset = null;
	  this.numIndicesSouth = null;
	  this.indicesWest = null;
	  this.indicesWestOffset = null;
	  this.numIndicesWest = null;
	  this.indicesEast = null;
	  this.indicesEastOffset = null;
	  this.numIndicesEast = null;
	  this.indicesLoresNorth = null;
	  this.indicesLoresNorthOffset = null;
	  this.numIndicesLoresNorth = null;
	  this.indicesLoresSouth = null;
	  this.indicesLoresSouthOffset = null;
	  this.numIndicesLoresSouth = null;
	  this.indicesLoresWest = null;
	  this.indicesLoresWestOffset = null;
	  this.numIndicesLoresWest = null;
	  this.indicesLoresEast = null;
	  this.indicesLoresEastOffset = null;
	  this.numIndicesLoresEast = null;
	  this.outlineIndicesOffset = null;
	  this.numOutlineIndices = null;
	  this.wireframeIndicesOffset = null;
	  this.numWireframeIndices = null;
	  this.scratchMatrix = Matrix.fromIdentity();
	  this.scratchElevations = null;
	  this.scratchPrevElevations = null;
	  this.corners = {};
	  this.tiles = [];
	}
	/**
	 * Creates the visible terrain of the globe associated with the current draw context.
	 * @param {DrawContext} dc The draw context.
	 * @returns {Terrain} The computed terrain, or null if terrain could not be computed.
	 * @throws {ArgumentError} If the dc is null or undefined.
	 */


	Tessellator.prototype.tessellate = function (dc) {
	  if (!dc) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tessellator", "tessellate", "missingDC"));
	  }

	  var lastElevationsChange = dc.globe.elevationTimestamp();

	  if (this.lastGlobeStateKey === dc.globeStateKey && this.lastVerticalExaggeration === dc.verticalExaggeration && this.elevationTimestamp === lastElevationsChange && dc.modelviewProjection.equals(this.lastModelViewProjection)) {
	    return this.lastTerrain;
	  }

	  this.lastModelViewProjection.copy(dc.modelviewProjection);
	  this.lastGlobeStateKey = dc.globeStateKey;
	  this.elevationTimestamp = lastElevationsChange;
	  this.lastVerticalExaggeration = dc.verticalExaggeration;
	  this.currentTiles.removeAllTiles();

	  if (!this.topLevelTiles[dc.globeStateKey] || this.topLevelTiles[dc.globeStateKey].length == 0) {
	    this.createTopLevelTiles(dc);
	  }

	  this.corners = {};
	  this.tiles = [];

	  for (var index = 0, len = this.topLevelTiles[dc.globeStateKey].length; index < len; index += 1) {
	    var tile = this.topLevelTiles[dc.globeStateKey][index];
	    tile.update(dc);

	    if (this.isTileVisible(dc, tile)) {
	      this.addTileOrDescendants(dc, tile);
	    }
	  }

	  this.refineNeighbors(dc);
	  this.finishTessellating(dc);
	  this.lastTerrain = this.currentTiles.length === 0 ? null : new Terrain(dc.globe, this, this.currentTiles, dc.verticalExaggeration);
	  return this.lastTerrain;
	};

	Tessellator.prototype.createTile = function (tileSector, level, row, column) {
	  if (!tileSector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "constructor", "missingSector"));
	  }

	  if (!level) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "constructor", "The specified level is null or undefined."));
	  }

	  if (row < 0 || column < 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tile", "constructor", "The specified row or column is less than zero."));
	  }

	  return new TerrainTile(tileSector, level, row, column);
	};
	/**
	 * Initializes rendering state to draw a succession of terrain tiles.
	 * @param {DrawContext} dc The draw context.
	 */


	Tessellator.prototype.beginRendering = function (dc) {
	  var program = dc.currentProgram; // use the current program; the caller configures other program state

	  if (!program) {
	    Logger$1.logMessage(Logger$1.LEVEL_INFO, "Tessellator", "beginRendering", "Current Program is empty");
	    return;
	  }

	  this.buildSharedGeometry();
	  this.cacheSharedGeometryVBOs(dc);
	  var gl = dc.currentGlContext,
	      gpuResourceCache = dc.gpuResourceCache; // Keep track of the program's attribute locations. The tessellator does not know which program the caller has
	  // bound, and therefore must look up the location of attributes by name.

	  this.vertexPointLocation = program.attributeLocation(gl, "vertexPoint");
	  this.vertexTexCoordLocation = program.attributeLocation(gl, "vertexTexCoord");
	  gl.enableVertexAttribArray(this.vertexPointLocation);

	  if (this.vertexTexCoordLocation >= 0) {
	    // location of vertexTexCoord attribute is -1 when the basic program is bound
	    var texCoordVbo = gpuResourceCache.resourceForKey(this.texCoordVboCacheKey);
	    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordVbo);
	    gl.vertexAttribPointer(this.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	    gl.enableVertexAttribArray(this.vertexTexCoordLocation);
	  }

	  var indicesVbo = gpuResourceCache.resourceForKey(this.indicesVboCacheKey);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesVbo);
	};
	/**
	 * Restores rendering state after drawing a succession of terrain tiles.
	 * @param {DrawContext} dc The draw context.
	 */


	Tessellator.prototype.endRendering = function (dc) {
	  var gl = dc.currentGlContext;
	  gl.bindBuffer(gl.ARRAY_BUFFER, null);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); // Restore the global OpenGL vertex attribute array state.

	  if (this.vertexPointLocation >= 0) {
	    gl.disableVertexAttribArray(this.vertexPointLocation);
	  }

	  if (this.vertexTexCoordLocation >= 0) {
	    // location of vertexTexCoord attribute is -1 when the basic program is bound
	    gl.disableVertexAttribArray(this.vertexTexCoordLocation);
	  }
	};
	/**
	 * Initializes rendering state for drawing a specified terrain tile.
	 * @param {DrawContext} dc The draw context.
	 * @param {TerrainTile} terrainTile The terrain tile subsequently drawn via this tessellator's render function.
	 * @throws {ArgumentError} If the specified tile is null or undefined.
	 */


	Tessellator.prototype.beginRenderingTile = function (dc, terrainTile) {
	  if (!terrainTile) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tessellator", "beginRenderingTile", "missingTile"));
	  }

	  var gl = dc.currentGlContext,
	      gpuResourceCache = dc.gpuResourceCache;
	  this.scratchMatrix.setToMultiply(dc.modelviewProjection, terrainTile.transformationMatrix);
	  dc.currentProgram.loadModelviewProjection(gl, this.scratchMatrix);
	  var vboCacheKey = dc.globeStateKey + terrainTile.tileKey,
	      vbo = gpuResourceCache.resourceForKey(vboCacheKey);

	  if (!vbo) {
	    vbo = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
	    gl.bufferData(gl.ARRAY_BUFFER, terrainTile.points, gl.STATIC_DRAW);
	    dc.frameStatistics.incrementVboLoadCount(1);
	    gpuResourceCache.putResource(vboCacheKey, vbo, terrainTile.points.length * 4);
	    terrainTile.pointsVboStateKey = terrainTile.pointsStateKey;
	  } else if (terrainTile.pointsVboStateKey != terrainTile.pointsStateKey) {
	    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
	    gl.bufferSubData(gl.ARRAY_BUFFER, 0, terrainTile.points);
	    terrainTile.pointsVboStateKey = terrainTile.pointsStateKey;
	  } else {
	    dc.currentGlContext.bindBuffer(gl.ARRAY_BUFFER, vbo);
	  }

	  gl.vertexAttribPointer(this.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	};
	/**
	 * Restores rendering state after drawing the most recent tile specified to
	 * [beginRenderingTile]{@link Tessellator#beginRenderingTile}.
	 * @param {DrawContext} dc The draw context.
	 * @param {TerrainTile} terrainTile The terrain tile most recently rendered.
	 * @throws {ArgumentError} If the specified tile is null or undefined.
	 */


	Tessellator.prototype.endRenderingTile = function (dc, terrainTile) {// Intentionally empty until there's some reason to add code here.
	};
	/**
	 * Renders a specified terrain tile.
	 * @param {DrawContext} dc The draw context.
	 * @param {TerrainTile} terrainTile The terrain tile to render.
	 * @throws {ArgumentError} If the specified tile is null or undefined.
	 */


	Tessellator.prototype.renderTile = function (dc, terrainTile) {
	  if (!terrainTile) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tessellator", "renderTile", "missingTile"));
	  }

	  var gl = dc.currentGlContext,
	      prim = gl.TRIANGLE_STRIP; // replace TRIANGLE_STRIP with LINE_STRIP to debug borders

	  /*
	   * Indices order in the buffer:
	   *
	   * base indices
	   *
	   * north border
	   * south border
	   * west border
	   * east border
	   *
	   * north lores
	   * south lores
	   * west lores
	   * east lores
	   *
	   * wireframe
	   * outline
	   */

	  gl.drawElements(prim, this.numBaseIndices, gl.UNSIGNED_SHORT, this.baseIndicesOffset * 2);
	  var level = terrainTile.level,
	      neighborLevel;
	  neighborLevel = terrainTile.neighborLevel(WorldWind.NORTH);

	  if (neighborLevel && neighborLevel.compare(level) < 0) {
	    gl.drawElements(prim, this.numIndicesLoresNorth, gl.UNSIGNED_SHORT, this.indicesLoresNorthOffset * 2);
	  } else {
	    gl.drawElements(prim, this.numIndicesNorth, gl.UNSIGNED_SHORT, this.indicesNorthOffset * 2);
	  }

	  neighborLevel = terrainTile.neighborLevel(WorldWind.SOUTH);

	  if (neighborLevel && neighborLevel.compare(level) < 0) {
	    gl.drawElements(prim, this.numIndicesLoresSouth, gl.UNSIGNED_SHORT, this.indicesLoresSouthOffset * 2);
	  } else {
	    gl.drawElements(prim, this.numIndicesSouth, gl.UNSIGNED_SHORT, this.indicesSouthOffset * 2);
	  }

	  neighborLevel = terrainTile.neighborLevel(WorldWind.WEST);

	  if (neighborLevel && neighborLevel.compare(level) < 0) {
	    gl.drawElements(prim, this.numIndicesLoresWest, gl.UNSIGNED_SHORT, this.indicesLoresWestOffset * 2);
	  } else {
	    gl.drawElements(prim, this.numIndicesWest, gl.UNSIGNED_SHORT, this.indicesWestOffset * 2);
	  }

	  neighborLevel = terrainTile.neighborLevel(WorldWind.EAST);

	  if (neighborLevel && neighborLevel.compare(level) < 0) {
	    gl.drawElements(prim, this.numIndicesLoresEast, gl.UNSIGNED_SHORT, this.indicesLoresEastOffset * 2);
	  } else {
	    gl.drawElements(prim, this.numIndicesEast, gl.UNSIGNED_SHORT, this.indicesEastOffset * 2);
	  }
	};
	/**
	 * Draws outlines of the triangles composing the tile.
	 * @param {DrawContext} dc The current draw context.
	 * @param {TerrainTile} terrainTile The tile to draw.
	 * @throws {ArgumentError} If the specified tile is null or undefined.
	 */


	Tessellator.prototype.renderWireframeTile = function (dc, terrainTile) {
	  if (!terrainTile) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tessellator", "renderWireframeTile", "missingTile"));
	  }

	  var gl = dc.currentGlContext; // Must turn off texture coordinates, which were turned on in beginRendering.

	  if (this.vertexTexCoordLocation >= 0) {
	    gl.disableVertexAttribArray(this.vertexTexCoordLocation);
	  }

	  gl.drawElements(gl.LINES, this.numWireframeIndices, gl.UNSIGNED_SHORT, this.wireframeIndicesOffset * 2);
	};
	/**
	 * Draws the outer boundary of a specified terrain tile.
	 * @param {DrawContext} dc The current draw context.
	 * @param {TerrainTile} terrainTile The tile whose outer boundary to draw.
	 * @throws {ArgumentError} If the specified tile is null or undefined.
	 */


	Tessellator.prototype.renderTileOutline = function (dc, terrainTile) {
	  if (!terrainTile) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tessellator", "renderTileOutline", "missingTile"));
	  }

	  var gl = dc.currentGlContext; // Must turn off texture coordinates, which were turned on in beginRendering.

	  if (this.vertexTexCoordLocation >= 0) {
	    gl.disableVertexAttribArray(this.vertexTexCoordLocation);
	  }

	  gl.drawElements(gl.LINE_LOOP, this.numOutlineIndices, gl.UNSIGNED_SHORT, this.outlineIndicesOffset * 2);
	};
	/**
	 * Causes this terrain to perform the picking operations on the specified tiles, as appropriate for the draw
	 * context's pick settings. Normally, this draws the terrain in a unique pick color and computes the picked
	 * terrain position. When the draw context is set to region picking mode, this omits the computation of a picked
	 * terrain position.
	 * @param {DrawContext} dc The current draw context.
	 * @param {Array} tileList The list of tiles to pick.
	 * @param {Object} pickDelegate Indicates the object to use as the picked object's <code>userObject</code>.
	 * If null, then this tessellator is used as the <code>userObject</code>.
	 * @throws {ArgumentError} If either the draw context or the tile list are null or undefined.
	 */


	Tessellator.prototype.pick = function (dc, tileList, pickDelegate) {
	  if (!dc) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tessellator", "pick", "missingDc"));
	  }

	  if (!tileList) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Tessellator", "pick", "missingList"));
	  }

	  var color = null,
	      userObject = pickDelegate || this,
	      position = new Position(0, 0, 0),
	      pickableTiles = []; // Assemble a list of tiles that intersect the pick frustum. This eliminates unnecessary work for tiles that
	  // do not contribute to the pick result.

	  for (var i = 0, len = tileList.length; i < len; i++) {
	    var tile = tileList[i];

	    if (tile.extent.intersectsFrustum(dc.pickFrustum)) {
	      pickableTiles.push(tile);
	    }
	  } // Draw the pickable tiles in a unique pick color. Suppress this step when picking the terrain only. In this
	  // case drawing to the pick framebuffer is unnecessary.


	  if (!dc.pickTerrainOnly) {
	    color = dc.uniquePickColor();
	    this.drawPickTiles(dc, pickableTiles, color);
	  } // Determine the terrain position at the pick point. If the terrain is picked, add a corresponding picked
	  // object to the draw context. Suppress this step in region picking mode.


	  if (!dc.regionPicking) {
	    var ray = dc.pickRay.clone(),
	        // Cloning the pick ray is necessary here due to the fact that Tesselator.computeIntersections modifies ray
	    point = this.computeNearestIntersection(ray, pickableTiles);

	    if (point) {
	      dc.globe.computePositionFromPoint(point[0], point[1], point[2], position);
	      position.altitude = dc.globe.elevationAtLocation(position.latitude, position.longitude);
	      dc.addPickedObject(new PickedObject(color, userObject, position, null, true));
	    }
	  }
	}; // Internal function. Intentionally not documented.


	Tessellator.prototype.drawPickTiles = function (dc, tileList, color) {
	  var gl = dc.currentGlContext;

	  try {
	    dc.findAndBindProgram(BasicProgram);
	    dc.currentProgram.loadColor(gl, color);
	    this.beginRendering(dc);

	    for (var i = 0, len = tileList.length; i < len; i++) {
	      var tile = tileList[i];
	      this.beginRenderingTile(dc, tile);
	      this.renderTile(dc, tile);
	      this.endRenderingTile(dc, tile);
	    }
	  } finally {
	    this.endRendering(dc);
	  }
	}; // Internal function. Intentionally not documented.


	Tessellator.prototype.computeNearestIntersection = function (line, tileList) {
	  // Compute all intersections between the specified line and tile list.
	  var results = [];

	  for (var i = 0, len = tileList.length; i < len; i++) {
	    this.computeIntersections(line, tileList[i], results);
	  }

	  if (results.length == 0) {
	    return null; // no intersection
	  } else {
	    // Find and return the intersection nearest to the line's origin.
	    var minDistance = Number.POSITIVE_INFINITY,
	        minIndex;

	    for (i = 0, len = results.length; i < len; i++) {
	      var distance = line.origin.distanceToSquared(results[i]);

	      if (minDistance > distance) {
	        minDistance = distance;
	        minIndex = i;
	      }
	    }

	    return results[minIndex];
	  }
	}; // Internal function. Intentionally not documented.


	Tessellator.prototype.computeIntersections = function (line, tile, results) {
	  var level = tile.level,
	      neighborLevel,
	      points = tile.points,
	      elements,
	      firstResult = results.length; // Translate the line from model coordinates to tile local coordinates.

	  line.origin.subtract(tile.referencePoint); // Assemble the shared tile index geometry. This initializes the index properties used below.

	  this.buildSharedGeometry(tile); // Compute any intersections with the tile's interior triangles..

	  elements = this.baseIndices;
	  WWMath.computeTriStripIntersections(line, points, elements, results); // Compute any intersections with the tile's south border triangles.

	  neighborLevel = tile.neighborLevel(WorldWind.SOUTH);
	  elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresSouth : this.indicesSouth;
	  WWMath.computeTriStripIntersections(line, points, elements, results); // Compute any intersections with the tile's west border triangles.

	  neighborLevel = tile.neighborLevel(WorldWind.WEST);
	  elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresWest : this.indicesWest;
	  WWMath.computeTriStripIntersections(line, points, elements, results); // Compute any intersections with the tile's east border triangles.

	  neighborLevel = tile.neighborLevel(WorldWind.EAST);
	  elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresEast : this.indicesEast;
	  WWMath.computeTriStripIntersections(line, points, elements, results); // Compute any intersections with the tile's north border triangles.

	  neighborLevel = tile.neighborLevel(WorldWind.NORTH);
	  elements = neighborLevel && neighborLevel.compare(level) < 0 ? this.indicesLoresNorth : this.indicesNorth;
	  WWMath.computeTriStripIntersections(line, points, elements, results); // Translate the line and the intersection results from tile local coordinates to model coordinates.

	  line.origin.add(tile.referencePoint);

	  for (var i = firstResult, len = results.length; i < len; i++) {
	    results[i].add(tile.referencePoint);
	  }
	};
	/***********************************************************************
	 * Internal methods - assume that arguments have been validated already.
	 ***********************************************************************/


	Tessellator.prototype.createTopLevelTiles = function (dc) {
	  this.topLevelTiles[dc.globeStateKey] = [];
	  Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles[dc.globeStateKey]);
	};

	Tessellator.prototype.addTileOrDescendants = function (dc, tile) {
	  if (this.tileMeetsRenderCriteria(dc, tile)) {
	    this.addTile(dc, tile);
	    return;
	  }

	  this.addTileDescendants(dc, tile);
	};

	Tessellator.prototype.addTileDescendants = function (dc, tile) {
	  var nextLevel = tile.level.nextLevel();
	  var subTiles = tile.subdivideToCache(nextLevel, this, this.tileCache);

	  for (var index = 0; index < subTiles.length; index += 1) {
	    var child = subTiles[index];
	    child.update(dc);

	    if (this.levels.sector.intersects(child.sector) && this.isTileVisible(dc, child)) {
	      this.addTileOrDescendants(dc, child);
	    }
	  }
	};

	Tessellator.prototype.addTile = function (dc, tile) {
	  // Insert tile at index idx.
	  var idx = this.tiles.length;
	  this.tiles.push(tile); // Insert tile into corner data collection for later LOD neighbor analysis.

	  var sector = tile.sector; // Corners of the tile.

	  var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),
	      seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),
	      nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),
	      swTileCorner = [sector.minLatitude, sector.minLongitude].toString(),
	      corner;
	  corner = this.corners[swTileCorner];

	  if (!corner) {
	    this.corners[swTileCorner] = {
	      'sw': idx
	    }; //corner;
	  } else {
	    // assert(!corner.sw, "sw already defined");
	    corner.sw = idx;
	  }

	  corner = this.corners[nwTileCorner];

	  if (!corner) {
	    this.corners[nwTileCorner] = {
	      'nw': idx
	    };
	  } else {
	    // assert(!corner.nw, "nw already defined");
	    corner.nw = idx;
	  }

	  corner = this.corners[seTileCorner];

	  if (!corner) {
	    this.corners[seTileCorner] = {
	      'se': idx
	    };
	  } else {
	    // assert(!corver.se, "se already defined");
	    corner.se = idx;
	  }

	  corner = this.corners[neTileCorner];

	  if (!corner) {
	    this.corners[neTileCorner] = {
	      'ne': idx
	    };
	  } else {
	    //assert(!corner.ne, "ne already defined");
	    corner.ne = idx;
	  }
	};

	Tessellator.prototype.refineNeighbors = function (dc) {
	  var tileRefinementSet = {};

	  for (var idx = 0, len = this.tiles.length; idx < len; idx += 1) {
	    var tile = this.tiles[idx],
	        levelNumber = tile.level.levelNumber,
	        sector = tile.sector,
	        corner,
	        neighbor,
	        idx,
	        len; // Corners of the tile.

	    var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),
	        seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),
	        nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),
	        swTileCorner = [sector.minLatitude, sector.minLongitude].toString();
	    corner = this.corners[neTileCorner]; // assert(corner, "northeast corner not found");

	    if (corner.hasOwnProperty('se')) {
	      neighbor = corner.se;

	      if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	        if (!tileRefinementSet[neighbor]) {
	          tileRefinementSet[neighbor] = true;
	        }
	      }
	    }

	    if (corner.hasOwnProperty('nw')) {
	      neighbor = corner.nw;

	      if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	        if (!tileRefinementSet[neighbor]) {
	          tileRefinementSet[neighbor] = true;
	        }
	      }
	    }

	    corner = this.corners[seTileCorner]; // assert(corner, "southeast corner not found");

	    if (corner.hasOwnProperty('ne')) {
	      neighbor = corner.ne;

	      if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	        if (!tileRefinementSet[neighbor]) {
	          tileRefinementSet[neighbor] = true;
	        }
	      }
	    }

	    if (corner.hasOwnProperty('sw')) {
	      neighbor = corner.sw;

	      if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	        if (!tileRefinementSet[neighbor]) {
	          tileRefinementSet[neighbor] = true;
	        }
	      }
	    }

	    corner = this.corners[nwTileCorner]; // assert(corner, "northwest corner not found");

	    if (corner.hasOwnProperty('ne')) {
	      neighbor = corner.ne;

	      if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	        if (!tileRefinementSet[neighbor]) {
	          tileRefinementSet[neighbor] = true;
	        }
	      }
	    }

	    if (corner.hasOwnProperty('sw')) {
	      neighbor = corner.sw;

	      if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	        if (!tileRefinementSet[neighbor]) {
	          tileRefinementSet[neighbor] = true;
	        }
	      }
	    }

	    corner = this.corners[swTileCorner]; // assert(corner, "southwest corner not found");

	    if (corner.hasOwnProperty('se')) {
	      neighbor = corner.se;

	      if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	        if (!tileRefinementSet[neighbor]) {
	          tileRefinementSet[neighbor] = true;
	        }
	      }
	    }

	    if (corner.hasOwnProperty('nw')) {
	      neighbor = corner.nw;

	      if (this.tiles[neighbor].level.levelNumber < levelNumber - 1) {
	        if (!tileRefinementSet[neighbor]) {
	          tileRefinementSet[neighbor] = true;
	        }
	      }
	    }
	  } // Partition tiles into those requiring refinement and those that don't need refinement.


	  var tilesNeedingRefinement = [],
	      tilesNotNeedingRefinement = [];

	  for (idx = 0, len = this.tiles.length; idx < len; idx += 1) {
	    tile = this.tiles[idx];

	    if (tileRefinementSet[idx]) {
	      tilesNeedingRefinement.push(tile);
	    } else {
	      tilesNotNeedingRefinement.push(tile);
	    }
	  } // When tiles need refinement, recur.


	  if (tilesNeedingRefinement.length > 0) {
	    // Reset refinement state.
	    this.tiles = [];
	    this.corners = {}; // For tiles that don't need refinement, simply add the tile.

	    for (idx = 0, len = tilesNotNeedingRefinement.length; idx < len; idx += 1) {
	      tile = tilesNotNeedingRefinement[idx];
	      this.addTile(dc, tile);
	    } // For tiles that do need refinement, subdivide the tile and add its descendants.


	    for (idx = 0, len = tilesNeedingRefinement.length; idx < len; idx += 1) {
	      var tile = tilesNeedingRefinement[idx];
	      this.addTileDescendants(dc, tile);
	    } // Recur.


	    this.refineNeighbors(dc);
	  }
	};

	Tessellator.prototype.finishTessellating = function (dc) {
	  for (var idx = 0, len = this.tiles.length; idx < len; idx += 1) {
	    var tile = this.tiles[idx];
	    this.setNeighbors(tile);
	    this.regenerateTileGeometryIfNeeded(dc, tile);
	    this.currentTiles.addTile(tile);
	  }
	};

	Tessellator.prototype.setNeighbors = function (tile) {
	  var sector = tile.sector; // Corners of the tile.

	  var neTileCorner = [sector.maxLatitude, sector.maxLongitude].toString(),
	      seTileCorner = [sector.minLatitude, sector.maxLongitude].toString(),
	      nwTileCorner = [sector.maxLatitude, sector.minLongitude].toString(),
	      swTileCorner = [sector.minLatitude, sector.minLongitude].toString();
	  var neCorner = this.corners[neTileCorner],
	      seCorner = this.corners[seTileCorner],
	      nwCorner = this.corners[nwTileCorner],
	      swCorner = this.corners[swTileCorner];
	  var northIdx = -1,
	      // neCorner.hasOwnProperty('se') ? neCorner.se : nwCorner.hasOwnProperty('sw') ? nwCorner.sw : -1,
	  southIdx = -1,
	      // seCorner.hasOwnProperty('ne') ? seCorner.ne : swCorner.hasOwnProperty('nw') ? swCorner.nw : -1,
	  eastIdx = -1,
	      // neCorner.hasOwnProperty('nw') ? neCorner.nw : seCorner.hasOwnProperty('sw') ? seCorner.sw : -1,
	  westIdx = -1; //nwCorner.hasOwnProperty('ne') ? nwCorner.ne : swCorner.hasOwnProperty('se') ? swCorner.se : -1;

	  if (neCorner.hasOwnProperty('se')) {
	    northIdx = neCorner.se;
	  } else if (nwCorner.hasOwnProperty('sw')) {
	    northIdx = nwCorner.sw;
	  }

	  if (seCorner.hasOwnProperty('ne')) {
	    southIdx = seCorner.ne;
	  } else if (swCorner.hasOwnProperty('nw')) {
	    southIdx = swCorner.nw;
	  }

	  if (neCorner.hasOwnProperty('nw')) {
	    eastIdx = neCorner.nw;
	  } else if (seCorner.hasOwnProperty('sw')) {
	    eastIdx = seCorner.sw;
	  }

	  if (nwCorner.hasOwnProperty('ne')) {
	    westIdx = nwCorner.ne;
	  } else if (swCorner.hasOwnProperty('se')) {
	    westIdx = swCorner.se;
	  }

	  tile.setNeighborLevel(WorldWind.NORTH, northIdx >= 0 ? this.tiles[northIdx].level : null);
	  tile.setNeighborLevel(WorldWind.SOUTH, southIdx >= 0 ? this.tiles[southIdx].level : null);
	  tile.setNeighborLevel(WorldWind.EAST, eastIdx >= 0 ? this.tiles[eastIdx].level : null);
	  tile.setNeighborLevel(WorldWind.WEST, westIdx >= 0 ? this.tiles[westIdx].level : null);
	};

	Tessellator.prototype.isTileVisible = function (dc, tile) {
	  if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
	    return false;
	  }

	  return tile.extent.intersectsFrustum(dc.frustumInModelCoordinates);
	};

	Tessellator.prototype.tileMeetsRenderCriteria = function (dc, tile) {
	  var s = this.detailControl;

	  if (tile.sector.minLatitude >= 75 || tile.sector.maxLatitude <= -75) {
	    s *= 2;
	  }

	  return tile.level.isLastLevel() || !tile.mustSubdivide(dc, s);
	};

	Tessellator.prototype.regenerateTileGeometryIfNeeded = function (dc, tile) {
	  var stateKey = dc.globeStateKey + tile.stateKey + dc.verticalExaggeration;

	  if (!tile.points || tile.pointsStateKey != stateKey) {
	    this.regenerateTileGeometry(dc, tile);
	    tile.pointsStateKey = stateKey;
	  }
	};
	/**
	 * Internal use only.
	 * TODO: Remove this function when Tessellator and ElevationModel are refactored
	 * Artificially calculates an adjusted target resolution for the given texel size to more
	 * optimally select elevation coverages until later refactoring.
	 * @returns {Number} An adjusted target resolution in degrees.
	 * @ignore
	 */


	Tessellator.prototype.coverageTargetResolution = function (texelSize) {
	  return texelSize / 8 * Angle.RADIANS_TO_DEGREES;
	};

	Tessellator.prototype.regenerateTileGeometry = function (dc, tile) {
	  var numLat = tile.tileHeight + 1,
	      // num points in each dimension is 1 more than the number of tile cells
	  numLon = tile.tileWidth + 1,
	      refPoint = tile.referencePoint,
	      elevations = this.scratchElevations; // Allocate space for the tile's elevations.

	  if (!elevations) {
	    elevations = new Float64Array(numLat * numLon);
	    this.scratchElevations = elevations;
	  } // Allocate space for the tile's Cartesian coordinates.


	  if (!tile.points) {
	    tile.points = new Float32Array(numLat * numLon * 3);
	  } // Retrieve the elevations for all points in the tile.


	  WWUtil.fillArray(elevations, 0);
	  dc.globe.elevationsForGrid(tile.sector, numLat, numLon, this.coverageTargetResolution(tile.texelSize), elevations); // Modify the elevations around the tile's border to match neighbors of lower resolution, if any.

	  if (this.mustAlignNeighborElevations(dc, tile)) {
	    this.alignNeighborElevations(dc, tile, elevations);
	  } // Compute the tile's Cartesian coordinates relative to a local origin, called the reference point.


	  WWUtil.multiplyArray(elevations, dc.verticalExaggeration);
	  dc.globe.computePointsForGrid(tile.sector, numLat, numLon, elevations, refPoint, tile.points); // Establish a transform that is used later to move the tile coordinates into place relative to the globe.

	  tile.transformationMatrix.setTranslation(refPoint[0], refPoint[1], refPoint[2]);
	};

	Tessellator.prototype.mustAlignNeighborElevations = function (dc, tile) {
	  var level = tile.level,
	      northLevel = tile.neighborLevel(WorldWind.NORTH),
	      southLevel = tile.neighborLevel(WorldWind.SOUTH),
	      eastLevel = tile.neighborLevel(WorldWind.EAST),
	      westLevel = tile.neighborLevel(WorldWind.WEST);
	  return northLevel && northLevel.compare(level) < 0 || southLevel && southLevel.compare(level) < 0 || eastLevel && eastLevel.compare(level) < 0 || westLevel && westLevel.compare(level) < 0;
	};

	Tessellator.prototype.alignNeighborElevations = function (dc, tile, elevations) {
	  var numLat = tile.tileHeight + 1,
	      // num points in each dimension is 1 more than the number of tile cells
	  numLon = tile.tileWidth + 1,
	      level = tile.level,
	      prevNumLat = Math.floor(numLat / 2) + 1,
	      // num prev level points is 1 more than 1/2 the number of cells
	  prevNumLon = Math.floor(numLon / 2) + 1,
	      prevLevel = level.previousLevel(),
	      prevElevations = this.scratchPrevElevations,
	      neighborLevel,
	      i,
	      index,
	      prevIndex; // Allocate space for the previous level elevations.

	  if (!prevElevations) {
	    prevElevations = new Float64Array(prevNumLat * prevNumLon);
	    this.scratchPrevElevations = prevElevations;
	  } // Retrieve the previous level elevations, using 1/2 the number of tile cells.


	  WWUtil.fillArray(prevElevations, 0);
	  dc.globe.elevationsForGrid(tile.sector, prevNumLat, prevNumLon, this.coverageTargetResolution(prevLevel.texelSize), prevElevations); // Use previous level elevations along the north edge when the northern neighbor is lower resolution.

	  neighborLevel = tile.neighborLevel(WorldWind.NORTH);

	  if (neighborLevel && neighborLevel.compare(level) < 0) {
	    index = (numLat - 1) * numLon;
	    prevIndex = (prevNumLat - 1) * prevNumLon;

	    for (i = 0; i < prevNumLon; i++, index += 2, prevIndex += 1) {
	      elevations[index] = prevElevations[prevIndex];

	      if (i < prevNumLon - 1) {
	        elevations[index + 1] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + 1]);
	      }
	    }
	  } // Use previous level elevations along the south edge when the southern neighbor is lower resolution.


	  neighborLevel = tile.neighborLevel(WorldWind.SOUTH);

	  if (neighborLevel && neighborLevel.compare(level) < 0) {
	    index = 0;
	    prevIndex = 0;

	    for (i = 0; i < prevNumLon; i++, index += 2, prevIndex += 1) {
	      elevations[index] = prevElevations[prevIndex];

	      if (i < prevNumLon - 1) {
	        elevations[index + 1] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + 1]);
	      }
	    }
	  } // Use previous level elevations along the east edge when the eastern neighbor is lower resolution.


	  neighborLevel = tile.neighborLevel(WorldWind.EAST);

	  if (neighborLevel && neighborLevel.compare(level) < 0) {
	    index = numLon - 1;
	    prevIndex = prevNumLon - 1;

	    for (i = 0; i < prevNumLat; i++, index += 2 * numLon, prevIndex += prevNumLon) {
	      elevations[index] = prevElevations[prevIndex];

	      if (i < prevNumLat - 1) {
	        elevations[index + numLon] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + prevNumLon]);
	      }
	    }
	  } // Use previous level elevations along the west edge when the western neighbor is lower resolution.


	  neighborLevel = tile.neighborLevel(WorldWind.WEST);

	  if (neighborLevel && neighborLevel.compare(level) < 0) {
	    index = 0;
	    prevIndex = 0;

	    for (i = 0; i < prevNumLat; i++, index += 2 * numLon, prevIndex += prevNumLon) {
	      elevations[index] = prevElevations[prevIndex];

	      if (i < prevNumLat - 1) {
	        elevations[index + numLon] = 0.5 * (prevElevations[prevIndex] + prevElevations[prevIndex + prevNumLon]);
	      }
	    }
	  }
	};

	Tessellator.prototype.buildSharedGeometry = function () {
	  // TODO: put all indices into a single buffer
	  var tileWidth = this.levels.tileWidth,
	      tileHeight = this.levels.tileHeight;

	  if (!this.texCoords) {
	    this.buildTexCoords(tileWidth, tileHeight);
	  }

	  if (!this.indices) {
	    this.buildIndices(tileWidth, tileHeight);
	  }
	};

	Tessellator.prototype.buildTexCoords = function (tileWidth, tileHeight) {
	  var numCols = tileWidth + 1,
	      numRows = tileHeight + 1,
	      colDelta = 1 / tileWidth,
	      rowDelta = 1 / tileHeight,
	      buffer = new Float32Array(numCols * numRows * 2),
	      index = 0;

	  for (var row = 0, t = 0; row < numRows; row++, t += rowDelta) {
	    if (row == numRows - 1) {
	      t = 1; // explicitly set the last row coordinate to ensure alignment
	    }

	    for (var col = 0, s = 0; col < numCols; col++, s += colDelta) {
	      if (col == numCols - 1) {
	        s = 1; // explicitly set the last column coordinate to ensure alignment
	      }

	      buffer[index++] = s;
	      buffer[index++] = t;
	    }
	  }

	  this.texCoords = buffer;
	};

	Tessellator.prototype.buildIndices = function (tileWidth, tileHeight) {
	  var vertexIndex; // The index of the vertex in the sample grid.
	  // The number of vertices in each dimension is 1 more than the number of cells.

	  var numLatVertices = tileHeight + 1,
	      numLonVertices = tileWidth + 1;
	 // Assumption: tileWidth is even, so that there is a midpoint!
	  // Each vertex has two indices associated with it: the current vertex index and the index of the row.
	  // There are tileHeight rows.
	  // There are tileHeight + 2 columns

	  var numIndices = 2 * (numLatVertices - 3) * (numLonVertices - 2) + 2 * (numLatVertices - 3);
	  var indices = []; // Inset core by one round of sub-tiles. Full grid is numLatVertices x numLonVertices. This must be used
	  // to address vertices in the core as well.

	  var index = 0;

	  for (var lonIndex = 1; lonIndex < numLonVertices - 2; lonIndex += 1) {
	    for (var latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {
	      vertexIndex = lonIndex + latIndex * numLonVertices; // Create a triangle strip joining each adjacent column of vertices, starting in the top left corner and
	      // proceeding to the right. The first vertex starts with the left row of vertices and moves right to create a
	      // counterclockwise winding order.

	      indices[index++] = vertexIndex;
	      indices[index++] = vertexIndex + 1;
	    } // Insert indices to create 2 degenerate triangles:
	    //      one for the end of the current row, and
	    //      one for the beginning of the next row.


	    indices[index++] = vertexIndex + 1;
	    vertexIndex = lonIndex + 1 + 1 * numLonVertices;
	    indices[index++] = vertexIndex;
	  }

	  this.baseIndicesOffset = indices.length - numIndices;
	  this.baseIndices = new Uint16Array(indices.slice(this.baseIndicesOffset));
	  this.numBaseIndices = numIndices; // TODO: parameterize and refactor!!!!!
	  // Software engineering notes: There are patterns being used in the following code that should be abstracted.
	  // However, I suspect that the process of abstracting the patterns will result in as much code created
	  // as gets removed. YMMV. If JavaScript had a meta-programming (a.k.a., macro) facility, that code would be
	  // processed at "compile" time rather than "runtime". But it doesn't have such a facility that I know of.
	  //
	  // Patterns used:
	  //  0) Each tile has four borders: north, south, east, and west.
	  //  1) Counter-clockwise traversal around the outside results in clockwise meshes amendable to back-face elimination.
	  //  2) For each vertex on the exterior, there corresponds a vertex on the interior that creates a diagonal.
	  //  3) Each border construction is broken into three phases:
	  //      a) The starting phase to generate the first half of the border,
	  //      b) The middle phase, where a single vertex reference gets created, and
	  //      c) The ending phase to complete the generation of the border.
	  //  4) Each border is generated in two variants:
	  //      a) one variant that mates with a tile at the same level of detail, and
	  //      b) another variant that mates with a tile at the next lower level of detail.
	  //  5) Borders that mate with the next lower level of detail are constrained to lie on even indices.
	  //  6) Evenness is generated by ANDing the index with a mask that has 1's in all bits except for the LSB,
	  //      which results in clearing the LSB os the index, making it even.
	  //  7) The section that generates lower level LOD borders gives up any attempt to be optimal because of the
	  //      complexity. Instead, correctness was preferred. That said, any performance lost is in the noise,
	  //      since this code only gets run once.

	  /*
	   *  The following section of code generates full resolution boundary meshes. These are used to mate
	   *  with neighboring tiles that are at the same level of detail.
	   */
	  // North border.

	  numIndices = 2 * numLonVertices - 2;
	  latIndex = numLatVertices - 1; // Corner vertex.

	  lonIndex = numLonVertices - 1;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;

	  for (lonIndex = numLonVertices - 2; lonIndex > 0; lonIndex -= 1) {
	    vertexIndex = lonIndex + latIndex * numLonVertices;
	    indices[index++] = vertexIndex;
	    indices[index++] = vertexIndex - numLonVertices;
	  } // Corner vertex.


	  lonIndex = 0;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;
	  this.indicesNorthOffset = indices.length - numIndices;
	  this.indicesNorth = new Uint16Array(indices.slice(this.indicesNorthOffset));
	  this.numIndicesNorth = numIndices; // South border.

	  numIndices = 2 * numLonVertices - 2;
	  latIndex = 0; // Corner vertex.

	  lonIndex = 0;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;

	  for (lonIndex = 1; lonIndex < numLonVertices - 1; lonIndex += 1) {
	    vertexIndex = lonIndex + latIndex * numLonVertices;
	    indices[index++] = vertexIndex;
	    indices[index++] = vertexIndex + numLonVertices;
	  } // Corner vertex.


	  lonIndex = numLonVertices - 1;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;
	  this.indicesSouthOffset = indices.length - numIndices;
	  this.indicesSouth = new Uint16Array(indices.slice(this.indicesSouthOffset));
	  this.numIndicesSouth = numIndices; // West border.

	  numIndices = 2 * numLatVertices - 2;
	  lonIndex = 0; // Corner vertex.

	  latIndex = numLatVertices - 1;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;

	  for (latIndex = numLatVertices - 2; latIndex > 0; latIndex -= 1) {
	    vertexIndex = lonIndex + latIndex * numLonVertices;
	    indices[index++] = vertexIndex;
	    indices[index++] = vertexIndex + 1;
	  } // Corner vertex.


	  latIndex = 0;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;
	  this.indicesWestOffset = indices.length - numIndices;
	  this.indicesWest = new Uint16Array(indices.slice(this.indicesWestOffset));
	  this.numIndicesWest = numIndices; // East border.

	  numIndices = 2 * numLatVertices - 2;
	  lonIndex = numLonVertices - 1; // Corner vertex.

	  latIndex = 0;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;

	  for (latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {
	    vertexIndex = lonIndex + latIndex * numLonVertices;
	    indices[index++] = vertexIndex;
	    indices[index++] = vertexIndex - 1;
	  } // Corner vertex.


	  latIndex = numLatVertices - 1;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;
	  this.indicesEastOffset = indices.length - numIndices;
	  this.indicesEast = new Uint16Array(indices.slice(this.indicesEastOffset));
	  this.numIndicesEast = numIndices;
	  /*
	   *  The following section of code generates "lores" low resolution boundary meshes. These are used to mate
	   *  with neighboring tiles that are at a lower level of detail. The property of these lower level meshes is that
	   *  they have half the number of vertices.
	   *
	   *  To generate the boundary meshes, force the use of only even boundary vertex indices.
	   */
	  // North border.

	  numIndices = 2 * numLonVertices - 2;
	  latIndex = numLatVertices - 1; // Corner vertex.

	  lonIndex = numLonVertices - 1;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;

	  for (lonIndex = numLonVertices - 2; lonIndex > 0; lonIndex -= 1) {
	    // Exterior vertex rounded up to even index.
	    vertexIndex = (lonIndex + 1 & ~1) + latIndex * numLonVertices;
	    indices[index++] = vertexIndex; // Interior vertex.

	    vertexIndex = lonIndex + (latIndex - 1) * numLonVertices;
	    indices[index++] = vertexIndex;
	  } // Corner vertex.


	  lonIndex = 0;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;
	  this.indicesLoresNorthOffset = indices.length - numIndices;
	  this.indicesLoresNorth = new Uint16Array(indices.slice(this.indicesLoresNorthOffset));
	  this.numIndicesLoresNorth = numIndices; // South border.

	  numIndices = 2 * numLonVertices - 2;
	  latIndex = 0; // Corner vertex.

	  lonIndex = 0;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;

	  for (lonIndex = 1; lonIndex < numLonVertices - 1; lonIndex += 1) {
	    // Exterior Vertex rounded down to even index.
	    vertexIndex = (lonIndex & ~1) + latIndex * numLonVertices;
	    indices[index++] = vertexIndex; // Interior vertex.

	    vertexIndex = lonIndex + (latIndex + 1) * numLonVertices;
	    indices[index++] = vertexIndex;
	  } // Corner vertex.


	  lonIndex = numLonVertices - 1;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;
	  this.indicesLoresSouthOffset = indices.length - numIndices;
	  this.indicesLoresSouth = new Uint16Array(indices.slice(this.indicesLoresSouthOffset));
	  this.numIndicesLoresSouth = numIndices; // West border.

	  numIndices = 2 * numLatVertices - 2;
	  lonIndex = 0; // Corner vertex.

	  latIndex = numLatVertices - 1;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;

	  for (latIndex = numLatVertices - 2; latIndex > 0; latIndex -= 1) {
	    // Exterior Vertex rounded up to even index.
	    vertexIndex = lonIndex + (latIndex + 1 & ~1) * numLonVertices;
	    indices[index++] = vertexIndex; // Interior vertex.

	    vertexIndex = lonIndex + 1 + latIndex * numLonVertices;
	    indices[index++] = vertexIndex;
	  } // Corner vertex.


	  latIndex = 0;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;
	  this.indicesLoresWestOffset = indices.length - numIndices;
	  this.indicesLoresWest = new Uint16Array(indices.slice(this.indicesLoresWestOffset));
	  this.numIndicesLoresWest = numIndices; // East border.

	  numIndices = 2 * numLatVertices - 2;
	  lonIndex = numLonVertices - 1; // Corner vertex.

	  latIndex = 0;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;

	  for (latIndex = 1; latIndex < numLatVertices - 1; latIndex += 1) {
	    // Exterior vertex rounded down to even index.
	    vertexIndex = lonIndex + (latIndex & ~1) * numLonVertices;
	    indices[index++] = vertexIndex; // Interior vertex.

	    vertexIndex = lonIndex - 1 + latIndex * numLonVertices;
	    indices[index++] = vertexIndex;
	  } // Corner vertex.


	  latIndex = numLatVertices - 1;
	  vertexIndex = lonIndex + latIndex * numLonVertices;
	  indices[index++] = vertexIndex;
	  this.indicesLoresEastOffset = indices.length - numIndices;
	  this.indicesLoresEast = new Uint16Array(indices.slice(this.indicesLoresEastOffset));
	  this.numIndicesLoresEast = numIndices;
	  var wireframeIndices = this.buildWireframeIndices(tileWidth, tileHeight);
	  var outlineIndices = this.buildOutlineIndices(tileWidth, tileHeight);
	  indices = indices.concat(wireframeIndices);
	  this.wireframeIndicesOffset = indices.length - this.numWireframeIndices;
	  indices = indices.concat(outlineIndices);
	  this.outlineIndicesOffset = indices.length - this.numOutlineIndices;
	  this.indices = new Uint16Array(indices);
	};

	Tessellator.prototype.buildWireframeIndices = function (tileWidth, tileHeight) {
	  // The wireframe representation draws the vertices that appear on the surface.
	  // The number of vertices in each dimension is 1 more than the number of cells.
	  var numLatVertices = tileHeight + 1;
	  var numLonVertices = tileWidth + 1; // Allocate an array to hold the computed indices.

	  var numIndices = 2 * tileWidth * numLatVertices + 2 * tileHeight * numLonVertices;
	  var indices = [];
	  var rowStride = numLonVertices;
	  var index = 0,
	      lonIndex,
	      latIndex,
	      vertexIndex; // Add a line between each row to define the horizontal cell outlines.

	  for (latIndex = 0; latIndex < numLatVertices; latIndex += 1) {
	    for (lonIndex = 0; lonIndex < tileWidth; lonIndex += 1) {
	      vertexIndex = lonIndex + latIndex * rowStride;
	      indices[index] = vertexIndex;
	      indices[index + 1] = vertexIndex + 1;
	      index += 2;
	    }
	  } // Add a line between each column to define the vertical cell outlines.


	  for (lonIndex = 0; lonIndex < numLonVertices; lonIndex += 1) {
	    for (latIndex = 0; latIndex < tileHeight; latIndex += 1) {
	      vertexIndex = lonIndex + latIndex * rowStride;
	      indices[index] = vertexIndex;
	      indices[index + 1] = vertexIndex + rowStride;
	      index += 2;
	    }
	  }

	  this.numWireframeIndices = numIndices;
	  return indices;
	};

	Tessellator.prototype.buildOutlineIndices = function (tileWidth, tileHeight) {
	  // The outline representation traces the tile's outer edge on the surface.
	  // The number of vertices in each dimension is 1 more than the number of cells.
	  var numLatVertices = tileHeight + 1;
	  var numLonVertices = tileWidth + 1; // Allocate an array to hold the computed indices.

	  var numIndices = 2 * (numLatVertices - 2) + 2 * numLonVertices + 1;
	  var indices = [];
	  var index = 0,
	      lonIndex,
	      latIndex,
	      vertexIndex; // Bottom row, starting at the left and going right.

	  latIndex = 0;

	  for (lonIndex = 0; lonIndex < numLonVertices; lonIndex += 1) {
	    vertexIndex = lonIndex + latIndex * numLonVertices;
	    indices[index] = vertexIndex;
	    index += 1;
	  } // Right column, starting at the bottom and going up.


	  lonIndex = numLonVertices - 1;

	  for (latIndex = 1; latIndex < numLatVertices; latIndex += 1) {
	    vertexIndex = lonIndex + latIndex * numLonVertices;
	    indices[index] = vertexIndex;
	    index += 1;
	  } // Top row, starting on the right and going to the left.


	  latIndex = numLatVertices - 1;

	  for (lonIndex = numLonVertices - 1; lonIndex >= 0; lonIndex -= 1) {
	    vertexIndex = lonIndex + latIndex * numLonVertices;
	    indices[index] = vertexIndex;
	    index += 1;
	  } // Leftmost column, starting at the top and going down.


	  lonIndex = 0;

	  for (latIndex = numLatVertices - 1; latIndex >= 0; latIndex -= 1) {
	    vertexIndex = lonIndex + latIndex * numLonVertices;
	    indices[index] = vertexIndex;
	    index += 1;
	  }

	  this.numOutlineIndices = numIndices;
	  return indices;
	};

	Tessellator.prototype.cacheSharedGeometryVBOs = function (dc) {
	  var gl = dc.currentGlContext,
	      gpuResourceCache = dc.gpuResourceCache;
	  var texCoordVbo = gpuResourceCache.resourceForKey(this.texCoordVboCacheKey);

	  if (!texCoordVbo) {
	    texCoordVbo = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordVbo);
	    gl.bufferData(gl.ARRAY_BUFFER, this.texCoords, gl.STATIC_DRAW);
	    dc.frameStatistics.incrementVboLoadCount(1);
	    gpuResourceCache.putResource(this.texCoordVboCacheKey, texCoordVbo, this.texCoords.length * 4 / 2);
	  }

	  var indicesVbo = gpuResourceCache.resourceForKey(this.indicesVboCacheKey);

	  if (!indicesVbo) {
	    indicesVbo = gl.createBuffer();
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesVbo);
	    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
	    dc.frameStatistics.incrementVboLoadCount(1);
	    gpuResourceCache.putResource(this.indicesVboCacheKey, indicesVbo, this.indices.length * 2);
	  }
	};

	/**
	 * @exports Globe
	 */
	/**
	 * Constructs an ellipsoidal Globe with default radii for Earth (WGS84).
	 * @alias Globe
	 * @constructor
	 * @classdesc Represents an ellipsoidal globe. The default configuration represents Earth but may be changed.
	 * To configure for another planet, set the globe's equatorial and polar radii properties and its
	 * eccentricity-squared property.
	 * <p>
	 * A globe uses a Cartesian coordinate system whose origin is at the globe's center. It's Y axis points to the
	 * north pole, the Z axis points to the intersection of the prime meridian and the equator,
	 * and the X axis completes a right-handed coordinate system, is in the equatorial plane and 90 degrees east
	 * of the Z axis.
	 * <p>
	 *     All Cartesian coordinates and elevations are in meters.

	 * @param {ElevationModel} elevationModel The elevation model to use for this globe.
	 * @param {GeographicProjection} projection The projection to apply to the globe. May be null or undefined,
	 * in which case no projection is applied and the globe is a WGS84 ellipsoid.
	 * @throws {ArgumentError} If the specified elevation model is null or undefined.
	 */

	function Globe(elevationModel, projection) {
	  if (!elevationModel) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "constructor", "Elevation model is null or undefined."));
	  }
	  /**
	   * This globe's elevation model.
	   * @type {ElevationModel}
	   */


	  this.elevationModel = elevationModel;
	  /**
	   * This globe's equatorial radius in meters.
	   *
	   * @type {Number}
	   * @default WGS 84 semi-major axis (6378137.0 meters)
	   */

	  this.equatorialRadius = WorldWind.WGS84_SEMI_MAJOR_AXIS;
	  var f = 1 / WorldWind.WGS84_INVERSE_FLATTENING;
	  /**
	   * This globe's polar radius in meters.
	   * @type {Number}
	   * @default WGS 84 semi-minor axis (6356752.3142 meters). Taken from NGA.STND.0036_1.0.0_WGS84, section 3.2.
	   */

	  this.polarRadius = this.equatorialRadius * (1 - f);
	  /**
	   * This globe's eccentricity squared.
	   * @type {Number}
	   * @default WGS 84 first eccentricity squared (6.694379990141e-3). Taken from NGA.STND.0036_1.0.0_WGS84, section 3.3.
	   */

	  this.eccentricitySquared = 2 * f - f * f;
	  /**
	   * The tessellator used to create this globe's terrain.
	   * @type {Tessellator}
	   */

	  this.tessellator = new Tessellator(); // Internal. Intentionally not documented.

	  this._projection = projection || new ProjectionWgs84(); // Internal. Intentionally not documented.

	  this._offset = 0; // Internal. Intentionally not documented.

	  this.offsetVector = new Vec3$1(0, 0, 0); // A unique ID for this globe. Intentionally not documented.

	  this.id = ++Globe.idPool;
	  this._stateKey = "globe " + this.id.toString() + " ";
	}

	Globe.idPool = 0; // Used to assign unique IDs to globes for use in their state keys.

	Object.defineProperties(Globe.prototype, {
	  /**
	   * A string identifying this globe's current state. Used to compare states during rendering to
	   * determine whether globe-state dependent cached values must be updated. Applications typically do not
	   * interact with this property.
	   * @memberof Globe.prototype
	   * @readonly
	   * @type {String}
	   */
	  stateKey: {
	    get: function () {
	      return this._stateKey + this.elevationModel.stateKey + "offset " + this.offset.toString() + " " + this.projection.stateKey;
	    }
	  },

	  /**
	   * Indicates whether this globe is 2D and continuous with itself -- that it should scroll continuously
	   * horizontally.
	   * @memberof Globe.prototype
	   * @readonly
	   * @type {Boolean}
	   */
	  continuous: {
	    get: function () {
	      return this.projection.continuous;
	    }
	  },

	  /**
	   * The projection used by this globe.
	   * @memberof Globe.prototype
	   * @default {@link ProjectionWgs84}
	   * @type {GeographicProjection}
	   */
	  projection: {
	    get: function () {
	      return this._projection;
	    },
	    set: function (projection) {
	      if (!projection) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "projection", "missingProjection"));
	      }

	      if (this.projection != projection) {
	        this.tessellator = new Tessellator();
	      }

	      this._projection = projection;
	    }
	  },

	  /**
	   * The projection limits of the associated projection.
	   * @memberof Globe.prototype
	   * @type {Sector}
	   */
	  projectionLimits: {
	    get: function () {
	      return this._projection.projectionLimits;
	    }
	  },

	  /**
	   * An offset to apply to this globe when translating between Geographic positions and Cartesian points.
	   * Used during scrolling to position points appropriately.
	   * Applications typically do not access this property. It is used by the associated globe.
	   * @memberof Globe.prototype
	   * @type {Number}
	   */
	  offset: {
	    get: function () {
	      return this._offset;
	    },
	    set: function (offset) {
	      this._offset = offset;
	      this.offsetVector[0] = offset * 2 * Math.PI * this.equatorialRadius;
	    }
	  }
	});
	/**
	 * Indicates whether this is a 2D globe.
	 * @returns {Boolean} true if this is a 2D globe, otherwise false.
	 */

	Globe.prototype.is2D = function () {
	  return this.projection.is2D;
	};
	/**
	 * Computes a Cartesian point from a specified position.
	 * See this class' Overview section for a description of the Cartesian coordinate system used.
	 * @param {Number} latitude The position's latitude.
	 * @param {Number} longitude The position's longitude.
	 * @param {Number} altitude The position's altitude.
	 * @param {Vec3} result A reference to a pre-allocated {@link Vec3} in which to return the computed X,
	 * Y and Z Cartesian coordinates.
	 * @returns {Vec3} The result argument.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Globe.prototype.computePointFromPosition = function (latitude, longitude, altitude, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "computePointFromPosition", "missingResult"));
	  }

	  return this.projection.geographicToCartesian(this, latitude, longitude, altitude, this.offsetVector, result);
	};
	/**
	 * Computes a Cartesian point from a specified location.
	 * See this class' Overview section for a description of the Cartesian coordinate system used.
	 * @param {Number} latitude The position's latitude.
	 * @param {Number} longitude The position's longitude.
	 * @param {Vec3} result A reference to a pre-allocated {@link Vec3} in which to return the computed X,
	 * Y and Z Cartesian coordinates.
	 * @returns {Vec3} The result argument.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Globe.prototype.computePointFromLocation = function (latitude, longitude, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "computePointFromLocation", "missingResult"));
	  }

	  return this.computePointFromPosition(latitude, longitude, 0, result);
	};
	/**
	 * Computes a grid of Cartesian points within a specified sector and relative to a specified Cartesian
	 * reference point.
	 * <p>
	 * This method is used to compute a collection of points within a sector. It is used by tessellators to
	 * efficiently generate a tile's interior points. The number of points to generate is indicated by the numLon
	 * and numLat parameters.
	 * <p>
	 * For each implied position within the sector, an elevation value is specified via an array of elevations. The
	 * calculation at each position incorporates the associated elevation. There must be numLat x numLon elevations
	 * in the array.
	 *
	 * @param {Sector} sector The sector for which to compute the points.
	 * @param {Number} numLat The number of latitudinal points in the grid.
	 * @param {Number} numLon The number of longitudinal points in the grid.
	 * @param {Number[]} elevations An array of elevations to incorporate in the point calculations. There must be
	 * one elevation value in the array for each generated point. Elevations are in meters. There must be
	 * numLat x numLon elevations in the array.
	 * @param {Vec3} referencePoint The X, Y and Z Cartesian coordinates to subtract from the computed coordinates.
	 * This makes the computed coordinates relative to the specified point.
	 * @param {Float32Array} result A typed array to hold the computed coordinates. It must be at least of
	 * size numLat x numLon. The points are returned in row major order, beginning with the row of minimum latitude.
	 * @returns {Float32Array} The specified result argument.
	 * @throws {ArgumentError} if the specified sector, elevations array or results arrays are null or undefined, or
	 * if the lengths of any of the arrays are insufficient.
	 */


	Globe.prototype.computePointsForGrid = function (sector, numLat, numLon, elevations, referencePoint, result) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "computePointsFromPositions", "missingSector"));
	  }

	  if (numLat < 1 || numLon < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "computePointsFromPositions", "Number of latitude or longitude locations is less than one."));
	  }

	  var numPoints = numLat * numLon;

	  if (!elevations || elevations.length < numPoints) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "computePointsFromPositions", "Elevations array is null, undefined or insufficient length."));
	  }

	  if (!result || result.length < numPoints) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "computePointsFromPositions", "Result array is null, undefined or insufficient length."));
	  }

	  return this.projection.geographicToCartesianGrid(this, sector, numLat, numLon, elevations, referencePoint, this.offsetVector, result);
	};
	/**
	 * Computes a geographic position from a specified Cartesian point.
	 *
	 * See this class' Overview section for a description of the Cartesian coordinate system used.
	 *
	 * @param {Number} x The X coordinate.
	 * @param {Number} y The Y coordinate.
	 * @param {Number} z The Z coordinate.
	 * @param {Position} result A pre-allocated {@link Position} instance in which to return the computed position.
	 * @returns {Position} The specified result position.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Globe.prototype.computePositionFromPoint = function (x, y, z, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "computePositionFromPoint", "missingResult"));
	  }

	  this.projection.cartesianToGeographic(this, x, y, z, this.offsetVector, result); // Wrap if the globe is continuous.

	  if (this.continuous) {
	    if (result.longitude < -180) {
	      result.longitude += 360;
	    } else if (result.longitude > 180) {
	      result.longitude -= 360;
	    }
	  }

	  return result;
	};
	/**
	 * Computes the radius of this globe at a specified location.
	 * @param {Number} latitude The locations' latitude.
	 * @param {Number} longitude The locations' longitude.
	 * @returns {Number} The radius at the specified location.
	 */


	Globe.prototype.radiusAt = function (latitude, longitude) {
	  var sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
	      rpm = this.equatorialRadius / Math.sqrt(1.0 - this.eccentricitySquared * sinLat * sinLat);
	  return rpm * Math.sqrt(1.0 + (this.eccentricitySquared * this.eccentricitySquared - 2.0 * this.eccentricitySquared) * sinLat * sinLat);
	};
	/**
	 * Computes the normal vector to this globe's surface at a specified location.
	 * @param {Number} latitude The location's latitude.
	 * @param {Number} longitude The location's longitude.
	 * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
	 * normal vector is unit length.
	 * @returns {Vec3} The specified result vector.  The returned normal vector is unit length.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Globe.prototype.surfaceNormalAtLocation = function (latitude, longitude, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "surfaceNormalAtLocation", "missingResult"));
	  } // For backwards compatibility, check whether the projection defines a surfaceNormalAtLocation function
	  // before calling it. If it's not available, use the old code to compute the normal.


	  if (this.projection.surfaceNormalAtLocation) {
	    return this.projection.surfaceNormalAtLocation(this, latitude, longitude, result);
	  }

	  if (this.is2D()) {
	    result[0] = 0;
	    result[1] = 0;
	    result[2] = 1;
	    return result;
	  }

	  var cosLat = Math.cos(latitude * Angle.DEGREES_TO_RADIANS),
	      cosLon = Math.cos(longitude * Angle.DEGREES_TO_RADIANS),
	      sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
	      sinLon = Math.sin(longitude * Angle.DEGREES_TO_RADIANS);
	  result[0] = cosLat * sinLon;
	  result[1] = sinLat;
	  result[2] = cosLat * cosLon;
	  return result.normalize();
	};
	/**
	 * Computes the normal vector to this globe's surface at a specified Cartesian point.
	 * @param {Number} x The point's X coordinate.
	 * @param {Number} y The point's Y coordinate.
	 * @param {Number} z The point's Z coordinate.
	 * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
	 * normal vector is unit length.
	 * @returns {Vec3} The specified result vector.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Globe.prototype.surfaceNormalAtPoint = function (x, y, z, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "surfaceNormalAtPoint", "missingResult"));
	  } // For backwards compatibility, check whether the projection defines a surfaceNormalAtPoint function
	  // before calling it. If it's not available, use the old code to compute the normal.


	  if (this.projection.surfaceNormalAtPoint) {
	    return this.projection.surfaceNormalAtPoint(this, x, y, z, result);
	  }

	  if (this.is2D()) {
	    result[0] = 0;
	    result[1] = 0;
	    result[2] = 1;
	    return result;
	  }

	  var eSquared = this.equatorialRadius * this.equatorialRadius,
	      polSquared = this.polarRadius * this.polarRadius;
	  result[0] = x / eSquared;
	  result[1] = y / polSquared;
	  result[2] = z / eSquared;
	  return result.normalize();
	};
	/**
	 * Computes the north-pointing tangent vector to this globe's surface at a specified location.
	 * @param {Number} latitude The location's latitude.
	 * @param {Number} longitude The location's longitude.
	 * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
	 * tangent vector is unit length.
	 * @returns {Vec3} The specified result vector.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Globe.prototype.northTangentAtLocation = function (latitude, longitude, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "northTangentAtLocation", "missingResult"));
	  }

	  return this.projection.northTangentAtLocation(this, latitude, longitude, result);
	};
	/**
	 * Computes the north-pointing tangent vector to this globe's surface at a specified Cartesian point.
	 * @param {Number} x The point's X coordinate.
	 * @param {Number} y The point's Y coordinate.
	 * @param {Number} z The point's Z coordinate.
	 * @param {Vec3} result A pre-allocated {@Link Vec3} instance in which to return the computed vector. The returned
	 * tangent vector is unit length.
	 * @returns {Vec3} The specified result vector.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	Globe.prototype.northTangentAtPoint = function (x, y, z, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "northTangentAtPoint", "missingResult"));
	  }

	  return this.projection.northTangentAtPoint(this, x, y, z, this.offsetVector, result);
	};
	/**
	 * Indicates whether this globe intersects a specified frustum.
	 * @param {Frustum} frustum The frustum to test.
	 * @returns {Boolean} true if this globe intersects the frustum, otherwise false.
	 * @throws {ArgumentError} If the specified frustum is null or undefined.
	 */


	Globe.prototype.intersectsFrustum = function (frustum) {
	  if (!frustum) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "intersectsFrustum", "missingFrustum"));
	  }

	  if (this.is2D()) {
	    var bbox = new BoundingBox();
	    bbox.setToSector(Sector.FULL_SPHERE, this, this.elevationModel.minElevation, this.elevationModel.maxElevation);
	    return bbox.intersectsFrustum(frustum);
	  }

	  if (frustum.far.distance <= this.equatorialRadius) return false;
	  if (frustum.left.distance <= this.equatorialRadius) return false;
	  if (frustum.right.distance <= this.equatorialRadius) return false;
	  if (frustum.top.distance <= this.equatorialRadius) return false;
	  if (frustum.bottom.distance <= this.equatorialRadius) return false;
	  if (frustum.near.distance <= this.equatorialRadius) return false;
	  return true;
	};
	/**
	 * Computes the first intersection of this globe with a specified line. The line is interpreted as a ray;
	 * intersection points behind the line's origin are ignored.
	 * @param {Line} line The line to intersect with this globe.
	 * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
	 * @returns {boolean} true If the ray intersects the globe, otherwise false.
	 * @throws {ArgumentError} If the specified line or result argument is null or undefined.
	 */


	Globe.prototype.intersectsLine = function (line, result) {
	  if (!line) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "intersectWithRay", "missingLine"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "intersectsLine", "missingResult"));
	  } // Taken from "Mathematics for 3D Game Programming and Computer Graphics, Third Edition", Section 6.2.3.
	  //
	  // Note that the parameter n from equations 6.70 and 6.71 is omitted here. For an ellipsoidal globe this
	  // parameter is always 1, so its square and its product with any other value simplifies to the identity.


	  var vx = line.direction[0],
	      vy = line.direction[1],
	      vz = line.direction[2],
	      sx = line.origin[0],
	      sy = line.origin[1],
	      sz = line.origin[2],
	      t;

	  if (this.is2D()) {
	    if (vz == 0 && sz != 0) {
	      // ray is parallel to and not coincident with the XY plane
	      return false;
	    }

	    t = -sz / vz; // intersection distance, simplified for the XY plane

	    if (t < 0) {
	      // intersection is behind the ray's origin
	      return false;
	    }

	    result[0] = sx + vx * t;
	    result[1] = sy + vy * t;
	    result[2] = sz + vz * t;
	    return true;
	  } else {
	    var eqr = this.equatorialRadius,
	        eqr2 = eqr * eqr,
	        m = eqr / this.polarRadius,
	        m2 = m * m,
	        a,
	        b,
	        c,
	        d;
	    a = vx * vx + m2 * vy * vy + vz * vz;
	    b = 2 * (sx * vx + m2 * sy * vy + sz * vz);
	    c = sx * sx + m2 * sy * sy + sz * sz - eqr2;
	    d = b * b - 4 * a * c; // discriminant

	    if (d < 0) {
	      return false;
	    }

	    t = (-b - Math.sqrt(d)) / (2 * a); // check if the nearest intersection point is in front of the origin of the ray

	    if (t > 0) {
	      result[0] = sx + vx * t;
	      result[1] = sy + vy * t;
	      result[2] = sz + vz * t;
	      return true;
	    }

	    t = (-b + Math.sqrt(d)) / (2 * a); // check if the second intersection point is in the front of the origin of the ray

	    if (t > 0) {
	      result[0] = sx + vx * t;
	      result[1] = sy + vy * t;
	      result[2] = sz + vz * t;
	      return true;
	    } // the intersection points were behind the origin of the provided line


	    return false;
	  }
	};
	/**
	 * Returns the time at which any elevations associated with this globe last changed.
	 * @returns {Number} The time in milliseconds relative to the Epoch of the most recent elevation change.
	 */


	Globe.prototype.elevationTimestamp = function () {
	  return this.elevationModel.timestamp;
	};
	/**
	 * Returns this globe's minimum elevation.
	 * @returns {Number} This globe's minimum elevation.
	 */


	Globe.prototype.minElevation = function () {
	  return this.elevationModel.minElevation;
	};
	/**
	 * Returns this globe's maximum elevation.
	 * @returns {Number} This globe's maximum elevation.
	 */


	Globe.prototype.maxElevation = function () {
	  return this.elevationModel.maxElevation;
	};
	/**
	 * Returns the minimum and maximum elevations within a specified sector of this globe.
	 * @param {Sector} sector The sector for which to determine extreme elevations.
	 * @returns {Number[]} The An array containing the minimum and maximum elevations.
	 * @throws {ArgumentError} If the specified sector is null or undefined.
	 */


	Globe.prototype.minAndMaxElevationsForSector = function (sector) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "minAndMaxElevationsForSector", "missingSector"));
	  }

	  return this.elevationModel.minAndMaxElevationsForSector(sector);
	};
	/**
	 * Returns the elevation at a specified location.
	 * @param {Number} latitude The location's latitude in degrees.
	 * @param {Number} longitude The location's longitude in degrees.
	 * @returns {Number} The elevation at the specified location, in meters. Returns zero if the location is
	 * outside the coverage area of this elevation model.
	 */


	Globe.prototype.elevationAtLocation = function (latitude, longitude) {
	  return this.elevationModel.elevationAtLocation(latitude, longitude);
	};
	/**
	 * Returns the elevations at locations within a specified sector.
	 * @param {Sector} sector The sector for which to determine the elevations.
	 * @param {Number} numLat The number of latitudinal sample locations within the sector.
	 * @param {Number} numLon The number of longitudinal sample locations within the sector.
	 * @param {Number} targetResolution The desired elevation resolution, in degrees. (To compute degrees from
	 * meters, divide the number of meters by the globe's radius to obtain radians and convert the result to degrees.)
	 * @param {Number[]} result An array in which to return the requested elevations.
	 * @returns {Number} The resolution actually achieved, which may be greater than that requested if the
	 * elevation data for the requested resolution is not currently available.
	 * @throws {ArgumentError} If the specified sector or result array is null or undefined, or if either of the
	 * specified numLat or numLon values is less than one.
	 */


	Globe.prototype.elevationsForGrid = function (sector, numLat, numLon, targetResolution, result) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "elevationsForSector", "missingSector"));
	  }

	  if (numLat <= 0 || numLon <= 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "elevationsForSector", "numLat or numLon is less than 1"));
	  }

	  if (!result || result.length < numLat * numLon) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Globe", "elevationsForSector", "missingArray"));
	  }

	  return this.elevationModel.elevationsForGrid(sector, numLat, numLon, targetResolution, result);
	};

	/**
	 * @exports Texture
	 */
	/**
	 * Constructs a texture for a specified image.
	 * @alias Texture
	 * @constructor
	 * @classdesc Represents a WebGL texture. Applications typically do not interact with this class.
	 * @param {WebGLRenderingContext} gl The current WebGL rendering context.
	 * @param {Image} image The texture's image.
	 * @param {GLenum} wrapMode Optional. Specifies the wrap mode of the texture. Defaults to gl.CLAMP_TO_EDGE
	 * @throws {ArgumentError} If the specified WebGL context or image is null or undefined.
	 */

	function Texture$1(gl, image, wrapMode) {
	  if (!gl) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Texture", "constructor", "missingGlContext"));
	  }

	  if (!image) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Texture", "constructor", "missingImage"));
	  }

	  if (!wrapMode) {
	    wrapMode = gl.CLAMP_TO_EDGE;
	  }

	  var textureId = gl.createTexture(),
	      isPowerOfTwo = WWMath.isPowerOfTwo(image.width) && WWMath.isPowerOfTwo(image.height);
	  this.originalImageWidth = image.width;
	  this.originalImageHeight = image.height;

	  if (wrapMode === gl.REPEAT && !isPowerOfTwo) {
	    image = this.resizeImage(image);
	    isPowerOfTwo = true;
	  }

	  this.imageWidth = image.width;
	  this.imageHeight = image.height;
	  this.size = image.width * image.height * 4;
	  gl.bindTexture(gl.TEXTURE_2D, textureId);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, isPowerOfTwo ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapMode);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapMode);
	  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
	  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

	  if (isPowerOfTwo) {
	    gl.generateMipmap(gl.TEXTURE_2D);
	  }

	  this.textureId = textureId;
	  /**
	   * The time at which this texture was created.
	   * @type {Date}
	   */

	  this.creationTime = new Date(); // Internal use only. Intentionally not documented.

	  this.texParameters = {}; // Internal use only. Intentionally not documented.
	  // https://www.khronos.org/registry/webgl/extensions/EXT_texture_filter_anisotrop

	  this.anisotropicFilterExt = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
	}
	/**
	 * Sets a texture parameter to apply when binding this texture.
	 *
	 * Currently only gl.TEXTURE_MAG_FILTER has an effect.
	 *
	 * @param {Glenum} name The name of the parameter
	 * @param {GLint} value The value for this parameter
	 */


	Texture$1.prototype.setTexParameter = function (name, value) {
	  this.texParameters[name] = value;
	};
	/**
	 * Returns the value of a texture parameter to be assigned to this texture.
	 * @param {Glenum} name The name of the parameter
	 * @returns {GLint} The value for this parameter
	 */


	Texture$1.prototype.getTexParameter = function (name) {
	  return this.texParameters[name];
	};
	/**
	 * Clears the list of texture parameters to apply when binding this texture.
	 */


	Texture$1.prototype.clearTexParameters = function () {
	  this.texParameters = {};
	};
	/**
	 * Disposes of the WebGL texture object associated with this texture.
	 * @param gl
	 */


	Texture$1.prototype.dispose = function (gl) {
	  gl.deleteTexture(this.textureId);
	  delete this.textureId;
	};
	/**
	 * Binds this texture in the current WebGL graphics context.
	 * @param {DrawContext} dc The current draw context.
	 */


	Texture$1.prototype.bind = function (dc) {
	  var gl = dc.currentGlContext;
	  gl.bindTexture(gl.TEXTURE_2D, this.textureId);
	  this.applyTexParameters(dc);
	  dc.frameStatistics.incrementTextureLoadCount(1);
	  return true;
	};
	/**
	 * Applies the configured texture parameters to the OpenGL context.
	 * @param {DrawContext} dc The current draw context.
	 */


	Texture$1.prototype.applyTexParameters = function (dc) {
	  var gl = dc.currentGlContext; // Configure the OpenGL texture magnification function. Use linear by default.

	  var textureMagFilter = this.texParameters[gl.TEXTURE_MAG_FILTER] || gl.LINEAR;
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, textureMagFilter); // Try to enable the anisotropic texture filtering only if we have a linear magnification filter.
	  // This can't be enabled all the time because Windows seems to ignore the TEXTURE_MAG_FILTER parameter when
	  // this extension is enabled.

	  if (textureMagFilter === gl.LINEAR) {
	    // Setup 4x anisotropic texture filtering when this feature is available.
	    if (this.anisotropicFilterExt) {
	      gl.texParameteri(gl.TEXTURE_2D, this.anisotropicFilterExt.TEXTURE_MAX_ANISOTROPY_EXT, 4);
	    }
	  }
	};
	/**
	 * Resizes an image to a power of two.
	 * @param {Image} image The image to resize.
	 */


	Texture$1.prototype.resizeImage = function (image) {
	  var canvas = document.createElement("canvas");
	  canvas.width = WWMath.powerOfTwoFloor(image.width);
	  canvas.height = WWMath.powerOfTwoFloor(image.height);
	  var ctx = canvas.getContext("2d");
	  ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
	  return canvas;
	};

	/**
	 * @exports GpuResourceCache
	 */
	/**
	 * Constructs a GPU resource cache for a specified size and low-water value.
	 * @alias GpuResourceCache
	 * @constructor
	 * @classdesc Maintains a cache of GPU resources such as textures and GLSL programs.
	 * Applications typically do not interact with this class unless they create their own shapes.
	 * @param {Number} capacity The cache capacity, in bytes.
	 * @param {Number} lowWater The number of bytes to clear the cache to when it exceeds its capacity.
	 * @throws {ArgumentError} If the specified capacity is undefined, 0 or negative or the low-water value is
	 * undefined, negative or not less than the capacity.
	 */

	function GpuResourceCache(capacity, lowWater) {
	  if (!capacity || capacity < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuResourceCache", "constructor", "Specified cache capacity is undefined, 0 or negative."));
	  }

	  if (!lowWater || lowWater < 0 || lowWater >= capacity) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuResourceCache", "constructor", "Specified cache low-water value is undefined, negative or not less than the capacity."));
	  } // Private. Holds the actual cache entries.


	  this.entries = new MemoryCache(capacity, lowWater); // Private. Counter for generating cache keys.

	  this.cacheKeyPool = 0; // Private. List of retrievals currently in progress.

	  this.currentRetrievals = {}; // Private. Identifies requested resources that whose retrieval failed.

	  this.absentResourceList = new AbsentResourceList(3, 60e3);
	}

	Object.defineProperties(GpuResourceCache.prototype, {
	  /**
	   * Indicates the capacity of this cache in bytes.
	   * @type {Number}
	   * @readonly
	   * @memberof GpuResourceCache.prototype
	   */
	  capacity: {
	    get: function () {
	      return this.entries.capacity;
	    }
	  },

	  /**
	   * Indicates the low-water value for this cache in bytes, the size this cache is cleared to when it
	   * exceeds its capacity.
	   * @type {Number}
	   * @readonly
	   * @memberof GpuResourceCache.prototype
	   */
	  lowWater: {
	    get: function () {
	      return this.entries.lowWater;
	    }
	  },

	  /**
	   * Indicates the number of bytes currently used by this cache.
	   * @type {Number}
	   * @readonly
	   * @memberof GpuResourceCache.prototype
	   */
	  usedCapacity: {
	    get: function () {
	      return this.entries.usedCapacity;
	    }
	  },

	  /**
	   * Indicates the number of free bytes in this cache.
	   * @type {Number}
	   * @readonly
	   * @memberof GpuResourceCache.prototype
	   */
	  freeCapacity: {
	    get: function () {
	      return this.entries.freeCapacity;
	    }
	  }
	});
	/**
	 * Creates a cache key unique to this cache, typically for a resource about to be added to this cache.
	 * @returns {String} The generated cache key.
	 */

	GpuResourceCache.prototype.generateCacheKey = function () {
	  return "GpuResourceCache " + ++this.cacheKeyPool;
	};
	/**
	 * Adds a specified resource to this cache. Replaces the existing resource for the specified key if the
	 * cache currently contains a resource for that key.
	 * @param {String|ImageSource} key The key or image source of the resource to add.
	 * @param {Object} resource The resource to add to the cache.
	 * @param {Number} size The resource's size in bytes. Must be greater than 0.
	 * @throws {ArgumentError} If either the key or resource arguments is null or undefined
	 * or if the specified size is less than 1.
	 */


	GpuResourceCache.prototype.putResource = function (key, resource, size) {
	  if (!key) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuResourceCache", "putResource", "missingKey."));
	  }

	  if (!resource) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuResourceCache", "putResource", "missingResource."));
	  }

	  if (!size || size < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GpuResourceCache", "putResource", "The specified resource size is undefined or less than 1."));
	  }

	  var entry = {
	    resource: resource
	  };
	  this.entries.putEntry(key instanceof ImageSource ? key.key : key, entry, size);
	};
	/**
	 * Returns the resource associated with a specified key.
	 * @param {String|ImageSource} key The key or image source of the resource to find.
	 * @returns {Object} The resource associated with the specified key, or null if the resource is not in
	 * this cache or the specified key is null or undefined.
	 */


	GpuResourceCache.prototype.resourceForKey = function (key) {
	  var entry = key instanceof ImageSource ? this.entries.entryForKey(key.key) : this.entries.entryForKey(key);
	  var resource = entry ? entry.resource : null; // This is faster than checking if the resource is a texture using instanceof.

	  if (resource !== null && typeof resource.clearTexParameters === "function") {
	    resource.clearTexParameters();
	  }

	  return resource;
	};
	/**
	 * Sets a resource's aging factor (multiplier).
	 * @param {String} key The key of the resource to modify. If null or undefined, the resource's cache entry is not modified.
	 * @param {Number} agingFactor A multiplier applied to the age of the resource.
	 */


	GpuResourceCache.prototype.setResourceAgingFactor = function (key, agingFactor) {
	  this.entries.setEntryAgingFactor(key, agingFactor);
	};
	/**
	 * Indicates whether a specified resource is in this cache.
	 * @param {String|ImageSource} key The key or image source of the resource to find.
	 * @returns {Boolean} true If the resource is in this cache, false if the resource
	 * is not in this cache or the specified key is null or undefined.
	 */


	GpuResourceCache.prototype.containsResource = function (key) {
	  return this.entries.containsKey(key instanceof ImageSource ? key.key : key);
	};
	/**
	 * Removes the specified resource from this cache. The cache is not modified if the specified key is null or
	 * undefined or does not correspond to an entry in the cache.
	 * @param {String|ImageSource} key The key or image source of the resource to remove.
	 */


	GpuResourceCache.prototype.removeResource = function (key) {
	  this.entries.removeEntry(key instanceof ImageSource ? key.key : key);
	};
	/**
	 * Removes all resources from this cache.
	 */


	GpuResourceCache.prototype.clear = function () {
	  this.entries.clear(false);
	};
	/**
	 * Retrieves an image and adds it to this cache when it arrives. If the specified image source is a URL, a
	 * retrieval request for the image is made and this method returns immediately with a value of null. A redraw
	 * event is generated when the image subsequently arrives and is added to this cache. If the image source is an
	 * {@link ImageSource}, the image is used immediately and this method returns the {@link Texture} created and
	 * cached for the image. No redraw event is generated in this case.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {String|ImageSource} imageSource The image source, either a {@link ImageSource} or a String
	 * giving the URL of the image.
	 * @param {GLenum} wrapMode Optional. Specifies the wrap mode of the texture. Defaults to gl.CLAMP_TO_EDGE
	 * @returns {Texture} The {@link Texture} created for the image if the specified image source is an
	 * {@link ImageSource}, otherwise null.
	 */


	GpuResourceCache.prototype.retrieveTexture = function (gl, imageSource, wrapMode) {
	  if (!imageSource) {
	    return null;
	  }

	  if (imageSource instanceof ImageSource) {
	    var t = new Texture$1(gl, imageSource.image, wrapMode);
	    this.putResource(imageSource.key, t, t.size);
	    return t;
	  }

	  if (this.currentRetrievals[imageSource] || this.absentResourceList.isResourceAbsent(imageSource)) {
	    return null;
	  }

	  var cache = this,
	      image = new Image();

	  image.onload = function () {
	    Logger$1.log(Logger$1.LEVEL_INFO, "Image retrieval succeeded: " + imageSource);
	    var texture = new Texture$1(gl, image, wrapMode);
	    cache.putResource(imageSource, texture, texture.size);
	    delete cache.currentRetrievals[imageSource];
	    cache.absentResourceList.unmarkResourceAbsent(imageSource); // Send an event to request a redraw.

	    var e = document.createEvent('Event');
	    e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
	    window.dispatchEvent(e);
	  };

	  image.onerror = function () {
	    delete cache.currentRetrievals[imageSource];
	    cache.absentResourceList.markResourceAbsent(imageSource);
	    Logger$1.log(Logger$1.LEVEL_WARNING, "Image retrieval failed: " + imageSource);
	  };

	  this.currentRetrievals[imageSource] = imageSource;
	  image.crossOrigin = 'anonymous';
	  image.src = imageSource;
	  return null;
	};

	/**
	 * @exports PickedObjectList
	 */

	/**
	 * Constructs a picked-object list.
	 * @alias PickedObjectList
	 * @constructor
	 * @classdesc Holds a collection of picked objects.
	 */
	function PickedObjectList() {
	  /**
	   * The picked objects.
	   * @type {Array}
	   */
	  this.objects = [];
	}
	/**
	 * Indicates whether this list contains picked objects that are not terrain.
	 * @returns {Boolean} true if this list contains objects that are not terrain,
	 * otherwise false.
	 */


	PickedObjectList.prototype.hasNonTerrainObjects = function () {
	  return this.objects.length > 1 || this.objects.length === 1 && this.terrainObject() == null;
	};
	/**
	 * Returns the terrain object within this list, if this list contains a terrain object.
	 * @returns {PickedObject} The terrain object, or null if this list does not contain a terrain object.
	 */


	PickedObjectList.prototype.terrainObject = function () {
	  for (var i = 0, len = this.objects.length; i < len; i++) {
	    if (this.objects[i].isTerrain) {
	      return this.objects[i];
	    }
	  }

	  return null;
	};
	/**
	 * Adds a picked object to this list.
	 * If the picked object is a terrain object and the list already contains a terrain object, the terrain
	 * object in the list is replaced by the specified one.
	 * @param {PickedObject} pickedObject The picked object to add. If null, this list remains unchanged.
	 */


	PickedObjectList.prototype.add = function (pickedObject) {
	  if (pickedObject) {
	    if (pickedObject.isTerrain) {
	      var terrainObjectIndex = this.objects.length;

	      for (var i = 0, len = this.objects.length; i < len; i++) {
	        if (this.objects[i].isTerrain) {
	          terrainObjectIndex = i;
	          break;
	        }
	      }

	      this.objects[terrainObjectIndex] = pickedObject;
	    } else {
	      this.objects.push(pickedObject);
	    }
	  }
	};
	/**
	 * Removes all items from this list.
	 */


	PickedObjectList.prototype.clear = function () {
	  this.objects = [];
	};
	/**
	 * Returns the top-most picked object in this list.
	 * @returns {PickedObject} The top-most picked object in this list, or null if this list is empty.
	 */


	PickedObjectList.prototype.topPickedObject = function () {
	  var size = this.objects.length;

	  if (size > 1) {
	    for (var i = 0; i < size; i++) {
	      if (this.objects[i].isOnTop) {
	        return this.objects[i];
	      }
	    }
	  }

	  if (size > 0) {
	    return this.objects[0];
	  }

	  return null;
	};

	/**
	 * @exports Text
	 */
	/**
	 * Constructs a text shape. This constructor is intended to be called only by subclasses.
	 * @alias Text
	 * @constructor
	 * @augments Renderable
	 * @classdesc Represents a string of text displayed at a specified geographic or screen position.
	 * This is an abstract class meant to be subclassed and not meant to be instantiated directly.
	 * See {@link GeographicText} and {@link ScreenText} for concrete classes.
	 *
	 * @param {String} text The text to display.
	 * @throws {ArgumentError} If the specified text is null or undefined.
	 */

	function Text(text) {
	  if (!text) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Text", "constructor", "missingText"));
	  }

	  Renderable.call(this);
	  /**
	   * The text's attributes. If null and this text is not highlighted, this text is not drawn.
	   * @type {TextAttributes}
	   * @default see [TextAttributes]{@link TextAttributes}
	   */

	  this.attributes = new TextAttributes(null);
	  /**
	   * The attributes used when this text's highlighted flag is true. If null and the
	   * highlighted flag is true, this text's normal attributes are used. If they, too, are null, this
	   * text is not drawn.
	   * @type {TextAttributes}
	   * @default null
	   */

	  this.highlightAttributes = null;
	  /**
	   * Indicates whether this text uses its highlight attributes rather than its normal attributes.
	   * @type {boolean}
	   * @default false
	   */

	  this.highlighted = false;
	  /**
	   * Indicates whether this text is drawn.
	   * @type {boolean}
	   * @default true
	   */

	  this.enabled = true;
	  /**
	   * This shape's text. If null or empty, no text is drawn.
	   * @type {String}
	   * @default null
	   */

	  this.text = text;
	  /**
	   * This text's altitude mode. May be one of
	   * <ul>
	   *  <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	   *  <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	   *  <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	   * </ul>
	   * @default WorldWind.ABSOLUTE
	   */

	  this.altitudeMode = WorldWind.ABSOLUTE;
	  /**
	   * Indicates the object to return as the userObject of this text when picked. If null,
	   * then this text object is returned as the userObject.
	   * @type {Object}
	   * @default null
	   * @see  [PickedObject.userObject]{@link PickedObject#userObject}
	   */

	  this.pickDelegate = null;
	  /**
	   * Indicates whether this text has visual priority over other shapes in the scene.
	   * @type {Boolean}
	   * @default false
	   */

	  this.alwaysOnTop = false;
	  /**
	   * This shape's target visibility, a value between 0 and 1. During ordered rendering this shape modifies its
	   * [current visibility]{@link Text#currentVisibility} towards its target visibility at the rate
	   * specified by the draw context's [fadeVelocity]{@link DrawContext#fadeVelocity} property. The target
	   * visibility and current visibility are used to control the fading in and out of this shape.
	   * @type {Number}
	   * @default 1
	   */

	  this.targetVisibility = 1;
	  /**
	   * This shape's current visibility, a value between 0 and 1. This property scales the shape's effective
	   * opacity. It is incremented or decremented each frame according to the draw context's
	   * [fade velocity]{@link DrawContext#fadeVelocity} property in order to achieve this shape's current
	   * [target visibility]{@link Text#targetVisibility}. This current visibility and target visibility are
	   * used to control the fading in and out of this shape.
	   * @type {Number}
	   * @default 1
	   * @readonly
	   */

	  this.currentVisibility = 1;
	  /**
	   * Indicates the group ID of the declutter group to include this Text shape. If non-zer0, this shape
	   * is decluttered relative to all other shapes within its group.
	   * @type {Number}
	   * @default 0
	   */

	  this.declutterGroup = 0;
	  /**
	   * The image to display when this text shape is eliminated from the scene due to decluttering.
	   * @type {String}
	   * @default A round dot drawn in this shape's text color.
	   */

	  this.markerImageSource = WorldWind.configuration.baseUrl + "images/white-dot.png";
	  /**
	   * The scale to apply to the [markerImageSource]{@link Text#markerImageSource}.
	   * @type {Number}
	   * @default 0.1
	   */

	  this.markerImageScale = 0.1; // Internal use only. Intentionally not documented.

	  this.activeAttributes = null; // Internal use only. Intentionally not documented.

	  this.activeTexture = null; // Internal use only. Intentionally not documented.

	  this.imageTransform = Matrix.fromIdentity(); // Internal use only. Intentionally not documented.

	  this.imageBounds = null; // Internal use only. Intentionally not documented.

	  this.layer = null; // Internal use only. Intentionally not documented.

	  this.depthOffset = -0.003; // Internal use only. Intentionally not documented.

	  this.screenPoint = new Vec3$1(0, 0, 0);
	} // Internal use only. Intentionally not documented.


	Text.matrix = Matrix.fromIdentity(); // scratch variable

	Text.glPickPoint = new Vec3$1(0, 0, 0); // scratch variable

	Text.prototype = Object.create(Renderable.prototype);
	/**
	 * Copies the contents of a specified text object to this text object.
	 * @param {Text} that The text object to copy.
	 */

	Text.prototype.copy = function (that) {
	  this.text = that.text;
	  this.attributes = that.attributes;
	  this.highlightAttributes = that.highlightAttributes;
	  this.highlighted = that.highlighted;
	  this.enabled = that.enabled;
	  this.altitudeMode = that.altitudeMode;
	  this.pickDelegate = that.pickDelegate;
	  this.alwaysOnTop = that.alwaysOnTop;
	  this.depthOffset = that.depthOffset;
	  this.declutterGroup = that.declutterGroup;
	  this.targetVisibility = that.targetVisibility;
	  this.currentVisibility = that.currentVisibility;
	  return this;
	};

	Object.defineProperties(Text.prototype, {
	  /**
	   * Indicates the screen coordinate bounds of this shape during ordered rendering.
	   * @type {Rectangle}
	   * @readonly
	   * @memberof Text.prototype
	   */
	  screenBounds: {
	    get: function () {
	      return this.imageBounds;
	    }
	  }
	});
	/**
	 * Renders this text. This method is typically not called by applications but is called by
	 * [RenderableLayer]{@link RenderableLayer} during rendering. For this shape this method creates and
	 * enques an ordered renderable with the draw context and does not actually draw the text.
	 * @param {DrawContext} dc The current draw context.
	 */

	Text.prototype.render = function (dc) {
	  if (!this.enabled || !this.text || this.text.length === 0) {
	    return;
	  }

	  if (!dc.accumulateOrderedRenderables) {
	    return;
	  } // Create an ordered renderable for this text. If one has already been created this frame then we're
	  // in 2D-continuous mode and another needs to be created for one of the alternate globe offsets.


	  var orderedText;

	  if (this.lastFrameTime !== dc.timestamp) {
	    orderedText = this.makeOrderedRenderable(dc);
	  } else {
	    var textCopy = this.clone();
	    orderedText = textCopy.makeOrderedRenderable(dc);
	  }

	  if (!orderedText) {
	    return;
	  }

	  if (!orderedText.isVisible(dc)) {
	    return;
	  }

	  orderedText.layer = dc.currentLayer;
	  this.lastFrameTime = dc.timestamp;
	  dc.addOrderedRenderable(orderedText);
	};
	/**
	 * Draws this shape as an ordered renderable. Applications do not call this function. It is called by
	 * {@link WorldWindow} during rendering. Implements the {@link OrderedRenderable} interface.
	 * @param {DrawContext} dc The current draw context.
	 */


	Text.prototype.renderOrdered = function (dc) {
	  // Optimize away the case of achieved target visibility of 0 and no marker image to display in that case.
	  if (this.currentVisibility === 0 && this.targetVisibility === 0 && !this.markerImageSource) {
	    return;
	  }

	  this.drawOrderedText(dc);

	  if (dc.pickingMode) {
	    var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this, this.position, this.layer, false);
	    dc.resolvePick(po);
	  }
	}; // Intentionally not documented.


	Text.prototype.makeOrderedRenderable = function (dc) {
	  var w, h, s, offset;
	  this.determineActiveAttributes(dc);

	  if (!this.activeAttributes) {
	    return null;
	  } //// Compute the text's screen point and distance to the eye point.


	  if (!this.computeScreenPointAndEyeDistance(dc)) {
	    return null;
	  }

	  this.activeTexture = dc.createTextTexture(this.text, this.activeAttributes);
	  w = this.activeTexture.imageWidth;
	  h = this.activeTexture.imageHeight;
	  s = this.activeAttributes.scale;
	  offset = this.activeAttributes.offset.offsetForSize(w, h);
	  this.imageTransform.setTranslation(this.screenPoint[0] - offset[0] * s, this.screenPoint[1] - offset[1] * s, this.screenPoint[2]);
	  this.imageTransform.setScale(w * s, h * s, 1);
	  this.imageBounds = WWMath.boundingRectForUnitQuad(this.imageTransform);
	  return this;
	};
	/**
	 * Computes this shape's screen point and eye distance. Subclasses must override this method.
	 * @param {DrawContext} dc The current draw context.
	 * @returns {Boolean} true if the screen point can be computed, otherwise false.
	 * @protected
	 */


	Text.prototype.computeScreenPointAndEyeDistance = function (dc) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Renderable", "render", "abstractInvocation"));
	}; // Internal. Intentionally not documented.


	Text.prototype.determineActiveAttributes = function (dc) {
	  if (this.highlighted && this.highlightAttributes) {
	    this.activeAttributes = this.highlightAttributes;
	  } else {
	    this.activeAttributes = this.attributes;
	  }
	}; // Internal. Intentionally not documented.


	Text.prototype.isVisible = function (dc) {
	  if (dc.pickingMode) {
	    return dc.pickRectangle && this.imageBounds.intersects(dc.pickRectangle);
	  } else {
	    return this.imageBounds.intersects(dc.viewport);
	  }
	}; // Internal. Intentionally not documented.


	Text.prototype.drawOrderedText = function (dc) {
	  this.beginDrawing(dc);

	  try {
	    this.doDrawOrderedText(dc);

	    if (!dc.pickingMode) {//this.drawBatchOrderedText(dc);
	    }
	  } finally {
	    this.endDrawing(dc);
	  }
	}; // Internal. Intentionally not documented.


	Text.prototype.drawBatchOrderedText = function (dc) {
	  // Draw any subsequent text in the ordered renderable queue, removing each from the queue as it's
	  // processed. This avoids the overhead of setting up and tearing down OpenGL state for each text shape.
	  var or;

	  while ((or = dc.peekOrderedRenderable()) && or instanceof Text) {
	    dc.popOrderedRenderable(); // remove it from the queue

	    try {
	      or.doDrawOrderedText(dc);
	    } catch (e) {
	      Logger$1.logMessage(Logger$1.LEVEL_WARNING, 'Text', 'drawBatchOrderedText', "Error occurred while rendering text using batching: " + e.message);
	    } // Keep going. Render the rest of the ordered renderables.

	  }
	}; // Internal. Intentionally not documented.


	Text.prototype.beginDrawing = function (dc) {
	  var gl = dc.currentGlContext,
	      program;
	  dc.findAndBindProgram(BasicTextureProgram); // Configure GL to use the draw context's unit quad VBOs for both model coordinates and texture coordinates.
	  // Most browsers can share the same buffer for vertex and texture coordinates, but Internet Explorer requires
	  // that they be in separate buffers, so the code below uses the 3D buffer for vertex coords and the 2D
	  // buffer for texture coords.

	  program = dc.currentProgram;
	  gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer3());
	  gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	  gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer());
	  gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	  gl.enableVertexAttribArray(program.vertexPointLocation);
	  gl.enableVertexAttribArray(program.vertexTexCoordLocation); // Tell the program which texture unit to use.

	  program.loadTextureUnit(gl, gl.TEXTURE0); // Turn off color modulation since we want to pick against the text box and not just the text.

	  program.loadModulateColor(gl, false); // Suppress depth-buffer writes.

	  gl.depthMask(false);
	}; // Internal. Intentionally not documented.


	Text.prototype.endDrawing = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram; // Restore the default GL vertex attribute state.

	  gl.disableVertexAttribArray(program.vertexPointLocation);
	  gl.disableVertexAttribArray(program.vertexTexCoordLocation); // Restore the default GL buffer and texture bindings.

	  gl.bindBuffer(gl.ARRAY_BUFFER, null);
	  gl.bindTexture(gl.TEXTURE_2D, null); // Restore the default GL depth mask state.

	  gl.depthMask(true);
	}; // Internal. Intentionally not documented.


	Text.prototype.doDrawOrderedText = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram; // Compute the text's current visibility, potentially requesting additional frames.

	  if (!dc.pickingMode && this.currentVisibility !== this.targetVisibility) {
	    var visibilityDelta = (dc.timestamp - dc.previousRedrawTimestamp) / dc.fadeTime;

	    if (this.currentVisibility < this.targetVisibility) {
	      this.currentVisibility = Math.min(1, this.currentVisibility + visibilityDelta);
	    } else {
	      this.currentVisibility = Math.max(0, this.currentVisibility - visibilityDelta);
	    }

	    dc.redrawRequested = true;
	  } // Turn off depth testing for the text unless it's been requested.


	  if (!this.activeAttributes.depthTest) {
	    gl.disable(gl.DEPTH_TEST);
	  } // Use the text color and opacity. Modulation is done to white to avoid the program's shader from
	  // modifying the text color. When picking, use the pick color, 100% opacity and no texture.


	  if (!dc.pickingMode) {
	    program.loadColor(gl, Color.WHITE);
	    program.loadOpacity(gl, this.layer.opacity * this.currentVisibility);
	  } else {
	    this.pickColor = dc.uniquePickColor();
	    program.loadColor(gl, this.pickColor);
	    program.loadOpacity(gl, 1);
	    program.loadTextureEnabled(gl, false);
	  } // When the text is visible, draw the text label.


	  if (this.currentVisibility > 0) {
	    this.drawLabel(dc);
	  } // When the text is not visible, draw a marker to indicate that something is there.


	  if (this.currentVisibility < 1 && this.markerImageSource) {
	    this.drawMarker(dc);
	  } // Restore the default GL depth test state.


	  if (!this.activeAttributes.depthTest) {
	    gl.enable(gl.DEPTH_TEST);
	  }
	}; // Internal. Intentionally not documented.


	Text.prototype.drawLabel = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram,
	      textureBound; // Use the label texture when not picking.

	  if (!dc.pickingMode && this.activeTexture) {
	    Text.matrix.setToIdentity();
	    Text.matrix.multiplyByTextureTransform(this.activeTexture);
	    textureBound = this.activeTexture.bind(dc); // returns false if texture is null or cannot be bound

	    program.loadTextureEnabled(gl, textureBound);
	    program.loadTextureMatrix(gl, Text.matrix);
	  } // Compute and specify the text label's modelview-projection matrix.


	  Text.matrix.copy(dc.screenProjection);
	  Text.matrix.multiplyMatrix(this.imageTransform);
	  program.loadModelviewProjection(gl, Text.matrix); // Draw the text as a two-triangle square.

	  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	}; // Internal. Intentionally not documented.


	Text.prototype.drawMarker = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram,
	      textureBound;
	  var markerTexture = dc.gpuResourceCache.resourceForKey(this.markerImageSource);

	  if (!markerTexture) {
	    dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this.markerImageSource);
	    return;
	  } // Use the marker opacity and texture when not picking.


	  if (!dc.pickingMode) {
	    Text.matrix.setToIdentity();
	    Text.matrix.multiplyByTextureTransform(markerTexture);
	    textureBound = markerTexture.bind(dc); // returns false if texture is null or cannot be bound

	    program.loadTextureEnabled(gl, textureBound);
	    program.loadTextureMatrix(gl, Text.matrix);
	    program.loadOpacity(gl, this.layer.opacity * (1 - this.currentVisibility));
	  } // Compute and specify the marker's modelview-projection matrix.


	  var s = this.markerImageScale;
	  Text.matrix.copy(dc.screenProjection);
	  Text.matrix.multiplyByTranslation(this.screenPoint[0] - s * markerTexture.imageWidth / 2, this.screenPoint[1] - s * markerTexture.imageWidth / 2, this.screenPoint[2]);
	  Text.matrix.multiplyByScale(markerTexture.imageWidth * s, markerTexture.imageHeight * s, 1);
	  program.loadModelviewProjection(gl, Text.matrix); // Draw the marker as a two-triangle square.

	  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	};

	/**
	 * @exports ScreenText
	 */
	/**
	 * Constructs a screen text shape at a specified screen location.
	 * @alias ScreenText
	 * @constructor
	 * @augments Text
	 * @classdesc Represents a string of text displayed at a screen location.
	 * <p>
	 * See also {@link GeographicText}.
	 *
	 * @param {Offset} screenOffset The offset indicating the text's placement on the screen.
	 * Use [TextAttributes.offset]{@link TextAttributes#offset} to position the text relative to the specified
	 * screen offset.
	 * @param {String} text The text to display.
	 * @throws {ArgumentError} If either the specified screen offset or text is null or undefined.
	 */

	function ScreenText(screenOffset, text) {
	  if (!screenOffset) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Text", "constructor", "missingOffset"));
	  }

	  Text.call(this, text);
	  /**
	   * The offset indicating this text's placement on the screen.
	   * The [TextAttributes.offset]{@link TextAttributes#offset} property indicates the relationship of the text
	   * string to this location.
	   * @type {Offset}
	   */

	  this.screenOffset = screenOffset;
	  /**
	   * Inherited from [Text]{@link Text#altitudeMode} but not utilized by screen text.
	   */

	  this.altitudeMode = null;
	}

	ScreenText.prototype = Object.create(Text.prototype); // Documented in superclass.

	ScreenText.prototype.render = function (dc) {
	  // Ensure that this text is drawn only once per frame.
	  if (this.lastFrameTime !== dc.timestamp) {
	    Text.prototype.render.call(this, dc);
	  }
	}; // Documented in superclass.


	ScreenText.prototype.computeScreenPointAndEyeDistance = function (dc) {
	  var gl = dc.currentGlContext,
	      offset = this.screenOffset.offsetForSize(gl.drawingBufferWidth, gl.drawingBufferHeight);
	  this.screenPoint[0] = offset[0];
	  this.screenPoint[1] = offset[1];
	  this.screenPoint[2] = 0;
	  this.eyeDistance = 0;
	  return true;
	};

	/**
	 * @exports ScreenCreditController
	 */
	/**
	 * Constructs a screen credit controller.
	 * @alias ScreenCreditController
	 * @constructor
	 * @augments Layer
	 * @classdesc Collects and displays screen credits.
	 */

	function ScreenCreditController() {
	  Layer.call(this, "ScreenCreditController");
	  /**
	   * An {@link Offset} indicating where to place the attributions on the screen.
	   * @type {Offset}
	   * @default The lower left corner of the window with an 11px left margin and a 2px bottom margin.
	   */

	  this.creditPlacement = new Offset(WorldWind.OFFSET_PIXELS, 11, WorldWind.OFFSET_PIXELS, 2);
	  /**
	   * The amount of horizontal spacing between adjacent attributions.
	   * @type {number}
	   * @default An 11px margin between attributions.
	   */

	  this.creditMargin = 11; // Apply 50% opacity to all shapes rendered by this layer.

	  this.opacity = 0.5; // Internal. Intentionally not documented.

	  this.credits = [];
	}

	ScreenCreditController.prototype = Object.create(Layer.prototype);
	/**
	 * Clears all credits from this controller.
	 */

	ScreenCreditController.prototype.clear = function () {
	  this.credits = [];
	};
	/**
	 * Adds a credit to this controller.
	 * @param {String} creditString The text to display in the credits area.
	 * @param {Color} color The color with which to draw the string.
	 * @param {String} hyperlinkUrl Optional argument if screen credit is intended to work as a hyperlink.
	 * @throws {ArgumentError} If either the specified string or color is null or undefined.
	 */


	ScreenCreditController.prototype.addCredit = function (creditString, color, hyperlinkUrl) {
	  if (!creditString) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ScreenCreditController", "addCredit", "missingText"));
	  }

	  if (!color) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ScreenCreditController", "addCredit", "missingColor"));
	  } // Verify if text credit is not already in controller, if it is, don't add it.


	  for (var i = 0, len = this.credits.length; i < len; i++) {
	    if (this.credits[i].text === creditString) {
	      return;
	    }
	  }

	  var credit = new ScreenText(new Offset(WorldWind.OFFSET_PIXELS, 0, WorldWind.OFFSET_PIXELS, 0), creditString);
	  credit.attributes.font = new Font(10);
	  credit.attributes.color = color;
	  credit.attributes.enableOutline = false;
	  credit.attributes.offset = new Offset(WorldWind.OFFSET_FRACTION, 0, WorldWind.OFFSET_FRACTION, 0); // Append new user property to store URL for hyperlinking.
	  // (See BasicWorldWindowController.handleClickOrTap).

	  if (hyperlinkUrl) {
	    credit.userProperties.url = hyperlinkUrl;
	  }

	  this.credits.push(credit);
	}; // Internal use only. Intentionally not documented.


	ScreenCreditController.prototype.doRender = function (dc) {
	  var point = this.creditPlacement.offsetForSize(dc.viewport.width, dc.viewport.height);

	  for (var i = 0, len = this.credits.length; i < len; i++) {
	    // Place the credit text on screen and render it.
	    this.credits[i].screenOffset.x = point[0];
	    this.credits[i].screenOffset.y = point[1];
	    this.credits[i].render(dc); // Advance the screen position for the next credit.

	    dc.textRenderer.typeFace = this.credits[i].attributes.font;
	    dc.textRenderer.outlineWidth = this.credits[i].attributes.outlineWidth;
	    dc.textRenderer.enableOutline = this.credits[i].attributes.enableOutline;
	    point[0] += dc.textRenderer.textSize(this.credits[i].text)[0];
	    point[0] += this.creditMargin;
	  }
	};

	/**
	 * @exports NotYetImplementedError
	 */
	/**
	 * Constructs a not-yet-implemented error with a specified message.
	 * @alias NotYetImplementedError
	 * @constructor
	 * @classdesc Represents an error associated with an operation that is not yet implemented.
	 * @augments AbstractError
	 * @param {String} message The message.
	 */

	function NotYetImplementedError(message) {
	  AbstractError.call(this, "NotYetImplementedError", message);
	  var stack;

	  try {
	    //noinspection ExceptionCaughtLocallyJS
	    throw new Error();
	  } catch (e) {
	    stack = e.stack;
	  }

	  this.stack = stack;
	}

	NotYetImplementedError.prototype = Object.create(AbstractError.prototype);

	/**
	 * @exports HashMap
	 */

	/**
	 * Constructs a hash map.
	 * @alias HashMap
	 * @constructor
	 */
	function HashMap() {
	  this._entries = Object.create(null);
	}
	/**
	 * Returns the stored value for this key or undefined
	 * @param{String | Number} key
	 * @returns the value for the specified key or undefined
	 */


	HashMap.prototype.get = function (key) {
	  return this._entries[key];
	};
	/**
	 * Stores a value for a specified key
	 * @param{String | Number} key
	 * @param value a value to store for the specified key
	 */


	HashMap.prototype.set = function (key, value) {
	  this._entries[key] = value;
	};
	/**
	 * Removes the value and key for a specified key
	 * @param{String | Number} key
	 */


	HashMap.prototype.remove = function (key) {
	  delete this._entries[key];
	};
	/**
	 * Indicates if the has map contains a key
	 * @param{String | Number} key
	 * @returns {Boolean}
	 */


	HashMap.prototype.contains = function (key) {
	  return key in this._entries;
	};
	/**
	 * Internal. Applications should call this function
	 * Creates a new HashMap with the same values as the original but increased indexes.
	 * The keys are used as indexes and are assumed to be natural numbers.
	 * Used by the PolygonSplitter.
	 * @param{HashMap} hashMap the hash map to re-index
	 * @param{Number} fromIndex the index from with to start reindexing
	 * @param{Number} amount the amount by which to increase the index
	 * @returns {HashMap} a new has map with re-indexed keys
	 */


	HashMap.reIndex = function (hashMap, fromIndex, amount) {
	  var newHashMap = new HashMap();

	  for (var key in hashMap._entries) {
	    var index = parseInt(key);

	    if (index >= fromIndex) {
	      index += amount;
	    }

	    var entry = hashMap.get(key);
	    entry.index = index;
	    newHashMap.set(index, entry);
	  }

	  return newHashMap;
	};

	/**
	 * Splits polygons that cross the anti-meridian and/or contain a pole.
	 * @exports PolygonSplitter
	 */

	var PolygonSplitter = {
	  //Internal
	  //Keeps track of the index of added points so that no point is duplicated
	  addedIndex: -1,
	  //Internal
	  //The index where pole insertion began
	  poleIndexOffset: -1,

	  /**
	   * Splits an array of polygons that cross the anti-meridian or contain a pole.
	   *
	   * @param {Array} contours an array of arrays of Locations or Positions
	   * Each array entry defines one of this polygon's boundaries.
	   * @param {Array} resultContours an empty array to put the result of the split. Each element will have the
	   * shape of PolygonSplitter.formatContourOutput
	   * @returns {Boolean} true if one of the boundaries crosses the anti-meridian otherwise false
	   * */
	  splitContours: function (contours, resultContours) {
	    var doesCross = false;

	    for (var i = 0, len = contours.length; i < len; i++) {
	      var contourInfo = this.splitContour(contours[i]);

	      if (contourInfo.polygons.length > 1) {
	        doesCross = true;
	      }

	      resultContours.push(contourInfo);
	    }

	    return doesCross;
	  },

	  /**
	   * Splits a polygon that cross the anti-meridian or contain a pole.
	   *
	   * @param {Location[] | Position[]} points an array of Locations or Positions that define a polygon
	   * @returns {Object} @see PolygonSplitter.formatContourOutput
	   * */
	  splitContour: function (points) {
	    var iMap = new HashMap();
	    var newPoints = [];
	    var intersections = [];
	    var polygons = [];
	    var iMaps = [];
	    var poleIndex = -1;
	    var pole = this.findIntersectionAndPole(points, newPoints, intersections, iMap);

	    if (intersections.length === 0) {
	      polygons.push(newPoints);
	      iMaps.push(iMap);
	      return this.formatContourOutput(polygons, pole, poleIndex, iMaps);
	    }

	    if (intersections.length > 2) {
	      intersections.sort(function (a, b) {
	        return b.latitude - a.latitude;
	      });
	    }

	    if (pole !== Location.poles.NONE) {
	      newPoints = this.handleOnePole(newPoints, intersections, iMap, pole);
	      iMap = this.reindexIntersections(intersections, iMap, this.poleIndexOffset);
	    }

	    if (intersections.length === 0) {
	      polygons.push(newPoints);
	      iMaps.push(iMap);
	      poleIndex = 0;
	      return this.formatContourOutput(polygons, pole, poleIndex, iMaps);
	    }

	    this.linkIntersections(intersections, iMap);
	    poleIndex = this.makePolygons(newPoints, intersections, iMap, polygons, iMaps);
	    return this.formatContourOutput(polygons, pole, poleIndex, iMaps);
	  },

	  /**
	   * Internal. Applications should not call this method.
	   * Finds the intersections with the anti-meridian and if the polygon contains one of the poles.
	   * A new polygon is constructed with the intersections and pole points and stored in newPoints
	   *
	   * @param {Location[] | Position[]} points An array of Locations or Positions that define a polygon
	   * @param {Location[] | Position[]} newPoints An empty array where to store the resulting polygon with intersections
	   * @param {Array} intersections An empty array where to store the intersection latitude and index
	   * @param {HashMap} iMap A hashMap to store intersection data
	   * The key is the index in the newPoints array and value is PolygonSplitter.makeIntersectionEntry
	   * @returns {Number} The pole number @see Location.poles
	   * */
	  findIntersectionAndPole: function (points, newPoints, intersections, iMap) {
	    var containsPole = false;
	    var minLatitude = 90.0;
	    var maxLatitude = -90.0;
	    this.addedIndex = -1;

	    for (var i = 0, lenC = points.length; i < lenC; i++) {
	      var pt1 = points[i];
	      var pt2 = points[(i + 1) % lenC];
	      minLatitude = Math.min(minLatitude, pt1.latitude);
	      maxLatitude = Math.max(maxLatitude, pt1.latitude);
	      var doesCross = Location.locationsCrossDateLine([pt1, pt2]);

	      if (doesCross) {
	        containsPole = !containsPole;
	        var iLatitude = Location.meridianIntersection(pt1, pt2, 180);

	        if (iLatitude === null) {
	          iLatitude = (pt1.latitude + pt2.latitude) / 2;
	        }

	        var iLongitude = WWMath.signum(pt1.longitude) * 180 || 180;
	        var iLoc1 = this.createPoint(iLatitude, iLongitude, pt1.altitude);
	        var iLoc2 = this.createPoint(iLatitude, -iLongitude, pt2.altitude);
	        this.safeAdd(newPoints, pt1, i, lenC);
	        var index = newPoints.length;
	        iMap.set(index, this.makeIntersectionEntry(index));
	        iMap.set(index + 1, this.makeIntersectionEntry(index + 1));
	        intersections.push({
	          indexEnd: index,
	          indexStart: index + 1,
	          latitude: iLatitude
	        });
	        newPoints.push(iLoc1);
	        newPoints.push(iLoc2);
	        this.safeAdd(newPoints, pt2, i + 1, lenC);
	      } else {
	        this.safeAdd(newPoints, pt1, i, lenC);
	        this.safeAdd(newPoints, pt2, i + 1, lenC);
	      }
	    }

	    var pole = Location.poles.NONE;

	    if (containsPole) {
	      pole = this.determinePole(minLatitude, maxLatitude);
	    }

	    return pole;
	  },

	  /**
	   * Internal. Applications should not call this method.
	   * Determine which pole is enclosed. If the shape is entirely in one hemisphere, then assume that it encloses
	   * the pole in that hemisphere. Otherwise, assume that it encloses the pole that is closest to the shape's
	   * extreme latitude.
	   * @param {Number} minLatitude The minimum latitude of a polygon that contains a pole
	   * @param {Number} maxLatitude The maximum latitude of a polygon that contains a pole
	   * @returns {Number} The pole number @see Location.poles
	   * */
	  determinePole: function (minLatitude, maxLatitude) {
	    var pole;

	    if (minLatitude > 0) {
	      pole = Location.poles.NORTH; // Entirely in Northern Hemisphere.
	    } else if (maxLatitude < 0) {
	      pole = Location.poles.SOUTH; // Entirely in Southern Hemisphere.
	    } else if (Math.abs(maxLatitude) >= Math.abs(minLatitude)) {
	      pole = Location.poles.NORTH; // Spans equator, but more north than south.
	    } else {
	      pole = Location.poles.SOUTH; // Spans equator, but more south than north.
	    }

	    return pole;
	  },

	  /**
	   * Internal. Applications should not call this method.
	   * Creates a new array of points containing the two pole locations on both sides of the anti-meridian
	   *
	   * @param {Location[] | Position[]} points
	   * @param {Array} intersections
	   * @param {HashMap} iMap
	   * @param {Number} pole
	   * @return {Object} an object containing the new points and a new reIndexed iMap
	   * */
	  handleOnePole: function (points, intersections, iMap, pole) {
	    var pointsClone;

	    if (pole === Location.poles.NORTH) {
	      var intersection = intersections.shift();
	      var poleLat = 90;
	    } else if (pole === Location.poles.SOUTH) {
	      intersection = intersections.pop();
	      poleLat = -90;
	    }

	    var iEnd = iMap.get(intersection.indexEnd);
	    var iStart = iMap.get(intersection.indexStart);
	    iEnd.forPole = true;
	    iStart.forPole = true;
	    this.poleIndexOffset = intersection.indexStart;
	    pointsClone = points.slice(0, intersection.indexEnd + 1);
	    var polePoint1 = this.createPoint(poleLat, points[iEnd.index].longitude, points[iEnd.index].altitude);
	    var polePoint2 = this.createPoint(poleLat, points[iStart.index].longitude, points[iStart.index].altitude);
	    pointsClone.push(polePoint1, polePoint2);
	    pointsClone = pointsClone.concat(points.slice(this.poleIndexOffset));
	    return pointsClone;
	  },

	  /**
	   * Internal. Applications should not call this method.
	   * Links adjacents pairs of intersection by index
	   * @param {Array} intersections
	   * @param {HashMap} iMap
	   * */
	  linkIntersections: function (intersections, iMap) {
	    for (var i = 0; i < intersections.length - 1; i += 2) {
	      var i0 = intersections[i];
	      var i1 = intersections[i + 1];
	      var iEnd0 = iMap.get(i0.indexEnd);
	      var iStart0 = iMap.get(i0.indexStart);
	      var iEnd1 = iMap.get(i1.indexEnd);
	      var iStart1 = iMap.get(i1.indexStart);
	      iEnd0.linkTo = i1.indexStart;
	      iStart0.linkTo = i1.indexEnd;
	      iEnd1.linkTo = i0.indexStart;
	      iStart1.linkTo = i0.indexEnd;
	    }
	  },

	  /**
	   * Internal. Applications should not call this method.
	   * ReIndexes the intersections due to the poles being added to the array of points
	   * @param {Array} intersections
	   * @param {HashMap} iMap
	   * @param {Number} indexOffset the index from which to start reIndexing
	   * @returns {HashMap} a new hash map with the correct indices
	   * */
	  reindexIntersections: function (intersections, iMap, indexOffset) {
	    iMap = HashMap.reIndex(iMap, indexOffset, 2);

	    for (var i = 0, len = intersections.length; i < len; i++) {
	      if (intersections[i].indexEnd >= indexOffset) {
	        intersections[i].indexEnd += 2;
	      }

	      if (intersections[i].indexStart >= indexOffset) {
	        intersections[i].indexStart += 2;
	      }
	    }

	    return iMap;
	  },

	  /**
	   * Internal. Applications should not call this method.
	   * @param {Location[] | Position[]} points
	   * @param {Array} intersections
	   * @param {HashMap} iMap
	   * @param {Array} polygons an empty array to store the resulting polygons
	   * @param {HashMap[]} iMaps an empty array to store the resulting hasp maps for each polygon
	   * @returns {Number} the pole number @see Location.poles
	   * */
	  makePolygons: function (points, intersections, iMap, polygons, iMaps) {
	    var poleIndex = -1;

	    for (var i = 0; i < intersections.length - 1; i += 2) {
	      var i0 = intersections[i];
	      var i1 = intersections[i + 1];
	      var start = i0.indexStart;
	      var end = i1.indexEnd;
	      var polygon = [];
	      var polygonHashMap = new HashMap();
	      var containsPole = this.makePolygon(start, end, points, iMap, polygon, polygonHashMap);

	      if (polygon.length) {
	        polygons.push(polygon);
	        iMaps.push(polygonHashMap);

	        if (containsPole) {
	          poleIndex = polygons.length - 1;
	        }
	      }

	      start = i1.indexStart;
	      end = i0.indexEnd;
	      polygon = [];
	      polygonHashMap = new HashMap();
	      containsPole = this.makePolygon(start, end, points, iMap, polygon, polygonHashMap);

	      if (polygon.length) {
	        polygons.push(polygon);
	        iMaps.push(polygonHashMap);

	        if (containsPole) {
	          poleIndex = polygons.length - 1;
	        }
	      }
	    }

	    return poleIndex;
	  },

	  /**
	   * Internal. Applications should not call this method.
	   * Paths from a start intersection index to an end intersection index and makes a polygon and a hashMap
	   * with the intersection indices
	   * @param {Number} start the index of a start type intersection
	   * @param {Number} end the index of an end type intersection
	   * @param {Location[] | Position[]} points
	   * @param {HashMap} iMap
	   * @param {Location[] | Position[]} resultPolygon an empty array to store the resulting polygon
	   * @param {HashMap} polygonHashMap a hash map to record the indices of the intersections in the polygon
	   * @returns {Boolean} true if the polygon contains a pole
	   * */
	  makePolygon: function (start, end, points, iMap, resultPolygon, polygonHashMap) {
	    var pass = false;
	    var len = points.length;
	    var containsPole = false;

	    if (end < start) {
	      end += len;
	    }

	    for (var i = start; i <= end; i++) {
	      var idx = i % len;
	      var pt = points[idx];
	      var intersection = iMap.get(idx);

	      if (intersection) {
	        if (intersection.visited) {
	          break;
	        }

	        resultPolygon.push(pt);
	        polygonHashMap.set(resultPolygon.length - 1, intersection);

	        if (intersection.forPole) {
	          containsPole = true;
	        } else {
	          if (pass) {
	            i = intersection.linkTo - 1;

	            if (i + 1 === start) {
	              break;
	            }
	          }

	          pass = !pass;
	          intersection.visited = true;
	        }
	      } else {
	        resultPolygon.push(pt);
	      }
	    }

	    return containsPole;
	  },

	  /**
	   * Internal. Applications should not call this method.
	   * Adds an element to an array preventing duplication
	   * @param {Location[] | Position[]} points
	   * @param {Location | Position} point
	   * @param {Number} index The index of the Point from the source array
	   * @param {Number} len The length of the source array
	   * */
	  safeAdd: function (points, point, index, len) {
	    if (this.addedIndex < index && this.addedIndex < len - 1) {
	      points.push(point);
	      this.addedIndex = index;
	    }
	  },

	  /**
	   * Internal. Applications should not call this method.
	   * Creates a Location or a Position
	   * @param {Number} latitude
	   * @param {Number} longitude
	   * @param {Number} altitude
	   * @returns Location | Position
	   * */
	  createPoint: function (latitude, longitude, altitude) {
	    if (altitude == null) {
	      return new Location(latitude, longitude);
	    }

	    return new Position(latitude, longitude, altitude);
	  },

	  /**
	   * Internal. Applications should not call this method.
	   * @param {Array} polygons an array of arrays of Locations or Positions
	   * @param {Number} pole the pole number @see Location.poles
	   * @param {Number} poleIndex the index of the polygon containing the pole
	   * @param {HashMap[]} iMaps an array of hash maps for each polygon
	   * */
	  formatContourOutput: function (polygons, pole, poleIndex, iMaps) {
	    return {
	      polygons: polygons,
	      pole: pole,
	      poleIndex: poleIndex,
	      iMap: iMaps
	    };
	  },

	  /**
	   * Internal. Applications should not call this method.
	   * @param {Number} index the index of the intersection in the array of points
	   * */
	  makeIntersectionEntry: function (index) {
	    if (index == null) {
	      index = -1;
	    }

	    return {
	      visited: false,
	      forPole: false,
	      index: index,
	      linkTo: -1
	    };
	  }
	};

	/**
	 * @exports ShapeAttributes
	 */
	/**
	 * Constructs a shape attributes bundle, optionally specifying a prototype set of attributes. Not all shapes
	 * use all the properties in the bundle. See the documentation of a specific shape to determine the properties
	 * it does use.
	 * @alias ShapeAttributes
	 * @constructor
	 * @classdesc Holds attributes applied to WorldWind shapes.
	 * @param {ShapeAttributes} attributes An attribute bundle whose properties are used to initially populate
	 * the constructed attributes bundle. May be null, in which case the constructed attributes bundle is populated
	 * with default attributes.
	 */

	function ShapeAttributes(attributes) {
	  // All these are documented with their property accessors below.
	  this._drawInterior = attributes ? attributes._drawInterior : true;
	  this._drawOutline = attributes ? attributes._drawOutline : true;
	  this._enableLighting = attributes ? attributes._enableLighting : false;
	  this._interiorColor = attributes ? attributes._interiorColor.clone() : Color.WHITE.clone();
	  this._outlineColor = attributes ? attributes._outlineColor.clone() : Color.RED.clone();
	  this._outlineWidth = attributes ? attributes._outlineWidth : 1.0;
	  this._outlineStippleFactor = attributes ? attributes._outlineStippleFactor : 0;
	  this._outlineStipplePattern = attributes ? attributes._outlineStipplePattern : 0xF0F0;
	  this._imageSource = attributes ? attributes._imageSource : null;
	  this._depthTest = attributes ? attributes._depthTest : true;
	  this._drawVerticals = attributes ? attributes._drawVerticals : false;
	  this._applyLighting = attributes ? attributes._applyLighting : false;
	  /**
	   * Indicates whether this object's state key is invalid. Subclasses must set this value to true when their
	   * attributes change. The state key will be automatically computed the next time it's requested. This flag
	   * will be set to false when that occurs.
	   * @type {Boolean}
	   * @protected
	   */

	  this.stateKeyInvalid = true;
	}
	/**
	 * Computes the state key for this attributes object. Subclasses that define additional attributes must
	 * override this method, call it from that method, and append the state of their attributes to its
	 * return value.
	 * @returns {String} The state key for this object.
	 * @protected
	 */


	ShapeAttributes.prototype.computeStateKey = function () {
	  return "di " + this._drawInterior + " do " + this._drawOutline + " el " + this._enableLighting + " ic " + this._interiorColor.toHexString(true) + " oc " + this._outlineColor.toHexString(true) + " ow " + this._outlineWidth + " osf " + this._outlineStippleFactor + " osp " + this._outlineStipplePattern + " is " + (this._imageSource ? this.imageSource instanceof ImageSource ? this.imageSource.key : this.imageSource : "null") + " dt " + this._depthTest + " dv " + this._drawVerticals + " li " + this._applyLighting;
	};

	Object.defineProperties(ShapeAttributes.prototype, {
	  /**
	   * A string identifying the state of this attributes object. The string encodes the current values of all
	   * this object's properties. It's typically used to validate cached representations of shapes associated
	   * with this attributes object.
	   * @type {String}
	   * @readonly
	   * @memberof ShapeAttributes.prototype
	   */
	  stateKey: {
	    get: function () {
	      if (this.stateKeyInvalid) {
	        this._stateKey = this.computeStateKey();
	        this.stateKeyInvalid = false;
	      }

	      return this._stateKey;
	    }
	  },

	  /**
	   * Indicates whether the interior of the associated shape is drawn.
	   * @type {Boolean}
	   * @default true
	   * @memberof ShapeAttributes.prototype
	   */
	  drawInterior: {
	    get: function () {
	      return this._drawInterior;
	    },
	    set: function (value) {
	      this._drawInterior = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates whether the outline of the associated shape is drawn
	   * @type {Boolean}
	   * @default true
	   * @memberof ShapeAttributes.prototype
	   */
	  drawOutline: {
	    get: function () {
	      return this._drawOutline;
	    },
	    set: function (value) {
	      this._drawOutline = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates whether lighting is applied to the associated shape.
	   * @type {Boolean}
	   * @default false
	   * @memberof ShapeAttributes.prototype
	   */
	  enableLighting: {
	    get: function () {
	      return this._enableLighting;
	    },
	    set: function (value) {
	      this._enableLighting = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the associated shape's interior color and opacity.
	   * @type {Color}
	   * @default Opaque white (red = 1, green = 1, blue = 1, alpha = 1)
	   * @memberof ShapeAttributes.prototype
	   */
	  interiorColor: {
	    get: function () {
	      return this._interiorColor;
	    },
	    set: function (value) {
	      this._interiorColor = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the associated shape's outline color and opacity.
	   * @type {Color}
	   * @default Opaque red (red = 1, green = 0, blue = 0, alpha = 1)
	   * @memberof ShapeAttributes.prototype
	   */
	  outlineColor: {
	    get: function () {
	      return this._outlineColor;
	    },
	    set: function (value) {
	      this._outlineColor = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the associated shape's outline width.
	   * @type {Number}
	   * @default 1.0
	   * @memberof ShapeAttributes.prototype
	   */
	  outlineWidth: {
	    get: function () {
	      return this._outlineWidth;
	    },
	    set: function (value) {
	      this._outlineWidth = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the associated shape's outline stipple pattern. Specifies a number whose lower 16 bits
	   * define a pattern of which pixels in the outline are rendered and which are suppressed. Each bit
	   * corresponds to a pixel in the shape's outline, and the pattern repeats after every n*16 pixels, where
	   * n is the [stipple factor]{@link ShapeAttributes#outlineStippleFactor}. For example, if the outline
	   * stipple factor is 3, each bit in the stipple pattern is repeated three times before using the next bit.
	   * <p>
	   * To disable outline stippling, either specify a stipple factor of 0 or specify a stipple pattern of
	   * all 1 bits, i.e., 0xFFFF.
	   * @type {Number}
	   * @default 0xF0F0
	   * @memberof ShapeAttributes.prototype
	   */
	  outlineStipplePattern: {
	    get: function () {
	      return this._outlineStipplePattern;
	    },
	    set: function (value) {
	      this._outlineStipplePattern = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the associated shape's outline stipple factor. Specifies the number of times each bit in the
	   * outline stipple pattern is repeated before the next bit is used. For example, if the outline stipple
	   * factor is 3, each bit is repeated three times before using the next bit. The specified factor must be
	   * either 0 or an integer greater than 0. A stipple factor of 0 indicates no stippling.
	   * @type {Number}
	   * @default 0
	   * @memberof ShapeAttributes.prototype
	   */
	  outlineStippleFactor: {
	    get: function () {
	      return this._outlineStippleFactor;
	    },
	    set: function (value) {
	      this._outlineStippleFactor = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the associated shape's image source. May be null, in which case no image is
	   * applied to the shape.
	   * @type {String|ImageSource}
	   * @memberof ShapeAttributes.prototype
	   * @default null
	   */
	  imageSource: {
	    get: function () {
	      return this._imageSource;
	    },
	    set: function (value) {
	      this._imageSource = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates whether the shape should be depth-tested against other objects in the scene. If true,
	   * the shape may be occluded by terrain and other objects in certain viewing situations. If false,
	   * the shape will not be occluded by terrain and other objects.
	   * @type {Boolean}
	   * @default true
	   * @memberof ShapeAttributes.prototype
	   */
	  depthTest: {
	    get: function () {
	      return this._depthTest;
	    },
	    set: function (value) {
	      this._depthTest = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates whether this shape should draw vertical lines extending from its specified positions to the
	   * ground.
	   * @type {Boolean}
	   * @default false
	   * @memberof ShapeAttributes.prototype
	   */
	  drawVerticals: {
	    get: function () {
	      return this._drawVerticals;
	    },
	    set: function (value) {
	      this._drawVerticals = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates whether lighting is applied to the shape.
	   * @type {Boolean}
	   * @default false
	   * @memberof ShapeAttributes.prototype
	   */
	  applyLighting: {
	    get: function () {
	      return this._applyLighting;
	    },
	    set: function (value) {
	      this._applyLighting = value;
	      this.stateKeyInvalid = true;
	    }
	  }
	});

	/**
	 * @exports SurfaceShape
	 */
	/**
	 * Constructs a surface shape with an optionally specified bundle of default attributes.
	 * @alias SurfaceShape
	 * @constructor
	 * @augments Renderable
	 * @abstract
	 * @classdesc Represents a surface shape. This is an abstract base class and is meant to be instantiated
	 * only by subclasses.
	 * <p>
	 * Surface shapes other than SurfacePolyline {@link SurfacePolyline} have an interior and an outline and utilize
	 * the corresponding attributes in their associated ShapeAttributes {@link ShapeAttributes}. They do not
	 * utilize image-related attributes.
	 *
	 * @param {ShapeAttributes} attributes The attributes to apply to this shape. May be null, in which case
	 * attributes must be set directly before the shape is drawn.
	 */

	function SurfaceShape(attributes) {
	  Renderable.call(this); // All these are documented with their property accessors below.

	  this._displayName = "Surface Shape";
	  this._attributes = attributes ? attributes : new ShapeAttributes(null);
	  this._highlightAttributes = null;
	  this._highlighted = false;
	  this._enabled = true;
	  this._pathType = WorldWind.GREAT_CIRCLE;
	  this._maximumNumEdgeIntervals = SurfaceShape.DEFAULT_NUM_EDGE_INTERVALS;
	  this._polarThrottle = SurfaceShape.DEFAULT_POLAR_THROTTLE;
	  this._boundingSector = null;
	  /**
	   * Indicates the object to return as the owner of this shape when picked.
	   * @type {Object}
	   * @default null
	   */

	  this.pickDelegate = null;
	  /*
	   * The bounding sectors for this tile, which may be needed for crossing the dateline.
	   * @type {Sector[]}
	   * @protected
	   */

	  this._boundingSectors = [];
	  /*
	   * The raw collection of locations defining this shape and are explicitly specified by the client of this class.
	   * @type {Location[]}
	   * @protected
	   */

	  this._locations = null;
	  /*
	   * Boundaries that are either the user specified locations or locations that are algorithmically generated.
	   * @type {Location[]}
	   * @protected
	   */

	  this._boundaries = null;
	  /*
	   * The collection of locations that describes a closed curve which can be filled.
	   * @type {Location[][]}
	   * @protected
	   */

	  this._interiorGeometry = null;
	  /*
	   * The collection of locations that describe the outline of the shape.
	   * @type {Location[][]}
	   * @protected
	   */

	  this._outlineGeometry = null;
	  /*
	   * Internal use only.
	   * Inhibit the filling of the interior. This is to be used ONLY by polylines.
	   * @type {Boolean}
	   * @protected
	   */

	  this._isInteriorInhibited = false;
	  /*
	   * Indicates whether this object's state key is invalid. Subclasses must set this value to true when their
	   * attributes change. The state key will be automatically computed the next time it's requested. This flag
	   * will be set to false when that occurs.
	   * @type {Boolean}
	   * @protected
	   */

	  this.stateKeyInvalid = true; // Internal use only. Intentionally not documented.

	  this._attributesStateKey = null; // Internal use only. Intentionally not documented.

	  this.boundariesArePrepared = false; // Internal use only. Intentionally not documented.

	  this.layer = null; // Internal use only. Intentionally not documented.

	  this.pickColor = null; //the split contours returned from polygon splitter

	  this.contours = [];
	  this.containsPole = false;
	  this.crossesAntiMeridian = false;
	  /**
	   * Indicates how long to use terrain-specific shape data before regenerating it, in milliseconds. A value
	   * of zero specifies that shape data should be regenerated every frame. While this causes the shape to
	   * adapt more frequently to the terrain, it decreases performance.
	   * @type {Number}
	   * @default 2000 (milliseconds)
	   */

	  this.expirationInterval = 2000; // Internal use only. Intentionally not documented.
	  // Holds the per-globe data

	  this.shapeDataCache = new MemoryCache(3, 2); // Internal use only. Intentionally not documented.
	  // The shape-data-cache data that is for the currently active globe.

	  this.currentData = null;
	}

	SurfaceShape.prototype = Object.create(Renderable.prototype);
	Object.defineProperties(SurfaceShape.prototype, {
	  stateKey: {
	    /**
	     * A hash key of the total visible external state of the surface shape.
	     * @memberof SurfaceShape.prototype
	     * @type {String}
	     */
	    get: function () {
	      // If we don't have a state key for the shape attributes, consider this state key to be invalid.
	      if (!this._attributesStateKey) {
	        // Update the state key for the appropriate attributes for future
	        if (this._highlighted) {
	          if (this._highlightAttributes) {
	            this._attributesStateKey = this._highlightAttributes.stateKey;
	          }
	        } else {
	          if (this._attributes) {
	            this._attributesStateKey = this._attributes.stateKey;
	          }
	        } // If we now actually have a state key for the attributes, it was previously invalid.


	        if (this._attributesStateKey) {
	          this.stateKeyInvalid = true;
	        }
	      } else {
	        // Detect a change in the appropriate attributes.
	        var currentAttributesStateKey = null;

	        if (this._highlighted) {
	          // If there are highlight attributes associated with this shape, ...
	          if (this._highlightAttributes) {
	            currentAttributesStateKey = this._highlightAttributes.stateKey;
	          }
	        } else {
	          if (this._attributes) {
	            currentAttributesStateKey = this._attributes.stateKey;
	          }
	        } // If the attributes state key changed, ...


	        if (currentAttributesStateKey != this._attributesStateKey) {
	          this._attributesStateKey = currentAttributesStateKey;
	          this.stateKeyInvalid = true;
	        }
	      }

	      if (this.stateKeyInvalid) {
	        this._stateKey = this.computeStateKey();
	      }

	      return this._stateKey;
	    }
	  },

	  /**
	   * The shape's display name and label text.
	   * @memberof SurfaceShape.prototype
	   * @type {String}
	   * @default Surface Shape
	   */
	  displayName: {
	    get: function () {
	      return this._displayName;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this._displayName = value;
	    }
	  },

	  /**
	   * The shape's attributes. If null and this shape is not highlighted, this shape is not drawn.
	   * @memberof SurfaceShape.prototype
	   * @type {ShapeAttributes}
	   * @default see [ShapeAttributes]{@link ShapeAttributes}
	   */
	  attributes: {
	    get: function () {
	      return this._attributes;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this._attributes = value;
	      this._attributesStateKey = value.stateKey;
	    }
	  },

	  /**
	   * The attributes used when this shape's highlighted flag is true. If null and the
	   * highlighted flag is true, this shape's normal attributes are used. If they, too, are null, this
	   * shape is not drawn.
	   * @memberof SurfaceShape.prototype
	   * @type {ShapeAttributes}
	   * @default null
	   */
	  highlightAttributes: {
	    get: function () {
	      return this._highlightAttributes;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this._highlightAttributes = value;
	    }
	  },

	  /**
	   * Indicates whether this shape displays with its highlight attributes rather than its normal attributes.
	   * @memberof SurfaceShape.prototype
	   * @type {Boolean}
	   * @default false
	   */
	  highlighted: {
	    get: function () {
	      return this._highlighted;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this._highlighted = value;
	    }
	  },

	  /**
	   * Indicates whether this shape is drawn.
	   * @memberof SurfaceShape.prototype
	   * @type {Boolean}
	   * @default true
	   */
	  enabled: {
	    get: function () {
	      return this._enabled;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this._enabled = value;
	    }
	  },

	  /**
	   * The path type to used to interpolate between locations on this shape. Recognized values are:
	   * <ul>
	   * <li>WorldWind.GREAT_CIRCLE</li>
	   * <li>WorldWind.RHUMB_LINE</li>
	   * <li>WorldWind.LINEAR</li>
	   * </ul>
	   * @memberof SurfaceShape.prototype
	   * @type {String}
	   * @default WorldWind.GREAT_CIRCLE
	   */
	  pathType: {
	    get: function () {
	      return this._pathType;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._pathType = value;
	    }
	  },

	  /**
	   * The maximum number of intervals an edge will be broken into. This is the number of intervals that an
	   * edge that spans to opposite side of the globe would be broken into. This is strictly an upper bound
	   * and the number of edge intervals may be lower if this resolution is not needed.
	   * @memberof SurfaceShape.prototype
	   * @type {Number}
	   * @default SurfaceShape.DEFAULT_NUM_EDGE_INTERVALS
	   */
	  maximumNumEdgeIntervals: {
	    get: function () {
	      return this._maximumNumEdgeIntervals;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._maximumNumEdgeIntervals = value;
	    }
	  },

	  /**
	   * A dimensionless number that controls throttling of edge traversal near the poles where edges need to be
	   * sampled more closely together.
	   * A value of 0 indicates that no polar throttling is to be performed.
	   * @memberof SurfaceShape.prototype
	   * @type {Number}
	   * @default SurfaceShape.DEFAULT_POLAR_THROTTLE
	   */
	  polarThrottle: {
	    get: function () {
	      return this._polarThrottle;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._polarThrottle = value;
	    }
	  },

	  /**
	   * Defines the extent of the shape in latitude and longitude.
	   * This sector only has valid data once the boundary is defined. Prior to this, it is null.
	   * @memberof SurfaceShape.prototype
	   * @type {Sector}
	   */
	  boundingSector: {
	    get: function () {
	      return this._boundingSector;
	    }
	  }
	});

	SurfaceShape.staticStateKey = function (shape) {
	  shape.stateKeyInvalid = false;

	  if (shape.highlighted) {
	    if (!shape._highlightAttributes) {
	      if (!shape._attributes) {
	        shape._attributesStateKey = null;
	      } else {
	        shape._attributesStateKey = shape._attributes.stateKey;
	      }
	    } else {
	      shape._attributesStateKey = shape._highlightAttributes.stateKey;
	    }
	  } else {
	    if (!shape._attributes) {
	      shape._attributesStateKey = null;
	    } else {
	      shape._attributesStateKey = shape._attributes.stateKey;
	    }
	  }

	  return "dn " + shape.displayName + " at " + (!shape._attributesStateKey ? "null" : shape._attributesStateKey) + " hi " + shape.highlighted + " en " + shape.enabled + " pt " + shape.pathType + " ne " + shape.maximumNumEdgeIntervals + " po " + shape.polarThrottle + " se " + "[" + shape.boundingSector.minLatitude + "," + shape.boundingSector.maxLatitude + "," + shape.boundingSector.minLongitude + "," + shape.boundingSector.maxLongitude + "]";
	};

	SurfaceShape.prototype.computeStateKey = function () {
	  return SurfaceShape.staticStateKey(this);
	};
	/**
	 * Returns this shape's area in square meters.
	 * @param {Globe} globe The globe on which to compute the area.
	 * @param {Boolean} terrainConformant If true, the returned area is that of the terrain,
	 * including its hillsides and other undulations. If false, the returned area is the shape's
	 * projected area.
	 */


	SurfaceShape.prototype.area = function (globe, terrainConformant) {
	  throw new NotYetImplementedError(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceShape", "area", "notYetImplemented"));
	}; // Internal function. Intentionally not documented.


	SurfaceShape.prototype.computeBoundaries = function (globe) {
	  // This method is in the base class and should be overridden if the boundaries are generated.
	  // TODO: Incorrect error class
	  throw new AbstractError(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceShape", "computeBoundaries", "abstractInvocation"));
	}; // Internal. Intentionally not documented.


	SurfaceShape.prototype.intersectsFrustum = function (dc) {
	  if (this.currentData && this.currentData.extent) {
	    if (dc.pickingMode) {
	      return this.currentData.extent.intersectsFrustum(dc.pickFrustum);
	    } else {
	      return this.currentData.extent.intersectsFrustum(dc.frustumInModelCoordinates);
	    }
	  } else {
	    return true;
	  }
	};
	/**
	 * Indicates whether a specified shape data object is current. Subclasses may override this method to add
	 * criteria indicating whether the shape data object is current, but must also call this method on this base
	 * class. Applications do not call this method.
	 * @param {DrawContext} dc The current draw context.
	 * @param {Object} shapeData The object to validate.
	 * @returns {Boolean} true if the object is current, otherwise false.
	 * @protected
	 */


	SurfaceShape.prototype.isShapeDataCurrent = function (dc, shapeData) {
	  return shapeData.verticalExaggeration === dc.verticalExaggeration && shapeData.expiryTime > Date.now();
	};
	/**
	 * Creates a new shape data object for the current globe state. Subclasses may override this method to
	 * modify the shape data object that this method creates, but must also call this method on this base class.
	 * Applications do not call this method.
	 * @returns {Object} The shape data object.
	 * @protected
	 */


	SurfaceShape.prototype.createShapeDataObject = function () {
	  return {};
	}; // Intentionally not documented.


	SurfaceShape.prototype.resetExpiration = function (shapeData) {
	  // The random addition in the line below prevents all shapes from regenerating during the same frame.
	  shapeData.expiryTime = Date.now() + this.expirationInterval + 1e3 * Math.random();
	}; // Internal. Intentionally not documented.


	SurfaceShape.prototype.establishCurrentData = function (dc) {
	  this.currentData = this.shapeDataCache.entryForKey(dc.globeStateKey);

	  if (!this.currentData) {
	    this.currentData = this.createShapeDataObject();
	    this.resetExpiration(this.currentData);
	    this.shapeDataCache.putEntry(dc.globeStateKey, this.currentData, 1);
	  }

	  this.currentData.isExpired = !this.isShapeDataCurrent(dc, this.currentData);
	}; // Internal function. Intentionally not documented.


	SurfaceShape.prototype.render = function (dc) {
	  if (!this.enabled) {
	    return;
	  }

	  this.layer = dc.currentLayer;
	  this.prepareBoundaries(dc);
	  this.establishCurrentData(dc);

	  if (this.currentData.isExpired || !this.currentData.extent) {
	    this.computeExtent(dc);
	    this.currentData.verticalExaggeration = dc.verticalExaggeration;
	    this.resetExpiration(this.currentData);
	  } // Use the last computed extent to see if this shape is out of view.


	  if (this.currentData && this.currentData.extent && !this.intersectsFrustum(dc)) {
	    return;
	  }

	  dc.surfaceShapeTileBuilder.insertSurfaceShape(this);
	}; // Internal function. Intentionally not documented.


	SurfaceShape.prototype.interpolateLocations = function (locations) {
	  var first = locations[0],
	      next = first,
	      prev,
	      isNextFirst = true,
	      isPrevFirst = true,
	      // Don't care initially, this will get set in first iteration.
	  countFirst = 0,
	      isInterpolated = true,
	      idx,
	      len;
	  this._locations = [first];

	  for (idx = 1, len = locations.length; idx < len; idx += 1) {
	    // Advance to next location, retaining previous location.
	    prev = next;
	    isPrevFirst = isNextFirst;
	    next = locations[idx]; // Detect whether the next location and the first location are the same.

	    isNextFirst = next.latitude == first.latitude && next.longitude == first.longitude; // Inhibit interpolation if either endpoint if the first location,
	    // except for the first segement which will be the actual first location or that location
	    // as the polygon closes the first time.
	    // All subsequent encounters of the first location are used to connected secondary domains with the
	    // primary domain in multiply-connected geometry (an outer ring with multiple inner rings).

	    isInterpolated = true;

	    if (isNextFirst || isPrevFirst) {
	      countFirst += 1;

	      if (countFirst > 2) {
	        isInterpolated = false;
	      }
	    }

	    if (isInterpolated) {
	      this.interpolateEdge(prev, next, this._locations);
	    }

	    this._locations.push(next);

	    prev = next;
	  } // Force the closing of the border.


	  if (!this._isInteriorInhibited) {
	    // Avoid duplication if the first endpoint was already emitted.
	    if (prev.latitude != first.latitude || prev.longitude != first.longitude) {
	      this.interpolateEdge(prev, first, this._locations);

	      this._locations.push(first);
	    }
	  }
	}; // Internal function. Intentionally not documented.


	SurfaceShape.prototype.interpolateEdge = function (start, end, locations) {
	  var distanceRadians = Location.greatCircleDistance(start, end),
	      steps = Math.round(this._maximumNumEdgeIntervals * distanceRadians / Math.PI),
	      dt,
	      location;

	  if (steps > 0) {
	    dt = 1 / steps;
	    location = start;

	    for (var t = this.throttledStep(dt, location); t < 1; t += this.throttledStep(dt, location)) {
	      location = new Location(0, 0);
	      Location.interpolateAlongPath(this._pathType, t, start, end, location); //florin: ensure correct longitude sign and decimal error for anti-meridian

	      if (start.longitude === 180 && end.longitude === 180) {
	        location.longitude = 180;
	      } else if (start.longitude === -180 && end.longitude === -180) {
	        location.longitude = -180;
	      }

	      locations.push(location);
	    }
	  }
	}; // Internal function. Intentionally not documented.
	// Return a throttled step size when near the poles.


	SurfaceShape.prototype.throttledStep = function (dt, location) {
	  var cosLat = Math.cos(location.latitude * Angle.DEGREES_TO_RADIANS);
	  cosLat *= cosLat; // Square cos to emphasize poles and de-emphasize equator.
	  // Remap polarThrottle:
	  //  0 .. INF => 0 .. 1
	  // This acts as a weight between no throttle and fill throttle.

	  var weight = this._polarThrottle / (1 + this._polarThrottle);
	  return dt * (1 - weight + weight * cosLat);
	}; // Internal function. Intentionally not documented.


	SurfaceShape.prototype.prepareBoundaries = function (dc) {
	  if (this.boundariesArePrepared) {
	    return;
	  }

	  this.computeBoundaries(dc);
	  var newBoundaries = this.formatBoundaries();
	  this.normalizeAngles(newBoundaries);
	  newBoundaries = this.interpolateBoundaries(newBoundaries);
	  var contoursInfo = [];
	  var doesCross = PolygonSplitter.splitContours(newBoundaries, contoursInfo);
	  this.contours = contoursInfo;
	  this.crossesAntiMeridian = doesCross;
	  this.prepareGeometry(dc, contoursInfo);
	  this.prepareSectors();
	  this.boundariesArePrepared = true;
	}; //Internal. Formats the boundaries of a surface shape to be a multi dimensional array


	SurfaceShape.prototype.formatBoundaries = function () {
	  var boundaries = [];

	  if (!this._boundaries.length) {
	    return boundaries;
	  }

	  if (this._boundaries[0].latitude != null) {
	    //not multi dim array
	    boundaries.push(this._boundaries);
	  } else {
	    boundaries = this._boundaries;
	  }

	  return boundaries;
	}; // Internal. Resets boundaries for SurfaceShape recomputing.


	SurfaceShape.prototype.resetBoundaries = function () {
	  this.boundariesArePrepared = false;
	  this.shapeDataCache.clear(false);
	}; // Internal use only. Intentionally not documented.


	SurfaceShape.prototype.normalizeAngles = function (boundaries) {
	  for (var i = 0, len = boundaries.length; i < len; i++) {
	    var polygon = boundaries[i];

	    for (var j = 0, lenP = polygon.length; j < lenP; j++) {
	      var point = polygon[j];

	      if (point.longitude < -180 || point.longitude > 180) {
	        point.longitude = Angle.normalizedDegreesLongitude(point.longitude);
	      }

	      if (point.latitude < -90 || point.latitude > 90) {
	        point.latitude = Angle.normalizedDegreesLatitude(point.latitude);
	      }
	    }
	  }
	}; // Internal use only. Intentionally not documented.


	SurfaceShape.prototype.interpolateBoundaries = function (boundaries) {
	  var newBoundaries = [];

	  for (var i = 0, len = boundaries.length; i < len; i++) {
	    var contour = boundaries[i];
	    this.interpolateLocations(contour);
	    newBoundaries.push(this._locations.slice());
	    this._locations.length = 0;
	  }

	  return newBoundaries;
	};
	/**
	 * Computes the bounding sectors for the shape. There will be more than one if the shape crosses the date line,
	 * but does not enclose a pole.
	 *
	 * @param {DrawContext} dc The drawing context containing a globe.
	 *
	 * @return {Sector[]}  Bounding sectors for the shape.
	 */


	SurfaceShape.prototype.computeSectors = function (dc) {
	  // Return a previously computed value if it already exists.
	  if (this._boundingSectors && this._boundingSectors.length > 0) {
	    return this._boundingSectors;
	  }

	  this.prepareBoundaries(dc);
	  return this._boundingSectors;
	};
	/**
	 * Computes the extent for the shape based on its sectors.
	 *
	 * @param {DrawContext} dc The drawing context containing a globe.
	 *
	 * @return {BoundingBox} The extent for the shape.
	 */


	SurfaceShape.prototype.computeExtent = function (dc) {
	  if (!this._boundingSectors || this._boundingSectors.length === 0) {
	    return null;
	  }

	  if (!this.currentData) {
	    return null;
	  }

	  if (!this.currentData.extent) {
	    this.currentData.extent = new BoundingBox();
	  }

	  var boxPoints; // This surface shape does not cross the international dateline, and therefore has a single bounding sector.
	  // Return the box which contains that sector.

	  if (this._boundingSectors.length === 1) {
	    boxPoints = this._boundingSectors[0].computeBoundingPoints(dc.globe, dc.verticalExaggeration);
	    this.currentData.extent.setToVec3Points(boxPoints);
	  } // This surface crosses the international dateline, and its bounding sectors are split along the dateline.
	  // Return a box which contains the corners of the boxes bounding each sector.
	  else {
	      var boxCorners = [];

	      for (var i = 0; i < this._boundingSectors.length; i++) {
	        boxPoints = this._boundingSectors[i].computeBoundingPoints(dc.globe, dc.verticalExaggeration);
	        var box = new BoundingBox();
	        box.setToVec3Points(boxPoints);
	        var corners = box.getCorners();

	        for (var j = 0; j < corners.length; j++) {
	          boxCorners.push(corners[j]);
	        }
	      }

	      this.currentData.extent.setToVec3Points(boxCorners);
	    }

	  return this.currentData.extent;
	};
	/**
	 * Computes a new set of locations translated from a specified location to a new location for a shape.
	 *
	 * @param {Globe} globe The globe on which to compute a new set of locations.
	 * @param {Location} oldLocation The original reference location.
	 * @param {Location} newLocation The new reference location.
	 * @param {Location[]} locations The locations to translate.
	 *
	 * @return {Location[]} The translated locations.
	 */


	SurfaceShape.prototype.computeShiftedLocations = function (globe, oldLocation, newLocation, locations) {
	  var newLocations = [];
	  var result = new Vec3$1(0, 0, 0);
	  var newPos = new WorldWind.Position(0, 0, 0);
	  var oldPoint = globe.computePointFromLocation(oldLocation.latitude, oldLocation.longitude, new Vec3$1(0, 0, 0));
	  var newPoint = globe.computePointFromLocation(newLocation.latitude, newLocation.longitude, new Vec3$1(0, 0, 0));
	  var delta = newPoint.subtract(oldPoint);

	  for (var i = 0, len = locations.length; i < len; i++) {
	    globe.computePointFromLocation(locations[i].latitude, locations[i].longitude, result);
	    result.add(delta);
	    globe.computePositionFromPoint(result[0], result[1], result[2], newPos);
	    newLocations.push(new Location(newPos.latitude, newPos.longitude));
	  }

	  return newLocations;
	}; // Internal use only. Intentionally not documented.


	SurfaceShape.prototype.prepareSectors = function () {
	  this.determineSectors();

	  if (this.crossesAntiMeridian) {
	    this.sectorsOverAntiMeridian();
	  } else {
	    this.sectorsNotOverAntiMeridian();
	  }
	}; // Internal use only. Intentionally not documented.


	SurfaceShape.prototype.determineSectors = function () {
	  for (var i = 0, len = this.contours.length; i < len; i++) {
	    var contour = this.contours[i];
	    var polygons = contour.polygons;
	    contour.sectors = [];

	    for (var j = 0, lenP = polygons.length; j < lenP; j++) {
	      var polygon = polygons[j];
	      var sector = new Sector(0, 0, 0, 0);
	      sector.setToBoundingSector(polygon);

	      if (this._pathType === WorldWind.GREAT_CIRCLE) {
	        var extremes = Location.greatCircleArcExtremeLocations(polygon);
	        var minLatitude = Math.min(sector.minLatitude, extremes[0].latitude);
	        var maxLatitude = Math.max(sector.maxLatitude, extremes[1].latitude);
	        sector.minLatitude = minLatitude;
	        sector.maxLatitude = maxLatitude;
	      }

	      contour.sectors.push(sector);
	    }
	  }
	}; // Internal use only. Intentionally not documented.


	SurfaceShape.prototype.sectorsOverAntiMeridian = function () {
	  var eastSector = new Sector(90, -90, 180, -180); //positive

	  var westSector = new Sector(90, -90, 180, -180); //negative

	  for (var i = 0, len = this.contours.length; i < len; i++) {
	    var sectors = this.contours[i].sectors;

	    for (var j = 0, lenS = sectors.length; j < lenS; j++) {
	      var sector = sectors[j];

	      if (sector.minLongitude < 0 && sector.maxLongitude > 0) {
	        westSector.union(sector);
	        eastSector.union(sector);
	      } else if (sector.minLongitude < 0) {
	        westSector.union(sector);
	      } else {
	        eastSector.union(sector);
	      }
	    }
	  }

	  var minLatitude = Math.min(eastSector.minLatitude, westSector.minLatitude);
	  var maxLatitude = Math.max(eastSector.maxLatitude, eastSector.maxLatitude);
	  this._boundingSector = new Sector(minLatitude, maxLatitude, -180, 180);
	  this._boundingSectors = [eastSector, westSector];
	}; // Internal use only. Intentionally not documented.


	SurfaceShape.prototype.sectorsNotOverAntiMeridian = function () {
	  this._boundingSector = new Sector(90, -90, 180, -180);

	  for (var i = 0, len = this.contours.length; i < len; i++) {
	    var sectors = this.contours[i].sectors;

	    for (var j = 0, lenS = sectors.length; j < lenS; j++) {
	      this._boundingSector.union(sectors[j]);
	    }
	  }

	  this._boundingSectors = [this._boundingSector];
	}; // Internal use only. Intentionally not documented.


	SurfaceShape.prototype.prepareGeometry = function (dc, contours) {
	  var interiorPolygons = [];
	  var outlinePolygons = [];

	  for (var i = 0, len = contours.length; i < len; i++) {
	    var contour = contours[i];
	    var poleIndex = contour.poleIndex;

	    for (var j = 0, lenC = contour.polygons.length; j < lenC; j++) {
	      var polygon = contour.polygons[j];
	      var iMap = contour.iMap[j];
	      interiorPolygons.push(polygon);

	      if (contour.pole !== Location.poles.NONE && lenC > 1) {
	        //split with pole
	        if (j === poleIndex) {
	          this.outlineForPole(polygon, iMap, outlinePolygons);
	        } else {
	          this.outlineForSplit(polygon, iMap, outlinePolygons);
	        }
	      } else if (contour.pole !== Location.poles.NONE && lenC === 1) {
	        //only pole
	        this.outlineForPole(polygon, iMap, outlinePolygons);
	      } else if (contour.pole === Location.poles.NONE && lenC > 1) {
	        //only split
	        this.outlineForSplit(polygon, iMap, outlinePolygons);
	      } else if (contour.pole === Location.poles.NONE && lenC === 1) {
	        //no pole, no split
	        outlinePolygons.push(polygon);
	      }
	    }
	  }

	  this._interiorGeometry = interiorPolygons;
	  this._outlineGeometry = outlinePolygons;
	}; // Internal use only. Intentionally not documented.


	SurfaceShape.prototype.outlineForPole = function (polygon, iMap, outlinePolygons) {
	  this.containsPole = true;
	  var outlinePolygon = [];
	  var pCount = 0;

	  for (var k = 0, lenP = polygon.length; k < lenP; k++) {
	    var point = polygon[k];
	    var intersection = iMap.get(k);

	    if (intersection && intersection.forPole) {
	      pCount++;

	      if (pCount % 2 === 1) {
	        outlinePolygon.push(point);
	        outlinePolygons.push(outlinePolygon);
	        outlinePolygon = [];
	      }
	    }

	    if (pCount % 2 === 0) {
	      outlinePolygon.push(point);
	    }
	  }

	  if (outlinePolygon.length) {
	    outlinePolygons.push(outlinePolygon);
	  }
	}; // Internal use only. Intentionally not documented.


	SurfaceShape.prototype.outlineForSplit = function (polygon, iMap, outlinePolygons) {
	  var outlinePolygon = [];
	  var iCount = 0;

	  for (var k = 0, lenP = polygon.length; k < lenP; k++) {
	    var point = polygon[k];
	    var intersection = iMap.get(k);

	    if (intersection && !intersection.forPole) {
	      iCount++;

	      if (iCount % 2 === 0) {
	        outlinePolygon.push(point);
	        outlinePolygons.push(outlinePolygon);
	        outlinePolygon = [];
	      }
	    }

	    if (iCount % 2 === 1) {
	      outlinePolygon.push(point);
	    }
	  }
	}; // Internal use only. Intentionally not documented.


	SurfaceShape.prototype.resetPickColor = function () {
	  this.pickColor = null;
	};
	/**
	 * Internal use only.
	 * Render the shape onto the texture map of the tile.
	 * @param {DrawContext} dc The draw context to render onto.
	 * @param {CanvasRenderingContext2D} ctx2D The rendering context for SVG.
	 * @param {Number} xScale The multiplicative scale factor in the horizontal direction.
	 * @param {Number} yScale The multiplicative scale factor in the vertical direction.
	 * @param {Number} dx The additive offset in the horizontal direction.
	 * @param {Number} dy The additive offset in the vertical direction.
	 */


	SurfaceShape.prototype.renderToTexture = function (dc, ctx2D, xScale, yScale, dx, dy) {
	  var attributes = this._highlighted ? this._highlightAttributes || this._attributes : this._attributes;

	  if (!attributes) {
	    return;
	  }

	  var drawInterior = !this._isInteriorInhibited && attributes.drawInterior;
	  var drawOutline = attributes.drawOutline && attributes.outlineWidth > 0;

	  if (!drawInterior && !drawOutline) {
	    return;
	  }

	  if (dc.pickingMode) {
	    if (!this.pickColor) {
	      this.pickColor = dc.uniquePickColor();
	    }

	    ctx2D.fillStyle = this.pickColor.toCssColorString();
	    ctx2D.strokeStyle = ctx2D.fillStyle;
	    ctx2D.lineWidth = attributes.outlineWidth;
	  } else {
	    var ic = attributes.interiorColor,
	        oc = attributes.outlineColor;
	    ctx2D.fillStyle = new Color(ic.red, ic.green, ic.blue, ic.alpha * this.layer.opacity).toCssColorString();
	    ctx2D.strokeStyle = new Color(oc.red, oc.green, oc.blue, oc.alpha * this.layer.opacity).toCssColorString();
	    ctx2D.lineWidth = attributes.outlineWidth;
	  }

	  if (this.crossesAntiMeridian || this.containsPole) {
	    if (drawInterior) {
	      this.draw(this._interiorGeometry, ctx2D, xScale, yScale, dx, dy);
	      ctx2D.fill();
	    }

	    if (drawOutline) {
	      this.draw(this._outlineGeometry, ctx2D, xScale, yScale, dx, dy);
	      ctx2D.stroke();
	    }
	  } else {
	    this.draw(this._interiorGeometry, ctx2D, xScale, yScale, dx, dy);

	    if (drawInterior) {
	      ctx2D.fill();
	    }

	    if (drawOutline) {
	      ctx2D.stroke();
	    }
	  }

	  if (dc.pickingMode) {
	    var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this, null, this.layer, false);
	    dc.resolvePick(po);
	  }
	};

	SurfaceShape.prototype.draw = function (contours, ctx2D, xScale, yScale, dx, dy) {
	  ctx2D.beginPath();

	  for (var i = 0, len = contours.length; i < len; i++) {
	    var contour = contours[i];
	    var point = contour[0];
	    var x = point.longitude * xScale + dx;
	    var y = point.latitude * yScale + dy;
	    ctx2D.moveTo(x, y);

	    for (var j = 1, lenC = contour.length; j < lenC; j++) {
	      point = contour[j];
	      x = point.longitude * xScale + dx;
	      y = point.latitude * yScale + dy;
	      ctx2D.lineTo(x, y);
	    }
	  }
	};
	/**
	 * Default value for the maximum number of edge intervals. This results in a maximum error of 480 m for an arc
	 * that spans the entire globe.
	 *
	 * Other values for this parameter have the associated errors below:
	 * Intervals        Maximum error (meters)
	 *      2           1280253.5
	 *      4           448124.5
	 *      8           120837.6
	 *      16          30628.3
	 *      32          7677.9
	 *      64          1920.6
	 *      128         480.2
	 *      256         120.0
	 *      512         30.0
	 *      1024        7.5
	 *      2048        1.8
	 * The errors cited above are upper bounds and the actual error may be lower.
	 * @type {Number}
	 */


	SurfaceShape.DEFAULT_NUM_EDGE_INTERVALS = 128;
	/**
	 * The defualt value for the polar throttle, which slows edge traversal near the poles.
	 * @type {Number}
	 */

	SurfaceShape.DEFAULT_POLAR_THROTTLE = 10;

	/**
	 * @exports SurfaceShapeTile
	 */
	/**
	 * Constructs a surface shape tile.
	 * @alias SurfaceShapeTile
	 * @constructor
	 * @classdesc Represents a texture map containing renditions of surface shapes applied to a portion of a globe's terrain.
	 * @param {Sector} sector The sector this tile covers.
	 * @param {Level} level The level this tile is associated with.
	 * @param {number} row This tile's row in the associated level.
	 * @param {number} column This tile's column in the associated level.
	 * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
	 * are less than zero, or the specified image path is null, undefined or empty.
	 *
	 */

	function SurfaceShapeTile(sector, level, row, column) {
	  TextureTile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

	  /**
	   * The surface shapes that affect this tile.
	   * @type {SurfaceShape[]}
	   */

	  this.surfaceShapes = []; // Internal use only. Intentionally not documented.

	  this.surfaceShapeStateKeys = []; // Internal use only. Intentionally not documented.

	  this.asRenderedSurfaceShapeStateKeys = [];
	  /**
	   * The sector that bounds this tile.
	   * @type {Sector}
	   */

	  this.sector = sector;
	  /**
	   * A string to use as a cache key.
	   * @type {string}
	   */

	  this.cacheKey = null; // Internal use only. Intentionally not documented.

	  this.pickSequence = 0;
	  this.createCtx2D();
	}

	SurfaceShapeTile.prototype = Object.create(TextureTile.prototype);
	/**
	 * Clear all collected surface shapes.
	 */

	SurfaceShapeTile.prototype.clearShapes = function () {
	  // Clear out next surface shape.
	  this.surfaceShapes = [];
	  this.surfaceShapeStateKeys = [];
	};
	/**
	 * Query whether any surface shapes have been collected.
	 * @returns {boolean} Returns true if there are collected surface shapes.
	 */


	SurfaceShapeTile.prototype.hasShapes = function () {
	  return this.surfaceShapes.length > 0;
	};
	/**
	 * Get all shapes that this tile references.
	 * @returns {SurfaceShape[]} The collection of surface shapes referenced by this tile.
	 */


	SurfaceShapeTile.prototype.getShapes = function () {
	  return this.surfaceShapes;
	};
	/**
	 * Set the shapes this tile should reference.
	 * @param {SurfaceShape[]} surfaceShapes The collection of surface shapes to be referenced by this tile.
	 */


	SurfaceShapeTile.prototype.setShapes = function (surfaceShapes) {
	  this.surfaceShapes = surfaceShapes;
	};
	/**
	 * The sector that bounds this tile.
	 * @returns {Sector}
	 */


	SurfaceShapeTile.prototype.getSector = function () {
	  return this.sector;
	};
	/**
	 * Add a surface shape to this tile's collection of surface shapes.
	 * @param {SurfaceShape} surfaceShape The surface shape to add.
	 */


	SurfaceShapeTile.prototype.addSurfaceShape = function (surfaceShape) {
	  this.surfaceShapes.push(surfaceShape);
	  this.surfaceShapeStateKeys.push(surfaceShape.stateKey + " lo " + surfaceShape.layer.opacity); // combine the shape state key with layer opacity
	}; // Internal use only. Intentionally not documented.


	SurfaceShapeTile.prototype.needsUpdate = function (dc) {
	  var idx, len; // If the number of surface shapes does not match the number of surface shapes already in the texture

	  if (this.surfaceShapes.length != this.asRenderedSurfaceShapeStateKeys.length) {
	    return true;
	  } // If the state key of the shape is different from the saved state key (in order or configuration)


	  for (idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {
	    if (this.surfaceShapeStateKeys[idx] !== this.asRenderedSurfaceShapeStateKeys[idx]) {
	      return true;
	    }
	  } // If a texture does not already exist, ...


	  if (!this.hasTexture(dc)) {
	    return true;
	  } // If you get here, the texture can be reused.


	  return false;
	};
	/**
	 * Determine whether the surface shape tile has a valid texture.
	 * @param {DrawContext} dc The draw context.
	 * @returns {boolean} True if the surface shape tile has a valid texture, else false.
	 */


	SurfaceShapeTile.prototype.hasTexture = function (dc) {
	  if (dc.pickingMode) {
	    return false;
	  }

	  if (!this.gpuCacheKey) {
	    this.gpuCacheKey = this.getCacheKey();
	  }

	  return dc.gpuResourceCache.containsResource(this.gpuCacheKey);
	};
	/**
	 * Redraw all of the surface shapes onto the texture for this tile.
	 * @param {DrawContext} dc
	 * @returns {Texture}
	 */


	SurfaceShapeTile.prototype.updateTexture = function (dc) {
	  var gl = dc.currentGlContext,
	      canvas = SurfaceShapeTile.canvas,
	      ctx2D = SurfaceShapeTile.ctx2D;
	  canvas.width = this.tileWidth;
	  canvas.height = this.tileHeight; // Mapping from lat/lon to x/y:
	  //  lon = minlon => x = 0
	  //  lon = maxLon => x = 256
	  //  lat = minLat => y = 256
	  //  lat = maxLat => y = 0
	  //  (assuming texture size is 256)
	  // So:
	  //  x = 256 / sector.dlon * (lon - minLon)
	  //  y = -256 / sector.dlat * (lat - maxLat)

	  var xScale = this.tileWidth / this.sector.deltaLongitude(),
	      yScale = -this.tileHeight / this.sector.deltaLatitude(),
	      xOffset = -this.sector.minLongitude * xScale,
	      yOffset = -this.sector.maxLatitude * yScale; // Reset the surface shape state keys

	  this.asRenderedSurfaceShapeStateKeys = [];

	  for (var idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {
	    var shape = this.surfaceShapes[idx];
	    this.asRenderedSurfaceShapeStateKeys.push(this.surfaceShapeStateKeys[idx]);
	    shape.renderToTexture(dc, ctx2D, xScale, yScale, xOffset, yOffset);
	  }

	  this.gpuCacheKey = this.getCacheKey();
	  var gpuResourceCache = dc.gpuResourceCache;
	  var texture = new Texture$1(gl, canvas);
	  gpuResourceCache.putResource(this.gpuCacheKey, texture, texture.size);
	  gpuResourceCache.setResourceAgingFactor(this.gpuCacheKey, 10); // age this texture 10x faster than normal resources (e.g., tiles)

	  return texture;
	};
	/**
	 * Get a key suitable for cache look-ups.
	 * @returns {string}
	 */


	SurfaceShapeTile.prototype.getCacheKey = function () {
	  if (!this.cacheKey) {
	    this.cacheKey = "SurfaceShapeTile:" + this.tileKey + "," + this.pickSequence.toString();
	  }

	  return this.cacheKey;
	};
	/**
	 * Create a new canvas and its 2D context on demand.
	 */


	SurfaceShapeTile.prototype.createCtx2D = function () {
	  // If the context was previously created, ...
	  if (!SurfaceShapeTile.ctx2D) {
	    SurfaceShapeTile.canvas = document.createElement("canvas");
	    SurfaceShapeTile.ctx2D = SurfaceShapeTile.canvas.getContext("2d");
	  }
	};
	/*
	 * For internal use only.
	 * 2D canvas and context, which is created lazily on demand.
	 */


	SurfaceShapeTile.canvas = null;
	SurfaceShapeTile.ctx2D = null;

	/**
	 * @exports SurfaceShapeTileBuilder
	 */

	function SurfaceShapeTileBuilder() {
	  // Parameterize top level subdivision in one place.
	  // TilesInTopLevel describes the most coarse tile structure.
	  this.numRowsTilesInTopLevel = 4;
	  this.numColumnsTilesInTopLevel = 8; // The maximum number of levels that will ever be tessellated.

	  this.maximumSubdivisionDepth = 15; // tileWidth, tileHeight - the number of subdivisions a single tile has; this determines the sampling grid.

	  this.tileWidth = 256;
	  this.tileHeight = 256;
	  /**
	   * The collection of levels.
	   * @type {LevelSet}
	   */

	  this.levels = new LevelSet(Sector.FULL_SPHERE, new Location(180 / this.numRowsTilesInTopLevel, 360 / this.numColumnsTilesInTopLevel), this.maximumSubdivisionDepth, this.tileWidth, this.tileHeight);
	  /**
	   * The collection of surface shapes processed by this class.
	   * @type {SurfaceShape[]}
	   */

	  this.surfaceShapes = [];
	  /**
	   * The collection of surface shape tiles that actually contain surface shapes.
	   * @type {SurfaceShapeTile[]}
	   */

	  this.surfaceShapeTiles = [];
	  /**
	   * The collection of top level surface shape tiles, from which actual tiles are derived.
	   * @type {SurfaceShapeTile[]}
	   */

	  this.topLevelTiles = [];
	  /**
	   * Accumulator of all sectors for surface shapes
	   * @type {Sector}
	   */

	  this.sector = new Sector(-90, 90, -180, 180);
	  /**
	   * The default split scale. The split scale 2.9 has been empirically determined to render sharp lines and edges with
	   * the SurfaceShapes such as SurfacePolyline and SurfacePolygon.
	   *
	   * @type {Number}
	   */

	  this.detailControl = 1.25; // Internal use only. Intentionally not documented.

	  this.tileCache = new MemoryCache(500000, 400000);
	}
	/**
	 * Clear all transient state from the surface shape tile builder.
	 */


	SurfaceShapeTileBuilder.prototype.clear = function () {
	  this.surfaceShapeTiles.splice(0, this.surfaceShapeTiles.length);
	  this.surfaceShapes.splice(0, this.surfaceShapes.length);
	};
	/**
	 * Insert a surface shape to be rendered into the surface shape tile builder.
	 *
	 * @param {SurfaceShape} surfaceShape A surfave shape to be processed.
	 */


	SurfaceShapeTileBuilder.prototype.insertSurfaceShape = function (surfaceShape) {
	  this.surfaceShapes.push(surfaceShape);
	};
	/**
	 * Perform the rendering of any accumulated surface shapes by building the surface shape tiles that contain these
	 * shapes and then rendering those tiles.
	 *
	 * @param {DrawContext} dc The drawing context.
	 */


	SurfaceShapeTileBuilder.prototype.doRender = function (dc) {
	  if (dc.pickingMode) {
	    // Picking rendering strategy:
	    //  1) save all tiles created prior to picking,
	    //  2) construct and render new tiles with pick-based contents (colored with pick IDs),
	    //  3) restore all prior tiles.
	    // This has a big potential win for normal rendering, since there is a lot of coherence
	    // from frame to frame if no picking is occurring.
	    for (var idx = 0, len = this.surfaceShapes.length; idx < len; idx += 1) {
	      this.surfaceShapes[idx].resetPickColor();
	    }

	    SurfaceShapeTileBuilder.pickSequence += 1;
	    var savedTiles = this.surfaceShapeTiles;
	    var savedTopLevelTiles = this.topLevelTiles;
	    this.surfaceShapeTiles = [];
	    this.topLevelTiles = [];
	    this.buildTiles(dc);

	    if (dc.deepPicking) {
	      // Normally, we render all shapes together in one tile (or a small number, but this detail
	      // doesn't matter). For deep picking, we need to render each shape individually.
	      this.doDeepPickingRender(dc);
	    } else {
	      dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);
	    }

	    this.surfaceShapeTiles = savedTiles;
	    this.topLevelTiles = savedTopLevelTiles;
	  } else {
	    this.buildTiles(dc);
	    dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);
	  }
	};

	SurfaceShapeTileBuilder.prototype.doDeepPickingRender = function (dc) {
	  var idxTile, lenTiles, idxShape, lenShapes, idxPick, lenPicks, po, shape, tile; // Determine the shapes that were drawn during buildTiles. These shapes may not actually be
	  // at the pick point, but they are candidates for deep picking.

	  var deepPickShapes = [];

	  for (idxPick = 0, lenPicks = dc.objectsAtPickPoint.objects.length; idxPick < lenPicks; idxPick += 1) {
	    po = dc.objectsAtPickPoint.objects[idxPick];

	    if (po.userObject instanceof SurfaceShape) {
	      shape = po.userObject; // If the shape was not already in the collection of deep picked shapes, ...

	      if (deepPickShapes.indexOf(shape) < 0) {
	        deepPickShapes.push(shape); // Delete the shape that was drawn during buildTiles from the pick list.

	        dc.objectsAtPickPoint.objects.splice(idxPick, 1); // Update the index and length to reflect the deletion.

	        idxPick -= 1;
	        lenPicks -= 1;
	      }
	    }
	  }

	  if (deepPickShapes.length <= 0) {
	    return;
	  } // For all shapes,
	  //  1) force that shape to be the only shape in a tile,
	  //  2) re-render the tile, and
	  //  3) use the surfaceTileRenderer to render the tile on the terrain,
	  //  4) read the color to see if it is attributable to the current shape.


	  var resolvablePickObjects = [];

	  for (idxShape = 0, lenShapes = deepPickShapes.length; idxShape < lenShapes; idxShape += 1) {
	    shape = deepPickShapes[idxShape];

	    for (idxTile = 0, lenTiles = this.surfaceShapeTiles.length; idxTile < lenTiles; idxTile += 1) {
	      tile = this.surfaceShapeTiles[idxTile];
	      tile.setShapes([shape]);
	      tile.updateTexture(dc);
	    }

	    dc.surfaceTileRenderer.renderTiles(dc, this.surfaceShapeTiles, 1);
	    var pickColor = dc.readPickColor(dc.pickPoint);

	    if (!!pickColor && shape.pickColor.equals(pickColor)) {
	      po = new PickedObject(shape.pickColor.clone(), shape.pickDelegate ? shape.pickDelegate : shape, null, shape.layer, false);
	      resolvablePickObjects.push(po);
	    }
	  } // Flush surface shapes that have accumulated in the updateTexture pass just completed on all shapes.


	  for (idxPick = 0, lenPicks = dc.objectsAtPickPoint.objects.length; idxPick < lenPicks; idxPick += 1) {
	    po = dc.objectsAtPickPoint.objects[idxPick];

	    if (po.userObject instanceof SurfaceShape) {
	      // Delete the shape that was picked in the most recent pass.
	      dc.objectsAtPickPoint.objects.splice(idxPick, 1); // Update the index and length to reflect the deletion.

	      idxPick -= 1;
	      lenPicks -= 1;
	    }
	  } // Add the resolvable pick objects for surface shapes that were actually visible at the pick point
	  // to the pick list.


	  for (idxPick = 0, lenPicks = resolvablePickObjects.length; idxPick < lenPicks; idxPick += 1) {
	    po = resolvablePickObjects[idxPick];
	    dc.objectsAtPickPoint.objects.push(po);
	  }
	};
	/**
	 * Assembles the surface tiles and draws any surface shapes that have been accumulated into those offscreen tiles. The
	 * surface tiles are assembled to meet the necessary resolution of to the draw context's.
	 * <p/>
	 * This does nothing if there are no surface shapes associated with this builder.
	 *
	 * @param {DrawContext} dc The draw context to build tiles for.
	 *
	 * @throws {ArgumentError} If the draw context is null.
	 */


	SurfaceShapeTileBuilder.prototype.buildTiles = function (dc) {
	  if (!dc) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceShapeTileBuilder", "buildTiles", "missingDc"));
	  }

	  if (!this.surfaceShapes || this.surfaceShapes.length < 1) {
	    return;
	  } // Assemble the current visible tiles and update their associated textures if necessary.


	  this.assembleTiles(dc); // Clean up references to all surface shapes to avoid dangling references. The surface shape list is no
	  // longer needed, now that the shapes are held by each tile.

	  this.surfaceShapes.splice(0, this.surfaceShapes.length);

	  for (var idx = 0, len = this.surfaceShapeTiles.length; idx < len; idx += 1) {
	    var tile = this.surfaceShapeTiles[idx];
	    tile.clearShapes();
	  }
	};
	/**
	 * Assembles a set of surface tiles that are visible in the specified DrawContext and meet the tile builder's
	 * resolution criteria. Tiles are culled against the current surface shape list, against the DrawContext's view
	 * frustum during rendering mode, and against the DrawContext's pick frustums during picking mode. If a tile does
	 * not meet the tile builder's resolution criteria, it's split into four sub-tiles and the process recursively
	 * repeated on the sub-tiles.
	 * <p/>
	 * During assembly, each surface shape in {@link #surfaceShapes} is sorted into the tiles they
	 * intersect. The top level tiles are used as an index to quickly determine which tiles each shape intersects.
	 * Surface shapes are sorted into sub-tiles by simple intersection tests, and are added to each tile's surface
	 * renderable list at most once. See {@link SurfaceShapeTileBuilder.SurfaceShapeTile#addSurfaceShape(SurfaceShape,
	 * gov.nasa.worldwind.geom.Sector)}. Tiles that don't intersect any surface shapes are discarded.
	 *
	 * @param {DrawContext} dc The DrawContext to assemble tiles for.
	 */


	SurfaceShapeTileBuilder.prototype.assembleTiles = function (dc) {
	  var tile, idxShape, lenShapes, idxTile, lenTiles, idxSector, lenSectors; // Create a set of top level tiles only if that set doesn't exist yet.

	  if (this.topLevelTiles.length < 1) {
	    this.createTopLevelTiles();
	  } // Store the top level tiles in a set to ensure that each top level tile is added only once. Store the tiles
	  // that intersect each surface shape in a set to ensure that each object is added to a tile at most once.


	  var intersectingTiles = {}; // Iterate over the current surface shapes, adding each surface shape to the top level tiles that it
	  // intersects. This produces a set of top level tiles containing the surface shapes that intersect each
	  // tile. We use the tile structure as an index to quickly determine the tiles a surface shape intersects,
	  // and add object to those tiles. This has the effect of quickly sorting the objects into the top level tiles.
	  // We collect the top level tiles in a HashSet to ensure there are no duplicates when multiple objects intersect
	  // the same top level tiles.

	  for (idxShape = 0, lenShapes = this.surfaceShapes.length; idxShape < lenShapes; idxShape += 1) {
	    var surfaceShape = this.surfaceShapes[idxShape];
	    var sectors = surfaceShape.computeSectors(dc);

	    if (!sectors) {
	      continue;
	    }

	    for (idxSector = 0, lenSectors = sectors.length; idxSector < lenSectors; idxSector += 1) {
	      var sector = sectors[idxSector];

	      for (idxTile = 0, lenTiles = this.topLevelTiles.length; idxTile < lenTiles; idxTile += 1) {
	        tile = this.topLevelTiles[idxTile];

	        if (tile.sector.intersects(sector)) {
	          var cacheKey = tile.tileKey;
	          intersectingTiles[cacheKey] = tile;
	          tile.addSurfaceShape(surfaceShape);
	        }
	      }
	    }
	  } // Add each top level tile or its descendants to the current tile list.
	  //for (var idxTile = 0, lenTiles = this.topLevelTiles.length; idxTile < lenTiles; idxTile += 1) {


	  for (var key in intersectingTiles) {
	    if (intersectingTiles.hasOwnProperty(key)) {
	      tile = intersectingTiles[key];
	      this.addTileOrDescendants(dc, this.levels, null, tile);
	    }
	  }
	};
	/**
	 * Potentially adds the specified tile or its descendants to the tile builder's surface shape tile collection.
	 * The tile and its descendants are discarded if the tile is not visible or does not intersect any surface shapes in the
	 * parent's surface shape list.
	 * <p/>
	 * If the tile meet the tile builder's resolution criteria it's added to the tile builder's
	 * <code>currentTiles</code> list. Otherwise, it's split into four sub-tiles and each tile is recursively processed.
	 *
	 * @param {DrawContext} dc              The current DrawContext.
	 * @param {LevelSet} levels             The tile's LevelSet.
	 * @param {SurfaceShapeTile} parentTile The tile's parent, or null if the tile is a top level tile.
	 * @param {SurfaceShapeTile} tile       The tile to add.
	 */


	SurfaceShapeTileBuilder.prototype.addTileOrDescendants = function (dc, levels, parentTile, tile) {
	  // Ignore this tile if it falls completely outside the frustum. This may be the viewing frustum or the pick
	  // frustum, depending on the implementation.
	  if (!this.intersectsFrustum(dc, tile)) {
	    // This tile is not added to the current tile list, so we clear it's object list to prepare it for use
	    // during the next frame.
	    tile.clearShapes();
	    return;
	  } // If the parent tile is not null, add any parent surface shapes that intersect this tile.


	  if (parentTile != null) {
	    this.addIntersectingShapes(dc, parentTile, tile);
	  } // Ignore tiles that do not intersect any surface shapes.


	  if (!tile.hasShapes()) {
	    return;
	  } // If this tile meets the current rendering criteria, add it to the current tile list. This tile's object list
	  // is cleared after the tile update operation.


	  if (this.meetsRenderCriteria(dc, levels, tile)) {
	    this.addTile(dc, tile);
	    return;
	  }

	  var nextLevel = levels.level(tile.level.levelNumber + 1);
	  var subTiles = dc.pickingMode ? tile.subdivide(nextLevel, this) : tile.subdivideToCache(nextLevel, this, this.tileCache);

	  for (var idxTile = 0, lenTiles = subTiles.length; idxTile < lenTiles; idxTile += 1) {
	    var subTile = subTiles[idxTile];
	    this.addTileOrDescendants(dc, levels, tile, subTile);
	  } // This tile is not added to the current tile list, so we clear it's object list to prepare it for use during
	  // the next frame.


	  tile.clearShapes();
	};
	/**
	 * Adds surface shapes from the parent's object list to the specified tile's object list. Adds any of the
	 * parent's surface shapes that intersect the tile's sector to the tile's object list.
	 *
	 * @param {DrawContext} dc              The current DrawContext.
	 * @param {SurfaceShapeTile} parentTile The tile's parent.
	 * @param {SurfaceShapeTile} tile       The tile to add intersecting surface shapes to.
	 */


	SurfaceShapeTileBuilder.prototype.addIntersectingShapes = function (dc, parentTile, tile) {
	  var shapes = parentTile.getShapes();

	  for (var idxShape = 0, lenShapes = shapes.length; idxShape < lenShapes; idxShape += 1) {
	    var shape = shapes[idxShape];
	    var sectors = shape.computeSectors(dc);

	    if (!sectors) {
	      continue;
	    } // Test intersection against each of the surface shape's sectors. We break after finding an
	    // intersection to avoid adding the same object to the tile more than once.


	    for (var idxSector = 0, lenSectors = sectors.length; idxSector < lenSectors; idxSector += 1) {
	      var sector = sectors[idxSector];

	      if (tile.getSector().intersects(sector)) {
	        tile.addSurfaceShape(shape);
	        break;
	      }
	    }
	  }
	};
	/**
	 * Adds the specified tile to this tile builder's surface tile collection.
	 *
	 * @param {DrawContext} dc The draw context.
	 * @param {SurfaceShapeTile} tile The tile to add.
	 */


	SurfaceShapeTileBuilder.prototype.addTile = function (dc, tile) {
	  if (dc.pickingMode) {
	    tile.pickSequence = SurfaceShapeTileBuilder.pickSequence;
	  }

	  if (tile.needsUpdate(dc)) {
	    tile.updateTexture(dc);
	  }

	  this.surfaceShapeTiles.push(tile);
	};
	/**
	 * Internal use only.
	 *
	 * Returns a new SurfaceObjectTile corresponding to the specified {@code sector}, {@code level}, {@code row},
	 * and {@code column}.
	 *
	 * CAUTION: it is assumed that there exists a single SurfaceShapeTileBuilder. This algorithm might be invalid if there
	 * are more of them (or it might actually work, although it hasn't been tested in that context).
	 *
	 * @param {Sector} sector       The tile's Sector.
	 * @param {Level} level         The tile's Level in a {@link LevelSet}.
	 * @param {Number} row          The tile's row in the Level, starting from 0 and increasing to the right.
	 * @param {Number} column       The tile's column in the Level, starting from 0 and increasing upward.
	 *
	 * @return {SurfaceShapeTile} a new SurfaceShapeTile.
	 */


	SurfaceShapeTileBuilder.prototype.createTile = function (sector, level, row, column) {
	  return new SurfaceShapeTile(sector, level, row, column);
	};

	SurfaceShapeTileBuilder.prototype.createTopLevelTiles = function () {
	  Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles);
	};
	/**
	 * Test if the tile intersects the specified draw context's frustum. During picking mode, this tests intersection
	 * against all of the draw context's pick frustums. During rendering mode, this tests intersection against the draw
	 * context's viewing frustum.
	 *
	 * @param {DrawContext} dc   The draw context the surface shape is related to.
	 * @param {SurfaceShapeTile} tile The tile to test for intersection.
	 *
	 * @return {Boolean} true if the tile intersects the draw context's frustum; false otherwise.
	 */


	SurfaceShapeTileBuilder.prototype.intersectsFrustum = function (dc, tile) {
	  if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
	    return false;
	  }

	  tile.update(dc);
	  return tile.extent.intersectsFrustum(dc.pickingMode ? dc.pickFrustum : dc.frustumInModelCoordinates);
	};
	/**
	 * Tests if the specified tile meets the rendering criteria on the specified draw context. This returns true if the
	 * tile is from the level set's final level, or if the tile achieves the desired resolution on the draw context.
	 *
	 * @param {DrawContext} dc          The current draw context.
	 * @param {LevelSet} levels         The level set the tile belongs to.
	 * @param {SurfaceShapeTile} tile   The tile to test.
	 *
	 * @return {Boolean} true if the tile meets the rendering criteria; false otherwise.
	 */


	SurfaceShapeTileBuilder.prototype.meetsRenderCriteria = function (dc, levels, tile) {
	  return tile.level.levelNumber == levels.lastLevel().levelNumber || !tile.mustSubdivide(dc, this.detailControl);
	};
	/**
	 * Internal use only.
	 * Count of pick operations. This is used to give a surface shape tile a unique pick sequence number if it is
	 * participating in picking.
	 * @type {Number}
	 */


	SurfaceShapeTileBuilder.pickSequence = 0;

	var SurfaceTileVertex = "\r\nattribute vec4 vertexPoint;\r\nattribute vec4 vertexTexCoord;\r\n\r\nuniform mat4 mvpMatrix;\r\nuniform mat4 texSamplerMatrix;\r\nuniform mat4 texMaskMatrix;\r\n\r\nvarying vec2 texSamplerCoord;\r\nvarying vec2 texMaskCoord;\r\n\r\nvoid main() {\r\n    gl_Position = mvpMatrix * vertexPoint;\r\n\r\n    texSamplerCoord = (texSamplerMatrix * vertexTexCoord).st;\r\n\r\n    texMaskCoord = (texMaskMatrix * vertexTexCoord).st;\r\n}";

	var SurfaceTileFragment = "\r\nprecision mediump float;\r\n\r\nuniform sampler2D texSampler;\r\nuniform float opacity;\r\nuniform vec4 color;\r\nuniform bool modulateColor;\r\n\r\nvarying vec2 texSamplerCoord;\r\nvarying vec2 texMaskCoord;\r\n\r\n\r\nbool isInsideTextureImage(const vec2 coord) {\r\n    return coord.x >= 0.0 && coord.x <= 1.0 && coord.y >= 0.0 && coord.y <= 1.0;\r\n}\r\n\r\n\r\nvoid main(void) {\r\n    float mask = float(isInsideTextureImage(texMaskCoord));\r\n    if (modulateColor) {\r\n        gl_FragColor = color * mask * floor(texture2D(texSampler, texSamplerCoord).a + 0.5);\r\n    } else {\r\n\r\n        gl_FragColor = texture2D(texSampler, texSamplerCoord) * mask * opacity;\r\n    }\r\n}";

	/**
	 * @exports SurfaceTileRendererProgram
	 */
	/**
	 * Constructs a new surface-tile-renderer program.
	 * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	 * <p>
	 * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program. This
	 * method then compiles the shaders and links the program if compilation is successful. Use the bind method to make the
	 * program current during rendering.
	 *
	 * @alias SurfaceTileRendererProgram
	 * @constructor
	 * @augments GpuProgram
	 * @classdesc A GLSL program that draws textured geometry on the globe's terrain.
	 * Application's typically do not interact with this class.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 */

	function SurfaceTileRendererProgram(gl) {
	  var vertexShaderSource = SurfaceTileVertex,
	      fragmentShaderSource = SurfaceTileFragment; // Call to the superclass, which performs shader program compiling and linking.

	  GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource); // Capture the attribute and uniform locations.

	  /**
	   * This program's vertex point location.
	   * @type {Number}
	   * @readonly
	   */

	  this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");
	  /**
	   * This program's texture coordinate location.
	   * @type {Number}
	   * @readonly
	   */

	  this.vertexTexCoordLocation = this.attributeLocation(gl, "vertexTexCoord");
	  /**
	   * This program's modelview-projection matrix location.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");
	  /**
	   * The WebGL location for this program's 'color' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.colorLocation = this.uniformLocation(gl, "color");
	  /**
	   * The WebGL location for this program's 'modulateColor' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.modulateColorLocation = this.uniformLocation(gl, "modulateColor"); // The rest of these are strictly internal and intentionally not documented.

	  this.texSamplerMatrixLocation = this.uniformLocation(gl, "texSamplerMatrix");
	  this.texMaskMatrixLocation = this.uniformLocation(gl, "texMaskMatrix");
	  this.texSamplerLocation = this.uniformLocation(gl, "texSampler");
	  this.opacityLocation = this.uniformLocation(gl, "opacity");
	  /**
	   * The WebGL location for this program's 'vertexTexCoord' attribute.
	   * @type {Number}
	   * @readonly
	   */

	  this.vertexPointLocation = -1;
	}
	/**
	 * A string that uniquely identifies this program.
	 * @type {string}
	 * @readonly
	 */


	SurfaceTileRendererProgram.key = "WorldWindGpuSurfaceTileRenderingProgram";
	SurfaceTileRendererProgram.prototype = Object.create(GpuProgram.prototype);
	/**
	 * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix} matrix The matrix to load.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */

	SurfaceTileRendererProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadModelviewProjection", "missingMatrix"));
	  }

	  this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	};
	/**
	 * Loads the specified matrix as the value of this program's 'texSamplerMatrix' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix} matrix The matrix to load.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */


	SurfaceTileRendererProgram.prototype.loadTexSamplerMatrix = function (gl, matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadTexSamplerMatrix", "missingMatrix"));
	  }

	  this.loadUniformMatrix(gl, matrix, this.texSamplerMatrixLocation);
	};
	/**
	 * Loads the specified matrix as the value of this program's 'texMaskMatrix' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix} matrix The matrix to load.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */


	SurfaceTileRendererProgram.prototype.loadTexMaskMatrix = function (gl, matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadTexMaskMatrix", "missingMatrix"));
	  }

	  this.loadUniformMatrix(gl, matrix, this.texMaskMatrixLocation);
	};
	/**
	 * Loads the specified texture unit ID as the value of this program's 'texSampler' uniform variable.
	 * The specified unit ID must be one of the GL_TEXTUREi WebGL enumerations, where i ranges from 0 to
	 * GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} unit The unit ID to load.
	 */


	SurfaceTileRendererProgram.prototype.loadTexSampler = function (gl, unit) {
	  gl.uniform1i(this.texSamplerLocation, unit - WebGLRenderingContext.TEXTURE0);
	};
	/**
	 * Loads the specified value as the value of this program's 'opacity' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} opacity The opacity to load.
	 */


	SurfaceTileRendererProgram.prototype.loadOpacity = function (gl, opacity) {
	  gl.uniform1f(this.opacityLocation, opacity);
	};
	/**
	 * Loads the specified color as the value of this program's 'color' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Color} color The color to load.
	 * @throws {ArgumentError} If the specified color is null or undefined.
	 */


	SurfaceTileRendererProgram.prototype.loadColor = function (gl, color) {
	  if (!color) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceTileRendererProgram", "loadColor", "missingColor"));
	  }

	  this.loadUniformColor(gl, color, this.colorLocation);
	};
	/**
	 * Loads the specified boolean as the value of this program's 'modulateColor' uniform variable. When this
	 * value is true the color uniform of this shader is
	 * multiplied by the rounded alpha component of the texture color at each fragment. This causes the color
	 * to be either fully opaque or fully transparent depending on the value of the texture color's alpha value.
	 * This is used during picking to replace opaque or mostly opaque texture colors with the pick color, and
	 * to make all other texture colors transparent.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Boolean} enable <code>true</code> to enable modulation, <code>false</code> to disable modulation.
	 */


	SurfaceTileRendererProgram.prototype.loadModulateColor = function (gl, enable) {
	  gl.uniform1i(this.modulateColorLocation, enable ? 1 : 0);
	};

	/**
	 * @exports SurfaceTileRenderer
	 */
	/**
	 * Constructs a new surface tile renderer.
	 * @alias SurfaceTileRenderer
	 * @constructor
	 * @classdesc This class is responsible for rendering imagery onto the terrain.
	 * It is meant to be used internally. Applications typically do not interact with this class.
	 */

	function SurfaceTileRenderer() {
	  // Scratch values to avoid constantly recreating these matrices.
	  this.texMaskMatrix = Matrix.fromIdentity();
	  this.texSamplerMatrix = Matrix.fromIdentity(); // Internal. Intentionally not documented.

	  this.isSurfaceShapeTileRendering = false;
	}
	/**
	 * Render a specified collection of surface tiles.
	 * @param {DrawContext} dc The current draw context.
	 * @param {SurfaceTile[]} surfaceTiles The surface tiles to render.
	 * @param {Number} opacity The opacity at which to draw the surface tiles.
	 * @param {Boolean} tilesHaveOpacity If true, incoming tiles each have their own opacity property and
	 * it's value is applied when the tile is drawn.
	 * @throws {ArgumentError} If the specified surface tiles array is null or undefined.
	 */


	SurfaceTileRenderer.prototype.renderTiles = function (dc, surfaceTiles, opacity, tilesHaveOpacity) {
	  if (!surfaceTiles) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceTileRenderer", "renderTiles", "Specified surface tiles array is null or undefined."));
	  }

	  if (surfaceTiles.length < 1) return;
	  var terrain = dc.terrain,
	      gl = dc.currentGlContext,
	      tileCount = 0,
	      // for frame statistics,
	  program,
	      terrainTile,
	      terrainTileSector,
	      surfaceTile,
	      currentTileOpacity = 1;
	  if (!terrain) return;
	  this.isSurfaceShapeTileRendering = surfaceTiles[0] instanceof SurfaceShapeTile;
	  opacity *= dc.surfaceOpacity; // For each terrain tile, render it for each overlapping surface tile.

	  program = this.beginRendering(dc, opacity);
	  terrain.beginRendering(dc);

	  try {
	    for (var i = 0, ttLen = terrain.surfaceGeometry.length; i < ttLen; i++) {
	      terrainTile = terrain.surfaceGeometry[i];
	      terrainTileSector = terrainTile.sector;
	      terrain.beginRenderingTile(dc, terrainTile);

	      try {
	        // Render the terrain tile for each overlapping surface tile.
	        for (var j = 0, stLen = surfaceTiles.length; j < stLen; j++) {
	          surfaceTile = surfaceTiles[j];

	          if (surfaceTile.sector.overlaps(terrainTileSector)) {
	            if (surfaceTile.bind(dc)) {
	              if (dc.pickingMode) {
	                if (surfaceTile.pickColor) {
	                  program.loadColor(gl, surfaceTile.pickColor);
	                } else {// Surface shape tiles don't use a pick color. Pick colors are encoded into
	                  // the colors of the individual shapes drawn into the tile.
	                }
	              } else {
	                if (tilesHaveOpacity && surfaceTile.opacity != currentTileOpacity) {
	                  program.loadOpacity(gl, opacity * surfaceTile.opacity);
	                  currentTileOpacity = surfaceTile.opacity;
	                }
	              }

	              this.applyTileState(dc, terrainTile, surfaceTile);
	              terrain.renderTile(dc, terrainTile);
	              ++tileCount;
	            }
	          }
	        }
	      } catch (e) {
	        console.log(e);
	      } finally {
	        terrain.endRenderingTile(dc, terrainTile);
	      }
	    }
	  } catch (e) {
	    console.log(e);
	  } finally {
	    terrain.endRendering(dc);
	    this.endRendering(dc);
	    dc.frameStatistics.incrementRenderedTileCount(tileCount);
	  }
	}; // Intentionally not documented.


	SurfaceTileRenderer.prototype.beginRendering = function (dc, opacity) {
	  var gl = dc.currentGlContext,
	      program = dc.findAndBindProgram(SurfaceTileRendererProgram);
	  program.loadTexSampler(gl, gl.TEXTURE0);

	  if (dc.pickingMode && !this.isSurfaceShapeTileRendering) {
	    program.loadModulateColor(gl, true);
	  } else {
	    program.loadModulateColor(gl, false);
	    program.loadOpacity(gl, opacity);
	  }

	  return program;
	}; // Intentionally not documented.


	SurfaceTileRenderer.prototype.endRendering = function (dc) {
	  var gl = dc.currentGlContext;
	  gl.bindTexture(gl.TEXTURE_2D, null);
	}; // Intentionally not documented.


	SurfaceTileRenderer.prototype.applyTileState = function (dc, terrainTile, surfaceTile) {
	  // Sets up the texture transform and mask that applies the texture tile to the terrain tile.
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram,
	      terrainSector = terrainTile.sector,
	      terrainDeltaLat = terrainSector.deltaLatitude(),
	      terrainDeltaLon = terrainSector.deltaLongitude(),
	      surfaceSector = surfaceTile.sector,
	      rawSurfaceDeltaLat = surfaceSector.deltaLatitude(),
	      rawSurfaceDeltaLon = surfaceSector.deltaLongitude(),
	      surfaceDeltaLat = rawSurfaceDeltaLat > 0 ? rawSurfaceDeltaLat : 1,
	      surfaceDeltaLon = rawSurfaceDeltaLon > 0 ? rawSurfaceDeltaLon : 1,
	      sScale = terrainDeltaLon / surfaceDeltaLon,
	      tScale = terrainDeltaLat / surfaceDeltaLat,
	      sTrans = -(surfaceSector.minLongitude - terrainSector.minLongitude) / surfaceDeltaLon,
	      tTrans = -(surfaceSector.minLatitude - terrainSector.minLatitude) / surfaceDeltaLat;
	  this.texMaskMatrix.set(sScale, 0, 0, sTrans, 0, tScale, 0, tTrans, 0, 0, 1, 0, 0, 0, 0, 1);
	  this.texSamplerMatrix.setToUnitYFlip();
	  surfaceTile.applyInternalTransform(dc, this.texSamplerMatrix);
	  this.texSamplerMatrix.multiplyMatrix(this.texMaskMatrix);
	  program.loadTexSamplerMatrix(gl, this.texSamplerMatrix);
	  program.loadTexMaskMatrix(gl, this.texMaskMatrix);
	};

	/**
	 * @exports TextRenderer
	 */
	/**
	 * Constructs a TextRenderer instance.
	 * @alias TextRenderer
	 * @constructor
	 * @classdesc Provides methods useful for displaying text. An instance of this class is attached to the
	 * WorldWindow {@link DrawContext} and is not intended to be used independently of that. Applications typically do
	 * not create instances of this class.
	 * @param {drawContext} drawContext The current draw context. Typically the same draw context that TextRenderer
	 * is attached to.
	 * @throws {ArgumentError} If the specified draw context is null or undefined.
	 */

	function TextRenderer(drawContext) {
	  if (!drawContext) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TextRenderer", "constructor", "missingDc"));
	  } // Internal use only. Intentionally not documented.


	  this.canvas2D = document.createElement("canvas"); // Internal use only. Intentionally not documented.

	  this.ctx2D = this.canvas2D.getContext("2d"); // Internal use only. Intentionally not documented.

	  this.dc = drawContext;
	  /**
	   * Indicates if the text will feature an outline around its characters.
	   * @type {boolean}
	   */

	  this.enableOutline = true; // Internal use only. Intentionally not documented.

	  this.lineSpacing = 0.15; // fraction of font size

	  /**
	   * The color for the Text outline.
	   * Its default has half transparency to avoid visual artifacts that appear while fully opaque.
	   * @type {Color}
	   */

	  this.outlineColor = new Color(0, 0, 0, 0.5);
	  /**
	   * Indicates the text outline width (or thickness) in pixels.
	   * @type {number}
	   */

	  this.outlineWidth = 4;
	  /**
	   * The text color.
	   * @type {Color}
	   */

	  this.textColor = new Color(1, 1, 1, 1);
	  /**
	   * The text size, face and other characteristics, as described in [Font]{@link Font}.
	   * @type {Font}
	   */

	  this.typeFace = new Font(14);
	}
	/**
	 * Returns the width and height of a specified text string considering the current typeFace and outline usage.
	 * @param {string} text The text string.
	 * @returns {Vec2} A vector indicating the text's width and height, respectively, in pixels.
	 */


	TextRenderer.prototype.textSize = function (text) {
	  if (text.length === 0) {
	    return new Vec2(0, 0);
	  }

	  this.ctx2D.font = this.typeFace.fontString;
	  var lines = text.split("\n"),
	      height = lines.length * (this.typeFace.size * (1 + this.lineSpacing)),
	      maxWidth = 0;

	  for (var i = 0; i < lines.length; i++) {
	    maxWidth = Math.max(maxWidth, this.ctx2D.measureText(lines[i]).width);
	  }

	  if (this.enableOutline) {
	    maxWidth += this.outlineWidth;
	    height += this.outlineWidth;
	  }

	  return new Vec2(maxWidth, height);
	};
	/**
	 * Creates a texture for a specified text string and current TextRenderer state.
	 * @param {String} text The text string.
	 * @returns {Texture} A texture for the specified text string.
	 */


	TextRenderer.prototype.renderText = function (text) {
	  if (text && text.length > 0) {
	    var canvas2D = this.drawText(text);
	    return new Texture$1(this.dc.currentGlContext, canvas2D);
	  } else {
	    return null;
	  }
	};
	/**
	 * Creates a 2D Canvas for a specified text string while considering current TextRenderer state in
	 * regards to outline usage and color, text color, typeface, and outline width.
	 * @param {String} text The text string.
	 * @returns {canvas2D} A 2D Canvas for the specified text string.
	 */


	TextRenderer.prototype.drawText = function (text) {
	  var ctx2D = this.ctx2D,
	      canvas2D = this.canvas2D,
	      textSize = this.textSize(text),
	      lines = text.split("\n"),
	      strokeOffset = this.enableOutline ? this.outlineWidth / 2 : 0,
	      pixelScale = this.dc.pixelScale;
	  canvas2D.width = Math.ceil(textSize[0]) * pixelScale;
	  canvas2D.height = Math.ceil(textSize[1]) * pixelScale;
	  ctx2D.scale(pixelScale, pixelScale);
	  ctx2D.font = this.typeFace.fontString;
	  ctx2D.textBaseline = "bottom";
	  ctx2D.textAlign = this.typeFace.horizontalAlignment;
	  ctx2D.fillStyle = this.textColor.toCssColorString();
	  ctx2D.strokeStyle = this.outlineColor.toCssColorString();
	  ctx2D.lineWidth = this.outlineWidth;
	  ctx2D.lineCap = "round";
	  ctx2D.lineJoin = "round";

	  if (this.typeFace.horizontalAlignment === "left") {
	    ctx2D.translate(strokeOffset, 0);
	  } else if (this.typeFace.horizontalAlignment === "right") {
	    ctx2D.translate(textSize[0] - strokeOffset, 0);
	  } else {
	    ctx2D.translate(textSize[0] / 2, 0);
	  }

	  for (var i = 0; i < lines.length; i++) {
	    ctx2D.translate(0, this.typeFace.size * (1 + this.lineSpacing) + strokeOffset);

	    if (this.enableOutline) {
	      ctx2D.strokeText(lines[i], 0, 0);
	    }

	    ctx2D.fillText(lines[i], 0, 0);
	  }

	  return canvas2D;
	};
	/**
	 * Calculates maximum line height based on the current typeFace and outline usage of TextRenderer.
	 * @returns {Vec2} A vector indicating the text's width and height, respectively, in pixels.
	 */


	TextRenderer.prototype.getMaxLineHeight = function () {
	  // Check underscore + capital E with acute accent
	  return this.textSize("_\u00c9")[1];
	};
	/**
	 * Wraps the text based on width and height using new line delimiter
	 * @param {String} text The text to wrap.
	 * @param {Number} width The width in pixels.
	 * @param {Number} height The height in pixels.
	 * @returns {String} The wrapped text.
	 */


	TextRenderer.prototype.wrap = function (text, width, height) {
	  if (!text) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.WARNING, "TextRenderer", "wrap", "missing text"));
	  }

	  var i;
	  var lines = text.split("\n");
	  var wrappedText = ""; // Wrap each line

	  for (i = 0; i < lines.length; i++) {
	    lines[i] = this.wrapLine(lines[i], width);
	  } // Concatenate all lines in one string with new line separators
	  // between lines - not at the end
	  // Checks for height limit.


	  var currentHeight = 0;
	  var heightExceeded = false;
	  var maxLineHeight = this.getMaxLineHeight();

	  for (i = 0; i < lines.length && !heightExceeded; i++) {
	    var subLines = lines[i].split("\n");

	    for (var j = 0; j < subLines.length && !heightExceeded; j++) {
	      if (height <= 0 || currentHeight + maxLineHeight <= height) {
	        wrappedText += subLines[j];
	        currentHeight += maxLineHeight + this.lineSpacing;

	        if (j < subLines.length - 1) {
	          wrappedText += '\n';
	        }
	      } else {
	        heightExceeded = true;
	      }
	    }

	    if (i < lines.length - 1 && !heightExceeded) {
	      wrappedText += '\n';
	    }
	  } // Add continuation string if text truncated


	  if (heightExceeded) {
	    if (wrappedText.length > 0) {
	      wrappedText = wrappedText.substring(0, wrappedText.length - 1);
	    }

	    wrappedText += "...";
	  }

	  return wrappedText;
	};
	/**
	 * Wraps a line of text based on width and height
	 * @param {String} text The text to wrap.
	 * @param {Number} width The width in pixels.
	 * @returns {String} The wrapped text.
	 */


	TextRenderer.prototype.wrapLine = function (text, width) {
	  var wrappedText = ""; // Single line - trim leading and trailing spaces

	  var source = text.trim();
	  var lineBounds = this.textSize(source);

	  if (lineBounds[0] > width) {
	    // Split single line to fit preferred width
	    var line = "";
	    var start = 0;
	    var end = source.indexOf(' ', start + 1);

	    while (start < source.length) {
	      if (end === -1) {
	        end = source.length; // last word
	      } // Extract a 'word' which is in fact a space and a word


	      var word = source.substring(start, end);
	      var linePlusWord = line + word;

	      if (this.textSize(linePlusWord)[0] <= width) {
	        // Keep adding to the current line
	        line += word;
	      } else {
	        // Width exceeded
	        if (line.length !== 0) {
	          // Finish current line and start new one
	          wrappedText += line;
	          wrappedText += '\n';
	          line = "";
	          line += word.trim(); // get read of leading space(s)
	        } else {
	          // Line is empty, force at least one word
	          line += word.trim();
	        }
	      } // Move forward in source string


	      start = end;

	      if (start < source.length - 1) {
	        end = source.indexOf(' ', start + 1);
	      }
	    } // Gather last line


	    wrappedText += line;
	  } else {
	    // Line doesn't need to be wrapped
	    wrappedText += source;
	  }

	  return wrappedText;
	};

	/**
	 * @exports DrawContext
	 */
	/**
	 * Constructs a DrawContext. Applications do not call this constructor. A draw context is created by a
	 * {@link WorldWindow} during its construction.
	 * @alias DrawContext
	 * @constructor
	 * @classdesc Provides current state during rendering. The current draw context is passed to most rendering
	 * methods in order to make those methods aware of current state.
	 * @param {WebGLRenderingContext} gl The WebGL rendering context this draw context is associated with.
	 * @throws {ArgumentError} If the specified WebGL rendering context is null or undefined.
	 */

	function DrawContext(gl) {
	  if (!gl) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Texture", "constructor", "missingGlContext"));
	  }
	  /**
	   * The current WebGL rendering context.
	   * @type {WebGLRenderingContext}
	   */


	  this.currentGlContext = gl;
	  /**
	   * A 2D canvas for creating texture maps.
	   * @type {HTMLElement}
	   */

	  this.canvas2D = document.createElement("canvas");
	  /**
	   * A 2D context for this draw context's [canvas property]{@link DrawContext#canvas}.
	   */

	  this.ctx2D = this.canvas2D.getContext("2d");
	  /**
	   * The current clear color.
	   * @type {Color}
	   * @default Color.TRANSPARENT (red = 0, green = 0, blue = 0, alpha = 0)
	   */

	  this.clearColor = Color.TRANSPARENT;
	  /**
	   * The GPU resource cache, which tracks WebGL resources.
	   * @type {GpuResourceCache}
	   */

	  this.gpuResourceCache = new GpuResourceCache(WorldWind.configuration.gpuCacheSize, 0.8 * WorldWind.configuration.gpuCacheSize);
	  /**
	   * The surface-tile-renderer to use for drawing surface tiles.
	   * @type {SurfaceTileRenderer}
	   */

	  this.surfaceTileRenderer = new SurfaceTileRenderer();
	  /**
	   * The surface shape tile builder used to create and draw surface shapes.
	   * @type {SurfaceShapeTileBuilder}
	   */

	  this.surfaceShapeTileBuilder = new SurfaceShapeTileBuilder();
	  /**
	   * Provides access to a multi-resolution WebGL framebuffer arranged as adjacent tiles in a pyramid. Surface
	   * shapes use these tiles internally to draw on the terrain surface.
	   * @type {FramebufferTileController}
	   */

	  this.surfaceShapeTileController = new FramebufferTileController();
	  /**
	   * The screen credit controller responsible for collecting and drawing screen credits.
	   * @type {ScreenCreditController}
	   */

	  this.screenCreditController = new ScreenCreditController();
	  /**
	   * A shared TextRenderer instance.
	   * @type {TextRenderer}
	   */

	  this.textRenderer = new TextRenderer(this);
	  /**
	   * The current WebGL framebuffer. Null indicates that the default WebGL framebuffer is active.
	   * @type {FramebufferTexture}
	   */

	  this.currentFramebuffer = null;
	  /**
	   * The current WebGL program. Null indicates that no WebGL program is active.
	   * @type {GpuProgram}
	   */

	  this.currentProgram = null;
	  /**
	   * The list of surface renderables.
	   * @type {Array}
	   */

	  this.surfaceRenderables = [];
	  /**
	   * Indicates whether this draw context is in ordered rendering mode.
	   * @type {Boolean}
	   */

	  this.orderedRenderingMode = false;
	  /**
	   * The list of ordered renderables.
	   * @type {Array}
	   */

	  this.orderedRenderables = []; // Internal. Intentionally not documented. Provides ordinal IDs to ordered renderables.

	  this.orderedRenderablesCounter = 0; // Number

	  /**
	   * The starting time of the current frame, in milliseconds. The frame timestamp is updated immediately
	   * before the WorldWindow associated with this draw context is rendered, either as a result of redrawing or
	   * as a result of a picking operation.
	   * @type {Number}
	   * @readonly
	   */

	  this.timestamp = Date.now();
	  /**
	   * The [time stamp]{@link DrawContext#timestamp} of the last visible frame, in milliseconds. This indicates
	   * the time stamp that was current during the WorldWindow's last frame, ignoring frames associated with a
	   * picking operation. The difference between the previous redraw time stamp and the current time stamp
	   * indicates the duration between visible frames, e.g. <code style='white-space:nowrap'>timeStamp - previousRedrawTimestamp</code>.
	   * @type {Number}
	   * @readonly
	   */

	  this.previousRedrawTimestamp = this.timestamp;
	  /**
	   * Indicates whether a redraw has been requested during the current frame. When true, this causes the World
	   * Window associated with this draw context to redraw after the current frame.
	   * @type {Boolean}
	   */

	  this.redrawRequested = false;
	  /**
	   * The globe being rendered.
	   * @type {Globe}
	   */

	  this.globe = null;
	  /**
	   * A copy of the current globe's state key. Provided here to avoid having to recompute it every time
	   * it's needed.
	   * @type {String}
	   */

	  this.globeStateKey = null;
	  /**
	   * The layers being rendered.
	   * @type {Layer[]}
	   */

	  this.layers = null;
	  /**
	   * The layer being rendered.
	   * @type {Layer}
	   */

	  this.currentLayer = null;
	  /**
	   * The current eye position.
	   * @type {Position}
	   */

	  this.eyePosition = new Position(0, 0, 0);
	  /**
	   * The eye point in model coordinates, relative to the globe's center.
	   * @type {Vec3}
	   * @readonly
	   */

	  this.eyePoint = new Vec3$1(0, 0, 0);
	  /**
	   * The current screen projection matrix.
	   * @type {Matrix}
	   */

	  this.screenProjection = Matrix.fromIdentity();
	  /**
	   * The terrain for the current frame.
	   * @type {Terrain}
	   */

	  this.terrain = null;
	  /**
	   * The current vertical exaggeration.
	   * @type {Number}
	   */

	  this.verticalExaggeration = 1;
	  /**
	   * The number of milliseconds over which to fade shapes that support fading. Fading is most typically
	   * used during decluttering.
	   * @type {Number}
	   * @default 500
	   */

	  this.fadeTime = 500;
	  /**
	   * The opacity to apply to terrain and surface shapes. Should be a number between 0 and 1.
	   * @type {Number}
	   * @default 1
	   */

	  this.surfaceOpacity = 1;
	  /**
	   * Frame statistics.
	   * @type {FrameStatistics}
	   */

	  this.frameStatistics = null;
	  /**
	   * Indicates whether the frame is being drawn for picking.
	   * @type {Boolean}
	   */

	  this.pickingMode = false;
	  /**
	   * Indicates that picking will return only the terrain object, if the pick point is over the terrain.
	   * @type {Boolean}
	   * @default false
	   */

	  this.pickTerrainOnly = false;
	  /**
	   * Indicates that picking will return all objects at the pick point, if any. The top-most object will have
	   * its isOnTop flag set to true. If [deep picking]{@link WorldWindow#deepPicking} is false, the default,
	   * only the top-most object is returned, plus the picked-terrain object if the pick point is over the
	   * terrain.
	   * @type {Boolean}
	   * @default false
	   */

	  this.deepPicking = false;
	  /**
	   * Indicates that picking will return all objects that intersect the pick region, if any. Visible objects
	   * will have the isOnTop flag set to true.
	   * @type {Boolean}
	   * @default false
	   */

	  this.regionPicking = false;
	  /**
	   * The current pick point, in screen coordinates.
	   * @type {Vec2}
	   */

	  this.pickPoint = null;
	  /**
	   * The current pick ray originating at the eyePoint and extending through the pick point.
	   * @type {Line}
	   */

	  this.pickRay = null;
	  /**
	   * The current pick rectangle, in WebGL (lower-left origin) screen coordinates.
	   * @type {Rectangle}
	   */

	  this.pickRectangle = null;
	  /**
	   * The off-screen WebGL framebuffer used during picking.
	   * @type {FramebufferTexture}
	   * @readonly
	   */

	  this.pickFramebuffer = null;
	  /**
	   * The current pick frustum, created anew each picking frame.
	   * @type {Frustum}
	   * @readonly
	   */

	  this.pickFrustum = null; // Internal. Keeps track of the current pick color.

	  this.pickColor = new Color(0, 0, 0, 1);
	  /**
	   * The objects at the current pick point.
	   * @type {PickedObjectList}
	   * @readonly
	   */

	  this.objectsAtPickPoint = new PickedObjectList(); // Intentionally not documented.

	  this.pixelScale = 1; // TODO: replace with camera in the next phase of navigator refactoring

	  this.navigator = null;
	  /**
	   * The model-view matrix. The model-view matrix transforms points from model coordinates to eye
	   * coordinates.
	   * @type {Matrix}
	   * @readonly
	   */

	  this.modelview = Matrix.fromIdentity();
	  /**
	   * The projection matrix. The projection matrix transforms points from eye coordinates to clip
	   * coordinates.
	   * @type {Matrix}
	   * @readonly
	   */

	  this.projection = Matrix.fromIdentity();
	  /**
	   * The concatenation of the DrawContext's model-view and projection matrices. This matrix transforms points
	   * from model coordinates to clip coordinates.
	   * @type {Matrix}
	   * @readonly
	   */

	  this.modelviewProjection = Matrix.fromIdentity();
	  /**
	   * The viewing frustum in model coordinates. The frustum originates at the eyePoint and extends
	   * outward along the forward vector. The near distance and far distance identify the minimum and
	   * maximum distance, respectively, at which an object in the scene is visible.
	   * @type {Frustum}
	   * @readonly
	   */

	  this.frustumInModelCoordinates = null;
	  /**
	   * The matrix that transforms normal vectors in model coordinates to normal vectors in eye coordinates.
	   * Typically used to transform a shape's normal vectors during lighting calculations.
	   * @type {Matrix}
	   * @readonly
	   */

	  this.modelviewNormalTransform = Matrix.fromIdentity();
	  /**
	   * The current viewport.
	   * @type {Rectangle}
	   * @readonly
	   */

	  this.viewport = new Rectangle(0, 0, 0, 0); // Intentionally not documented.

	  this.pixelSizeFactor = 0; // Intentionally not documented.

	  this.pixelSizeOffset = 0; // Intentionally not documented.

	  this.glExtensionsCache = {};
	} // Internal use. Intentionally not documented.


	DrawContext.unitCubeKey = "DrawContextUnitCubeKey";
	DrawContext.unitCubeElementsKey = "DrawContextUnitCubeElementsKey";
	DrawContext.unitQuadKey = "DrawContextUnitQuadKey";
	DrawContext.unitQuadKey3 = "DrawContextUnitQuadKey3";
	/**
	 * Prepare this draw context for the drawing of a new frame.
	 */

	DrawContext.prototype.reset = function () {
	  // Reset the draw context's internal properties.
	  this.screenCreditController.clear();
	  this.surfaceRenderables = []; // clears the surface renderables array

	  this.orderedRenderingMode = false;
	  this.orderedRenderables = []; // clears the ordered renderables array

	  this.screenRenderables = [];
	  this.orderedRenderablesCounter = 0; // Advance the per-frame timestamp.

	  var previousTimestamp = this.timestamp;
	  this.timestamp = Date.now();
	  if (this.timestamp === previousTimestamp) ++this.timestamp; // Reset properties set by the WorldWindow every frame.

	  this.redrawRequested = false;
	  this.globe = null;
	  this.globeStateKey = null;
	  this.layers = null;
	  this.currentLayer = null;
	  this.terrain = null;
	  this.verticalExaggeration = 1;
	  this.frameStatistics = null;
	  this.accumulateOrderedRenderables = true; // Reset picking properties that may be set by the WorldWindow.

	  this.pickingMode = false;
	  this.pickTerrainOnly = false;
	  this.deepPicking = false;
	  this.regionPicking = false;
	  this.pickPoint = null;
	  this.pickRay = null;
	  this.pickRectangle = null;
	  this.pickFrustum = null;
	  this.pickColor = new Color(0, 0, 0, 1);
	  this.objectsAtPickPoint.clear();
	  this.eyePoint.set(0, 0, 0);
	  this.modelview.setToIdentity();
	  this.projection.setToIdentity();
	  this.modelviewProjection.setToIdentity();
	  this.frustumInModelCoordinates = null;
	  this.modelviewNormalTransform.setToIdentity();
	};
	/**
	 * Computes any values necessary to render the upcoming frame. Called after all draw context state for the
	 * frame has been set.
	 */


	DrawContext.prototype.update = function () {
	  var gl = this.currentGlContext,
	      eyePoint = this.eyePoint;
	  this.globeStateKey = this.globe.stateKey;
	  this.globe.computePositionFromPoint(eyePoint[0], eyePoint[1], eyePoint[2], this.eyePosition);
	  this.screenProjection.setToScreenProjection(gl.drawingBufferWidth, gl.drawingBufferHeight);
	};
	/**
	 * Notifies this draw context that the current WebGL rendering context has been lost. This function removes all
	 * cached WebGL resources and resets all properties tracking the current WebGL state.
	 */


	DrawContext.prototype.contextLost = function () {
	  // Remove all cached WebGL resources, which are now invalid.
	  this.gpuResourceCache.clear();
	  this.pickFramebuffer = null; // Reset properties tracking the current WebGL state, which are now invalid.

	  this.currentFramebuffer = null;
	  this.currentProgram = null;
	  this.glExtensionsCache = {};
	};
	/**
	 * Notifies this draw context that the current WebGL rendering context has been restored. This function prepares
	 * this draw context to resume rendering.
	 */


	DrawContext.prototype.contextRestored = function () {
	  // Remove all cached WebGL resources. This cache is already cleared when the context is lost, but
	  // asynchronous load operations that complete between context lost and context restored populate the cache
	  // with invalid entries.
	  this.gpuResourceCache.clear();
	  this.glExtensionsCache = {};
	};
	/**
	 * Binds a specified WebGL framebuffer. This function also makes the framebuffer the active framebuffer.
	 * @param {FramebufferTexture} framebuffer The framebuffer to bind. May be null or undefined, in which case the
	 * default WebGL framebuffer is made active.
	 */


	DrawContext.prototype.bindFramebuffer = function (framebuffer) {
	  if (this.currentFramebuffer != framebuffer) {
	    this.currentGlContext.bindFramebuffer(this.currentGlContext.FRAMEBUFFER, framebuffer ? framebuffer.framebufferId : null);
	    this.currentFramebuffer = framebuffer;
	  }
	};
	/**
	 * Binds a specified WebGL program. This function also makes the program the current program.
	 * @param {GpuProgram} program The program to bind. May be null or undefined, in which case the currently
	 * bound program is unbound.
	 */


	DrawContext.prototype.bindProgram = function (program) {
	  if (this.currentProgram != program) {
	    this.currentGlContext.useProgram(program ? program.programId : null);
	    this.currentProgram = program;
	  }
	};
	/**
	 * Binds a potentially cached WebGL program, creating and caching it if it isn't already cached.
	 * This function also makes the program the current program.
	 * @param {function} programConstructor The constructor to use to create the program.
	 * @returns {GpuProgram} The bound program.
	 * @throws {ArgumentError} If the specified constructor is null or undefined.
	 */


	DrawContext.prototype.findAndBindProgram = function (programConstructor) {
	  if (!programConstructor) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "DrawContext", "findAndBindProgram", "The specified program constructor is null or undefined."));
	  }

	  var program = this.gpuResourceCache.resourceForKey(programConstructor.key);

	  if (program) {
	    this.bindProgram(program);
	  } else {
	    try {
	      program = new programConstructor(this.currentGlContext);
	      this.bindProgram(program);
	      this.gpuResourceCache.putResource(programConstructor.key, program, program.size);
	    } catch (e) {
	      Logger$1.log(Logger$1.LEVEL_SEVERE, "Error attempting to create GPU program.");
	    }
	  }

	  return program;
	};
	/**
	 * Adds a surface renderable to this draw context's surface renderable list.
	 * @param {SurfaceRenderable} surfaceRenderable The surface renderable to add. May be null, in which case the
	 * current surface renderable list remains unchanged.
	 */


	DrawContext.prototype.addSurfaceRenderable = function (surfaceRenderable) {
	  if (surfaceRenderable) {
	    this.surfaceRenderables.push(surfaceRenderable);
	  }
	};
	/**
	 * Returns the surface renderable at the head of the surface renderable list without removing it from the list.
	 * @returns {SurfaceRenderable} The first surface renderable in this draw context's surface renderable list, or
	 * null if the surface renderable list is empty.
	 */


	DrawContext.prototype.peekSurfaceRenderable = function () {
	  if (this.surfaceRenderables.length > 0) {
	    return this.surfaceRenderables[this.surfaceRenderables.length - 1];
	  } else {
	    return null;
	  }
	};
	/**
	 * Returns the surface renderable at the head of the surface renderable list and removes it from the list.
	 * @returns {SurfaceRenderable} The first surface renderable in this draw context's surface renderable list, or
	 * null if the surface renderable list is empty.
	 */


	DrawContext.prototype.popSurfaceRenderable = function () {
	  if (this.surfaceRenderables.length > 0) {
	    return this.surfaceRenderables.pop();
	  } else {
	    return null;
	  }
	};
	/**
	 * Reverses the surface renderable list in place. After this function completes, the functions
	 * peekSurfaceRenderable and popSurfaceRenderable return renderables in the order in which they were added to
	 * the surface renderable list.
	 */


	DrawContext.prototype.reverseSurfaceRenderables = function () {
	  this.surfaceRenderables.reverse();
	};
	/**
	 * Adds an ordered renderable to this draw context's ordered renderable list.
	 * @param {OrderedRenderable} orderedRenderable The ordered renderable to add. May be null, in which case the
	 * current ordered renderable list remains unchanged.
	 * @param {Number} eyeDistance An optional argument indicating the ordered renderable's eye distance.
	 * If this parameter is not specified then the ordered renderable must have an eyeDistance property.
	 */


	DrawContext.prototype.addOrderedRenderable = function (orderedRenderable, eyeDistance) {
	  if (orderedRenderable) {
	    var ore = {
	      orderedRenderable: orderedRenderable,
	      insertionOrder: this.orderedRenderablesCounter++,
	      eyeDistance: eyeDistance || orderedRenderable.eyeDistance,
	      globeStateKey: this.globeStateKey
	    };

	    if (this.globe.continuous) {
	      ore.globeOffset = this.globe.offset;
	    }

	    if (ore.eyeDistance === 0) {
	      this.screenRenderables.push(ore);
	    } else {
	      this.orderedRenderables.push(ore);
	    }
	  }
	};
	/**
	 * Adds an ordered renderable to the end of this draw context's ordered renderable list, denoting it as the
	 * most distant from the eye point.
	 * @param {OrderedRenderable} orderedRenderable The ordered renderable to add. May be null, in which case the
	 * current ordered renderable list remains unchanged.
	 */


	DrawContext.prototype.addOrderedRenderableToBack = function (orderedRenderable) {
	  if (orderedRenderable) {
	    var ore = {
	      orderedRenderable: orderedRenderable,
	      insertionOrder: this.orderedRenderablesCounter++,
	      eyeDistance: Number.MAX_VALUE,
	      globeStateKey: this.globeStateKey
	    };

	    if (this.globe.continuous) {
	      ore.globeOffset = this.globe.offset;
	    }

	    this.orderedRenderables.push(ore);
	  }
	};
	/**
	 * Returns the ordered renderable at the head of the ordered renderable list without removing it from the list.
	 * @returns {OrderedRenderable} The first ordered renderable in this draw context's ordered renderable list, or
	 * null if the ordered renderable list is empty.
	 */


	DrawContext.prototype.peekOrderedRenderable = function () {
	  if (this.orderedRenderables.length > 0) {
	    return this.orderedRenderables[this.orderedRenderables.length - 1].orderedRenderable;
	  } else {
	    return null;
	  }
	};
	/**
	 * Returns the ordered renderable at the head of the ordered renderable list and removes it from the list.
	 * @returns {OrderedRenderable} The first ordered renderable in this draw context's ordered renderable list, or
	 * null if the ordered renderable list is empty.
	 */


	DrawContext.prototype.popOrderedRenderable = function () {
	  if (this.orderedRenderables.length > 0) {
	    var ore = this.orderedRenderables.pop();
	    this.globeStateKey = ore.globeStateKey;

	    if (this.globe.continuous) {
	      // Restore the globe state to that when the ordered renderable was created.
	      this.globe.offset = ore.globeOffset;
	    }

	    return ore.orderedRenderable;
	  } else {
	    return null;
	  }
	};
	/**
	 * Returns the ordered renderable at the head of the ordered renderable list and removes it from the list.
	 * @returns {OrderedRenderable} The first ordered renderable in this draw context's ordered renderable list, or
	 * null if the ordered renderable list is empty.
	 */


	DrawContext.prototype.nextScreenRenderable = function () {
	  if (this.screenRenderables.length > 0) {
	    var ore = this.screenRenderables.shift();
	    this.globeStateKey = ore.globeStateKey;

	    if (this.globe.continuous) {
	      // Restore the globe state to that when the ordered renderable was created.
	      this.globe.offset = ore.globeOffset;
	    }

	    return ore.orderedRenderable;
	  } else {
	    return null;
	  }
	};
	/**
	 * Sorts the ordered renderable list from nearest to the eye point to farthest from the eye point.
	 */


	DrawContext.prototype.sortOrderedRenderables = function () {
	  // Sort the ordered renderables by eye distance from front to back and then by insertion time. The ordered
	  // renderable peek and pop access the back of the ordered renderable list, thereby causing ordered renderables to
	  // be processed from back to front.
	  this.orderedRenderables.sort(function (oreA, oreB) {
	    var eA = oreA.eyeDistance,
	        eB = oreB.eyeDistance;

	    if (eA < eB) {
	      // orA is closer to the eye than orB; sort orA before orB
	      return -1;
	    } else if (eA > eB) {
	      // orA is farther from the eye than orB; sort orB before orA
	      return 1;
	    } else {
	      // orA and orB are the same distance from the eye; sort them based on insertion time
	      var tA = oreA.insertionOrder,
	          tB = oreB.insertionOrder;

	      if (tA > tB) {
	        return -1;
	      } else if (tA < tB) {
	        return 1;
	      } else {
	        return 0;
	      }
	    }
	  });
	};
	/**
	 * Reads the color from the current render buffer at a specified point. Used during picking to identify the item most
	 * recently affecting the pixel at the specified point.
	 * @param {Vec2} pickPoint The current pick point.
	 * @returns {Color} The color at the pick point.
	 */


	DrawContext.prototype.readPickColor = function (pickPoint) {
	  var glPickPoint = this.convertPointToViewport(pickPoint, new Vec2(0, 0)),
	      colorBytes = new Uint8Array(4);
	  this.currentGlContext.readPixels(glPickPoint[0], glPickPoint[1], 1, 1, this.currentGlContext.RGBA, this.currentGlContext.UNSIGNED_BYTE, colorBytes);

	  if (this.clearColor.equalsBytes(colorBytes)) {
	    return null;
	  }

	  return Color.colorFromByteArray(colorBytes);
	};
	/**
	 * Reads the current pick buffer colors in a specified rectangle. Used during region picking to identify
	 * the items not occluded.
	 * @param {Rectangle} pickRectangle The rectangle for which to read the colors.
	 * @returns {{}} An object containing the unique colors in the specified rectangle, excluding the current
	 * clear color. The colors are referenced by their byte string
	 * (see [Color.toByteString]{@link Color#toByteString}.
	 */


	DrawContext.prototype.readPickColors = function (pickRectangle) {
	  var gl = this.currentGlContext,
	      colorBytes = new Uint8Array(pickRectangle.width * pickRectangle.height * 4),
	      uniqueColors = {},
	      color,
	      blankColor = new Color(0, 0, 0, 0),
	      packAlignment = gl.getParameter(gl.PACK_ALIGNMENT);
	  gl.pixelStorei(gl.PACK_ALIGNMENT, 1); // read byte aligned

	  this.currentGlContext.readPixels(pickRectangle.x, pickRectangle.y, pickRectangle.width, pickRectangle.height, gl.RGBA, gl.UNSIGNED_BYTE, colorBytes);
	  gl.pixelStorei(gl.PACK_ALIGNMENT, packAlignment); // restore the pack alignment

	  for (var i = 0, len = pickRectangle.width * pickRectangle.height; i < len; i++) {
	    var k = i * 4;
	    color = Color.colorFromBytes(colorBytes[k], colorBytes[k + 1], colorBytes[k + 2], colorBytes[k + 3]);
	    if (color.equals(this.clearColor) || color.equals(blankColor)) continue;
	    uniqueColors[color.toByteString()] = color;
	  }

	  return uniqueColors;
	};
	/**
	 * Determines whether a specified picked object is under the pick point, and if it is adds it to this draw
	 * context's list of picked objects. This method should be called by shapes during ordered rendering
	 * after the shape is drawn. If this draw context is in single-picking mode, the specified pickable object
	 * is added to the list of picked objects whether or not it is under the pick point.
	 * @param pickableObject
	 * @returns {null}
	 */


	DrawContext.prototype.resolvePick = function (pickableObject) {
	  if (!(pickableObject.userObject instanceof SurfaceShape) && this.deepPicking && !this.regionPicking) {
	    var color = this.readPickColor(this.pickPoint);

	    if (!color) {
	      // getPickColor returns null if the pick point selects the clear color
	      return null;
	    }

	    if (pickableObject.color.equals(color)) {
	      this.addPickedObject(pickableObject);
	    }
	  } else {
	    // Don't resolve. Just add the object to the pick list. It will be resolved later.
	    this.addPickedObject(pickableObject);
	  }
	};
	/**
	 * Adds an object to the current picked-object list. The list identifies objects that are at the pick point
	 * but not necessarily the top-most object.
	 * @param  {PickedObject} pickedObject The object to add.
	 */


	DrawContext.prototype.addPickedObject = function (pickedObject) {
	  if (pickedObject) {
	    this.objectsAtPickPoint.add(pickedObject);
	  }
	};
	/**
	 * Computes a unique color to use as a pick color.
	 * @returns {Color} A unique color.
	 */


	DrawContext.prototype.uniquePickColor = function () {
	  var color = this.pickColor.nextColor().clone();
	  return color.equals(this.clearColor) ? color.nextColor() : color;
	};
	/**
	 * Creates an off-screen WebGL framebuffer for use during picking and stores it in this draw context. The
	 * framebuffer width and height match the WebGL rendering context's drawingBufferWidth and drawingBufferHeight.
	 */


	DrawContext.prototype.makePickFramebuffer = function () {
	  var gl = this.currentGlContext,
	      width = gl.drawingBufferWidth,
	      height = gl.drawingBufferHeight;

	  if (!this.pickFramebuffer || this.pickFramebuffer.width != width || this.pickFramebuffer.height != height) {
	    this.pickFramebuffer = new FramebufferTexture(gl, width, height, true); // enable depth buffering
	  }

	  return this.pickFramebuffer;
	};
	/**
	 * Creates a pick frustum for the current pick point and stores it in this draw context. If this context's
	 * pick rectangle is null or undefined then a pick rectangle is also computed and assigned to this context.
	 * If the existing pick rectangle extends beyond the viewport then it is truncated by this method to fit
	 * within the viewport.
	 * This method assumes that this draw context's pick point or pick rectangle has been set. It returns
	 * false if neither one of these exists.
	 *
	 * @returns {Boolean} <code>true</code> if the pick frustum could be created, otherwise <code>false</code>.
	 */


	DrawContext.prototype.makePickFrustum = function () {
	  if (!this.pickPoint && !this.pickRectangle) {
	    return false;
	  }

	  var lln,
	      llf,
	      lrn,
	      lrf,
	      uln,
	      ulf,
	      urn,
	      urf,
	      // corner points of frustum
	  nl,
	      nr,
	      nt,
	      nb,
	      nn,
	      nf,
	      // normal vectors of frustum planes
	  l,
	      r,
	      t,
	      b,
	      n,
	      f,
	      // frustum planes
	  va,
	      vb = new Vec3$1(0, 0, 0),
	      // vectors formed by the corner points
	  apertureRadius = 2,
	      // radius of pick window in screen coordinates
	  screenPoint = new Vec3$1(0, 0, 0),
	      pickPoint,
	      pickRectangle = this.pickRectangle,
	      viewport = this.viewport; // Compute the pick rectangle if necessary.

	  if (!pickRectangle) {
	    pickPoint = this.convertPointToViewport(this.pickPoint, new Vec2(0, 0));
	    pickRectangle = new Rectangle(pickPoint[0] - apertureRadius, pickPoint[1] - apertureRadius, 2 * apertureRadius, 2 * apertureRadius);
	  } // Clamp the pick rectangle to the viewport.


	  var xl = pickRectangle.x,
	      xr = pickRectangle.x + pickRectangle.width,
	      yb = pickRectangle.y,
	      yt = pickRectangle.y + pickRectangle.height;

	  if (xr < 0 || yt < 0 || xl > viewport.x + viewport.width || yb > viewport.y + viewport.height) {
	    return false; // pick rectangle is outside the viewport.
	  }

	  pickRectangle.x = WWMath.clamp(xl, viewport.x, viewport.x + viewport.width);
	  pickRectangle.y = WWMath.clamp(yb, viewport.y, viewport.y + viewport.height);
	  pickRectangle.width = WWMath.clamp(xr, viewport.x, viewport.x + viewport.width) - pickRectangle.x;
	  pickRectangle.height = WWMath.clamp(yt, viewport.y, viewport.y + viewport.height) - pickRectangle.y;
	  this.pickRectangle = pickRectangle; // Compute the pick frustum.

	  var modelviewProjectionInv = Matrix.fromIdentity();
	  modelviewProjectionInv.invertMatrix(this.modelviewProjection);
	  screenPoint[0] = pickRectangle.x;
	  screenPoint[1] = pickRectangle.y;
	  screenPoint[2] = 0;
	  modelviewProjectionInv.unProject(screenPoint, viewport, lln = new Vec3$1(0, 0, 0));
	  screenPoint[0] = pickRectangle.x;
	  screenPoint[1] = pickRectangle.y;
	  screenPoint[2] = 1;
	  modelviewProjectionInv.unProject(screenPoint, viewport, llf = new Vec3$1(0, 0, 0));
	  screenPoint[0] = pickRectangle.x + pickRectangle.width;
	  screenPoint[1] = pickRectangle.y;
	  screenPoint[2] = 0;
	  modelviewProjectionInv.unProject(screenPoint, viewport, lrn = new Vec3$1(0, 0, 0));
	  screenPoint[0] = pickRectangle.x + pickRectangle.width;
	  screenPoint[1] = pickRectangle.y;
	  screenPoint[2] = 1;
	  modelviewProjectionInv.unProject(screenPoint, viewport, lrf = new Vec3$1(0, 0, 0));
	  screenPoint[0] = pickRectangle.x;
	  screenPoint[1] = pickRectangle.y + pickRectangle.height;
	  screenPoint[2] = 0;
	  modelviewProjectionInv.unProject(screenPoint, viewport, uln = new Vec3$1(0, 0, 0));
	  screenPoint[0] = pickRectangle.x;
	  screenPoint[1] = pickRectangle.y + pickRectangle.height;
	  screenPoint[2] = 1;
	  modelviewProjectionInv.unProject(screenPoint, viewport, ulf = new Vec3$1(0, 0, 0));
	  screenPoint[0] = pickRectangle.x + pickRectangle.width;
	  screenPoint[1] = pickRectangle.y + pickRectangle.height;
	  screenPoint[2] = 0;
	  modelviewProjectionInv.unProject(screenPoint, viewport, urn = new Vec3$1(0, 0, 0));
	  screenPoint[0] = pickRectangle.x + pickRectangle.width;
	  screenPoint[1] = pickRectangle.y + pickRectangle.height;
	  screenPoint[2] = 1;
	  modelviewProjectionInv.unProject(screenPoint, viewport, urf = new Vec3$1(0, 0, 0));
	  va = new Vec3$1(ulf[0] - lln[0], ulf[1] - lln[1], ulf[2] - lln[2]);
	  vb.set(uln[0] - llf[0], uln[1] - llf[1], uln[2] - llf[2]);
	  nl = va.cross(vb);
	  l = new Plane(nl[0], nl[1], nl[2], -nl.dot(lln));
	  l.normalize();
	  va = new Vec3$1(urn[0] - lrf[0], urn[1] - lrf[1], urn[2] - lrf[2]);
	  vb.set(urf[0] - lrn[0], urf[1] - lrn[1], urf[2] - lrn[2]);
	  nr = va.cross(vb);
	  r = new Plane(nr[0], nr[1], nr[2], -nr.dot(lrn));
	  r.normalize();
	  va = new Vec3$1(ulf[0] - urn[0], ulf[1] - urn[1], ulf[2] - urn[2]);
	  vb.set(urf[0] - uln[0], urf[1] - uln[1], urf[2] - uln[2]);
	  nt = va.cross(vb);
	  t = new Plane(nt[0], nt[1], nt[2], -nt.dot(uln));
	  t.normalize();
	  va = new Vec3$1(lrf[0] - lln[0], lrf[1] - lln[1], lrf[2] - lln[2]);
	  vb.set(llf[0] - lrn[0], llf[1] - lrn[1], llf[2] - lrn[2]);
	  nb = va.cross(vb);
	  b = new Plane(nb[0], nb[1], nb[2], -nb.dot(lrn));
	  b.normalize();
	  va = new Vec3$1(uln[0] - lrn[0], uln[1] - lrn[1], uln[2] - lrn[2]);
	  vb.set(urn[0] - lln[0], urn[1] - lln[1], urn[2] - lln[2]);
	  nn = va.cross(vb);
	  n = new Plane(nn[0], nn[1], nn[2], -nn.dot(lln));
	  n.normalize();
	  va = new Vec3$1(urf[0] - llf[0], urf[1] - llf[1], urf[2] - llf[2]);
	  vb.set(ulf[0] - lrf[0], ulf[1] - lrf[1], ulf[2] - lrf[2]);
	  nf = va.cross(vb);
	  f = new Plane(nf[0], nf[1], nf[2], -nf.dot(llf));
	  f.normalize();
	  this.pickFrustum = new Frustum(l, r, b, t, n, f);
	  return true;
	};
	/**
	 * Indicates whether an extent is smaller than a specified number of pixels.
	 * @param {BoundingBox} extent The extent to test.
	 * @param {Number} numPixels The number of pixels below which the extent is considered small.
	 * @returns {Boolean} True if the extent is smaller than the specified number of pixels, otherwise false.
	 * Returns false if the extent is null or undefined.
	 */


	DrawContext.prototype.isSmall = function (extent, numPixels) {
	  if (!extent) {
	    return false;
	  }

	  var distance = this.eyePoint.distanceTo(extent.center),
	      pixelSize = this.pixelSizeAtDistance(distance);
	  return 2 * extent.radius < numPixels * pixelSize; // extent diameter less than size of num pixels
	};
	/**
	 * Returns the VBO ID of an array buffer containing a unit cube expressed as eight 3D vertices at (0, 1, 0),
	 * (0, 0, 0), (1, 1, 0), (1, 0, 0), (0, 1, 1), (0, 0, 1), (1, 1, 1) and (1, 0, 1). The buffer is created on
	 * first use and cached. Subsequent calls to this method return the cached buffer.
	 * @returns {Object} The VBO ID identifying the array buffer.
	 */


	DrawContext.prototype.unitCubeBuffer = function () {
	  var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitCubeKey);

	  if (!vboId) {
	    var gl = this.currentGlContext,
	        points = new Float32Array(24),
	        i = 0;
	    points[i++] = 0; // upper left corner, z = 0

	    points[i++] = 1;
	    points[i++] = 0;
	    points[i++] = 0; // lower left corner, z = 0

	    points[i++] = 0;
	    points[i++] = 0;
	    points[i++] = 1; // upper right corner, z = 0

	    points[i++] = 1;
	    points[i++] = 0;
	    points[i++] = 1; // lower right corner, z = 0

	    points[i++] = 0;
	    points[i++] = 0;
	    points[i++] = 0; // upper left corner, z = 1

	    points[i++] = 1;
	    points[i++] = 1;
	    points[i++] = 0; // lower left corner, z = 1

	    points[i++] = 0;
	    points[i++] = 1;
	    points[i++] = 1; // upper right corner, z = 1

	    points[i++] = 1;
	    points[i++] = 1;
	    points[i++] = 1; // lower right corner, z = 1

	    points[i++] = 0;
	    points[i] = 1;
	    vboId = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
	    gl.bindBuffer(gl.ARRAY_BUFFER, null);
	    this.frameStatistics.incrementVboLoadCount(1);
	    this.gpuResourceCache.putResource(DrawContext.unitCubeKey, vboId, points.length * 4);
	  }

	  return vboId;
	};
	/**
	 * Returns the VBO ID of a element array buffer containing the tessellation of a unit cube expressed as
	 * a single buffer containing both triangle indices and line indices. This is intended for use in conjunction
	 * with <code>unitCubeBuffer</code>. The unit cube's interior and outline may be rasterized as shown in the
	 * following WebGL pseudocode:
	 * <code><pre>
	 * // Assumes that the VBO returned by unitCubeBuffer is used as the source of vertex positions.
	 * bindBuffer(ELEMENT_ARRAY_BUFFER, drawContext.unitCubeElements());
	 * drawElements(TRIANGLES, 36, UNSIGNED_SHORT, 0); // draw the unit cube interior
	 * drawElements(LINES, 24, UNSIGNED_SHORT, 72); // draw the unit cube outline
	 * </pre></code>
	 * The buffer is created on first use
	 * and cached. Subsequent calls to this method return the cached buffer.
	 * @returns {Object} The VBO ID identifying the element array buffer.
	 */


	DrawContext.prototype.unitCubeElements = function () {
	  var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitCubeElementsKey);

	  if (!vboId) {
	    var gl = this.currentGlContext,
	        elems = new Int16Array(60),
	        i = 0; // interior

	    elems[i++] = 1; // -z face

	    elems[i++] = 0;
	    elems[i++] = 3;
	    elems[i++] = 3;
	    elems[i++] = 0;
	    elems[i++] = 2;
	    elems[i++] = 4; // +z face

	    elems[i++] = 5;
	    elems[i++] = 6;
	    elems[i++] = 6;
	    elems[i++] = 5;
	    elems[i++] = 7;
	    elems[i++] = 5; // -y face

	    elems[i++] = 1;
	    elems[i++] = 7;
	    elems[i++] = 7;
	    elems[i++] = 1;
	    elems[i++] = 3;
	    elems[i++] = 6; // +y face

	    elems[i++] = 2;
	    elems[i++] = 4;
	    elems[i++] = 4;
	    elems[i++] = 2;
	    elems[i++] = 0;
	    elems[i++] = 4; // -x face

	    elems[i++] = 0;
	    elems[i++] = 5;
	    elems[i++] = 5;
	    elems[i++] = 0;
	    elems[i++] = 1;
	    elems[i++] = 7; // +x face

	    elems[i++] = 3;
	    elems[i++] = 6;
	    elems[i++] = 6;
	    elems[i++] = 3;
	    elems[i++] = 2; // outline

	    elems[i++] = 0; // left, -z

	    elems[i++] = 1;
	    elems[i++] = 1; // bottom, -z

	    elems[i++] = 3;
	    elems[i++] = 3; // right, -z

	    elems[i++] = 2;
	    elems[i++] = 2; // top, -z

	    elems[i++] = 0;
	    elems[i++] = 4; // left, +z

	    elems[i++] = 5;
	    elems[i++] = 5; // bottom, +z

	    elems[i++] = 7;
	    elems[i++] = 7; // right, +z

	    elems[i++] = 6;
	    elems[i++] = 6; // top, +z

	    elems[i++] = 4;
	    elems[i++] = 0; // upper left

	    elems[i++] = 4;
	    elems[i++] = 5; // lower left

	    elems[i++] = 1;
	    elems[i++] = 2; // upper right

	    elems[i++] = 6;
	    elems[i++] = 7; // lower right

	    elems[i] = 3;
	    vboId = gl.createBuffer();
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);
	    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, elems, gl.STATIC_DRAW);
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	    this.frameStatistics.incrementVboLoadCount(1);
	    this.gpuResourceCache.putResource(DrawContext.unitCubeElementsKey, vboId, elems.length * 2);
	  }

	  return vboId;
	};
	/**
	 * Returns the VBO ID of a buffer containing a unit quadrilateral expressed as four 2D vertices at (0, 1),
	 * (0, 0), (1, 1) and (1, 0). The four vertices are in the order required by a triangle strip. The buffer is
	 * created on first use and cached. Subsequent calls to this method return the cached buffer.
	 * @returns {Object} The VBO ID identifying the vertex buffer.
	 */


	DrawContext.prototype.unitQuadBuffer = function () {
	  var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitQuadKey);

	  if (!vboId) {
	    var gl = this.currentGlContext,
	        points = new Float32Array(8);
	    points[0] = 0; // upper left corner

	    points[1] = 1;
	    points[2] = 0; // lower left corner

	    points[3] = 0;
	    points[4] = 1; // upper right corner

	    points[5] = 1;
	    points[6] = 1; // lower right corner

	    points[7] = 0;
	    vboId = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
	    gl.bindBuffer(gl.ARRAY_BUFFER, null);
	    this.frameStatistics.incrementVboLoadCount(1);
	    this.gpuResourceCache.putResource(DrawContext.unitQuadKey, vboId, points.length * 4);
	  }

	  return vboId;
	};
	/**
	 * Returns the VBO ID of a buffer containing a unit quadrilateral expressed as four 3D vertices at (0, 1, 0),
	 * (0, 0, 0), (1, 1, 0) and (1, 0, 0).
	 * The four vertices are in the order required by a triangle strip. The buffer is created
	 * on first use and cached. Subsequent calls to this method return the cached buffer.
	 * @returns {Object} The VBO ID identifying the vertex buffer.
	 */


	DrawContext.prototype.unitQuadBuffer3 = function () {
	  var vboId = this.gpuResourceCache.resourceForKey(DrawContext.unitQuadKey3);

	  if (!vboId) {
	    var gl = this.currentGlContext,
	        points = new Float32Array(12);
	    points[0] = 0; // upper left corner

	    points[1] = 1;
	    points[2] = 0;
	    points[3] = 0; // lower left corner

	    points[4] = 0;
	    points[5] = 0;
	    points[6] = 1; // upper right corner

	    points[7] = 1;
	    points[8] = 0;
	    points[9] = 1; // lower right corner

	    points[10] = 0;
	    points[11] = 0;
	    vboId = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
	    gl.bindBuffer(gl.ARRAY_BUFFER, null);
	    this.frameStatistics.incrementVboLoadCount(1);
	    this.gpuResourceCache.putResource(DrawContext.unitQuadKey3, vboId, points.length * 4);
	  }

	  return vboId;
	};
	/**
	 * Computes a Cartesian point at a location on the surface of this terrain according to a specified
	 * altitude mode. If there is no current terrain, this function approximates the returned point by assuming
	 * the terrain is the globe's ellipsoid.
	 * @param {Number} latitude The location's latitude.
	 * @param {Number} longitude The location's longitude.
	 * @param {Number} offset Distance above the terrain, in meters relative to the specified altitude mode, at
	 * which to compute the point.
	 * @param {String} altitudeMode The altitude mode to use to compute the point. Recognized values are
	 * WorldWind.ABSOLUTE, WorldWind.CLAMP_TO_GROUND and
	 * WorldWind.RELATIVE_TO_GROUND. The mode WorldWind.ABSOLUTE is used if the
	 * specified mode is null, undefined or unrecognized, or if the specified location is outside this terrain.
	 * @param {Vec3} result A pre-allocated Vec3 in which to return the computed point.
	 * @returns {Vec3} The specified result parameter, set to the coordinates of the computed point.
	 * @throws {ArgumentError} If the specified result argument is null or undefined.
	 */


	DrawContext.prototype.surfacePointForMode = function (latitude, longitude, offset, altitudeMode, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "DrawContext", "surfacePointForMode", "missingResult"));
	  }

	  if (this.terrain) {
	    this.terrain.surfacePointForMode(latitude, longitude, offset, altitudeMode, result);
	  } else {
	    var h = offset + this.globe.elevationAtLocation(latitude, longitude) * this.verticalExaggeration;
	    this.globe.computePointFromPosition(latitude, longitude, h, result);
	  }

	  return result;
	};
	/**
	 * Transforms the specified model point from model coordinates to WebGL screen coordinates.
	 * <p>
	 * The resultant screen point is in WebGL screen coordinates, with the origin in the bottom-left corner and
	 * axes that extend up and to the right from the origin.
	 * <p>
	 * This function stores the transformed point in the result argument, and returns true or false to indicate
	 * whether or not the transformation is successful. It returns false if the modelview or
	 * projection matrices are malformed, or if the specified model point is clipped by the near clipping plane or
	 * the far clipping plane.
	 *
	 * @param {Vec3} modelPoint The model coordinate point to project.
	 * @param {Vec3} result A pre-allocated vector in which to return the projected point.
	 * @returns {boolean} true if the transformation is successful, otherwise false.
	 * @throws {ArgumentError} If either the specified point or result argument is null or undefined.
	 */


	DrawContext.prototype.project = function (modelPoint, result) {
	  if (!modelPoint) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "DrawContext", "project", "missingPoint"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "DrawContext", "project", "missingResult"));
	  } // Transform the model point from model coordinates to eye coordinates then to clip coordinates. This
	  // inverts the Z axis and stores the negative of the eye coordinate Z value in the W coordinate.


	  var mx = modelPoint[0],
	      my = modelPoint[1],
	      mz = modelPoint[2],
	      m = this.modelviewProjection,
	      x = m[0] * mx + m[1] * my + m[2] * mz + m[3],
	      y = m[4] * mx + m[5] * my + m[6] * mz + m[7],
	      z = m[8] * mx + m[9] * my + m[10] * mz + m[11],
	      w = m[12] * mx + m[13] * my + m[14] * mz + m[15];

	  if (w === 0) {
	    return false;
	  } // Complete the conversion from model coordinates to clip coordinates by dividing by W. The resultant X, Y
	  // and Z coordinates are in the range [-1,1].


	  x /= w;
	  y /= w;
	  z /= w; // Clip the point against the near and far clip planes.

	  if (z < -1 || z > 1) {
	    return false;
	  } // Convert the point from clip coordinate to the range [0,1]. This enables the X and Y coordinates to be
	  // converted to screen coordinates, and the Z coordinate to represent a depth value in the range[0,1].


	  x = x * 0.5 + 0.5;
	  y = y * 0.5 + 0.5;
	  z = z * 0.5 + 0.5; // Convert the X and Y coordinates from the range [0,1] to screen coordinates.

	  x = x * this.viewport.width + this.viewport.x;
	  y = y * this.viewport.height + this.viewport.y;
	  result[0] = x;
	  result[1] = y;
	  result[2] = z;
	  return true;
	};
	/**
	 * Transforms the specified model point from model coordinates to WebGL screen coordinates, applying an offset
	 * to the modelPoint's projected depth value.
	 * <p>
	 * The resultant screen point is in WebGL screen coordinates, with the origin in the bottom-left corner and axes
	 * that extend up and to the right from the origin.
	 * <p>
	 * This function stores the transformed point in the result argument, and returns true or false to indicate whether or
	 * not the transformation is successful. It returns false if the modelview or projection
	 * matrices are malformed, or if the modelPoint is clipped by the near clipping plane or the far clipping plane,
	 * ignoring the depth offset.
	 * <p>
	 * The depth offset may be any real number and is typically used to move the screenPoint slightly closer to the
	 * user's eye in order to give it visual priority over nearby objects or terrain. An offset of zero has no effect.
	 * An offset less than zero brings the screenPoint closer to the eye, while an offset greater than zero pushes the
	 * projected screen point away from the eye.
	 * <p>
	 * Applying a non-zero depth offset has no effect on whether the model point is clipped by this method or by
	 * WebGL. Clipping is performed on the original model point, ignoring the depth offset. The final depth value
	 * after applying the offset is clamped to the range [0,1].
	 *
	 * @param {Vec3} modelPoint The model coordinate point to project.
	 * @param {Number} depthOffset The amount of offset to apply.
	 * @param {Vec3} result A pre-allocated vector in which to return the projected point.
	 * @returns {boolean} true if the transformation is successful, otherwise false.
	 * @throws {ArgumentError} If either the specified point or result argument is null or undefined.
	 */


	DrawContext.prototype.projectWithDepth = function (modelPoint, depthOffset, result) {
	  if (!modelPoint) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "DrawContext", "projectWithDepth", "missingPoint"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "DrawContext", "projectWithDepth", "missingResult"));
	  } // Transform the model point from model coordinates to eye coordinates. The eye coordinate and the clip
	  // coordinate are transformed separately in order to reuse the eye coordinate below.


	  var mx = modelPoint[0],
	      my = modelPoint[1],
	      mz = modelPoint[2],
	      m = this.modelview,
	      ex = m[0] * mx + m[1] * my + m[2] * mz + m[3],
	      ey = m[4] * mx + m[5] * my + m[6] * mz + m[7],
	      ez = m[8] * mx + m[9] * my + m[10] * mz + m[11],
	      ew = m[12] * mx + m[13] * my + m[14] * mz + m[15]; // Transform the point from eye coordinates to clip coordinates.

	  var p = this.projection,
	      x = p[0] * ex + p[1] * ey + p[2] * ez + p[3] * ew,
	      y = p[4] * ex + p[5] * ey + p[6] * ez + p[7] * ew,
	      z = p[8] * ex + p[9] * ey + p[10] * ez + p[11] * ew,
	      w = p[12] * ex + p[13] * ey + p[14] * ez + p[15] * ew;

	  if (w === 0) {
	    return false;
	  } // Complete the conversion from model coordinates to clip coordinates by dividing by W. The resultant X, Y
	  // and Z coordinates are in the range [-1,1].


	  x /= w;
	  y /= w;
	  z /= w; // Clip the point against the near and far clip planes.

	  if (z < -1 || z > 1) {
	    return false;
	  } // Transform the Z eye coordinate to clip coordinates again, this time applying a depth offset. The depth
	  // offset is applied only to the matrix element affecting the projected Z coordinate, so we inline the
	  // computation here instead of re-computing X, Y, Z and W in order to improve performance. See
	  // Matrix.offsetProjectionDepth for more information on the effect of this offset.


	  z = p[8] * ex + p[9] * ey + p[10] * ez * (1 + depthOffset) + p[11] * ew;
	  z /= w; // Clamp the point to the near and far clip planes. We know the point's original Z value is contained within
	  // the clip planes, so we limit its offset z value to the range [-1, 1] in order to ensure it is not clipped
	  // by WebGL. In clip coordinates the near and far clip planes are perpendicular to the Z axis and are
	  // located at -1 and 1, respectively.

	  z = WWMath.clamp(z, -1, 1); // Convert the point from clip coordinates to the range [0, 1]. This enables the XY coordinates to be
	  // converted to screen coordinates, and the Z coordinate to represent a depth value in the range [0, 1].

	  x = x * 0.5 + 0.5;
	  y = y * 0.5 + 0.5;
	  z = z * 0.5 + 0.5; // Convert the X and Y coordinates from the range [0,1] to screen coordinates.

	  x = x * this.viewport.width + this.viewport.x;
	  y = y * this.viewport.height + this.viewport.y;
	  result[0] = x;
	  result[1] = y;
	  result[2] = z;
	  return true;
	};
	/**
	 * Converts a window-coordinate point to WebGL screen coordinates.
	 * <p>
	 * The specified point is understood to be in the window coordinate system of the WorldWindow, with the origin
	 * in the top-left corner and axes that extend down and to the right from the origin point.
	 * <p>
	 * The returned point is in WebGL screen coordinates, with the origin in the bottom-left corner and axes that
	 * extend up and to the right from the origin point.
	 *
	 * @param {Vec2} point The window-coordinate point to convert.
	 * @param {Vec2} result A pre-allocated {@link Vec2} in which to return the computed point.
	 * @returns {Vec2} The specified result argument set to the computed point.
	 * @throws {ArgumentError} If either argument is null or undefined.
	 */


	DrawContext.prototype.convertPointToViewport = function (point, result) {
	  if (!point) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "DrawContext", "convertPointToViewport", "missingPoint"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "DrawContext", "convertPointToViewport", "missingResult"));
	  }

	  result[0] = point[0];
	  result[1] = this.viewport.height - point[1];
	  return result;
	};
	/**
	 * Computes the approximate size of a pixel at a specified distance from the eye point.
	 * <p>
	 * This method assumes rectangular pixels, where pixel coordinates denote
	 * infinitely thin spaces between pixels. The units of the returned size are in model coordinates per pixel
	 * (usually meters per pixel). This returns 0 if the specified distance is zero. The returned size is undefined
	 * if the distance is less than zero.
	 *
	 * @param {Number} distance The distance from the eye point at which to determine pixel size, in model
	 * coordinates.
	 * @returns {Number} The approximate pixel size at the specified distance from the eye point, in model
	 * coordinates per pixel.
	 */


	DrawContext.prototype.pixelSizeAtDistance = function (distance) {
	  // Compute the pixel size from the width of a rectangle carved out of the frustum in model coordinates at
	  // the specified distance along the -Z axis and the viewport width in screen coordinates. The pixel size is
	  // expressed in model coordinates per screen coordinate (e.g. meters per pixel).
	  //
	  // The frustum width is determined by noticing that the frustum size is a linear function of distance from
	  // the eye point. The linear equation constants are determined during initialization, then solved for
	  // distance here.
	  //
	  // This considers only the frustum width by assuming that the frustum and viewport share the same aspect
	  // ratio, so that using either the frustum width or height results in the same pixel size.
	  return this.pixelSizeFactor * distance + this.pixelSizeOffset;
	};
	/**
	 * Propagates the values contained in a TextAttributes object to the currently attached TextRenderer
	 * {@link TextRenderer} as to provide format to a string of text. It first checks if the 2D texture is not
	 * already cached according to the text string and its attached TextAttributes {@link TextAttributes} state key.
	 * The TextRenderer then produces a 2D Texture with the aforementioned text and format to be used as a label
	 * for a Text {@link Text} subclass (<i>e.g.</i> Annotation {@link Annotation} or Placemark {@link Placemark}).
	 * @param {String} text The string of text that will be given color, font, and outline
	 * from which the resulting texture will be based on.
	 * @param {TextAttributes} textAttributes Attributes that will be applied to the string.
	 * See TextAttributes {@link TextAttributes}.
	 * @returns {Texture} A texture {@link Texture} with the specified text string, font, colors, and outline.
	 */


	DrawContext.prototype.createTextTexture = function (text, textAttributes) {
	  if (!text || !textAttributes) {
	    return null;
	  }

	  var textureKey = this.computeTextTextureStateKey(text, textAttributes);
	  var texture = this.gpuResourceCache.resourceForKey(textureKey);

	  if (!texture) {
	    this.textRenderer.textColor = textAttributes.color;
	    this.textRenderer.typeFace = textAttributes.font;
	    this.textRenderer.enableOutline = textAttributes.enableOutline;
	    this.textRenderer.outlineColor = textAttributes.outlineColor;
	    this.textRenderer.outlineWidth = textAttributes.outlineWidth;
	    texture = this.textRenderer.renderText(text);
	    this.gpuResourceCache.putResource(textureKey, texture, texture.size);
	    this.gpuResourceCache.setResourceAgingFactor(textureKey, 100); // age this texture 100x faster than normal resources (e.g., tiles)
	  }

	  return texture;
	};
	/**
	 * Computes a state key that relates to a text label, foregoing the TextAttributes {@link TextAttributes}
	 * properties that are not related to texture rendering (offset, scale, and depthTest).
	 * @param {String} text The label's string of text.
	 * @param {TextAttributes} attributes The TextAttributes object associated with the text label to render.
	 * @returns {String} A state key composed of the original string of text plus the TextAttributes associated
	 * with texture rendering.
	 */


	DrawContext.prototype.computeTextTextureStateKey = function (text, attributes) {
	  if (!text || !attributes) {
	    return null;
	  }

	  return text + "c " + attributes.color.toHexString(true) + " f " + attributes.font.toString() + " eo " + attributes.enableOutline + " ow " + attributes.outlineWidth + " oc " + attributes.outlineColor.toHexString(true);
	};
	/**
	 * Returns a WebGL extension and caches the result for subsequent calls.
	 *
	 * @param {String} extensionName The name of the WebGL extension.
	 * @returns {Object|null} A WebGL extension object, or null if the extension is not available.
	 * @throws {ArgumentError} If the argument is null or undefined.
	 */


	DrawContext.prototype.getExtension = function (extensionName) {
	  if (!extensionName) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "DrawContext", "getExtension", "missingExtensionName"));
	  }

	  if (!(extensionName in this.glExtensionsCache)) {
	    this.glExtensionsCache[extensionName] = this.currentGlContext.getExtension(extensionName) || null;
	  }

	  return this.glExtensionsCache[extensionName];
	};

	/**
	 * @exports GebcoElevationCoverage
	 */
	/**
	 * Constructs an Earth elevation coverage using GEBCO data.
	 * @alias GebcoElevationCoverage
	 * @constructor
	 * @augments TiledElevationCoverage
	 * @classdesc Provides elevations for Earth. Elevations are drawn from the NASA WorldWind elevation service.
	 */

	function GebcoElevationCoverage() {
	  TiledElevationCoverage.call(this, {
	    coverageSector: Sector.FULL_SPHERE,
	    resolution: 0.008333333333333,
	    retrievalImageFormat: "application/bil16",
	    minElevation: -11000,
	    maxElevation: 8850,
	    urlBuilder: new WmsUrlBuilder("https://worldwind26.arc.nasa.gov/elev", "GEBCO", "", "1.3.0")
	  });
	  this.displayName = "GEBCO Earth Elevation Coverage";
	}

	GebcoElevationCoverage.prototype = Object.create(TiledElevationCoverage.prototype);

	/**
	 * @exports UsgsNedElevationCoverage
	 */
	/**
	 * Constructs an Earth elevation coverage using USGS NED data.
	 * @alias UsgsNedElevationCoverage
	 * @constructor
	 * @augments TiledElevationCoverage
	 * @classdesc Provides elevations for Earth. Elevations are drawn from the NASA WorldWind elevation service.
	 */

	function UsgsNedElevationCoverage() {
	  // CONUS Extent: (-124.848974, 24.396308) - (-66.885444, 49.384358)
	  // TODO: Expand this extent to cover HI when the server NO_DATA value issue is resolved.
	  TiledElevationCoverage.call(this, {
	    coverageSector: new Sector(24.396308, 49.384358, -124.848974, -66.885444),
	    resolution: 0.000092592592593,
	    retrievalImageFormat: "application/bil16",
	    minElevation: -11000,
	    maxElevation: 8850,
	    urlBuilder: new WmsUrlBuilder("https://worldwind26.arc.nasa.gov/elev", "USGS-NED", "", "1.3.0")
	  });
	  this.displayName = "USGS NED Earth Elevation Coverage";
	}

	UsgsNedElevationCoverage.prototype = Object.create(TiledElevationCoverage.prototype);

	/**
	 * @exports UsgsNedHiElevationCoverage
	 */
	/**
	 * Constructs an Earth elevation coverage using USGS NED data.
	 * @alias UsgsNedHiElevationCoverage
	 * @constructor
	 * @augments TiledElevationCoverage
	 * @classdesc Provides elevations for Earth. Elevations are drawn from the NASA WorldWind elevation service.
	 */

	function UsgsNedHiElevationCoverage() {
	  // Hawaii Extent: (-178.443593, 18.865460) - (-154.755792, 28.517269)
	  // TODO: Remove this class when the server NO_DATA value issue is resolved.
	  TiledElevationCoverage.call(this, {
	    coverageSector: new Sector(18.865460, 28.517269, -178.443593, -154.755792),
	    resolution: 0.000092592592593,
	    retrievalImageFormat: "application/bil16",
	    minElevation: -11000,
	    maxElevation: 8850,
	    urlBuilder: new WmsUrlBuilder("https://worldwind26.arc.nasa.gov/elev", "USGS-NED", "", "1.3.0")
	  });
	  this.displayName = "USGS NED Hawaii Elevation Coverage";
	}

	UsgsNedHiElevationCoverage.prototype = Object.create(TiledElevationCoverage.prototype);

	/**
	 * @exports EarthElevationModel
	 */
	/**
	 * Constructs an EarthElevationModel consisting of three elevation coverages GEBCO, Aster V2, and USGS NED.
	 * @alias EarthElevationModel
	 * @constructor
	 */

	function EarthElevationModel() {
	  ElevationModel.call(this);
	  this.addCoverage(new GebcoElevationCoverage());
	  this.addCoverage(new AsterV2ElevationCoverage());
	  this.addCoverage(new UsgsNedElevationCoverage());
	  this.addCoverage(new UsgsNedHiElevationCoverage());
	}

	EarthElevationModel.prototype = Object.create(ElevationModel.prototype);

	/**
	 * @exports LevelRowColumnUrlBuilder
	 */
	/**
	 * Constructs a URL builder for level/row/column tiles.
	 * @alias LevelRowColumnUrlBuilder
	 * @constructor
	 * @classdesc Provides a factory to create URLs for level/row/column tile REST requests.
	 * <p>
	 * URLs are formed by appending the specified server address with the specified path and appending
	 * a path of the form <em>/level/row/row_column.image-format</em>, where image-format is the corresponding
	 * suffix to the image mime type specified when a URL is requested. For example, if the specified server
	 * address is <em>https://worldwind32.arc.nasa.gov</em> and the specified path-to-data is
	 * <em>../standalonedata/Earth/BlueMarble256</em>, and the requested tile's level, row and column are 0, 5 and 9
	 * respectively, and the image format is <em>image/jpeg</em>, the composed URL is
	 * <em>https://worldwind32.arc.nasa.gov/standalonedata/Earth/BlueMarble256/0/5/5_9.jpg</em>.
	 *
	 * @param {String} serverAddress The server address. May be null, in which case the address is assumed to be
	 * the current location (see <code>window.location</code>) minus the last path component.
	 * @param {String} pathToData The path to the dataset on the server. May be null or empty to indicate that
	 * the data is directly relative to the specified server address.
	 *
	 */

	function LevelRowColumnUrlBuilder(serverAddress, pathToData) {
	  /**
	   * The server address.
	   * @type {String}
	   */
	  this.serverAddress = serverAddress;

	  if (!serverAddress || serverAddress.length === 0) {
	    this.serverAddress = WWUtil.currentUrlSansFilePart();
	  }
	  /**
	   * The server-side path to the dataset.
	   * @type {String}
	   */


	  this.pathToData = pathToData;
	}
	/**
	 * Creates the URL string for a WMS Get Map request.
	 * @param {Tile} tile The tile for which to create the URL.
	 * @param {String} imageFormat The image format to request.
	 * @throws {ArgumentError} If the specified tile or image format are null or undefined.
	 */


	LevelRowColumnUrlBuilder.prototype.urlForTile = function (tile, imageFormat) {
	  if (!tile) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WmsUrlBuilder", "urlForTile", "missingTile"));
	  }

	  if (!imageFormat) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WmsUrlBuilder", "urlForTile", "The image format is null or undefined."));
	  }

	  var sb = this.serverAddress;

	  if (this.pathToData) {
	    sb = sb + "/" + this.pathToData;
	  }

	  sb = sb + "/" + tile.level.levelNumber.toString();
	  sb = sb + "/" + tile.row.toString();
	  sb = sb + "/" + tile.row.toString() + "_" + tile.column.toString();
	  sb = sb + "." + WWUtil.suffixForMimeType(imageFormat);
	  sb = sb.replace(" ", "%20");
	  return sb;
	};

	/**
	 * @exports EarthRestElevationCoverage
	 */
	/**
	 * Constructs an elevation coverage for Earth using a REST interface to retrieve the elevations from the server.
	 * @alias EarthRestElevationCoverage
	 * @constructor
	 * @classdesc Represents an Earth elevation coverage spanning the globe and using a REST interface to retrieve
	 * the elevations from the server.
	 * See [LevelRowColumnUrlBuilder]{@link LevelRowColumnUrlBuilder} for a description of the REST interface.
	 * @param {String} serverAddress The server address of the tile service. May be null, in which case the
	 * current origin is used (see <code>window.location</code>.
	 * @param {String} pathToData The path to the data directory relative to the specified server address.
	 * May be null, in which case the server address is assumed to be the full path to the data directory.
	 * @param {String} displayName The display name to associate with this elevation coverage.
	 */

	function EarthRestElevationCoverage(serverAddress, pathToData, displayName) {
	  TiledElevationCoverage.call(this, {
	    coverageSector: Sector.FULL_SPHERE,
	    resolution: 0.00732421875,
	    retrievalImageFormat: "application/bil16",
	    minElevation: -11000,
	    maxElevation: 8850,
	    urlBuilder: new LevelRowColumnUrlBuilder(serverAddress, pathToData)
	  });
	  this.displayName = displayName || "Earth Elevations"; // Override the default computed LevelSet. EarthRestElevationCoverage accesses a fixed set of tiles with
	  // a 60x60 top level tile delta, 5 levels, and tile dimensions of 512x512 pixels.

	  this.levels = new LevelSet(Sector.FULL_SPHERE, new Location(60, 60), 5, 512, 512);
	}

	EarthRestElevationCoverage.prototype = Object.create(TiledElevationCoverage.prototype);

	/**
	 * @exports AbstractShape
	 */
	/**
	 * Constructs an abstract shape instance. Meant to be called only by subclasses.
	 * @alias AbstractShape
	 * @constructor
	 * @augments Renderable
	 * @protected
	 * @classdesc Provides a base class for shapes other than surface shapes. Implements common attribute handling
	 * and rendering flow. This is an abstract class and is meant to be instantiated only by subclasses.
	 * <p>
	 *     In order to support simultaneous use of this shape by multiple windows and 2D globes, this shape
	 *     maintains a cache of data computed relative to the globe displayed in each window. During rendering,
	 *     the data for the currently active globe, as indicated in the draw context, is made current.
	 *     Subsequently called methods rely on the existence of this data cache entry.
	 *
	 * @param {ShapeAttributes} attributes The attributes to associate with this shape. May be null, in which case
	 * default attributes are associated.
	 */

	function AbstractShape(attributes) {
	  Renderable.call(this); // Documented with its property accessor below.

	  this._attributes = attributes ? attributes : new ShapeAttributes(null); // Documented with its property accessor below.

	  this._highlightAttributes = null;
	  /**
	   * Indicates whether this shape uses its normal attributes or its highlight attributes when displayed.
	   * If true, the highlight attributes are used, otherwise the normal attributes are used. The normal
	   * attributes are also used if no highlight attributes have been specified.
	   * @type {Boolean}
	   * @default false
	   */

	  this.highlighted = false; // Private. See defined property below for documentation.

	  this._altitudeMode = WorldWind.ABSOLUTE; // Internal use only. Intentionally not documented.
	  // A position used to compute relative coordinates for the shape.

	  this.referencePosition = null; // Internal use only. Intentionally not documented.
	  // Holds the per-globe data generated during makeOrderedRenderable.

	  this.shapeDataCache = new MemoryCache(3, 2); // Internal use only. Intentionally not documented.
	  // The shape-data-cache data that is for the currently active globe. This field is made current prior to
	  // calls to makeOrderedRenderable and doRenderOrdered.

	  this.currentData = null; // Internal use only. Intentionally not documented.

	  this.activeAttributes = null;
	  /**
	   * Indicates how long to use terrain-specific shape data before regenerating it, in milliseconds. A value
	   * of zero specifies that shape data should be regenerated every frame. While this causes the shape to
	   * adapt more frequently to the terrain, it decreases performance.
	   * @type {Number}
	   * @default 2000 (milliseconds)
	   */

	  this.expirationInterval = 2000;
	  /**
	   * Indicates whether to use a surface shape to represent this shape when drawn on a 2D globe.
	   * @type {Boolean}
	   * @default false
	   */

	  this.useSurfaceShapeFor2D = false;
	  this.scratchMatrix = Matrix.fromIdentity(); // scratch variable
	}

	AbstractShape.prototype = Object.create(Renderable.prototype);
	Object.defineProperties(AbstractShape.prototype, {
	  /**
	   * This shape's normal (non-highlight) attributes.
	   * @type {ShapeAttributes}
	   * @memberof AbstractShape.prototype
	   */
	  attributes: {
	    get: function () {
	      return this._attributes;
	    },
	    set: function (value) {
	      this._attributes = value;

	      if (this.surfaceShape) {
	        this.surfaceShape.attributes = this._attributes;
	      }
	    }
	  },

	  /**
	   * This shape's highlight attributes. If null or undefined and this shape's highlight flag is true, this
	   * shape's normal attributes are used. If they in turn are null or undefined, this shape is not drawn.
	   * @type {ShapeAttributes}
	   * @default null
	   * @memberof AbstractShape.prototype
	   */
	  highlightAttributes: {
	    get: function () {
	      return this._highlightAttributes;
	    },
	    set: function (value) {
	      this._highlightAttributes = value;

	      if (this.surfaceShape) {
	        this.surfaceShape.highlightAttributes = this._highlightAttributes;
	      }
	    }
	  },

	  /**
	   * The altitude mode to use when drawing this shape. Recognized values are:
	   * <ul>
	   *     <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	   *     <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	   *     <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	   * </ul>
	   * @type {String}
	   * @default WorldWind.ABSOLUTE
	   * @memberof AbstractShape.prototype
	   */
	  altitudeMode: {
	    get: function () {
	      return this._altitudeMode;
	    },
	    set: function (altitudeMode) {
	      if (!altitudeMode) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AbstractShape", "altitudeMode", "missingAltitudeMode"));
	      }

	      this._altitudeMode = altitudeMode;
	      this.reset();
	    }
	  }
	});
	/**
	 * Clears this shape's data cache. Should be called by subclasses when state changes invalidate
	 * cached data.
	 * @protected
	 */

	AbstractShape.prototype.reset = function () {
	  this.shapeDataCache.clear(false);
	  this.surfaceShape = null;
	};

	AbstractShape.prototype.updateSurfaceShape = function () {
	  // Synchronize this AbstractShape's properties with its SurfaceShape's properties. Note that the attributes
	  // and the highlightAttributes are synchronized separately.
	  this.surfaceShape.displayName = this.displayName;
	  this.surfaceShape.highlighted = this.highlighted;
	  this.surfaceShape.enabled = this.enabled;
	  this.surfaceShape.pathType = this.pathType;
	  this.surfaceShape.pickDelegate = this.pickDelegate ? this.pickDelegate : this;
	};

	AbstractShape.prototype.createSurfaceShape = function () {
	  return null;
	};

	AbstractShape.prototype.render = function (dc) {
	  if (!this.enabled) {
	    return;
	  }

	  if (!dc.accumulateOrderedRenderables) {
	    return;
	  }

	  if (dc.globe.is2D() && this.useSurfaceShapeFor2D) {
	    if (!this.surfaceShape) {
	      this.surfaceShape = this.createSurfaceShape();

	      if (this.surfaceShape) {
	        this.surfaceShape.attributes = this._attributes;
	        this.surfaceShape.highlightAttributes = this._highlightAttributes;
	      }
	    }

	    if (this.surfaceShape) {
	      this.updateSurfaceShape();
	      this.surfaceShape.render(dc);
	      return;
	    }
	  }

	  if (!dc.terrain && this.altitudeMode != WorldWind.ABSOLUTE) {
	    return;
	  }

	  this.establishCurrentData(dc);

	  if (dc.globe.projectionLimits && !this.isWithinProjectionLimits(dc)) {
	    return;
	  } // Use the last computed extent to see if this shape is out of view.


	  if (this.currentData.extent && !this.intersectsFrustum(dc)) {
	    return;
	  }

	  this.determineActiveAttributes(dc);

	  if (!this.activeAttributes) {
	    return;
	  }

	  var orderedRenderable = this.makeOrderedRenderable(dc);

	  if (orderedRenderable) {
	    // Use the updated extent to see if this shape is out of view.
	    if (!this.intersectsFrustum(dc)) {
	      return;
	    }

	    if (dc.isSmall(this.currentData.extent, 1)) {
	      return;
	    }

	    orderedRenderable.layer = dc.currentLayer;
	    dc.addOrderedRenderable(orderedRenderable, this.currentData.eyeDistance);
	  }
	};
	/**
	 * Draws this shape during ordered rendering. Implements the {@link OrderedRenderable} interface.
	 * This method is called by the WorldWindow and is not intended to be called by applications.
	 * @param {DrawContext} dc The current draw context.
	 */


	AbstractShape.prototype.renderOrdered = function (dc) {
	  this.currentData = this.shapeDataCache.entryForKey(dc.globeStateKey);
	  this.beginDrawing(dc);

	  try {
	    this.doRenderOrdered(dc);
	  } finally {
	    this.endDrawing(dc);
	  }
	}; // Internal. Intentionally not documented.


	AbstractShape.prototype.makeOrderedRenderable = function (dc) {
	  var or = this.doMakeOrderedRenderable(dc);
	  this.currentData.verticalExaggeration = dc.verticalExaggeration;
	  return or;
	};
	/**
	 * Called during rendering. Subclasses must override this method with one that creates and enques an
	 * ordered renderable for this shape if this shape is to be displayed. Applications do not call this method.
	 * @param {DrawContext} dc The current draw context.
	 * @protected
	 */


	AbstractShape.prototype.doMakeOrderedRenderable = function (dc) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AbstractShape", "makeOrderedRenderable", "abstractInvocation"));
	};
	/**
	 * Called during ordered rendering. Subclasses must override this method to render the shape using the current
	 * shape data.
	 * @param {DrawContext} dc The current draw context.
	 * @protected
	 */


	AbstractShape.prototype.doRenderOrdered = function (dc) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AbstractShape", "doRenderOrdered", "abstractInvocation"));
	};
	/**
	 * Called during ordered rendering. Subclasses may override this method in order to perform operations prior
	 * to drawing the shape. Applications do not call this method.
	 * @param {DrawContext} dc The current draw context.
	 * @protected
	 */


	AbstractShape.prototype.beginDrawing = function (dc) {};
	/**
	 * Called during ordered rendering. Subclasses may override this method in order to perform operations after
	 * the shape is drawn. Applications do not call this method.
	 * @param {DrawContext} dc The current draw context.
	 * @protected
	 */


	AbstractShape.prototype.endDrawing = function (dc) {}; // Internal. Intentionally not documented.


	AbstractShape.prototype.intersectsFrustum = function (dc) {
	  if (this.currentData && this.currentData.extent) {
	    if (dc.pickingMode) {
	      return this.currentData.extent.intersectsFrustum(dc.pickFrustum);
	    } else {
	      return this.currentData.extent.intersectsFrustum(dc.frustumInModelCoordinates);
	    }
	  } else {
	    return true;
	  }
	}; // Internal. Intentionally not documented.


	AbstractShape.prototype.establishCurrentData = function (dc) {
	  this.currentData = this.shapeDataCache.entryForKey(dc.globeStateKey);

	  if (!this.currentData) {
	    this.currentData = this.createShapeDataObject();
	    this.resetExpiration(this.currentData);
	    this.shapeDataCache.putEntry(dc.globeStateKey, this.currentData, 1);
	  }

	  this.currentData.isExpired = !this.isShapeDataCurrent(dc, this.currentData);
	};
	/**
	 * Creates a new shape data object for the current globe state. Subclasses may override this method to
	 * modify the shape data object that this method creates, but must also call this method on this base class.
	 * Applications do not call this method.
	 * @returns {Object} The shape data object.
	 * @protected
	 */


	AbstractShape.prototype.createShapeDataObject = function () {
	  return {
	    transformationMatrix: Matrix.fromIdentity(),
	    referencePoint: new Vec3$1(0, 0, 0)
	  };
	}; // Intentionally not documented.


	AbstractShape.prototype.resetExpiration = function (shapeData) {
	  // The random addition in the line below prevents all shapes from regenerating during the same frame.
	  shapeData.expiryTime = Date.now() + this.expirationInterval + 1e3 * Math.random();
	};
	/**
	 * Indicates whether a specified shape data object is current. Subclasses may override this method to add
	 * criteria indicating whether the shape data object is current, but must also call this method on this base
	 * class. Applications do not call this method.
	 * @param {DrawContext} dc The current draw context.
	 * @param {Object} shapeData The object to validate.
	 * @returns {Boolean} true if the object is current, otherwise false.
	 * @protected
	 */


	AbstractShape.prototype.isShapeDataCurrent = function (dc, shapeData) {
	  return shapeData.verticalExaggeration === dc.verticalExaggeration && shapeData.expiryTime > Date.now();
	}; // Internal. Intentionally not documented.


	AbstractShape.prototype.determineActiveAttributes = function (dc) {
	  if (this.highlighted && this._highlightAttributes) {
	    this.activeAttributes = this.highlightAttributes;
	  } else {
	    this.activeAttributes = this._attributes;
	  }
	};
	/**
	 * Indicates whether this shape is within the current globe's projection limits. Subclasses may implement
	 * this method to perform the test. The default implementation returns true. Applications do not call this
	 * method.
	 * @param {DrawContext} dc The current draw context.
	 * @returns {Boolean} true if this shape is is within or intersects the current globe's projection limits,
	 * otherwise false.
	 * @protected
	 */


	AbstractShape.prototype.isWithinProjectionLimits = function (dc) {
	  return true;
	};
	/**
	 * Apply the current navigator's model-view-projection matrix.
	 * @param {DrawContext} dc The current draw context.
	 * @protected
	 */


	AbstractShape.prototype.applyMvpMatrix = function (dc) {
	  this.scratchMatrix.copy(dc.modelviewProjection);
	  this.scratchMatrix.multiplyMatrix(this.currentData.transformationMatrix);
	  dc.currentProgram.loadModelviewProjection(dc.currentGlContext, this.scratchMatrix);
	};
	/**
	 * Apply the current navigator's model-view-projection matrix with an offset to make this shape's outline
	 * stand out.
	 * @param {DrawContext} dc The current draw context.
	 * @protected
	 */


	AbstractShape.prototype.applyMvpMatrixForOutline = function (dc) {
	  // Causes the outline to stand out from the interior.
	  this.scratchMatrix.copy(dc.projection);
	  this.scratchMatrix.offsetProjectionDepth(-0.001);
	  this.scratchMatrix.multiplyMatrix(dc.modelview);
	  this.scratchMatrix.multiplyMatrix(this.currentData.transformationMatrix);
	  dc.currentProgram.loadModelviewProjection(dc.currentGlContext, this.scratchMatrix);
	};

	/**
	 * @exports AbstractMesh
	 */
	/**
	 * Constructs an abstract mesh. Applications do not call this constructor. It is called only by subclasses of
	 * this abstract class.
	 * @alias AbstractMesh
	 * @constructor
	 * @augments AbstractShape
	 * @classdesc Provides an abstract base class for mesh shapes.
	 *
	 * @param {ShapeAttributes} attributes The attributes to associate with this mesh. May be null, in which case
	 * default attributes are associated.
	 */

	function AbstractMesh(attributes) {
	  AbstractShape.call(this, attributes);
	  /**
	   * Indicates whether this mesh is pickable when the pick point intersects transparent pixels of the
	   * image applied to this mesh. If no image is applied to this mesh, this property is ignored. If this
	   * property is true and an image with fully transparent pixels is applied to the mesh, the mesh is
	   * pickable at those transparent pixels, otherwise this mesh is not pickable at those transparent pixels.
	   * @type {Boolean}
	   * @default true
	   */

	  this.pickTransparentImagePixels = true; // Private. Documentation is with the defined property below.

	  this._altitudeScale = 1;
	}

	AbstractMesh.prototype = Object.create(AbstractShape.prototype);
	Object.defineProperties(AbstractMesh.prototype, {
	  /**
	   * Scales the altitudes of this mesh.
	   * @type {Number}
	   * @default 1
	   * @memberof AbstractMesh.prototype
	   */
	  altitudeScale: {
	    get: function () {
	      return this._altitudeScale;
	    },
	    set: function (value) {
	      this._altitudeScale = value;
	      this.reset();
	    }
	  }
	}); // Internal. Determines whether this shape's geometry must be re-computed.

	AbstractMesh.prototype.mustGenerateGeometry = function (dc) {
	  if (!this.currentData.meshPoints) {
	    return true;
	  }

	  if (this.currentData.drawInterior !== this.activeAttributes.drawInterior) {
	    return true;
	  }

	  if (this.activeAttributes.applyLighting && !this.currentData.normals) {
	    return true;
	  }

	  if (this.altitudeMode === WorldWind.ABSOLUTE) {
	    return false;
	  }

	  return this.currentData.isExpired;
	}; // Overridden from AbstractShape base class.


	AbstractMesh.prototype.doMakeOrderedRenderable = function (dc) {
	  if (!this.activeAttributes.drawInterior && !this.activeAttributes.drawOutline) {
	    return null;
	  } // See if the current shape data can be re-used.


	  if (!this.mustGenerateGeometry(dc)) {
	    return this;
	  }

	  var currentData = this.currentData; // Set the transformation matrix to correspond to the reference position.

	  var refPt = currentData.referencePoint;
	  dc.surfacePointForMode(this.referencePosition.latitude, this.referencePosition.longitude, this.referencePosition.altitude * this._altitudeScale, this._altitudeMode, refPt);
	  currentData.transformationMatrix.setToTranslation(refPt[0], refPt[1], refPt[2]); // Convert the geographic coordinates to the Cartesian coordinates that will be rendered.

	  currentData.meshPoints = this.computeMeshPoints(dc, currentData);
	  currentData.refreshVertexBuffer = true; // Capture texture coordinates in a parallel array to the mesh points. These are associated with this
	  // shape, itself, because they're independent of elevation or globe state.

	  if (this.activeAttributes.imageSource && !this.texCoords) {
	    this.texCoords = this.computeTexCoords();

	    if (this.texCoords) {
	      currentData.refreshTexCoordBuffer = true;
	    }
	  } // Compute the mesh and outline indices. These are associated with this shape, itself, because they're
	  // independent of elevation and globe state.


	  if (!this.meshIndices) {
	    this.meshIndices = this.computeMeshIndices();
	    currentData.refreshMeshIndices = true;
	  }

	  if (!this.meshOutlineIndices) {
	    this.meshOutlineIndices = this.computeOutlineIndices();

	    if (this.meshOutlineIndices) {
	      currentData.refreshOutlineIndices = true;
	    }
	  }

	  if (this.activeAttributes.applyLighting) {
	    this.computeNormals(currentData);
	  }

	  currentData.drawInterior = this.activeAttributes.drawInterior; // remember for validation

	  this.resetExpiration(currentData); // Create the extent from the Cartesian points. Those points are relative to this path's reference point,
	  // so translate the computed extent to the reference point.

	  if (!currentData.extent) {
	    currentData.extent = new BoundingBox();
	  }

	  currentData.extent.setToPoints(currentData.meshPoints);
	  currentData.extent.translate(currentData.referencePoint);
	  return this;
	}; // Private. Intentionally not documented.

	/**
	 * Computes this mesh's Cartesian points. Called by this abstract class during rendering to compute
	 * Cartesian points from geographic positions. This method must be overridden by subclasses. An
	 * exception is thrown if it is not.
	 *
	 * This method must also assign currentData.eyeDistance to be the minimum distance from this mesh to the
	 * current eye point.
	 *
	 * @param {DrawContext} dc The current draw context.
	 * @param {{}} currentData The current data for this shape.
	 * @returns {Float32Array} The Cartesian mesh points.
	 * @protected
	 */


	AbstractMesh.prototype.computeMeshPoints = function (dc, currentData) {
	  throw new UnsupportedOperationError(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AbstractMesh", "computeMeshPoints", "abstractInvocation"));
	}; // Intentionally not documented.

	/**
	 * Computes the texture coordinates for this shape. Called by this abstract class during rendering to copy or
	 * compute texture coordinates into a typed array. Subclasses should implement this method if the shape they
	 * define has texture coordinates. The default implementation returns null.
	 *
	 * @returns {Float32Array} The texture coordinates.
	 * @protected
	 */


	AbstractMesh.prototype.computeTexCoords = function () {
	  // Default implementation does nothing.
	  return null;
	};
	/**
	 * Computes or copies the indices of this mesh into a Uint16Array. Subclasses must implement this method.
	 * An exception is thrown if it is not implemented.
	 * @param {{}} currentData This shape's current data.
	 * @protected
	 */


	AbstractMesh.prototype.computeMeshIndices = function (currentData) {
	  throw new UnsupportedOperationError(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "AbstractMesh", "computeMeshIndices", "abstractInvocation"));
	};
	/**
	 * Computes or copies the outline indices of this mesh into a Uint16Array. Subclasses must implement this
	 * method if they have outlines. The default implementation returns null.
	 * @param {{}} currentData This shape's current data.
	 * @protected
	 */


	AbstractMesh.prototype.computeOutlineIndices = function (currentData) {// Default implementation does nothing.
	}; // Internal. Intentionally not documented.


	AbstractMesh.prototype.computeNormals = function (currentData) {
	  var normalsBuffer = new Float32Array(currentData.meshPoints.length),
	      indices = this.meshIndices,
	      vertices = currentData.meshPoints,
	      normals = [],
	      triPoints = [new Vec3$1(0, 0, 0), new Vec3$1(0, 0, 0), new Vec3$1(0, 0, 0)],
	      k; // For each triangle, compute its normal assign it to each participating index.

	  for (var i = 0; i < indices.length; i += 3) {
	    for (var j = 0; j < 3; j++) {
	      k = indices[i + j];
	      triPoints[j].set(vertices[3 * k], vertices[3 * k + 1], vertices[3 * k + 2]);
	    }

	    var n = Vec3$1.computeTriangleNormal(triPoints[0], triPoints[1], triPoints[2]);

	    for (j = 0; j < 3; j++) {
	      k = indices[i + j];

	      if (!normals[k]) {
	        normals[k] = [];
	      }

	      normals[k].push(n);
	    }
	  } // Average the normals associated with each index and add the result to the normals buffer.


	  n = new Vec3$1(0, 0, 0);

	  for (i = 0; i < normals.length; i++) {
	    if (normals[i]) {
	      Vec3$1.average(normals[i], n);
	      n.normalize();
	      normalsBuffer[i * 3] = n[0];
	      normalsBuffer[i * 3 + 1] = n[1];
	      normalsBuffer[i * 3 + 2] = n[2];
	    } else {
	      normalsBuffer[i * 3] = 0;
	      normalsBuffer[i * 3 + 1] = 0;
	      normalsBuffer[i * 3 + 2] = 0;
	    }
	  }

	  currentData.normals = normalsBuffer;
	  currentData.refreshNormalsBuffer = true;
	}; // Overridden from AbstractShape base class.


	AbstractMesh.prototype.doRenderOrdered = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram,
	      currentData = this.currentData,
	      hasTexture = this.texCoords && !!this.activeAttributes.imageSource,
	      vboId,
	      color,
	      pickColor,
	      textureBound;

	  if (dc.pickingMode) {
	    pickColor = dc.uniquePickColor();
	  } // Load the vertex data since both the interior and outline use it.


	  if (!currentData.pointsVboCacheKey) {
	    currentData.pointsVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	  }

	  vboId = dc.gpuResourceCache.resourceForKey(currentData.pointsVboCacheKey);

	  if (!vboId) {
	    vboId = gl.createBuffer();
	    dc.gpuResourceCache.putResource(currentData.pointsVboCacheKey, vboId, currentData.meshPoints.length * 4);
	    currentData.refreshVertexBuffer = true;
	  }

	  gl.bindBuffer(gl.ARRAY_BUFFER, vboId);

	  if (currentData.refreshVertexBuffer) {
	    gl.bufferData(gl.ARRAY_BUFFER, currentData.meshPoints, gl.STATIC_DRAW);
	    dc.frameStatistics.incrementVboLoadCount(1);
	    currentData.refreshVertexBuffer = false;
	  }

	  gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	  program.loadTextureEnabled(gl, false); // Draw the mesh if the interior requested.

	  if (this.activeAttributes.drawInterior) {
	    var applyLighting = !dc.pickingMode && currentData.normals && this.activeAttributes.applyLighting;
	    this.applyMvpMatrix(dc);

	    if (!currentData.meshIndicesVboCacheKey) {
	      currentData.meshIndicesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	    }

	    vboId = dc.gpuResourceCache.resourceForKey(currentData.meshIndicesVboCacheKey);

	    if (!vboId) {
	      vboId = gl.createBuffer();
	      dc.gpuResourceCache.putResource(currentData.meshIndicesVboCacheKey, vboId, this.meshIndices.length * 2);
	      currentData.refreshMeshIndices = true;
	    }

	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);

	    if (currentData.refreshMeshIndices) {
	      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.meshIndices, gl.STATIC_DRAW);
	      dc.frameStatistics.incrementVboLoadCount(1);
	      currentData.refreshMeshIndices = false;
	    }

	    color = this.activeAttributes.interiorColor; // Disable writing the shape's fragments to the depth buffer when the interior is semi-transparent.

	    gl.depthMask(color.alpha * this.layer.opacity >= 1 || dc.pickingMode);
	    program.loadColor(gl, dc.pickingMode ? pickColor : color);
	    program.loadOpacity(gl, dc.pickingMode ? 1 : this.layer.opacity);

	    if (hasTexture && (!dc.pickingMode || !this.pickTransparentImagePixels)) {
	      this.activeTexture = dc.gpuResourceCache.resourceForKey(this.activeAttributes.imageSource);

	      if (!this.activeTexture) {
	        this.activeTexture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this.activeAttributes.imageSource);
	      }

	      textureBound = this.activeTexture && this.activeTexture.bind(dc);

	      if (textureBound) {
	        if (!currentData.texCoordsVboCacheKey) {
	          currentData.texCoordsVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	        }

	        vboId = dc.gpuResourceCache.resourceForKey(currentData.texCoordsVboCacheKey);

	        if (!vboId) {
	          vboId = gl.createBuffer();
	          dc.gpuResourceCache.putResource(currentData.texCoordsVboCacheKey, vboId, this.texCoords.length * 4);
	          currentData.refreshTexCoordBuffer = true;
	        }

	        gl.bindBuffer(gl.ARRAY_BUFFER, vboId);

	        if (currentData.refreshTexCoordBuffer) {
	          gl.bufferData(gl.ARRAY_BUFFER, this.texCoords, gl.STATIC_DRAW);
	          dc.frameStatistics.incrementVboLoadCount(1);
	          currentData.refreshTexCoordBuffer = false;
	        }

	        gl.enableVertexAttribArray(program.vertexTexCoordLocation);
	        gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	        this.scratchMatrix.setToIdentity();
	        this.scratchMatrix.multiplyByTextureTransform(this.activeTexture);
	        program.loadTextureEnabled(gl, true);
	        program.loadTextureUnit(gl, gl.TEXTURE0);
	        program.loadTextureMatrix(gl, this.scratchMatrix);
	        program.loadModulateColor(gl, dc.pickingMode);
	      }
	    } // Apply lighting.


	    if (applyLighting) {
	      program.loadApplyLighting(gl, true);

	      if (!currentData.normalsVboCacheKey) {
	        currentData.normalsVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	      }

	      vboId = dc.gpuResourceCache.resourceForKey(currentData.normalsVboCacheKey);

	      if (!vboId) {
	        vboId = gl.createBuffer();
	        dc.gpuResourceCache.putResource(currentData.normalsVboCacheKey, vboId, currentData.normals.length * 4);
	        currentData.refreshNormalsBuffer = true;
	      }

	      gl.bindBuffer(gl.ARRAY_BUFFER, vboId);

	      if (currentData.refreshNormalsBuffer) {
	        gl.bufferData(gl.ARRAY_BUFFER, currentData.normals, gl.STATIC_DRAW);
	        dc.frameStatistics.incrementVboLoadCount(1);
	        currentData.refreshNormalsBuffer = false;
	      }

	      gl.enableVertexAttribArray(program.normalVectorLocation);
	      gl.vertexAttribPointer(program.normalVectorLocation, 3, gl.FLOAT, false, 0, 0);
	    }

	    gl.drawElements(gl.TRIANGLES, this.meshIndices.length, gl.UNSIGNED_SHORT, 0);

	    if (hasTexture) {
	      gl.disableVertexAttribArray(program.vertexTexCoordLocation);
	    }

	    if (applyLighting) {
	      program.loadApplyLighting(gl, false);
	      gl.disableVertexAttribArray(program.normalVectorLocation);
	    }
	  } // Draw the outline.


	  if (this.activeAttributes.drawOutline && this.meshOutlineIndices) {
	    program.loadTextureEnabled(gl, false);
	    gl.disableVertexAttribArray(program.vertexTexCoordLocation); // we're not texturing in this clause
	    // Make the outline stand out from the interior.

	    this.applyMvpMatrixForOutline(dc);
	    color = this.activeAttributes.outlineColor; // Disable writing the shape's fragments to the depth buffer when the interior is
	    // semi-transparent.

	    gl.depthMask(color.alpha * this.layer.opacity >= 1 || dc.pickingMode);
	    program.loadColor(gl, dc.pickingMode ? pickColor : color);
	    program.loadOpacity(gl, dc.pickingMode ? 1 : this.layer.opacity);
	    gl.lineWidth(this.activeAttributes.outlineWidth);

	    if (!currentData.outlineIndicesVboCacheKey) {
	      currentData.outlineIndicesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	    }

	    vboId = dc.gpuResourceCache.resourceForKey(currentData.outlineIndicesVboCacheKey);

	    if (!vboId) {
	      vboId = gl.createBuffer();
	      dc.gpuResourceCache.putResource(currentData.outlineIndicesVboCacheKey, vboId, this.meshOutlineIndices.length * 2);
	      currentData.refreshOutlineIndices = true;
	    }

	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);

	    if (currentData.refreshOutlineIndices) {
	      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.meshOutlineIndices, gl.STATIC_DRAW);
	      dc.frameStatistics.incrementVboLoadCount(1);
	      currentData.refreshOutlineIndices = false;
	    }

	    gl.drawElements(gl.LINE_STRIP, this.meshOutlineIndices.length, gl.UNSIGNED_SHORT, 0);
	  }

	  if (dc.pickingMode) {
	    var pickPosition = this.computePickPosition(dc);
	    var po = new PickedObject(pickColor, this.pickDelegate ? this.pickDelegate : this, pickPosition, this.layer, false);
	    dc.resolvePick(po);
	  }
	};

	AbstractMesh.prototype.computePickPosition = function (dc) {
	  var currentData = this.currentData,
	      line = dc.pickRay,
	      localLineOrigin = new Vec3$1(line.origin[0], line.origin[1], line.origin[2]).subtract(currentData.referencePoint),
	      localLine = new Line(localLineOrigin, line.direction),
	      intersectionPoints = [];

	  if (WWMath.computeIndexedTrianglesIntersection(localLine, currentData.meshPoints, this.meshIndices, intersectionPoints)) {
	    var iPoint = intersectionPoints[0];

	    if (intersectionPoints.length > 1) {
	      // Find the intersection nearest the eye point.
	      var distance2 = iPoint.distanceToSquared(dc.eyePoint);

	      for (var i = 1; i < intersectionPoints.length; i++) {
	        var d2 = intersectionPoints[i].distanceToSquared(dc.eyePoint);

	        if (d2 < distance2) {
	          distance2 = d2;
	          iPoint = intersectionPoints[i];
	        }
	      }
	    }

	    var pos = new Position(0, 0, 0);
	    dc.globe.computePositionFromPoint(iPoint[0] + currentData.referencePoint[0], iPoint[1] + currentData.referencePoint[1], iPoint[2] + currentData.referencePoint[2], pos);
	    pos.altitude /= this._altitudeScale;
	    return pos;
	  }

	  return null;
	}; // Overridden from AbstractShape base class.


	AbstractMesh.prototype.beginDrawing = function (dc) {
	  var gl = dc.currentGlContext;

	  if (this.activeAttributes.drawInterior) {
	    gl.disable(gl.CULL_FACE);
	    dc.findAndBindProgram(BasicTextureProgram);
	    var applyLighting = !dc.pickMode && this.currentData.normals && this.activeAttributes.applyLighting;

	    if (applyLighting) {
	      dc.currentProgram.loadModelviewInverse(gl, dc.modelviewNormalTransform);
	    }
	  }

	  gl.enableVertexAttribArray(dc.currentProgram.vertexPointLocation);
	}; // Overridden from AbstractShape base class.


	AbstractMesh.prototype.endDrawing = function (dc) {
	  var gl = dc.currentGlContext;
	  gl.disableVertexAttribArray(dc.currentProgram.vertexPointLocation);
	  gl.depthMask(true);
	  gl.lineWidth(1);
	  gl.enable(gl.CULL_FACE);
	};

	/**
	 * @exports SurfacePolygon
	 */
	/**
	 * Constructs a surface polygon.
	 * @alias SurfacePolygon
	 * @constructor
	 * @augments SurfaceShape
	 * @classdesc Represents a polygon draped over the terrain surface. The polygon may have multiple boundaries in
	 * order to define holes or empty regions.
	 * <p>
	 * SurfacePolygon uses the following attributes from its associated shape attributes bundle:
	 * <ul>
	 *         <li>Draw interior</li>
	 *         <li>Draw outline</li>
	 *         <li>Interior color</li>
	 *         <li>Outline color</li>
	 *         <li>Outline width</li>
	 *         <li>Outline stipple factor</li>
	 *         <li>Outline stipple pattern</li>
	 * </ul>
	 * @param {Array} boundaries The polygons boundary locations. If this argument is an array of
	 * [Locations]{@link Location} they define this polygon's outer boundary. If it is an array of arrays of
	 * Locations then each array entry defines one of this polygon's boundaries.
	 * @param {ShapeAttributes} attributes The attributes to apply to this shape. May be null, in which case
	 * attributes must be set directly before the shape is drawn.
	 *
	 * @throws {ArgumentError} If the specified boundaries are null or undefined.
	 */

	function SurfacePolygon(boundaries, attributes) {
	  if (!Array.isArray(boundaries)) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfacePolygon", "constructor", "The specified boundary is not an array."));
	  }

	  SurfaceShape.call(this, attributes);
	  this._boundaries = boundaries;
	  this._stateId = SurfacePolygon.stateId++;
	}

	SurfacePolygon.prototype = Object.create(SurfaceShape.prototype);
	Object.defineProperties(SurfacePolygon.prototype, {
	  /**
	   * This polygon's boundaries. The polygons boundary locations. If this argument is an array of
	   * [Locations]{@link Location} they define this polygon's outer boundary. If it is an array of arrays of
	   * Locations then each array entry defines one of this polygon's boundaries.
	   * @type {Location[][] | Location[]}
	   * @memberof SurfacePolygon.prototype
	   */
	  boundaries: {
	    get: function () {
	      return this._boundaries;
	    },
	    set: function (boundaries) {
	      if (!Array.isArray(boundaries)) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfacePolygon", "set boundaries", "The specified value is not an array."));
	      }

	      this.resetBoundaries();
	      this._boundaries = boundaries;
	      this._stateId = SurfacePolygon.stateId++;
	      this.stateKeyInvalid = true;
	    }
	  }
	}); // Internal use only. Intentionally not documented.

	SurfacePolygon.stateId = Number.MIN_SAFE_INTEGER; // Internal use only. Intentionally not documented.

	SurfacePolygon.staticStateKey = function (shape) {
	  var shapeStateKey = SurfaceShape.staticStateKey(shape);
	  return shapeStateKey + " pg " + shape._stateId;
	}; // Internal use only. Intentionally not documented.


	SurfacePolygon.prototype.computeStateKey = function () {
	  return SurfacePolygon.staticStateKey(this);
	}; // Internal. Polygon doesn't generate its own boundaries. See SurfaceShape.prototype.computeBoundaries.


	SurfacePolygon.prototype.computeBoundaries = function (dc) {}; // Internal use only. Intentionally not documented.


	SurfacePolygon.prototype.getReferencePosition = function () {
	  // Assign the first position as the reference position.
	  if (this.boundaries.length > 0 && this.boundaries[0].length > 2) {
	    return this.boundaries[0][0];
	  } else if (this.boundaries.length > 2) {
	    return this.boundaries[0];
	  } else {
	    return null;
	  }
	}; // Internal use only. Intentionally not documented.


	SurfacePolygon.prototype.moveTo = function (globe, position) {
	  if (this.boundaries.length > 0 && this.boundaries[0].length > 2) {
	    var boundaries = [];

	    for (var i = 0, len = this._boundaries.length; i < len; i++) {
	      var locations = this.computeShiftedLocations(globe, this.getReferencePosition(), position, this._boundaries[i]);
	      boundaries.push(locations);
	    }

	    this.boundaries = boundaries;
	  } else if (this.boundaries.length > 2) {
	    this.boundaries = this.computeShiftedLocations(globe, this.getReferencePosition(), position, this._boundaries);
	  }
	};

	/**
	 * @exports GeographicMesh
	 */
	/**
	 * Constructs a geographic mesh.
	 * @alias GeographicMesh
	 * @constructor
	 * @augments AbstractMesh
	 * @classdesc Represents a 3D geographic mesh.
	 * <p>
	 *     Altitudes within the mesh's positions are interpreted according to the mesh's altitude mode, which
	 *     can be one of the following:
	 * <ul>
	 *     <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	 *     <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	 *     <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	 * </ul>
	 * If the latter, the mesh positions' altitudes are ignored. (If the mesh should be draped onto the
	 * terrain, you might want to use {@link SurfacePolygon} instead.)
	 * <p>
	 *     Meshes have separate attributes for normal display and highlighted display. They use the interior and
	 *     outline attributes of {@link ShapeAttributes}. If those attributes identify an image, that image is
	 *     applied to the mesh. Texture coordinates for the image may be specified, but if not specified the full
	 *     image is stretched over the full mesh. If texture coordinates are specified, there must be one texture
	 *     coordinate for each vertex in the mesh.
	 *
	 * @param {Position[][]} positions A two-dimensional array containing the mesh vertices.
	 * Each entry of the array specifies the vertices of one row of the mesh. The arrays for all rows must
	 * have the same length. There must be at least two rows, and each row must have at least two vertices.
	 * There must be no more than 65536 positions.
	 * @param {ShapeAttributes} attributes The attributes to associate with this mesh. May be null, in which case
	 * default attributes are associated.
	 *
	 * @throws {ArgumentError} If the specified positions array is null or undefined, the number of rows or the
	 * number of vertices per row is less than 2, the array lengths are inconsistent, or too many positions are
	 * specified (limit is 65536).
	 */

	function GeographicMesh(positions, attributes) {
	  if (!positions) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicMesh", "constructor", "missingPositions"));
	  }

	  if (positions.length < 2 || positions[0].length < 2) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicMesh", "constructor", "Number of positions is insufficient."));
	  } // Check for size limit, which is the max number of available indices for a 16-bit unsigned int.


	  if (positions.length * positions[0].length > 65536) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicMesh", "constructor", "Too many positions. Must be fewer than 65536. Try using multiple meshes."));
	  }

	  var length = positions[0].length;

	  for (var i = 1; i < positions.length; i++) {
	    if (positions[i].length !== length) {
	      throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicMesh", "constructor", "Array lengths are inconsistent."));
	    }
	  }

	  var numRows = positions.length,
	      numCols = positions[0].length;
	  AbstractMesh.call(this, attributes);
	  /**
	   * Indicates whether this mesh is pickable when the pick point intersects transparent pixels of the
	   * image applied to this mesh. If no image is applied to this mesh, this property is ignored. If this
	   * property is true and an image with fully transparent pixels is applied to the mesh, the mesh is
	   * pickable at those transparent pixels, otherwise this mesh is not pickable at those transparent pixels.
	   * @type {Boolean}
	   * @default true
	   */

	  this.pickTransparentImagePixels = true; // Private. Documentation is with the defined property below and the constructor description above.

	  this._positions = positions; // Private. Documentation is with the defined property below.

	  this._altitudeScale = 1; // Internal. Intentionally not documented.

	  this.numRows = numRows;
	  this.numColumns = numCols; // Internal. Intentionally not documented.

	  this._textureCoordinates = null; // Internal. Intentionally not documented.

	  this.referencePosition = this.determineReferencePosition(this._positions);
	}

	GeographicMesh.prototype = Object.create(AbstractMesh.prototype);
	Object.defineProperties(GeographicMesh.prototype, {
	  /**
	   * This mesh's positions. Each array in the positions array specifies the geographic positions of one
	   * row of the mesh.
	   *
	   * @type {Position[][]}
	   * @memberof GeographicMesh.prototype
	   */
	  positions: {
	    get: function () {
	      return this._positions;
	    },
	    set: function (positions) {
	      if (!positions) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicMesh", "positions", "missingPositions"));
	      }

	      if (positions.length < 2 || positions[0].length < 2) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicMesh", "positions", "Number of positions is insufficient."));
	      }

	      var length = positions[0].length;

	      for (var i = 1; i < positions.length; i++) {
	        if (positions[i].length !== length) {
	          throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicMesh", "positions", "Array lengths are inconsistent."));
	        }
	      }

	      this.numRows = positions.length;
	      this.numColumns = positions[0].length;
	      this._positions = positions;
	      this.referencePosition = this.determineReferencePosition(this._positions);
	      this.reset();
	      this.meshIndices = null;
	      this.outlineIndices = null;
	    }
	  },

	  /**
	   * This mesh's texture coordinates if this mesh is textured. A texture coordinate must be
	   * provided for each mesh position. The texture coordinates are specified as a two-dimensional array,
	   * each entry of which specifies the texture coordinates for one row of the mesh. Each texture coordinate
	   * is a {@link Vec2} containing the s and t coordinates. If no texture coordinates are specified and
	   * the attributes associated with this mesh indicate an image source, then texture coordinates are
	   * automatically generated for the mesh.
	   * @type {Vec2[][]}
	   * @default null
	   * @memberof GeographicMesh.prototype
	   */
	  textureCoordinates: {
	    get: function () {
	      return this._textureCoordinates;
	    },
	    set: function (coords) {
	      if (coords && coords.length != this.numRows) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicMesh", "textureCoordinates", "Number of texture coordinate rows is inconsistent with the currently specified positions."));
	      }

	      for (var i = 0; i < this.numRows; i++) {
	        if (coords[i].length !== this.numColumns) {
	          throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GeographicMesh", "textureCoordinates", "Texture coordinate row lengths are inconsistent with the currently specified positions."));
	        }
	      }

	      this._textureCoordinates = coords;
	      this.reset();
	      this.texCoords = null;
	    }
	  }
	});

	GeographicMesh.makeGridIndices = function (nRows, nCols) {
	  // Compute indices for individual triangles.
	  var gridIndices = [],
	      i = 0;

	  for (var r = 0; r < nRows - 1; r++) {
	    for (var c = 0; c < nCols - 1; c++) {
	      var k = r * nCols + c;
	      gridIndices[i++] = k;
	      gridIndices[i++] = k + 1;
	      gridIndices[i++] = k + nCols;
	      gridIndices[i++] = k + 1;
	      gridIndices[i++] = k + 1 + nCols;
	      gridIndices[i++] = k + nCols;
	    }
	  }

	  return gridIndices;
	}; // Intentionally not documented.


	GeographicMesh.prototype.determineReferencePosition = function (positions) {
	  // Assign the first position as the reference position.
	  return positions[0][0];
	}; // Overridden from AbstractShape base class.


	GeographicMesh.prototype.createSurfaceShape = function () {
	  var boundaries = [];

	  for (var c = 0; c < this.numColumns; c++) {
	    boundaries.push(this._positions[0][c]);
	  }

	  for (var r = 1; r < this.numRows; r++) {
	    boundaries.push(this._positions[r][this.numColumns - 1]);
	  }

	  for (c = this.numColumns - 2; c >= 0; c--) {
	    boundaries.push(this._positions[this.numRows - 1][c]);
	  }

	  for (r = this.numRows - 2; r > 0; r--) {
	    boundaries.push(this._positions[r][0]);
	  }

	  return new SurfacePolygon(boundaries, null);
	};

	GeographicMesh.prototype.computeMeshPoints = function (dc, currentData) {
	  // Unwrap the mesh row arrays into one long array.
	  var eyeDistSquared = Number.MAX_VALUE,
	      eyePoint = dc.eyePoint,
	      meshPoints = new Float32Array(this.numRows * this.numColumns * 3),
	      pt = new Vec3$1(0, 0, 0),
	      k = 0,
	      pos,
	      dSquared;

	  for (var r = 0; r < this._positions.length; r++) {
	    for (var c = 0, len = this._positions[r].length; c < len; c++) {
	      pos = this._positions[r][c];
	      dc.surfacePointForMode(pos.latitude, pos.longitude, pos.altitude * this._altitudeScale, this.altitudeMode, pt);
	      dSquared = pt.distanceToSquared(eyePoint);

	      if (dSquared < eyeDistSquared) {
	        eyeDistSquared = dSquared;
	      }

	      pt.subtract(this.currentData.referencePoint);
	      meshPoints[k++] = pt[0];
	      meshPoints[k++] = pt[1];
	      meshPoints[k++] = pt[2];
	    }
	  }

	  currentData.eyeDistance = Math.sqrt(eyeDistSquared);
	  return meshPoints;
	};

	GeographicMesh.prototype.computeTexCoords = function () {
	  if (this._textureCoordinates) {
	    return this.computeExplicitTexCoords();
	  } else {
	    return this.computeImplicitTexCoords();
	  }
	}; // Intentionally not documented.


	GeographicMesh.prototype.computeExplicitTexCoords = function () {
	  // Capture the texture coordinates to a single array parallel to the mesh points array.
	  var texCoords = new Float32Array(2 * this.numRows * this.numColumns),
	      k = 0;

	  for (var r = 0; r < this._textureCoordinates.length; r++) {
	    for (var c = 0, len = this._textureCoordinates[r].length; c < len; c++) {
	      var texCoord = this._textureCoordinates[r][c];
	      texCoords[k++] = texCoord[0];
	      texCoords[k++] = texCoord[1];
	    }
	  }

	  return texCoords;
	}; // Intentionally not documented.


	GeographicMesh.prototype.computeImplicitTexCoords = function () {
	  // Create texture coordinates that map the full image source into the full mesh.
	  var texCoords = new Float32Array(2 * this.numRows * this.numColumns),
	      rowDelta = 1.0 / (this.numRows - 1),
	      columnDelta = 1.0 / (this.numColumns - 1),
	      k = 0;

	  for (var r = 0; r < this._positions.length; r++) {
	    var t = r === this.numRows - 1 ? 1.0 : r * rowDelta;

	    for (var c = 0, len = this._positions[r].length; c < len; c++) {
	      texCoords[k++] = c === this.numColumns - 1 ? 1.0 : c * columnDelta;
	      texCoords[k++] = t;
	    }
	  }

	  return texCoords;
	};

	GeographicMesh.prototype.computeMeshIndices = function () {
	  // Compute indices for individual triangles.
	  var meshIndices = new Uint16Array((this.numRows - 1) * (this.numColumns - 1) * 6),
	      i = 0;

	  for (var r = 0; r < this.numRows - 1; r++) {
	    for (var c = 0; c < this.numColumns - 1; c++) {
	      var k = r * this.numColumns + c;
	      meshIndices[i++] = k;
	      meshIndices[i++] = k + 1;
	      meshIndices[i++] = k + this.numColumns;
	      meshIndices[i++] = k + 1;
	      meshIndices[i++] = k + 1 + this.numColumns;
	      meshIndices[i++] = k + this.numColumns;
	    }
	  }

	  return meshIndices;
	};

	GeographicMesh.prototype.computeOutlineIndices = function () {
	  // Walk the mesh boundary and capture those positions for the outline.
	  var outlineIndices = new Uint16Array(2 * this.numRows + 2 * this.numColumns),
	      k = 0;

	  for (var c = 0; c < this.numColumns; c++) {
	    outlineIndices[k++] = c;
	  }

	  for (var r = 1; r < this.numRows; r++) {
	    outlineIndices[k++] = (r + 1) * this.numColumns - 1;
	  }

	  for (c = this.numRows * this.numColumns - 2; c >= (this.numRows - 1) * this.numColumns; c--) {
	    outlineIndices[k++] = c;
	  }

	  for (r = this.numRows - 2; r >= 0; r--) {
	    outlineIndices[k++] = r * this.numColumns;
	  }

	  return outlineIndices;
	};

	/**
	 * @exports GeographicText
	 */
	/**
	 * Constructs a geographic text shape at a specified position.
	 * @alias GeographicText
	 * @constructor
	 * @augments Text
	 * @classdesc Represents a string of text displayed at a geographic position.
	 * <p>
	 * See also {@link ScreenText}.
	 *
	 * @param {Position} position The text's geographic position.
	 * @param {String} text The text to display.
	 * @throws {ArgumentError} If either the specified position or text is null or undefined.
	 */

	function GeographicText(position, text) {
	  if (!position) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Text", "constructor", "missingPosition"));
	  }

	  Text.call(this, text);
	  /**
	   * This text's geographic position.
	   * The [TextAttributes.offset]{@link TextAttributes#offset} property indicates the relationship of the
	   * text string to this position.
	   * @type {Position}
	   */

	  this.position = position;
	  /**
	   * Indicates the group ID of the declutter group to include this Text shape. This shape
	   * is decluttered relative to all other shapes within its group by the default
	   * [declutter filter]{@link WorldWindow#declutter}. To prevent decluttering of this shape, set its
	   * declutter group to 0.
	   * @type {Number}
	   * @default 1
	   */

	  this.declutterGroup = 1;
	} // Internal use only. Intentionally not documented.


	GeographicText.placePoint = new Vec3$1(0, 0, 0); // Cartesian point corresponding to this placemark's geographic position

	GeographicText.prototype = Object.create(Text.prototype);
	/**
	 * Creates a new geographic text object that is a copy of this one.
	 * @returns {GeographicText} The new geographic text object.
	 */

	GeographicText.prototype.clone = function () {
	  var clone = new GeographicText(this.position, this.text);
	  clone.copy(this);
	  clone.pickDelegate = this.pickDelegate ? this.pickDelegate : this;
	  return clone;
	}; // Documented in superclass.


	GeographicText.prototype.render = function (dc) {
	  // Filter out instances outside any projection limits.
	  if (dc.globe.projectionLimits && !dc.globe.projectionLimits.containsLocation(this.position.latitude, this.position.longitude)) {
	    return;
	  }

	  Text.prototype.render.call(this, dc);
	}; // Documented in superclass.


	GeographicText.prototype.computeScreenPointAndEyeDistance = function (dc) {
	  // Compute the text's model point and corresponding distance to the eye point.
	  dc.surfacePointForMode(this.position.latitude, this.position.longitude, this.position.altitude, this.altitudeMode, GeographicText.placePoint);

	  if (!dc.frustumInModelCoordinates.containsPoint(GeographicText.placePoint)) {
	    return false;
	  }

	  this.eyeDistance = this.alwaysOnTop ? 0 : dc.eyePoint.distanceTo(GeographicText.placePoint); // Compute the text's screen point in the OpenGL coordinate system of the WorldWindow by projecting its model
	  // coordinate point onto the viewport. Apply a depth offset in order to cause the text to appear above nearby
	  // terrain. When text is displayed near the terrain portions of its geometry are often behind the terrain,
	  // yet as a screen element the text is expected to be visible. We adjust its depth values rather than moving
	  // the text itself to avoid obscuring its actual position.

	  if (!dc.projectWithDepth(GeographicText.placePoint, this.depthOffset, this.screenPoint)) {
	    return false;
	  }

	  return true;
	};

	/**
	 * @exports ProjectionEquirectangular
	 */
	/**
	 * Constructs an Equirectangular geographic projection, also known as Equidistant Cylindrical, Plate Carree and
	 * Rectangular. The projected globe is spherical, not ellipsoidal.
	 * @alias ProjectionEquirectangular
	 * @constructor
	 * @augments GeographicProjection
	 * @classdesc Represents an equirectangular geographic projection.
	 */

	function ProjectionEquirectangular() {
	  GeographicProjection.call(this, "Equirectangular", true, null);
	}

	ProjectionEquirectangular.prototype = Object.create(GeographicProjection.prototype);
	Object.defineProperties(ProjectionEquirectangular.prototype, {
	  /**
	   * A string identifying this projection's current state. Used to compare states during rendering to
	   * determine whether globe-state dependent cached values must be updated. Applications typically do not
	   * interact with this property.
	   * @memberof ProjectionEquirectangular.prototype
	   * @readonly
	   * @type {String}
	   */
	  stateKey: {
	    get: function () {
	      return "projection equirectangular ";
	    }
	  }
	}); // Documented in base class.

	ProjectionEquirectangular.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionEquirectangular", "geographicToCartesian", "missingGlobe"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionEquirectangular", "geographicToCartesian", "missingResult"));
	  }

	  result[0] = globe.equatorialRadius * longitude * Angle.DEGREES_TO_RADIANS + (offset ? offset[0] : 0);
	  result[1] = globe.equatorialRadius * latitude * Angle.DEGREES_TO_RADIANS;
	  result[2] = elevation;
	  return result;
	}; // Documented in base class.


	ProjectionEquirectangular.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations, referencePoint, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionEquirectangular", "geographicToCartesianGrid", "missingGlobe"));
	  }

	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionEquirectangular", "geographicToCartesianGrid", "missingSector"));
	  }

	  if (!elevations || elevations.length < numLat * numLon) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionEquirectangular", "geographicToCartesianGrid", "The specified elevations array is null, undefined or insufficient length"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionEquirectangular", "geographicToCartesianGrid", "missingResult"));
	  }

	  var eqr = globe.equatorialRadius,
	      minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,
	      maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,
	      minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,
	      maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,
	      deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
	      deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
	      refPoint = referencePoint ? referencePoint : new Vec3$1(0, 0, 0),
	      offsetX = offset ? offset[0] : 0,
	      latIndex,
	      lonIndex,
	      elevIndex = 0,
	      resultIndex = 0,
	      lat,
	      lon,
	      y; // Iterate over the latitude and longitude coordinates in the specified sector, computing the Cartesian
	  // point corresponding to each latitude and longitude.

	  for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {
	    if (latIndex === numLat - 1) {
	      lat = maxLat; // explicitly set the last lat to the max latitude to ensure alignment
	    } // Latitude is constant for each row. Values that are a function of latitude can be computed once per row.


	    y = eqr * lat - refPoint[1];

	    for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {
	      if (lonIndex === numLon - 1) {
	        lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
	      }

	      result[resultIndex++] = eqr * lon - refPoint[0] + offsetX;
	      result[resultIndex++] = y;
	      result[resultIndex++] = elevations[elevIndex++] - refPoint[2];
	    }
	  }

	  return result;
	}; // Documented in base class.


	ProjectionEquirectangular.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionEquirectangular", "cartesianToGeographic", "missingGlobe"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionEquirectangular", "cartesianToGeographic", "missingResult"));
	  }

	  result.latitude = y / globe.equatorialRadius * Angle.RADIANS_TO_DEGREES;
	  result.longitude = (x - (offset ? offset[0] : 0)) / globe.equatorialRadius * Angle.RADIANS_TO_DEGREES;
	  result.altitude = z;
	  return result;
	};

	/**
	 * @exports Globe2D
	 */
	/**
	 * Constructs a 2D globe with a default {@link ElevationModel} and
	 * [equirectangular projection]{@link ProjectionEquirectangular}.
	 * @alias Globe2D
	 * @constructor
	 * @augments Globe
	 * @classdesc Represents a 2D flat globe with a configurable projection.
	 * The default rectangular projection scrolls longitudinally.
	 */

	function Globe2D() {
	  Globe.call(this, new ElevationModel(), new ProjectionEquirectangular());
	}

	Globe2D.prototype = Object.create(Globe.prototype);

	/**
	 * @exports GoToAnimator
	 */
	/**
	 * Constructs a GoTo animator.
	 * @alias GoToAnimator
	 * @constructor
	 * @classdesc Incrementally and smoothly moves a {@link Navigator} to a specified position.
	 * @param {WorldWindow} worldWindow The WorldWindow in which to perform the animation.
	 * @throws {ArgumentError} If the specified WorldWindow is null or undefined.
	 */

	function GoToAnimator(worldWindow) {
	  if (!worldWindow) {
	    throw new ArgumentError(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GoToAnimator", "constructor", "missingWorldWindow"));
	  }
	  /**
	   * The WorldWindow associated with this animator.
	   * @type {WorldWindow}
	   * @readonly
	   */


	  this.wwd = worldWindow;
	  /**
	   * The frequency in milliseconds at which to animate the position change.
	   * @type {Number}
	   * @default 20
	   */

	  this.animationFrequency = 20;
	  /**
	   * The animation's duration, in milliseconds. When the distance is short, less than twice the viewport
	   * size, the travel time is reduced proportionally to the distance to travel. It therefore takes less
	   * time to move shorter distances.
	   * @type {Number}
	   * @default 3000
	   */

	  this.travelTime = 3000;
	  /**
	   * Indicates whether the current or most recent animation has been cancelled. Use the cancel() function
	   * to cancel an animation.
	   * @type {Boolean}
	   * @default false
	   * @readonly
	   */

	  this.cancelled = false;
	} // Stop the current animation.


	GoToAnimator.prototype.cancel = function () {
	  this.cancelled = true;
	};
	/**
	 * Moves the navigator to a specified location or position.
	 * @param {Location | Position} position The location or position to move the navigator to. If this
	 * argument contains an "altitude" property, as {@link Position} does, the end point of the navigation is
	 * at the specified altitude. Otherwise the end point is at the current altitude of the navigator.
	 * @param {Function} completionCallback If not null or undefined, specifies a function to call when the
	 * animation completes. The completion callback is called with a single argument, this animator.
	 * @throws {ArgumentError} If the specified location or position is null or undefined.
	 */


	GoToAnimator.prototype.goTo = function (position, completionCallback) {
	  if (!position) {
	    throw new ArgumentError(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "GoToAnimator", "goTo", "missingPosition"));
	  }

	  this.completionCallback = completionCallback; // Reset the cancellation flag.

	  this.cancelled = false; // Capture the target position and determine its altitude.

	  this.targetPosition = new Position(position.latitude, position.longitude, position.altitude || this.wwd.navigator.range); // Capture the start position and start time.

	  this.startPosition = new Position(this.wwd.navigator.lookAtLocation.latitude, this.wwd.navigator.lookAtLocation.longitude, this.wwd.navigator.range);
	  this.startTime = Date.now(); // Determination of the pan and range velocities requires the distance to be travelled.

	  var animationDuration = this.travelTime,
	      panDistance = Location.greatCircleDistance(this.startPosition, this.targetPosition),
	      rangeDistance; // Determine how high we need to go to give the user context. The max altitude computed is approximately
	  // that needed to fit the start and end positions in the same viewport assuming a 45 degree field of view.

	  var pA = this.wwd.globe.computePointFromLocation(this.startPosition.latitude, this.startPosition.longitude, new Vec3$1(0, 0, 0)),
	      pB = this.wwd.globe.computePointFromLocation(this.targetPosition.latitude, this.targetPosition.longitude, new Vec3$1(0, 0, 0));
	  this.maxAltitude = pA.distanceTo(pB); // Determine an approximate viewport size in radians in order to determine whether we actually change
	  // the range as we pan to the new location. We don't want to change the range if the distance between
	  // the start and target positions is small relative to the current viewport.

	  var viewportSize = this.wwd.pixelSizeAtDistance(this.startPosition.altitude) * this.wwd.canvas.clientWidth / this.wwd.globe.equatorialRadius;

	  if (panDistance <= 2 * viewportSize) {
	    // Start and target positions are close, so don't back out.
	    this.maxAltitude = this.startPosition.altitude;
	  } // We need to capture the time the max altitude is reached in order to begin decreasing the range
	  // midway through the animation. If we're already above the max altitude, then that time is now since
	  // we don't back out if the current altitude is above the computed max altitude.


	  this.maxAltitudeReachedTime = this.maxAltitude <= this.wwd.navigator.range ? Date.now() : null; // Compute the total range to travel since we need that to compute the range velocity.
	  // Note that the range velocity and pan velocity are computed so that the respective animations, which
	  // operate independently, finish at the same time.

	  if (this.maxAltitude > this.startPosition.altitude) {
	    rangeDistance = Math.max(0, this.maxAltitude - this.startPosition.altitude);
	    rangeDistance += Math.abs(this.targetPosition.altitude - this.maxAltitude);
	  } else {
	    rangeDistance = Math.abs(this.targetPosition.altitude - this.startPosition.altitude);
	  } // Determine which distance governs the animation duration.


	  var animationDistance = Math.max(panDistance, rangeDistance / this.wwd.globe.equatorialRadius);

	  if (animationDistance === 0) {
	    return; // current and target positions are the same
	  }

	  if (animationDistance < 2 * viewportSize) {
	    // Start and target positions are close, so reduce the travel time based on the
	    // distance to travel relative to the viewport size.
	    animationDuration = Math.min(animationDistance / viewportSize * this.travelTime, this.travelTime);
	  } // Don't let the animation duration go to 0.


	  animationDuration = Math.max(1, animationDuration); // Determine the pan velocity, in radians per millisecond.

	  this.panVelocity = panDistance / animationDuration; // Determine the range velocity, in meters per millisecond.

	  this.rangeVelocity = rangeDistance / animationDuration; // meters per millisecond
	  // Set up the animation timer.

	  var thisAnimator = this;

	  var timerCallback = function () {
	    if (thisAnimator.cancelled) {
	      if (thisAnimator.completionCallback) {
	        thisAnimator.completionCallback(thisAnimator);
	      }

	      return;
	    }

	    if (thisAnimator.update()) {
	      setTimeout(timerCallback, thisAnimator.animationFrequency);
	    } else if (thisAnimator.completionCallback) {
	      thisAnimator.completionCallback(thisAnimator);
	    }
	  };

	  setTimeout(timerCallback, this.animationFrequency); // invoke it the first time
	}; // Intentionally not documented.


	GoToAnimator.prototype.update = function () {
	  // This is the timer callback function. It invokes the range animator and the pan animator.
	  var currentPosition = new Position(this.wwd.navigator.lookAtLocation.latitude, this.wwd.navigator.lookAtLocation.longitude, this.wwd.navigator.range);
	  var continueAnimation = this.updateRange(currentPosition);
	  continueAnimation = this.updateLocation(currentPosition) || continueAnimation;
	  this.wwd.redraw();
	  return continueAnimation;
	}; // Intentionally not documented.


	GoToAnimator.prototype.updateRange = function (currentPosition) {
	  // This function animates the range.
	  var continueAnimation = false,
	      nextRange,
	      elapsedTime; // If we haven't reached the maximum altitude, then step-wise increase it. Otherwise step-wise change
	  // the range towards the target altitude.

	  if (!this.maxAltitudeReachedTime) {
	    elapsedTime = Date.now() - this.startTime;
	    nextRange = Math.min(this.startPosition.altitude + this.rangeVelocity * elapsedTime, this.maxAltitude); // We're done if we get withing 1 meter of the desired range.

	    if (Math.abs(this.wwd.navigator.range - nextRange) < 1) {
	      this.maxAltitudeReachedTime = Date.now();
	    }

	    this.wwd.navigator.range = nextRange;
	    continueAnimation = true;
	  } else {
	    elapsedTime = Date.now() - this.maxAltitudeReachedTime;

	    if (this.maxAltitude > this.targetPosition.altitude) {
	      nextRange = this.maxAltitude - this.rangeVelocity * elapsedTime;
	      nextRange = Math.max(nextRange, this.targetPosition.altitude);
	    } else {
	      nextRange = this.maxAltitude + this.rangeVelocity * elapsedTime;
	      nextRange = Math.min(nextRange, this.targetPosition.altitude);
	    }

	    this.wwd.navigator.range = nextRange; // We're done if we get withing 1 meter of the desired range.

	    continueAnimation = Math.abs(this.wwd.navigator.range - this.targetPosition.altitude) > 1;
	  }

	  return continueAnimation;
	}; // Intentionally not documented.


	GoToAnimator.prototype.updateLocation = function (currentPosition) {
	  // This function animates the pan to the desired location.
	  var elapsedTime = Date.now() - this.startTime,
	      distanceTravelled = Location.greatCircleDistance(this.startPosition, currentPosition),
	      distanceRemaining = Location.greatCircleDistance(currentPosition, this.targetPosition),
	      azimuthToTarget = Location.greatCircleAzimuth(currentPosition, this.targetPosition),
	      distanceForNow = this.panVelocity * elapsedTime,
	      nextDistance = Math.min(distanceForNow - distanceTravelled, distanceRemaining),
	      nextLocation = Location.greatCircleLocation(currentPosition, azimuthToTarget, nextDistance, new Location(0, 0)),
	      locationReached = false;
	  this.wwd.navigator.lookAtLocation.latitude = nextLocation.latitude;
	  this.wwd.navigator.lookAtLocation.longitude = nextLocation.longitude; // We're done if we're within a meter of the desired location.

	  if (nextDistance < 1 / this.wwd.globe.equatorialRadius) {
	    locationReached = true;
	  }

	  return !locationReached;
	};

	/**
	 * @exports HighlightController
	 */
	/**
	 * Constructs a highlight controller and associates it with a specified WorldWindow.
	 * @alias HighlightController
	 * @constructor
	 * @classdesc Monitors mouse-move and touch-device tap events and highlights shapes they identify.
	 * @param {WorldWindow} worldWindow The WorldWindow to monitor for mouse-move and tap events.
	 * @throws {ArgumentError} If the specified WorldWindow is null or undefined.
	 */

	function HighlightController(worldWindow) {
	  if (!worldWindow) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "HighlightController", "constructor", "missingWorldWindow"));
	  }
	  /**
	   * This controller's WorldWindow
	   * @type {WorldWindow}
	   * @readonly
	   */


	  this.worldWindow = worldWindow;
	  var highlightedItems = [];

	  var handlePick = function (o) {
	    // The input argument is either an Event or a TapRecognizer. Both have the same properties for determining
	    // the mouse or tap location.
	    var x = o.clientX,
	        y = o.clientY;
	    var redrawRequired = highlightedItems.length > 0; // must redraw if we de-highlight previous shapes
	    // De-highlight any previously highlighted shapes.

	    for (var h = 0; h < highlightedItems.length; h++) {
	      highlightedItems[h].highlighted = false;
	    }

	    highlightedItems = []; // Perform the pick. Must first convert from window coordinates to canvas coordinates, which are
	    // relative to the upper left corner of the canvas rather than the upper left corner of the page.

	    var pickList = worldWindow.pick(worldWindow.canvasCoordinates(x, y));

	    if (pickList.objects.length > 0) {
	      redrawRequired = true;
	    } // Highlight the items picked by simply setting their highlight flag to true.


	    if (pickList.objects.length > 0) {
	      for (var p = 0; p < pickList.objects.length; p++) {
	        if (!pickList.objects[p].isTerrain) {
	          pickList.objects[p].userObject.highlighted = true; // Keep track of highlighted items in order to de-highlight them later.

	          highlightedItems.push(pickList.objects[p].userObject);
	        }
	      }
	    } // Update the window if we changed anything.


	    if (redrawRequired) {
	      worldWindow.redraw(); // redraw to make the highlighting changes take effect on the screen
	    }
	  }; // Listen for mouse moves and highlight the placemarks that the cursor rolls over.


	  this.worldWindow.addEventListener("mousemove", handlePick); // Listen for taps on mobile devices and highlight the placemarks that the user taps.

	  var tapRecognizer = new WorldWind.TapRecognizer(this.worldWindow, handlePick);
	}

	/**
	 * @exports ImageTile
	 */
	/**
	 * Constructs an image tile.
	 * @alias ImageTile
	 * @constructor
	 * @classdesc Represents an image applied to a portion of a globe's terrain. Applications typically do not
	 * interact with this class.
	 * @augments TextureTile
	 * @param {Sector} sector The sector this tile covers.
	 * @param {Level} level The level this tile is associated with.
	 * @param {Number} row This tile's row in the associated level.
	 * @param {Number} column This tile's column in the associated level.
	 * @param {String} imagePath The full path to the image.
	 * @throws {ArgumentError} If the specified sector or level is null or undefined, the row or column arguments
	 * are less than zero, or the specified image path is null, undefined or empty.
	 *
	 */

	function ImageTile(sector, level, row, column, imagePath) {
	  if (!imagePath || imagePath.length < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ImageTile", "constructor", "The specified image path is null, undefined or zero length."));
	  }

	  TextureTile.call(this, sector, level, row, column); // args are checked in the superclass' constructor

	  /**
	   * This tile's image path.
	   * @type {String}
	   */

	  this.imagePath = imagePath;
	  /**
	   * The tile whose texture to use when this tile's texture is not available.
	   * @type {Matrix}
	   */

	  this.fallbackTile = null; // Assign imagePath to gpuCacheKey (inherited from TextureTile).

	  this.gpuCacheKey = imagePath;
	}

	ImageTile.prototype = Object.create(TextureTile.prototype);
	/**
	 * Returns the size of the this tile in bytes.
	 * @returns {Number} The size of this tile in bytes, not including the associated texture size.
	 */

	ImageTile.prototype.size = function () {
	  return this.__proto__.__proto__.size.call(this) + this.imagePath.length + 8;
	};
	/**
	 * Causes this tile's texture to be active. Implements [SurfaceTile.bind]{@link SurfaceTile#bind}.
	 * @param {DrawContext} dc The current draw context.
	 * @returns {Boolean} true if the texture was bound successfully, otherwise false.
	 */


	ImageTile.prototype.bind = function (dc) {
	  // Attempt to bind in TextureTile first.
	  var isBound = this.__proto__.__proto__.bind.call(this, dc);

	  if (isBound) {
	    return true;
	  }

	  if (this.fallbackTile) {
	    return this.fallbackTile.bind(dc);
	  }

	  return false;
	};
	/**
	 * If this tile's fallback texture is used, applies the appropriate texture transform to a specified matrix.
	 * @param {DrawContext} dc The current draw context.
	 * @param {Matrix} matrix The matrix to apply the transform to.
	 */


	ImageTile.prototype.applyInternalTransform = function (dc, matrix) {
	  if (this.fallbackTile && !dc.gpuResourceCache.resourceForKey(this.imagePath)) {
	    // Must apply a texture transform to map the tile's sector into its fallback's image.
	    this.applyFallbackTransform(matrix);
	  }
	}; // Intentionally not documented.


	ImageTile.prototype.applyFallbackTransform = function (matrix) {
	  var deltaLevel = this.level.levelNumber - this.fallbackTile.level.levelNumber;
	  if (deltaLevel <= 0) return;
	  var fbTileDeltaLat = this.fallbackTile.sector.deltaLatitude(),
	      fbTileDeltaLon = this.fallbackTile.sector.deltaLongitude(),
	      sx = this.sector.deltaLongitude() / fbTileDeltaLon,
	      sy = this.sector.deltaLatitude() / fbTileDeltaLat,
	      tx = (this.sector.minLongitude - this.fallbackTile.sector.minLongitude) / fbTileDeltaLon,
	      ty = (this.sector.minLatitude - this.fallbackTile.sector.minLatitude) / fbTileDeltaLat; // Apply a transform to the matrix that maps texture coordinates for this tile to texture coordinates for the
	  // fallback tile. Rather than perform the full set of matrix operations, a single multiply is performed with the
	  // precomputed non-zero values:
	  //
	  // Matrix trans = Matrix.fromTranslation(tx, ty, 0);
	  // Matrix scale = Matrix.fromScale(sxy, sxy, 1);
	  // matrix.multiply(trans);
	  // matrix.multiply(scale);

	  matrix.multiply(sx, 0, 0, tx, 0, sy, 0, ty, 0, 0, 1, 0, 0, 0, 0, 1);
	};

	/**
	 * @exports LengthMeasurer
	 */
	/**
	 * Utility class to measure length along a path on a globe. <p/> <p>Segments which are longer then the current
	 * maxSegmentLength will be subdivided along lines following the current pathType - WorldWind.LINEAR,
	 * WorldWind.RHUMB_LINE or WorldWind.GREAT_CIRCLE.</p> <p/> <p>For follow terrain, the computed length will
	 * account for terrain deformations as if someone was walking along that path. Otherwise the length is the sum
	 * of the cartesian distance between the positions.</p>
	 * <p/>
	 * <p>When following terrain the measurer will sample terrain elevations at regular intervals along the path.
	 * The minimum number of samples used for the whole length can be set with lengthTerrainSamplingSteps.
	 * However, the minimum sampling interval is 30 meters.
	 * @alias LengthMeasurer
	 * @constructor
	 * @param {WorldWindow} wwd The WorldWindow associated with LengthMeasurer.
	 * @throws {ArgumentError} If the specified WorldWindow is null or undefined.
	 */

	function LengthMeasurer(wwd) {
	  if (!wwd) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "LengthMeasurer", "constructor", "missingWorldWindow"));
	  }

	  this.wwd = wwd; // Private. The minimum length of a terrain following subdivision.

	  this.DEFAULT_MIN_SEGMENT_LENGTH = 30; // Private. Documentation is with the defined property below.

	  this._maxSegmentLength = 100e3; // Private. Documentation is with the defined property below.

	  this._lengthTerrainSamplingSteps = 128; // Private. A list of positions with no segment longer then maxLength and elevations following terrain or not.

	  this.subdividedPositions = null;
	}

	Object.defineProperties(LengthMeasurer.prototype, {
	  /**
	   * The maximum length a segment can have before being subdivided along a line following the current pathType.
	   * @type {Number}
	   * @memberof LengthMeasurer.prototype
	   */
	  maxSegmentLength: {
	    get: function () {
	      return this._maxSegmentLength;
	    },
	    set: function (value) {
	      this._maxSegmentLength = value;
	    }
	  },

	  /**
	   * The number of terrain elevation samples used along the path to approximate it's terrain following length.
	   * @type {Number}
	   * @memberof LengthMeasurer.prototype
	   */
	  lengthTerrainSamplingSteps: {
	    get: function () {
	      return this._lengthTerrainSamplingSteps;
	    },
	    set: function (value) {
	      this._lengthTerrainSamplingSteps = value;
	    }
	  }
	});
	/**
	 * Get the path length in meter. <p/> <p>If followTerrain is true, the computed length will account
	 * for terrain deformations as if someone was walking along that path. Otherwise the length is the sum of the
	 * cartesian distance between each positions.</p>
	 *
	 * @param {Position[]} positions
	 * @param {Boolean} followTerrain
	 * @param {String} pathType One of WorldWind.LINEAR, WorldWind.RHUMB_LINE or WorldWind.GREAT_CIRCLE
	 *
	 * @return the current path length or -1 if the position list is too short.
	 */

	LengthMeasurer.prototype.getLength = function (positions, followTerrain, pathType) {
	  pathType = pathType || WorldWind.GREAT_CIRCLE;
	  this.subdividedPositions = null;
	  return this.computeLength(positions, followTerrain, pathType);
	};
	/**
	 * Get the path length in meter of a Path. <p/> <p>If the path's followTerrain is true, the computed length
	 * will account for terrain deformations as if someone was walking along that path. Otherwise the length is the
	 * sum of the cartesian distance between each positions.</p>
	 *
	 * @param {Path} path
	 *
	 * @return the current path length or -1 if the position list is too short.
	 */


	LengthMeasurer.prototype.getPathLength = function (path) {
	  this.subdividedPositions = null;
	  return this.computeLength(path.positions, path.followTerrain, path.pathType);
	};
	/**
	 * Get the great circle, rhumb or linear distance, in meter, of a Path or an array of Positions.
	 *
	 * @param {Path|Position[]} path A Path or an array of Positions
	 * @param {String} pathType Optional argument used when path is an array of Positions.
	 * Defaults to WorldWind.GREAT_CIRCLE.
	 * Recognized values are:
	 * <ul>
	 * <li>[WorldWind.GREAT_CIRCLE]{@link WorldWind#GREAT_CIRCLE}</li>
	 * <li>[WorldWind.RHUMB_LINE]{@link WorldWind#RHUMB_LINE}</li>
	 * <li>[WorldWind.LINEAR]{@link WorldWind#LINEAR}</li>
	 * </ul>
	 *
	 * @return {Number} the current path length or -1 if the position list is too short.
	 */


	LengthMeasurer.prototype.getGeographicDistance = function (path, pathType) {
	  if (path instanceof WorldWind.Path) {
	    var positions = path.positions;
	    var _pathType = path.pathType;
	  } else if (Array.isArray(path)) {
	    positions = path;
	    _pathType = pathType || WorldWind.GREAT_CIRCLE;
	  }

	  if (!positions || positions.length < 2) {
	    return -1;
	  }

	  var fn = Location.greatCircleDistance;

	  if (_pathType === WorldWind.RHUMB_LINE) {
	    fn = Location.rhumbDistance;
	  } else if (_pathType === WorldWind.LINEAR) {
	    fn = Location.linearDistance;
	  }

	  var distance = 0;

	  for (var i = 0, len = positions.length - 1; i < len; i++) {
	    var pos1 = positions[i];
	    var pos2 = positions[i + 1];
	    distance += fn(pos1, pos2);
	  }

	  return distance * this.wwd.globe.equatorialRadius;
	};
	/**
	 * Computes the length.
	 * @param {Position[]} positions
	 * @param {Boolean} followTerrain
	 * @param {String} pathType One of WorldWind.LINEAR, WorldWind.RHUMB_LINE or WorldWind.GREAT_CIRCLE
	 */


	LengthMeasurer.prototype.computeLength = function (positions, followTerrain, pathType) {
	  if (!positions || positions.length < 2) {
	    return -1;
	  }

	  var globe = this.wwd.globe;

	  if (this.subdividedPositions == null) {
	    // Subdivide path so as to have at least segments smaller then maxSegmentLength. If follow terrain,
	    // subdivide so as to have at least lengthTerrainSamplingSteps segments, but no segments shorter then
	    // DEFAULT_MIN_SEGMENT_LENGTH either.
	    var maxLength = this._maxSegmentLength;

	    if (followTerrain) {
	      // Recurse to compute overall path length not following terrain
	      var pathLength = this.computeLength(positions, false, pathType); // Determine segment length to have enough sampling points

	      maxLength = pathLength / this._lengthTerrainSamplingSteps;
	      maxLength = Math.min(Math.max(maxLength, this.DEFAULT_MIN_SEGMENT_LENGTH), this._maxSegmentLength);
	    }

	    this.subdividedPositions = MeasurerUtils.subdividePositions(globe, positions, followTerrain, pathType, maxLength);
	  }

	  var distance = 0;
	  var pos0 = this.subdividedPositions[0];
	  var p1 = new Vec3$1(0, 0, 0);
	  var p2 = new Vec3$1(0, 0, 0);
	  p1 = globe.computePointFromPosition(pos0.latitude, pos0.longitude, pos0.altitude, p1);

	  for (var i = 1, len = this.subdividedPositions.length; i < len; i++) {
	    var pos = this.subdividedPositions[i];
	    p2 = globe.computePointFromPosition(pos.latitude, pos.longitude, pos.altitude, p2);
	    distance += p1.distanceTo(p2);
	    p1.copy(p2);
	  }

	  return distance;
	};

	/**
	 * @exports Navigator
	 */

	/**
	 * Constructs a base navigator.
	 * @alias Navigator
	 * @constructor
	 * @classdesc Provides an abstract base class for navigators. This class is not meant to be instantiated
	 * directly. See {@Link LookAtNavigator} for a concrete navigator.
	 */
	function Navigator() {
	  /**
	   * This navigator's heading, in degrees clockwise from north.
	   * @type {Number}
	   * @default 0
	   */
	  this.heading = 0;
	  /**
	   * This navigator's tilt, in degrees.
	   * @type {Number}
	   * @default 0
	   */

	  this.tilt = 0;
	  /**
	   * This navigator's roll, in degrees.
	   * @type {Number}
	   * @default 0
	   */

	  this.roll = 0;
	}

	/**
	 * @exports LookAtNavigator
	 */
	/**
	 * Constructs a look-at navigator.
	 * @alias LookAtNavigator
	 * @constructor
	 * @augments Navigator
	 * @classdesc Represents a navigator containing the required variables to enable the user to pan, zoom and tilt
	 * the globe.
	 */

	function LookAtNavigator() {
	  Navigator.call(this);
	  /**
	   * The geographic location at the center of the viewport.
	   * @type {Location}
	   */

	  this.lookAtLocation = new Location(30, -110);
	  /**
	   * The distance from this navigator's eye point to its look-at location.
	   * @type {Number}
	   * @default 10,000 kilometers
	   */

	  this.range = 10e6; // TODO: Compute initial range to fit globe in viewport.
	  // Development testing only. Set this to false to suppress default navigator limits on 2D globes.

	  this.enable2DLimits = true;
	}

	LookAtNavigator.prototype = Object.create(Navigator.prototype);

	/**
	 * @exports MeasuredLocation
	 */
	/**
	 * Constructs a measured location from a specified latitude and longitude in degrees associated with a measure.
	 * @alias MeasuredLocation
	 * @constructor
	 * @classdesc Represents a latitude, longitude pair in degrees with an associated measure.
	 * @augments Location
	 * @param {Number} latitude The latitude in degrees.
	 * @param {Number} longitude The longitude in degrees.
	 * @param {Number} measure The measure in an arbitrary unit.
	 */

	function MeasuredLocation(latitude, longitude, measure) {
	  Location.call(this, latitude, longitude);
	  /**
	   * The measure in an arbitrary unit.
	   * @type {Number}
	   */

	  this.measure = measure;
	}

	MeasuredLocation.prototype = Object.create(Location.prototype);
	/**
	 * Creates a measured location from angles specified in radians.
	 * @param {Number} latitudeRadians The latitude in radians.
	 * @param {Number} longitudeRadians The longitude in radians.
	 * @param {Number} measure The measure in an arbitrary unit.
	 * @returns {Location} The new location with latitude and longitude in degrees.
	 */

	MeasuredLocation.fromRadians = function (latitudeRadians, longitudeRadians, measure) {
	  return new MeasuredLocation(latitudeRadians * Angle.RADIANS_TO_DEGREES, longitudeRadians * Angle.RADIANS_TO_DEGREES, measure);
	};
	/**
	 * Copies this measured location to the latitude, longitude and measure of a specified measured location.
	 * @param {MeasuredLocation} measuredLocation The measured location to copy.
	 * @return {MeasuredLocation} This measured location, set to the values of the specified measured location.
	 * @throws {ArgumentError} If the specified measured location is null or undefined.
	 */


	MeasuredLocation.prototype.copy = function (measuredLocation) {
	  Location.prototype.copy.call(this, measuredLocation);
	  this.measure = measuredLocation.measure;
	  return this;
	};
	/**
	 * Sets this measured location to the latitude, longitude and measure.
	 * @param {Number} latitude The latitude to set
	 * @param {Number} longitude The longitude to set
	 * @param {Number} measure The measure to set.
	 * @return {MeasuredLocation} This measured location, set to the values of the specified latitude, longitude and
	 * measure.
	 */


	MeasuredLocation.prototype.set = function (latitude, longitude, measure) {
	  Location.prototype.set.call(this, latitude, longitude);
	  this.measure = measure;
	  return this;
	};
	/**
	 * Indicates whether this measured location is equal to a specified measured location.
	 * @param {MeasuredLocation} measuredLocation The measured location to compare this one to.
	 * @returns {Boolean} <code>true</code> if this measured location is equal to the specified measured location,
	 * otherwise <code>false</code>.
	 */


	MeasuredLocation.prototype.equals = function (measuredLocation) {
	  return Location.prototype.equals.call(this, measuredLocation) && this.measure === measuredLocation.measure;
	};

	/**
	 * Defines an interface for {@link MemoryCache} listeners.
	 * @exports MemoryCacheListener
	 * @interface MemoryCacheListener
	 */
	/**
	 * @alias MemoryCacheListener
	 * @constructor
	 */

	function MemoryCacheListener() {}
	/**
	 * Called when an entry is removed from the cache.
	 * Implementers of this interface must implement this function.
	 * @param {String} key The key of the entry removed.
	 * @param {Object} entry The entry removed.
	 */


	MemoryCacheListener.prototype.entryRemoved = function (key, entry) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCacheListener", "entryRemoved", "abstractInvocation"));
	};
	/**
	 * Called when an error occurs during entry removal.
	 * Implementers of this interface must implement this function.
	 * @param {Object} error The error object describing the error that occurred.
	 * @param {String} key The key of the entry being removed.
	 * @param {Object} entry The entry being removed.
	 */


	MemoryCacheListener.prototype.removalError = function (error, key, entry) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "MemoryCacheListener", "removalError", "abstractInvocation"));
	};

	/**
	 * @exports TiledImageLayer
	 */
	/**
	 * Constructs a tiled image layer.
	 * @alias TiledImageLayer
	 * @constructor
	 * @classdesc
	 * Provides a layer that displays multi-resolution imagery arranged as adjacent tiles in a pyramid.
	 * This is the primary WorldWind base class for displaying imagery of this type. While it may be used as a
	 * stand-alone class, it is typically subclassed by classes that identify the remote image server.
	 * <p>
	 * While the image tiles for this class are typically drawn from a remote server such as a WMS server. The actual
	 * retrieval protocol is independent of this class and encapsulated by a class implementing the {@link UrlBuilder}
	 * interface and associated with instances of this class as a property.
	 * <p>
	 * There is no requirement that image tiles of this class be remote, they may be local or procedurally generated. For
	 * such cases the subclass overrides this class' [retrieveTileImage]{@link TiledImageLayer#retrieveTileImage} method.
	 * <p>
	 * Layers of this type are by default not pickable. Their pick-enabled flag is initialized to false.
	 *
	 * @augments Layer
	 * @param {Sector} sector The sector this layer covers.
	 * @param {Location} levelZeroDelta The size in latitude and longitude of level zero (lowest resolution) tiles.
	 * @param {Number} numLevels The number of levels to define for the layer. Each level is successively one power
	 * of two higher resolution than the next lower-numbered level. (0 is the lowest resolution level, 1 is twice
	 * that resolution, etc.)
	 * Each level contains four times as many tiles as the next lower-numbered level, each 1/4 the geographic size.
	 * @param {String} imageFormat The mime type of the image format for the layer's tiles, e.g., <em>image/png</em>.
	 * @param {String} cachePath A string uniquely identifying this layer relative to other layers.
	 * @param {Number} tileWidth The horizontal size of image tiles in pixels.
	 * @param {Number} tileHeight The vertical size of image tiles in pixels.
	 * @throws {ArgumentError} If any of the specified sector, level-zero delta, cache path or image format arguments are
	 * null or undefined, or if the specified number of levels, tile width or tile height is less than 1.
	 *
	 */

	function TiledImageLayer(sector, levelZeroDelta, numLevels, imageFormat, cachePath, tileWidth, tileHeight) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledImageLayer", "constructor", "missingSector"));
	  }

	  if (!levelZeroDelta) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledImageLayer", "constructor", "The specified level-zero delta is null or undefined."));
	  }

	  if (!imageFormat) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledImageLayer", "constructor", "The specified image format is null or undefined."));
	  }

	  if (!cachePath) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledImageLayer", "constructor", "The specified cache path is null or undefined."));
	  }

	  if (!numLevels || numLevels < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledImageLayer", "constructor", "The specified number of levels is less than one."));
	  }

	  if (!tileWidth || !tileHeight || tileWidth < 1 || tileHeight < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledImageLayer", "constructor", "The specified tile width or height is less than one."));
	  }

	  Layer.call(this, "Tiled Image Layer");
	  this.retrievalImageFormat = imageFormat;
	  this.cachePath = cachePath;
	  /**
	   * Controls how many concurrent tile requests are allowed for this layer.
	   * @type {Number}
	   * @default WorldWind.configuration.layerRetrievalQueueSize
	   */

	  this.retrievalQueueSize = WorldWind.configuration.layerRetrievalQueueSize;
	  this.levels = new LevelSet(sector, levelZeroDelta, numLevels, tileWidth, tileHeight);
	  /**
	   * Controls the level of detail switching for this layer. The next highest resolution level is
	   * used when an image's texel size is greater than this number of pixels, up to the maximum resolution
	   * of this layer.
	   * @type {Number}
	   * @default 1.75
	   */

	  this.detailControl = 1.75;
	  /**
	   * Indicates whether credentials are sent when requesting images from a different origin.
	   *
	   * Allowed values are anonymous and use-credentials.
	   *
	   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-crossorigin
	   * @type {string}
	   * @default anonymous
	   */

	  this.crossOrigin = 'anonymous';
	  /* Intentionally not documented.
	   * Indicates the time at which this layer's imagery expire. Expired images are re-retrieved
	   * when the current time exceeds the specified expiry time. If null, images do not expire.
	   * @type {Date}
	   */

	  this.expiration = null;
	  this.currentTiles = [];
	  this.currentTilesInvalid = true;
	  this.tileCache = new MemoryCache(500000, 400000);
	  this.currentRetrievals = [];
	  this.absentResourceList = new AbsentResourceList(3, 50e3);
	  this.pickEnabled = false; // Internal. Intentionally not documented.

	  this.lasTtMVP = Matrix.fromIdentity();
	}

	TiledImageLayer.prototype = Object.create(Layer.prototype); // Inherited from Layer.

	TiledImageLayer.prototype.refresh = function () {
	  this.expiration = new Date();
	  this.currentTilesInvalid = true;
	};
	/**
	 * Initiates retrieval of this layer's level 0 images. Use
	 * [isPrePopulated]{@link TiledImageLayer#isPrePopulated} to determine when the images have been retrieved
	 * and associated with the level 0 tiles.
	 * Pre-populating is not required. It is used to eliminate the visual effect of loading tiles incrementally,
	 * but only for level 0 tiles. An application might pre-populate a layer in order to delay displaying it
	 * within a time series until all the level 0 images have been retrieved and added to memory.
	 * @param {WorldWindow} wwd The WorldWindow for which to pre-populate this layer.
	 * @throws {ArgumentError} If the specified WorldWindow is null or undefined.
	 */


	TiledImageLayer.prototype.prePopulate = function (wwd) {
	  if (!wwd) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledImageLayer", "prePopulate", "missingWorldWindow"));
	  }

	  var dc = wwd.drawContext;

	  if (!this.topLevelTiles || this.topLevelTiles.length === 0) {
	    this.createTopLevelTiles(dc);
	  }

	  for (var i = 0; i < this.topLevelTiles.length; i++) {
	    var tile = this.topLevelTiles[i];

	    if (!this.isTileTextureInMemory(dc, tile)) {
	      this.retrieveTileImage(dc, tile, true); // suppress redraw upon successful retrieval
	    }
	  }
	};
	/**
	 * Initiates retrieval of this layer's tiles that are visible in the specified WorldWindow. Pre-populating is
	 * not required. It is used to eliminate the visual effect of loading tiles incrementally.
	 * @param {WorldWindow} wwd The WorldWindow for which to pre-populate this layer.
	 * @throws {ArgumentError} If the specified WorldWindow is null or undefined.
	 */


	TiledImageLayer.prototype.prePopulateCurrentTiles = function (wwd) {
	  if (!wwd) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledImageLayer", "prePopulate", "missingWorldWindow"));
	  }

	  var dc = wwd.drawContext;
	  this.assembleTiles(dc);

	  for (var i = 0, len = this.currentTiles.length; i < len; i++) {
	    var tile = this.currentTiles[i];

	    if (!this.isTileTextureInMemory(dc, tile)) {
	      this.retrieveTileImage(dc, tile, true); // suppress redraw upon successful retrieval
	    }
	  }
	};
	/**
	 * Indicates whether this layer's level 0 tile images have been retrieved and associated with the tiles.
	 * Use [prePopulate]{@link TiledImageLayer#prePopulate} to initiate retrieval of level 0 images.
	 * @param {WorldWindow} wwd The WorldWindow associated with this layer.
	 * @returns {Boolean} true if all level 0 images have been retrieved, otherwise false.
	 * @throws {ArgumentError} If the specified WorldWindow is null or undefined.
	 */


	TiledImageLayer.prototype.isPrePopulated = function (wwd) {
	  if (!wwd) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TiledImageLayer", "isPrePopulated", "missingWorldWindow"));
	  }

	  for (var i = 0; i < this.topLevelTiles.length; i++) {
	    if (!this.isTileTextureInMemory(wwd.drawContext, this.topLevelTiles[i])) {
	      return false;
	    }
	  }

	  return true;
	}; // Intentionally not documented.


	TiledImageLayer.prototype.createTile = function (sector, level, row, column) {
	  var path = this.cachePath + "-layer/" + level.levelNumber + "/" + row + "/" + row + "_" + column + "." + WWUtil.suffixForMimeType(this.retrievalImageFormat);
	  return new ImageTile(sector, level, row, column, path);
	}; // Documented in superclass.


	TiledImageLayer.prototype.doRender = function (dc) {
	  if (!dc.terrain) return;

	  if (this.currentTilesInvalid || !dc.modelviewProjection.equals(this.lasTtMVP) || dc.globeStateKey !== this.lastGlobeStateKey) {
	    this.currentTilesInvalid = false; // Tile fading works visually only when the surface tiles are opaque, otherwise the surface flashes
	    // when two tiles are drawn over the same area, even though one of them is semi-transparent.
	    // So do not provide fading when the surface opacity is less than 1;

	    if (dc.surfaceOpacity >= 1 && this.opacity >= 1) {
	      // Fading of outgoing tiles requires determination of the those tiles. Prepare an object with all of
	      // the preceding frame's tiles so that we can subsequently compare the list of newly selected tiles
	      // with the previously selected tiles.
	      this.previousTiles = {};

	      for (var j = 0; j < this.currentTiles.length; j++) {
	        this.previousTiles[this.currentTiles[j].imagePath] = this.currentTiles[j];
	      }

	      this.assembleTiles(dc);
	      this.fadeOutgoingTiles(dc);
	    } else {
	      this.assembleTiles(dc);
	    }
	  }

	  this.lasTtMVP.copy(dc.modelviewProjection);
	  this.lastGlobeStateKey = dc.globeStateKey;

	  if (this.currentTiles.length > 0) {
	    dc.surfaceTileRenderer.renderTiles(dc, this.currentTiles, this.opacity, dc.surfaceOpacity >= 1);
	    dc.frameStatistics.incrementImageTileCount(this.currentTiles.length);
	    this.inCurrentFrame = true;
	  }
	};

	TiledImageLayer.prototype.fadeOutgoingTiles = function (dc) {
	  // Determine which files are outgoing and fade their disappearance. Must be called after this frame's
	  // current tiles for this layer have been determined.
	  var visibilityDelta = (dc.timestamp - dc.previousRedrawTimestamp) / dc.fadeTime; // Create a hash table of the current tiles so that we can check for tile inclusion below.

	  var current = {};

	  for (var i = 0; i < this.currentTiles.length; i++) {
	    var tile = this.currentTiles[i];
	    current[tile.imagePath] = tile;
	  } // Determine whether the tile was in the previous frame but is not in this one.  If that's the case,
	  // then the tile is outgoing and its opacity needs to be reduced.


	  for (var tileImagePath in this.previousTiles) {
	    if (this.previousTiles.hasOwnProperty(tileImagePath)) {
	      tile = this.previousTiles[tileImagePath];

	      if (tile.opacity > 0 && !current[tile.imagePath]) {
	        // Compute the reduced.
	        tile.opacity = Math.max(0, tile.opacity - visibilityDelta); // If not fully faded, add the tile to the list of current tiles and request a redraw so that
	        // we'll be called continuously until all tiles have faded completely. Note that order in the
	        // current tiles list is important: the non-opaque tiles must be drawn after the opaque tiles.

	        if (tile.opacity > 0) {
	          this.currentTiles.push(tile);
	          this.currentTilesInvalid = true;
	          dc.redrawRequested = true;
	        }
	      }
	    }
	  }
	}; // Documented in superclass.


	TiledImageLayer.prototype.isLayerInView = function (dc) {
	  return dc.terrain && dc.terrain.sector && dc.terrain.sector.intersects(this.levels.sector);
	}; // Documented in superclass.


	TiledImageLayer.prototype.createTopLevelTiles = function (dc) {
	  this.topLevelTiles = [];
	  Tile.createTilesForLevel(this.levels.firstLevel(), this, this.topLevelTiles);
	}; // Intentionally not documented.


	TiledImageLayer.prototype.assembleTiles = function (dc) {
	  this.currentTiles = [];

	  if (!this.topLevelTiles || this.topLevelTiles.length === 0) {
	    this.createTopLevelTiles(dc);
	  }

	  for (var i = 0, len = this.topLevelTiles.length; i < len; i++) {
	    var tile = this.topLevelTiles[i];
	    tile.update(dc);
	    this.currentAncestorTile = null;

	    if (this.isTileVisible(dc, tile)) {
	      this.addTileOrDescendants(dc, tile);
	    }
	  }
	}; // Intentionally not documented.


	TiledImageLayer.prototype.addTileOrDescendants = function (dc, tile) {
	  if (this.tileMeetsRenderingCriteria(dc, tile)) {
	    this.addTile(dc, tile);
	    return;
	  }

	  var ancestorTile = null;

	  try {
	    if (this.isTileTextureInMemory(dc, tile) || tile.level.levelNumber === 0) {
	      ancestorTile = this.currentAncestorTile;
	      this.currentAncestorTile = tile;
	    }

	    var nextLevel = this.levels.level(tile.level.levelNumber + 1),
	        subTiles = tile.subdivideToCache(nextLevel, this, this.tileCache);

	    for (var i = 0, len = subTiles.length; i < len; i++) {
	      var child = subTiles[i];
	      child.update(dc);

	      if (this.levels.sector.intersects(child.sector) && this.isTileVisible(dc, child)) {
	        this.addTileOrDescendants(dc, child);
	      }
	    }
	  } finally {
	    if (ancestorTile) {
	      this.currentAncestorTile = ancestorTile;
	    }
	  }
	}; // Intentionally not documented.


	TiledImageLayer.prototype.addTile = function (dc, tile) {
	  tile.fallbackTile = null;
	  var texture = dc.gpuResourceCache.resourceForKey(tile.imagePath);

	  if (texture) {
	    tile.opacity = 1;
	    this.currentTiles.push(tile); // If the tile's texture has expired, cause it to be re-retrieved. Note that the current,
	    // expired texture is still used until the updated one arrives.

	    if (this.expiration && this.isTextureExpired(texture)) {
	      this.retrieveTileImage(dc, tile);
	    }

	    return;
	  }

	  this.retrieveTileImage(dc, tile);

	  if (this.currentAncestorTile) {
	    if (this.isTileTextureInMemory(dc, this.currentAncestorTile)) {
	      // Set up to map the ancestor tile into the current one.
	      tile.fallbackTile = this.currentAncestorTile;
	      tile.fallbackTile.opacity = 1;
	      this.currentTiles.push(tile);
	    }
	  }
	}; // Intentionally not documented.


	TiledImageLayer.prototype.isTileVisible = function (dc, tile) {
	  if (dc.globe.projectionLimits && !tile.sector.overlaps(dc.globe.projectionLimits)) {
	    return false;
	  }

	  return tile.extent.intersectsFrustum(dc.frustumInModelCoordinates);
	}; // Intentionally not documented.


	TiledImageLayer.prototype.tileMeetsRenderingCriteria = function (dc, tile) {
	  var s = this.detailControl;

	  if (tile.sector.minLatitude >= 75 || tile.sector.maxLatitude <= -75) {
	    s *= 1.2;
	  }

	  return tile.level.isLastLevel() || !tile.mustSubdivide(dc, s);
	}; // Intentionally not documented.


	TiledImageLayer.prototype.isTileTextureInMemory = function (dc, tile) {
	  return dc.gpuResourceCache.containsResource(tile.imagePath);
	}; // Intentionally not documented.


	TiledImageLayer.prototype.isTextureExpired = function (texture) {
	  return this.expiration && texture.creationTime.getTime() <= this.expiration.getTime();
	};
	/**
	 * Retrieves the image for the specified tile. Subclasses should override this method in order to retrieve,
	 * compute or otherwise create the image.
	 * @param {DrawContext} dc The current draw context.
	 * @param {ImageTile} tile The tile for which to retrieve the resource.
	 * @param {Boolean} suppressRedraw true to suppress generation of redraw events when an image is successfully
	 * retrieved, otherwise false.
	 * @protected
	 */


	TiledImageLayer.prototype.retrieveTileImage = function (dc, tile, suppressRedraw) {
	  if (this.currentRetrievals.indexOf(tile.imagePath) < 0) {
	    if (this.currentRetrievals.length > this.retrievalQueueSize) {
	      return;
	    }

	    if (this.absentResourceList.isResourceAbsent(tile.imagePath)) {
	      return;
	    }

	    var url = this.resourceUrlForTile(tile, this.retrievalImageFormat),
	        image = new Image(),
	        imagePath = tile.imagePath,
	        cache = dc.gpuResourceCache,
	        canvas = dc.currentGlContext.canvas,
	        layer = this;

	    if (!url) {
	      this.currentTilesInvalid = true;
	      return;
	    }

	    image.onload = function () {
	      Logger$1.log(Logger$1.LEVEL_INFO, "Image retrieval succeeded: " + url);
	      var texture = layer.createTexture(dc, tile, image);
	      layer.removeFromCurrentRetrievals(imagePath);

	      if (texture) {
	        cache.putResource(imagePath, texture, texture.size);
	        layer.currentTilesInvalid = true;
	        layer.absentResourceList.unmarkResourceAbsent(imagePath);

	        if (!suppressRedraw) {
	          // Send an event to request a redraw.
	          var e = document.createEvent('Event');
	          e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
	          canvas.dispatchEvent(e);
	        }
	      }
	    };

	    image.onerror = function () {
	      layer.removeFromCurrentRetrievals(imagePath);
	      layer.absentResourceList.markResourceAbsent(imagePath);
	      Logger$1.log(Logger$1.LEVEL_WARNING, "Image retrieval failed: " + url);
	    };

	    this.currentRetrievals.push(imagePath);
	    image.crossOrigin = this.crossOrigin;
	    image.src = url;
	  }
	}; // Intentionally not documented.


	TiledImageLayer.prototype.createTexture = function (dc, tile, image) {
	  return new Texture$1(dc.currentGlContext, image);
	}; // Intentionally not documented.


	TiledImageLayer.prototype.removeFromCurrentRetrievals = function (imagePath) {
	  var index = this.currentRetrievals.indexOf(imagePath);

	  if (index > -1) {
	    this.currentRetrievals.splice(index, 1);
	  }
	};
	/**
	 * Returns the URL string for the resource.
	 * @param {ImageTile} tile The tile whose image is returned
	 * @param {String} imageFormat The mime type of the image format desired.
	 * @returns {String} The URL string, or null if the string can not be formed.
	 * @protected
	 */


	TiledImageLayer.prototype.resourceUrlForTile = function (tile, imageFormat) {
	  if (this.urlBuilder) {
	    return this.urlBuilder.urlForTile(tile, imageFormat);
	  } else {
	    return null;
	  }
	};

	/**
	 * @exports MercatorTiledImageLayer
	 */
	/**
	 * Constructs a layer supporting Mercator imagery.
	 * @alias MercatorTiledImageLayer
	 * @constructor
	 * @augments TiledImageLayer
	 * @classdesc Provides an abstract layer to support Mercator layers.
	 *
	 * @param {Sector} sector The sector this layer covers.
	 * @param {Location} levelZeroDelta The size in latitude and longitude of level zero (lowest resolution) tiles.
	 * @param {Number} numLevels The number of levels to define for the layer. Each level is successively one power
	 * of two higher resolution than the next lower-numbered level. (0 is the lowest resolution level, 1 is twice
	 * that resolution, etc.)
	 * Each level contains four times as many tiles as the next lower-numbered level, each 1/4 the geographic size.
	 * @param {String} imageFormat The mime type of the image format for the layer's tiles, e.g., <em>image/png</em>.
	 * @param {String} cachePath A string uniquely identifying this layer relative to other layers.
	 * @param {Number} tileWidth The horizontal size of image tiles in pixels.
	 * @param {Number} tileHeight The vertical size of image tiles in pixels.
	 * @throws {ArgumentError} If any of the specified sector, level-zero delta, cache path or image format arguments are
	 * null or undefined, or if the specified number of levels, tile width or tile height is less than 1.
	 */

	function MercatorTiledImageLayer(sector, levelZeroDelta, numLevels, imageFormat, cachePath, tileWidth, tileHeight) {
	  TiledImageLayer.call(this, sector, levelZeroDelta, numLevels, imageFormat, cachePath, tileWidth, tileHeight);
	  this.detectBlankImages = false; // These pixels are tested in retrieved images to determine whether the image is blank.

	  this.testPixels = [new Vec2(20, 20), new Vec2(235, 20), new Vec2(20, 235), new Vec2(235, 235)]; // Create a canvas we can use when unprojecting retrieved images.

	  this.destCanvas = document.createElement("canvas");
	  this.destContext = this.destCanvas.getContext("2d");
	}

	MercatorTiledImageLayer.prototype = Object.create(TiledImageLayer.prototype); // Overridden from TiledImageLayer. Computes a tile's sector and creates the tile.
	// Unlike typical tiles, Tiles at the same level do not have the same sector size.

	MercatorTiledImageLayer.prototype.createTile = function (sector, level, row, column) {
	  var mapSize = this.mapSizeForLevel(level.levelNumber),
	      swX = WWMath.clamp(column * this.imageSize, 0, mapSize),
	      neY = WWMath.clamp(row * this.imageSize, 0, mapSize),
	      neX = WWMath.clamp(swX + this.imageSize, 0, mapSize),
	      swY = WWMath.clamp(neY + this.imageSize, 0, mapSize),
	      x,
	      y,
	      swLat,
	      swLon,
	      neLat,
	      neLon;
	  x = swX / mapSize - 0.5;
	  y = 0.5 - swY / mapSize;
	  swLat = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
	  swLon = 360 * x;
	  x = neX / mapSize - 0.5;
	  y = 0.5 - neY / mapSize;
	  neLat = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
	  neLon = 360 * x;
	  sector = new Sector(swLat, neLat, swLon, neLon);
	  return TiledImageLayer.prototype.createTile.call(this, sector, level, row, column);
	}; // Overridden from TiledImageLayer to unproject the retrieved image prior to creating a texture for it.


	MercatorTiledImageLayer.prototype.createTexture = function (dc, tile, image) {
	  var srcCanvas = dc.canvas2D,
	      srcContext = dc.ctx2D,
	      srcImageData,
	      destCanvas = this.destCanvas,
	      destContext = this.destContext,
	      destImageData = destContext.createImageData(image.width, image.height),
	      sector = tile.sector,
	      tMin = WWMath.gudermannianInverse(sector.minLatitude),
	      tMax = WWMath.gudermannianInverse(sector.maxLatitude),
	      lat,
	      g,
	      srcRow,
	      kSrc,
	      kDest,
	      sy,
	      dy;
	  srcCanvas.width = image.width;
	  srcCanvas.height = image.height;
	  destCanvas.width = image.width;
	  destCanvas.height = image.height; // Draw the original image to a canvas so image data can be had for it.

	  srcContext.drawImage(image, 0, 0, image.width, image.height);
	  srcImageData = srcContext.getImageData(0, 0, image.width, image.height); // If it's a blank image, mark it as permanently absent.

	  if (this.detectBlankImages && this.isBlankImage(image, srcImageData)) {
	    this.absentResourceList.markResourceAbsentPermanently(tile.imagePath);
	    return null;
	  } // Unproject the retrieved image.


	  for (var n = 0; n < 1; n++) {
	    for (var y = 0; y < image.height; y++) {
	      sy = 1 - y / (image.height - 1);
	      lat = sy * sector.deltaLatitude() + sector.minLatitude;
	      g = WWMath.gudermannianInverse(lat);
	      dy = 1 - (g - tMin) / (tMax - tMin);
	      dy = WWMath.clamp(dy, 0, 1);
	      srcRow = Math.floor(dy * (image.height - 1));

	      for (var x = 0; x < image.width; x++) {
	        kSrc = 4 * (x + srcRow * image.width);
	        kDest = 4 * (x + y * image.width);
	        destImageData.data[kDest] = srcImageData.data[kSrc];
	        destImageData.data[kDest + 1] = srcImageData.data[kSrc + 1];
	        destImageData.data[kDest + 2] = srcImageData.data[kSrc + 2];
	        destImageData.data[kDest + 3] = srcImageData.data[kSrc + 3];
	      }
	    }
	  }

	  destContext.putImageData(destImageData, 0, 0);
	  return TiledImageLayer.prototype.createTexture.call(this, dc, tile, destCanvas);
	}; // Determines whether a retrieved image is blank.


	MercatorTiledImageLayer.prototype.isBlankImage = function (image, srcImageData) {
	  var pixel,
	      k,
	      pixelValue = null;

	  for (var i = 0, len = this.testPixels.length; i < len; i++) {
	    pixel = this.testPixels[i];
	    k = 4 * (pixel[0] + pixel[1] * image.width);

	    if (!pixelValue) {
	      pixelValue = [srcImageData.data[k], srcImageData.data[k + 1], srcImageData.data[k + 2]];
	    } else {
	      if (srcImageData.data[k] != pixelValue[0] || srcImageData.data[k + 1] != pixelValue[1] || srcImageData.data[k + 2] != pixelValue[2]) {
	        return false;
	      }
	    }
	  }

	  return true;
	};

	/**
	 * @exports NominatimGeocoder
	 */
	/**
	 * Constructs a Nominatim geocoder.
	 * @alias NominatimGeocoder
	 * @constructor
	 * @classdesc Provides a gazetteer that uses Open Street Map Nominatim geocoder at Mapquest.
	 */

	function NominatimGeocoder() {
	  /**
	   * The URL of the geocoder service.
	   * @type {String}
	   * @default http://open.mapquestapi.com/nominatim/v1/search/
	   */
	  this.service = "https://open.mapquestapi.com/nominatim/v1/search/";
	}
	/**
	 * Queries the geocoder service with a specified query string.
	 * @param {String} queryString The query string.
	 * @param {Function} callback The function to call when the service returns the query results. This
	 * function is passed two arguments: this geocoder and an array containing the query results. See
	 * [the OpenStreetMap Nominatim Wiki] {@link http://wiki.openstreetmap.org/wiki/Nominatim} for a description
	 * of the results. The result passed to the callback is parsed JSON.
	 * @param {String} accessKey The MapQuest API access key to use for the request. See
	 * https://developer.mapquest.com/plan_purchase/free/business_edition/business_edition_free
	 * to obtain a key.
	 */


	NominatimGeocoder.prototype.lookup = function (queryString, callback, accessKey) {
	  var url = this.service + queryString.replace(" ", "%20") + "?format=json",
	      xhr = new XMLHttpRequest(),
	      thisGeocoder = this;
	  url += "&key=" + (accessKey || "lUvVRchXGGDh5Xwk3oidrXeIDAAevOUS");
	  xhr.open("GET", url, true);

	  xhr.onreadystatechange = function () {
	    if (xhr.readyState === 4 && xhr.status === 200) {
	      var results = JSON.parse(xhr.responseText);
	      callback(thisGeocoder, results);
	    }
	  };

	  xhr.send(null);
	};

	/**
	 * @exports SurfacePolyline
	 */
	/**
	 * Constructs a surface polyline.
	 * @alias SurfacePolyline
	 * @constructor
	 * @augments SurfaceShape
	 * @classdesc Represents a polyline draped over the terrain surface.
	 * <p>
	 * SurfacePolyline uses the following attributes from its associated shape attributes bundle:
	 * <ul>
	 *         <li>Draw outline</li>
	 *         <li>Outline color</li>
	 *         <li>Outline width</li>
	 *         <li>Outline stipple factor</li>
	 *         <li>Outline stipple pattern</li>
	 * </ul>
	 * @param {Location[]} locations This polyline's locations.
	 * @param {ShapeAttributes} attributes The attributes to apply to this shape. May be null, in which case
	 * attributes must be set directly before the shape is drawn.
	 * @throws {ArgumentError} If the specified locations are null or undefined.
	 */

	function SurfacePolyline(locations, attributes) {
	  if (!locations) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfacePolyline", "constructor", "The specified locations array is null or undefined."));
	  }

	  SurfaceShape.call(this, attributes);
	  /**
	   * This shape's locations, specified as an array locations.
	   * @type {Array}
	   */

	  this._boundaries = locations;
	  this._stateId = SurfacePolyline.stateId++; // Internal use only.

	  this._isInteriorInhibited = true;
	}

	SurfacePolyline.prototype = Object.create(SurfaceShape.prototype);
	Object.defineProperties(SurfacePolyline.prototype, {
	  /**
	   * This polyline's boundaries. The polylines locations.
	   * @type {Location[]}
	   * @memberof SurfacePolyline.prototype
	   */
	  boundaries: {
	    get: function () {
	      return this._boundaries;
	    },
	    set: function (boundaries) {
	      if (!Array.isArray(boundaries)) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfacePolyline", "set boundaries", "The specified value is not an array."));
	      }

	      this.resetBoundaries();
	      this._boundaries = boundaries;
	      this._stateId = SurfacePolyline.stateId++;
	      this.stateKeyInvalid = true;
	    }
	  }
	}); // Internal use only. Intentionally not documented.

	SurfacePolyline.stateId = Number.MIN_SAFE_INTEGER; // Internal use only. Intentionally not documented.

	SurfacePolyline.staticStateKey = function (shape) {
	  var shapeStateKey = SurfaceShape.staticStateKey(shape);
	  return shapeStateKey + " pl " + shape._stateId;
	}; // Internal use only. Intentionally not documented.


	SurfacePolyline.prototype.computeStateKey = function () {
	  return SurfacePolyline.staticStateKey(this);
	}; // Internal. Polyline doesn't generate its own boundaries. See SurfaceShape.prototype.computeBoundaries.


	SurfacePolyline.prototype.computeBoundaries = function (dc) {}; // Internal use only. Intentionally not documented.


	SurfacePolyline.prototype.getReferencePosition = function () {
	  return this.boundaries.length > 1 ? this.boundaries[0] : null;
	}; // Internal use only. Intentionally not documented.


	SurfacePolyline.prototype.moveTo = function (globe, position) {
	  this.boundaries = this.computeShiftedLocations(globe, this.getReferencePosition(), position, this._boundaries);
	};

	/**
	 * @exports Path
	 */
	/**
	 * Constructs a path.
	 * @alias Path
	 * @constructor
	 * @augments AbstractShape
	 * @classdesc Represents a line, curve or curtain between specified positions. The path is drawn between input
	 * positions to achieve a specified path type, which can be one of the following:
	 * <ul>
	 *     <li>[WorldWind.GREAT_CIRCLE]{@link WorldWind#GREAT_CIRCLE}</li>
	 *     <li>[WorldWind.RHUMB_LINE]{@link WorldWind#RHUMB_LINE}</li>
	 *     <li>[WorldWind.LINEAR]{@link WorldWind#LINEAR}</li>
	 * </ul>
	 * <p>
	 *     Paths conform to the terrain if the path's [followTerrain]{@link Path#followTerrain} property is true.
	 * <p>
	 *     Altitudes within the path's positions are interpreted according to the path's altitude mode, which
	 *     can be one of the following:
	 * <ul>
	 *     <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	 *     <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	 *     <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	 * </ul>
	 * If the latter, the path positions' altitudes are ignored.
	 * <p>
	 *     Paths have separate attributes for normal display and highlighted display. They use the interior and
	 *     outline attributes of {@link ShapeAttributes} but do not use the image attributes.
	 * <p>
	 *     A path displays as a curtain if its [extrude]{@link Path#extrude} property is true. A curtain extends
	 *     from the line formed by the path positions to the ground.
	 * <p>
	 *     This shape uses a {@link SurfacePolyline} when drawing on 2D globes and this shape's
	 *     [useSurfaceShapeFor2D]{@link AbstractShape#useSurfaceShapeFor2D} is true.
	 *
	 * @param {Position[]} positions An array containing the path positions.
	 * @param {ShapeAttributes} attributes The attributes to associate with this path. May be null, in which case
	 * default attributes are associated.
	 * @throws {ArgumentError} If the specified positions array is null or undefined.
	 */

	function Path(positions, attributes) {
	  if (!positions) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Path", "constructor", "missingPositions"));
	  }

	  AbstractShape.call(this, attributes); // Private. Documentation is with the defined property below.

	  this._positions = positions; // Private. Documentation is with the defined property below.

	  this._pathType = WorldWind.GREAT_CIRCLE; // Private. Documentation is with the defined property below.

	  this._terrainConformance = 10; // Private. Documentation is with the defined property below.

	  this._numSubSegments = 10;
	  this.referencePosition = this.determineReferencePosition(this._positions);
	  this.scratchPoint = new Vec3$1(0, 0, 0); // scratch variable
	}

	Path.prototype = Object.create(AbstractShape.prototype);
	Object.defineProperties(Path.prototype, {
	  /**
	   * This path's positions.
	   * @type {Position[]}
	   * @memberof Path.prototype
	   */
	  positions: {
	    get: function () {
	      return this._positions;
	    },
	    set: function (positions) {
	      if (!positions) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Path", "constructor", "missingPositions"));
	      }

	      this._positions = positions;
	      this.referencePosition = this.determineReferencePosition(this._positions);
	      this.reset();
	    }
	  },

	  /**
	   * Indicates whether this path should conform to the terrain.
	   * @type {Boolean}
	   * @default false
	   * @memberof Path.prototype
	   */
	  followTerrain: {
	    get: function () {
	      return this._followTerrain;
	    },
	    set: function (followTerrain) {
	      this._followTerrain = followTerrain;
	      this.reset();
	    }
	  },

	  /**
	   * Specifies how accurately this path must adhere to the terrain when the path is terrain following. The value
	   * specifies the maximum number of pixels between tessellation points. Lower values increase accuracy but decrease
	   * performance.
	   * @type {Number}
	   * @default 10
	   * @memberof Path.prototype
	   */
	  terrainConformance: {
	    get: function () {
	      return this._terrainConformance;
	    },
	    set: function (terrainConformance) {
	      this._terrainConformance = terrainConformance;
	      this.reset();
	    }
	  },

	  /**
	   * Specifies the number of segments used between specified positions to achieve this path's path type. Higher values
	   * cause the path to conform more closely to the path type but decrease performance.
	   * <p/>
	   * Note: The sub-segments number is ignored when the path follows terrain or when the path type is
	   * WorldWind.LINEAR.
	   * @type {Number}
	   * @default 10
	   * @memberof Path.prototype
	   */
	  numSubSegments: {
	    get: function () {
	      return this._numSubSegments;
	    },
	    set: function (numSubSegments) {
	      this._numSubSegments = numSubSegments >= 0 ? numSubSegments : 0;
	      this.reset();
	    }
	  },

	  /**
	   * The type of path to follow when drawing the path. Recognized values are:
	   * <ul>
	   * <li>[WorldWind.GREAT_CIRCLE]{@link WorldWind#GREAT_CIRCLE}</li>
	   * <li>[WorldWind.RHUMB_LINE]{@link WorldWind#RHUMB_LINE}</li>
	   * <li>[WorldWind.LINEAR]{@link WorldWind#LINEAR}</li>
	   * </ul>
	   * @type {String}
	   * @default WorldWind.GREAT_CIRCLE
	   * @memberof Path.prototype
	   */
	  pathType: {
	    get: function () {
	      return this._pathType;
	    },
	    set: function (pathType) {
	      this._pathType = pathType;
	      this.reset();
	    }
	  },

	  /**
	   * Specifies whether to extrude this path to the ground by drawing a filled interior from the path to the
	   * terrain. The filled interior uses this path's interior attributes.
	   * @type {Boolean}
	   * @default false
	   * @memberof Path.prototype
	   */
	  extrude: {
	    get: function () {
	      return this._extrude;
	    },
	    set: function (extrude) {
	      this._extrude = extrude;
	      this.reset();
	    }
	  }
	}); // Intentionally not documented.

	Path.prototype.determineReferencePosition = function (positions) {
	  // Assign the first position as the reference position.
	  return positions.length > 0 ? positions[0] : null;
	}; // Internal. Determines whether this shape's geometry must be re-computed.


	Path.prototype.mustGenerateGeometry = function (dc) {
	  if (!this.currentData.tessellatedPoints) {
	    return true;
	  }

	  if (this.currentData.drawInterior !== this.activeAttributes.drawInterior || this.currentData.drawVerticals !== this.activeAttributes.drawVerticals) {
	    return true;
	  }

	  if (!this.followTerrain && this.currentData.numSubSegments !== this.numSubSegments) {
	    return true;
	  }

	  if (this.followTerrain && this.currentData.terrainConformance !== this.terrainConformance) {
	    return true;
	  }

	  if (this.altitudeMode === WorldWind.ABSOLUTE) {
	    return false;
	  }

	  return this.currentData.isExpired;
	};

	Path.prototype.createSurfaceShape = function () {
	  return new SurfacePolyline(this.positions, null);
	}; // Overridden from AbstractShape base class.


	Path.prototype.doMakeOrderedRenderable = function (dc) {
	  // A null reference position is a signal that there are no positions to render.
	  if (!this.referencePosition) {
	    return null;
	  } // See if the current shape data can be re-used.


	  if (!this.mustGenerateGeometry(dc)) {
	    return this;
	  } // Set the transformation matrix to correspond to the reference position.


	  var refPt = this.currentData.referencePoint;
	  dc.surfacePointForMode(this.referencePosition.latitude, this.referencePosition.longitude, this.referencePosition.altitude, this._altitudeMode, refPt);
	  this.currentData.transformationMatrix.setToTranslation(refPt[0], refPt[1], refPt[2]); // Tessellate the path in geographic coordinates.

	  var tessellatedPositions = this.makeTessellatedPositions(dc);

	  if (tessellatedPositions.length < 2) {
	    return null;
	  } // Convert the tessellated geographic coordinates to the Cartesian coordinates that will be rendered.


	  var tessellatedPoints = this.computeRenderedPath(dc, tessellatedPositions);
	  this.currentData.tessellatedPoints = tessellatedPoints;
	  this.currentData.drawInterior = this.activeAttributes.drawInterior;
	  this.currentData.drawVerticals = this.activeAttributes.drawVerticals;
	  this.currentData.numSubSegments = this.numSubSegments;
	  this.currentData.terrainConformance = this.terrainConformance;
	  this.resetExpiration(this.currentData);
	  this.currentData.fillVbo = true; // Create the extent from the Cartesian points. Those points are relative to this path's reference point, so
	  // translate the computed extent to the reference point.

	  if (!this.currentData.extent) {
	    this.currentData.extent = new BoundingBox();
	  }

	  this.currentData.extent.setToPoints(tessellatedPoints);
	  this.currentData.extent.translate(this.currentData.referencePoint);
	  return this;
	}; // Private. Intentionally not documented.


	Path.prototype.makeTessellatedPositions = function (dc) {
	  var tessellatedPositions = [],
	      eyePoint = dc.eyePoint,
	      showVerticals = this.mustDrawVerticals(dc),
	      ptA = new Vec3$1(0, 0, 0),
	      ptB = new Vec3$1(0, 0, 0),
	      posA = this._positions[0],
	      posB,
	      eyeDistance,
	      pixelSize;

	  if (showVerticals) {
	    this.currentData.verticalIndices = new Int16Array(this.positions.length * 2);
	    this.currentData.verticalIndices[0] = 0;
	    this.currentData.verticalIndices[1] = 1;
	  }

	  tessellatedPositions.push(posA);
	  dc.surfacePointForMode(posA.latitude, posA.longitude, posA.altitude, this._altitudeMode, ptA);

	  for (var i = 1, len = this._positions.length; i < len; i++) {
	    posB = this._positions[i];
	    dc.surfacePointForMode(posB.latitude, posB.longitude, posB.altitude, this._altitudeMode, ptB);
	    eyeDistance = eyePoint.distanceTo(ptA);
	    pixelSize = dc.pixelSizeAtDistance(eyeDistance);

	    if (ptA.distanceTo(ptB) < pixelSize * 8 && this.altitudeMode !== WorldWind.ABSOLUTE) {
	      tessellatedPositions.push(posB); // distance is short so no need for sub-segments
	    } else {
	      this.makeSegment(dc, posA, posB, ptA, ptB, tessellatedPositions);
	    }

	    posA = posB;
	    ptA.copy(ptB);

	    if (showVerticals) {
	      var k = 2 * (tessellatedPositions.length - 1);
	      this.currentData.verticalIndices[i * 2] = k;
	      this.currentData.verticalIndices[i * 2 + 1] = k + 1;
	    }
	  }

	  return tessellatedPositions;
	}; // Private. Intentionally not documented.


	Path.prototype.makeSegment = function (dc, posA, posB, ptA, ptB, tessellatedPositions) {
	  var eyePoint = dc.eyePoint,
	      pos = new Location(0, 0),
	      height = 0,
	      arcLength,
	      segmentAzimuth,
	      segmentDistance,
	      s,
	      p,
	      distance; // If it's just a straight line and not terrain following, then the segment is just two points.

	  if (this._pathType === WorldWind.LINEAR && !this._followTerrain) {
	    if (!ptA.equals(ptB)) {
	      tessellatedPositions.push(posB);
	    }

	    return;
	  } // Compute the segment length.


	  if (this._pathType === WorldWind.LINEAR) {
	    segmentDistance = Location.linearDistance(posA, posB);
	  } else if (this._pathType === WorldWind.RHUMB_LINE) {
	    segmentDistance = Location.rhumbDistance(posA, posB);
	  } else {
	    segmentDistance = Location.greatCircleDistance(posA, posB);
	  }

	  if (this._altitudeMode !== WorldWind.CLAMP_TO_GROUND) {
	    height = 0.5 * (posA.altitude + posB.altitude);
	  }

	  arcLength = segmentDistance * (dc.globe.equatorialRadius + height * dc.verticalExaggeration);

	  if (arcLength <= 0) {
	    // segment is 0 length
	    return;
	  } // Compute the azimuth to apply while tessellating the segment.


	  if (this._pathType === WorldWind.LINEAR) {
	    segmentAzimuth = Location.linearAzimuth(posA, posB);
	  } else if (this._pathType === WorldWind.RHUMB_LINE) {
	    segmentAzimuth = Location.rhumbAzimuth(posA, posB);
	  } else {
	    segmentAzimuth = Location.greatCircleAzimuth(posA, posB);
	  }

	  this.scratchPoint.copy(ptA);

	  for (s = 0, p = 0; s < 1;) {
	    if (this._followTerrain) {
	      p += this._terrainConformance * dc.pixelSizeAtDistance(this.scratchPoint.distanceTo(eyePoint));
	    } else {
	      p += arcLength / this._numSubSegments;
	    } // Stop adding intermediate positions when we reach the arc length, or the remaining distance is in
	    // millimeters on Earth.


	    if (arcLength < p || arcLength - p < 1e-9) break;
	    s = p / arcLength;
	    distance = s * segmentDistance;

	    if (this._pathType === WorldWind.LINEAR) {
	      Location.linearLocation(posA, segmentAzimuth, distance, pos);
	    } else if (this._pathType === WorldWind.RHUMB_LINE) {
	      Location.rhumbLocation(posA, segmentAzimuth, distance, pos);
	    } else {
	      Location.greatCircleLocation(posA, segmentAzimuth, distance, pos);
	    }

	    pos.altitude = (1 - s) * posA.altitude + s * posB.altitude;
	    tessellatedPositions.push(new Position(pos.latitude, pos.longitude, pos.altitude));

	    if (this._followTerrain) {
	      // Compute a new reference point for eye distance.
	      dc.surfacePointForMode(pos.latitude, pos.longitude, pos.altitude, WorldWind.CLAMP_TO_GROUND, this.scratchPoint);
	    }
	  }

	  tessellatedPositions.push(posB);
	}; // Private. Intentionally not documented.


	Path.prototype.computeRenderedPath = function (dc, tessellatedPositions) {
	  var capturePoles = this.mustDrawInterior(dc) || this.mustDrawVerticals(dc),
	      eyeDistSquared = Number.MAX_VALUE,
	      eyePoint = dc.eyePoint,
	      numPoints = (capturePoles ? 2 : 1) * tessellatedPositions.length,
	      tessellatedPoints = new Float32Array(numPoints * 3),
	      stride = capturePoles ? 6 : 3,
	      pt = new Vec3$1(0, 0, 0),
	      altitudeMode,
	      pos,
	      k,
	      dSquared;

	  if (this._followTerrain && this.altitudeMode !== WorldWind.CLAMP_TO_GROUND) {
	    altitudeMode = WorldWind.RELATIVE_TO_GROUND;
	  } else {
	    altitudeMode = this.altitudeMode;
	  }

	  for (var i = 0, len = tessellatedPositions.length; i < len; i++) {
	    pos = tessellatedPositions[i];
	    dc.surfacePointForMode(pos.latitude, pos.longitude, pos.altitude, altitudeMode, pt);
	    dSquared = pt.distanceToSquared(eyePoint);

	    if (dSquared < eyeDistSquared) {
	      eyeDistSquared = dSquared;
	    }

	    pt.subtract(this.currentData.referencePoint);
	    k = stride * i;
	    tessellatedPoints[k] = pt[0];
	    tessellatedPoints[k + 1] = pt[1];
	    tessellatedPoints[k + 2] = pt[2];

	    if (capturePoles) {
	      dc.surfacePointForMode(pos.latitude, pos.longitude, 0, WorldWind.CLAMP_TO_GROUND, pt);
	      dSquared = pt.distanceToSquared(eyePoint);

	      if (dSquared < eyeDistSquared) {
	        eyeDistSquared = dSquared;
	      }

	      pt.subtract(this.currentData.referencePoint);
	      tessellatedPoints[k + 3] = pt[0];
	      tessellatedPoints[k + 4] = pt[1];
	      tessellatedPoints[k + 5] = pt[2];
	    }
	  }

	  this.currentData.pointBufferHasExtrusionPoints = capturePoles;
	  this.currentData.eyeDistance = Math.sqrt(eyeDistSquared);
	  return tessellatedPoints;
	}; // Private. Intentionally not documented.


	Path.prototype.mustDrawInterior = function (dc) {
	  return this.activeAttributes.drawInterior && this._extrude && this._altitudeMode !== WorldWind.CLAMP_TO_GROUND;
	}; // Private. Intentionally not documented.


	Path.prototype.mustDrawVerticals = function (dc) {
	  return this.activeAttributes.drawOutline && this.activeAttributes.drawVerticals && this.altitudeMode !== WorldWind.CLAMP_TO_GROUND;
	}; // Overridden from AbstractShape base class.


	Path.prototype.doRenderOrdered = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram,
	      currentData = this.currentData,
	      numPoints = currentData.tessellatedPoints.length / 3,
	      vboId,
	      color,
	      pickColor,
	      stride,
	      nPts;
	  this.applyMvpMatrix(dc);

	  if (!currentData.vboCacheKey) {
	    currentData.vboCacheKey = dc.gpuResourceCache.generateCacheKey();
	  }

	  vboId = dc.gpuResourceCache.resourceForKey(currentData.vboCacheKey);

	  if (!vboId) {
	    vboId = gl.createBuffer();
	    dc.gpuResourceCache.putResource(this.currentData.vboCacheKey, vboId, currentData.tessellatedPoints.length * 4);
	    currentData.fillVbo = true;
	  } // Bind and if necessary fill the VBO. We fill the VBO here rather than in doMakeOrderedRenderable so that
	  // there's no possibility of the VBO being ejected from the cache between the time it's filled and
	  // the time it's used.


	  gl.bindBuffer(gl.ARRAY_BUFFER, vboId);

	  if (currentData.fillVbo) {
	    gl.bufferData(gl.ARRAY_BUFFER, currentData.tessellatedPoints, gl.STATIC_DRAW);
	    dc.frameStatistics.incrementVboLoadCount(1);
	  }

	  program.loadTextureEnabled(gl, false);

	  if (dc.pickingMode) {
	    pickColor = dc.uniquePickColor();
	  }

	  if (this.mustDrawInterior(dc)) {
	    color = this.activeAttributes.interiorColor; // Disable writing the shape's fragments to the depth buffer when the interior is semi-transparent.

	    gl.depthMask(color.alpha * this.layer.opacity >= 1 || dc.pickingMode);
	    program.loadColor(gl, dc.pickingMode ? pickColor : color);
	    program.loadOpacity(gl, dc.pickingMode ? 1 : this.layer.opacity);
	    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	    gl.drawArrays(gl.TRIANGLE_STRIP, 0, numPoints);
	  }

	  if (this.activeAttributes.drawOutline) {
	    if (this.mustDrawVerticals(dc) && this.mustDrawInterior(dc) || this.altitudeMode === WorldWind.CLAMP_TO_GROUND) {
	      // Make the verticals stand out from the interior, or the outline stand out from the terrain.
	      this.applyMvpMatrixForOutline(dc);
	    }

	    color = this.activeAttributes.outlineColor; // Disable writing the shape's fragments to the depth buffer when the interior is semi-transparent.

	    gl.depthMask(color.alpha * this.layer.opacity >= 1 || dc.pickingMode);
	    program.loadColor(gl, dc.pickingMode ? pickColor : color);
	    program.loadOpacity(gl, dc.pickingMode ? 1 : this.layer.opacity);
	    gl.lineWidth(this.activeAttributes.outlineWidth);

	    if (this.currentData.pointBufferHasExtrusionPoints) {
	      stride = 24;
	      nPts = numPoints / 2;
	    } else {
	      stride = 12;
	      nPts = numPoints;
	    }

	    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, stride, 0);
	    gl.drawArrays(gl.LINE_STRIP, 0, nPts);

	    if (this.mustDrawVerticals(dc)) {
	      if (!currentData.verticalIndicesVboCacheKey) {
	        currentData.verticalIndicesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	      }

	      vboId = dc.gpuResourceCache.resourceForKey(currentData.verticalIndicesVboCacheKey);

	      if (!vboId) {
	        vboId = gl.createBuffer();
	        dc.gpuResourceCache.putResource(currentData.verticalIndicesVboCacheKey, vboId, currentData.verticalIndices.length * 4);
	        currentData.fillVbo = true;
	      }

	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vboId);

	      if (currentData.fillVbo) {
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, currentData.verticalIndices, gl.STATIC_DRAW);
	        dc.frameStatistics.incrementVboLoadCount(1);
	      }

	      gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	      gl.drawElements(gl.LINES, currentData.verticalIndices.length, gl.UNSIGNED_SHORT, 0);
	    }
	  }

	  currentData.fillVbo = false;

	  if (dc.pickingMode) {
	    var po = new PickedObject(pickColor, this.pickDelegate ? this.pickDelegate : this, null, this.layer, false);
	    dc.resolvePick(po);
	  }
	}; // Overridden from AbstractShape base class.


	Path.prototype.beginDrawing = function (dc) {
	  var gl = dc.currentGlContext;

	  if (this.mustDrawInterior(dc)) {
	    gl.disable(gl.CULL_FACE);
	  }

	  dc.findAndBindProgram(BasicTextureProgram);
	  gl.enableVertexAttribArray(dc.currentProgram.vertexPointLocation);
	}; // Overridden from AbstractShape base class.


	Path.prototype.endDrawing = function (dc) {
	  var gl = dc.currentGlContext;
	  gl.disableVertexAttribArray(dc.currentProgram.vertexPointLocation);
	  gl.depthMask(true);
	  gl.lineWidth(1);
	  gl.enable(gl.CULL_FACE);
	};

	/**
	 * @exports PeriodicTimeSequence
	 */
	/**
	 * Constructs a time sequence from an ISO 8601 string.
	 * @alias PeriodicTimeSequence
	 * @constructor
	 * @classdesc Represents a time sequence described as an ISO 8601 time-format string as required by WMS.
	 * The string must be in the form start/end/period, where start and end are ISO 8601 time values and
	 * period is an ISO 8601 period specification. This class provides iteration over the sequence in steps
	 * specified by the period. If the start and end dates are different, iteration will start at the start
	 * date and end at the end date. If the start and end dates are the same, iteration will start at the
	 * specified date and will never end.
	 * @param {String} sequenceString The string describing the time sequence.
	 * @throws {ArgumentError} If the specified intervalString is null, undefined or not a valid time interval
	 * string.
	 */

	function PeriodicTimeSequence(sequenceString) {
	  if (!sequenceString) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "PeriodicTimeSequence", "constructor", "missingString"));
	  }

	  var intervalParts = sequenceString.split("/");

	  if (intervalParts.length !== 3) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "PeriodicTimeSequence", "constructor", "The interval string " + sequenceString + " does not contain 3 elements."));
	  }
	  /**
	   * This sequence's sequence string, as specified to the constructor.
	   * @type {String}
	   * @readonly
	   */


	  this.sequenceString = sequenceString;
	  /**
	   * This sequence's start time.
	   * @type {Date}
	   * @readonly
	   */

	  this.startTime = new Date(intervalParts[0]);
	  /**
	   * This sequence's end time.
	   * @type {Date}
	   * @readonly
	   */

	  this.endTime = new Date(intervalParts[1]); // Intentionally not documented.

	  this.intervalMilliseconds = this.endTime.getTime() - this.startTime.getTime(); // Documented with property accessor below.

	  this._currentTime = this.startTime;
	  /**
	   * Indicates whether this sequence is an infinite sequence -- the start and end dates are the same.
	   * @type {Boolean}
	   * @readonly
	   */

	  this.infiniteInterval = this.startTime.getTime() == this.endTime.getTime(); // Intentionally not documented. The array of sequence increments:
	  // year, month, week, day, hours, minutes, seconds

	  this.period = PeriodicTimeSequence.parsePeriodString(intervalParts[2], false);
	}

	Object.defineProperties(PeriodicTimeSequence.prototype, {
	  /**
	   * This sequence's current time.
	   * @type {Date}
	   * @default This sequence's start time.
	   * @memberof PeriodicTimeSequence.prototype
	   */
	  currentTime: {
	    get: function () {
	      return this._currentTime;
	    },
	    set: function (value) {
	      this._currentTime = value;
	    }
	  },

	  /**
	   * Indicates the position of this sequence's current time relative to the sequence's total interval,
	   * in the range [0, 1]. A value of 0 indicates this sequence's start time. A value of 1 indicates
	   * this sequence's end time. A value of 0.5 indicates a current time that's exactly mid-way between
	   * this sequence's start time and end time.
	   * @type {Number}
	   * @memberof PeriodicTimeSequence.prototype
	   */
	  scaleForCurrentTime: {
	    get: function () {
	      if (!this.currentTime) {
	        return 1;
	      } else {
	        return (this.currentTime.getTime() - this.startTime.getTime()) / this.intervalMilliseconds;
	      }
	    }
	  }
	});
	/**
	 * Sets this sequence's current time to the next time in the sequence and returns that time.
	 * @returns {Date|null} The next time of this sequence, or null if no more times are in the sequence.
	 * Use [reset]{@link PeriodicTimeSequence#reset} to re-start this sequence.
	 * Use [previous]{@link PeriodicTimeSequence#previous} to step backwards through this sequence.
	 */

	PeriodicTimeSequence.prototype.next = function () {
	  if (!this.currentTime) {
	    this.currentTime = this.startTime;
	  } else if (this.currentTime.getTime() >= this.endTime.getTime() && !this.infiniteInterval) {
	    this.currentTime = null;
	  } else {
	    this.currentTime = PeriodicTimeSequence.incrementTime(this.currentTime, this.period);
	  }

	  return this.currentTime;
	};
	/**
	 * Sets this sequence's current time to the previous time in the sequence and returns that time.
	 * @returns {Date|null} The previous time of this sequence, or null if the sequence is currently at its start
	 * time.
	 * Use [next]{@link PeriodicTimeSequence#next} to step forwards through this sequence.
	 */


	PeriodicTimeSequence.prototype.previous = function () {
	  if (!this.currentTime) {
	    this.currentTime = this.endTime;
	  } else if (this.currentTime.getTime() === this.startTime.getTime()) {
	    this.currentTime = null;
	  } else {
	    this.currentTime = this.getTimeForScale(0.9999 * this.scaleForCurrentTime);
	  }

	  return this.currentTime;
	};
	/**
	 * Resets this sequence's current time to its start time.
	 * Use [next]{@link PeriodicTimeSequence#next} to step forwards through this sequence.
	 * Use [previous]{@link PeriodicTimeSequence#previous} to step backwards through this sequence.
	 */


	PeriodicTimeSequence.prototype.reset = function () {
	  this.currentTime = null;
	};
	/**
	 * Returns the time associated with a specified value in the range [0, 1]. A value of 0 returns this
	 * sequence's start time. A value of 1 returns this sequence's end time. A value of 0.5 returs a time
	 * mid-way between this sequence's start and end times.
	 * @param scale The scale value. This value is clamped to the range [0, 1] before the time is determined.
	 * @returns {Date}
	 */


	PeriodicTimeSequence.prototype.getTimeForScale = function (scale) {
	  if (scale <= 0) {
	    return this.startTime;
	  }

	  if (scale >= 1) {
	    return this.endTime;
	  }

	  var time = new Date(this.startTime.getTime()),
	      previousTime = time,
	      s = 0;

	  for (s = 0; s < scale; s = (time.getTime() - this.startTime.getTime()) / this.intervalMilliseconds) {
	    previousTime = time;
	    time = PeriodicTimeSequence.incrementTime(time, this.period);
	  }

	  return previousTime;
	}; // Intentionally not documented. Adds this sequence's period to a specified time.


	PeriodicTimeSequence.incrementTime = function (currentTime, period) {
	  var newTime = new Date(currentTime.getTime());

	  if (period[0] != 0) {
	    newTime.setUTCFullYear(newTime.getUTCFullYear() + period[0]);
	  }

	  if (period[1] != 0) {
	    PeriodicTimeSequence.addMonths(newTime, period[1]);
	  }

	  if (period[2] != 0) {
	    newTime.setUTCDate(newTime.getUTCDate() + 7 * period[2]);
	  }

	  if (period[3] != 0) {
	    newTime.setUTCDate(newTime.getUTCDate() + period[3]);
	  }

	  if (period[4] != 0) {
	    newTime.setUTCHours(newTime.getUTCHours() + period[4]);
	  }

	  if (period[5] != 0) {
	    newTime.setUTCMinutes(newTime.getUTCMinutes() + period[5]);
	  }

	  if (period[6] != 0) {
	    newTime.setUTCSeconds(newTime.getUTCSeconds() + period[6]);
	  }

	  return newTime;
	}; // Intentionally not documented.


	PeriodicTimeSequence.isLeapYear = function (year) {
	  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
	}; // Intentionally not documented.


	PeriodicTimeSequence.getDaysInMonth = function (year, month) {
	  return [31, PeriodicTimeSequence.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
	}; // Intentionally not documented.


	PeriodicTimeSequence.addMonths = function (date, numMonths) {
	  var n = date.getUTCDate();
	  date.setUTCDate(1);
	  date.setUTCMonth(date.getUTCMonth() + numMonths);
	  date.setUTCDate(Math.min(n, PeriodicTimeSequence.getDaysInMonth(date.getUTCFullYear(), date.getUTCMonth())));
	  return date;
	};
	/*
	 * Parses a ISO8601 period string.
	 * @param {String} period iso8601 period string
	 * @param {Boolean} distributeOverflow if 'true', the unit overflows are merge into the next higher units.
	 */


	PeriodicTimeSequence.parsePeriodString = function (period, distributeOverflow) {
	  // Taken from https://github.com/nezasa/iso8601-js-period/blob/master/iso8601.js
	  // regex splits as follows
	  // grp0 omitted as it is equal to the sample
	  //
	  // | sample            | grp1   | grp2 | grp3 | grp4 | grp5 | grp6       | grp7 | grp8 | grp9 |
	  // --------------------------------------------------------------------------------------------
	  // | P1Y2M3W           | 1Y2M3W | 1Y   | 2M   | 3W   | 4D   | T12H30M17S | 12H  | 30M  | 17S  |
	  // | P3Y6M4DT12H30M17S | 3Y6M4D | 3Y   | 6M   |      | 4D   | T12H30M17S | 12H  | 30M  | 17S  |
	  // | P1M               | 1M     |      | 1M   |      |      |            |      |      |      |
	  // | PT1M              | 3Y6M4D |      |      |      |      | T1M        |      | 1M   |      |
	  // --------------------------------------------------------------------------------------------
	  var _distributeOverflow = distributeOverflow ? distributeOverflow : false;

	  var valueIndexes = [2, 3, 4, 5, 7, 8, 9];
	  var duration = [0, 0, 0, 0, 0, 0, 0];
	  var overflowLimits = [0, 12, 4, 7, 24, 60, 60];
	  var struct; // upcase the string just in case people don't follow the letter of the law

	  period = period.toUpperCase().trim(); // input validation

	  if (!period) return duration;else if (typeof period !== "string") {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "PeriodicTimeSequence", "parsePeriodString", "Invalid ISO8601 period string '" + period + "'"));
	  } // parse the string

	  if (struct = /^P((\d+Y)?(\d+M)?(\d+W)?(\d+D)?)?(T(\d+H)?(\d+M)?(\d+S)?)?$/.exec(period)) {
	    // remove letters, replace by 0 if not defined
	    for (var i = 0; i < valueIndexes.length; i++) {
	      var structIndex = valueIndexes[i];
	      duration[i] = struct[structIndex] ? +struct[structIndex].replace(/[A-Za-z]+/g, '') : 0;
	    }
	  } else {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "PeriodicTimeSequence", "parsePeriodString", "String '" + period + "' is not a valid ISO8601 period."));
	  }

	  if (_distributeOverflow) {
	    // note: stop at 1 to ignore overflow of years
	    for (i = duration.length - 1; i > 0; i--) {
	      if (duration[i] >= overflowLimits[i]) {
	        duration[i - 1] = duration[i - 1] + Math.floor(duration[i] / overflowLimits[i]);
	        duration[i] = duration[i] % overflowLimits[i];
	      }
	    }
	  }

	  return duration;
	};

	/**
	 * @exports PlacemarkAttributes
	 */
	/**
	 * Constructs a placemark attributes bundle.
	 * The defaults indicate a placemark displayed as a white 1x1 pixel square centered on the placemark's
	 * geographic position.
	 * @alias PlacemarkAttributes
	 * @constructor
	 * @classdesc Holds attributes applied to {@link Placemark} shapes.
	 *
	 * @param {PlacemarkAttributes} attributes Attributes to initialize this attributes instance to. May be null,
	 * in which case the new instance contains default attributes.
	 */

	function PlacemarkAttributes(attributes) {
	  // These are all documented with their property accessors below.
	  this._imageColor = attributes ? attributes._imageColor.clone() : Color.WHITE.clone();
	  this._imageOffset = attributes ? attributes._imageOffset : new Offset(WorldWind.OFFSET_FRACTION, 0.5, WorldWind.OFFSET_FRACTION, 0.5);
	  this._imageScale = attributes ? attributes._imageScale : 1;
	  this._imageSource = attributes ? attributes._imageSource : null;
	  this._depthTest = attributes ? attributes._depthTest : true;
	  this._labelAttributes = attributes ? attributes._labelAttributes : new TextAttributes(null);
	  this._drawLeaderLine = attributes ? attributes._drawLeaderLine : false;
	  this._leaderLineAttributes = attributes ? attributes._leaderLineAttributes : new ShapeAttributes(null);
	  /**
	   * Indicates whether this object's state key is invalid. Subclasses must set this value to true when their
	   * attributes change. The state key will be automatically computed the next time it's requested. This flag
	   * will be set to false when that occurs.
	   * @type {Boolean}
	   * @protected
	   */

	  this.stateKeyInvalid = true;
	}
	/**
	 * Computes the state key for this attributes object. Subclasses that define additional attributes must
	 * override this method, call it from that method, and append the state of their attributes to its
	 * return value.
	 * @returns {String} The state key for this object.
	 * @protected
	 */


	PlacemarkAttributes.prototype.computeStateKey = function () {
	  return "ic " + this._imageColor.toHexString(true) + " io " + this._imageOffset.toString() + " is " + this._imageScale + " ip " + this._imageSource + " dt " + this._depthTest + " la " + this._labelAttributes.stateKey + " dll " + this._drawLeaderLine + " lla " + this._leaderLineAttributes.stateKey;
	};

	Object.defineProperties(PlacemarkAttributes.prototype, {
	  /**
	   * A string identifying the state of this attributes object. The string encodes the current values of all
	   * this object's properties. It's typically used to validate cached representations of shapes associated
	   * with this attributes object.
	   * @type {String}
	   * @readonly
	   * @memberof PlacemarkAttributes.prototype
	   */
	  stateKey: {
	    get: function () {
	      if (this.stateKeyInvalid) {
	        this._stateKey = this.computeStateKey();
	        this.stateKeyInvalid = false;
	      }

	      return this._stateKey;
	    }
	  },

	  /**
	   * The image color.
	   * When this attribute bundle has a valid image path the placemark's image is composed with this image
	   * color to achieve the final placemark color. Otherwise the placemark is drawn in this color. The color
	   * white, the default, causes the image to be drawn in its native colors.
	   * @type {Color}
	   * @default White (1, 1, 1, 1)
	   * @memberof PlacemarkAttributes.prototype
	   */
	  imageColor: {
	    get: function () {
	      return this._imageColor;
	    },
	    set: function (value) {
	      this._imageColor = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the location within the placemark's image to align with the placemark's geographic position.
	   * May be null, in which case the image's bottom-left corner is placed at the geographic position.
	   * @type {Offset}
	   * @default 0.5, 0.5, both fractional (Centers the image on the geographic position.)
	   * @memberof PlacemarkAttributes.prototype
	   */
	  imageOffset: {
	    get: function () {
	      return this._imageOffset;
	    },
	    set: function (value) {
	      this._imageOffset = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the amount to scale the placemark's image.
	   * When this attribute bundle has a valid image path the scale is applied to the image's dimensions. Otherwise the
	   * scale indicates the dimensions in pixels of a square drawn at the placemark's geographic position.
	   * A scale of 0 causes the placemark to disappear; however, the placemark's label, if any, is still drawn.
	   * @type {Number}
	   * @default 1
	   * @memberof PlacemarkAttributes.prototype
	   */
	  imageScale: {
	    get: function () {
	      return this._imageScale;
	    },
	    set: function (value) {
	      this._imageScale = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * The image source of the placemark's image. May be either a string giving the URL of the image, or an
	   * {@link ImageSource} object identifying an Image created dynamically.
	   * If null, the placemark is drawn as a square whose width and height are
	   * the value of this attribute object's [imageScale]{@link PlacemarkAttributes#imageScale} property.
	   * @type {String|ImageSource}
	   * @default null
	   * @memberof PlacemarkAttributes.prototype
	   */
	  imageSource: {
	    get: function () {
	      return this._imageSource;
	    },
	    set: function (value) {
	      this._imageSource = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates whether the placemark should be depth-tested against other objects in the scene. If true,
	   * the placemark may be occluded by terrain and other objects in certain viewing situations. If false,
	   * the placemark will not be occluded by terrain and other objects. If this value is true, the placemark's
	   * label, if any, has an independent depth-test control.
	   * See [PlacemarkAttributes.labelAttributes]{@link PlacemarkAttributes#labelAttributes}
	   * and [TextAttributes.depthTest]{@link TextAttributes#depthTest}.
	   * @type {Boolean}
	   * @default true
	   * @memberof PlacemarkAttributes.prototype
	   */
	  depthTest: {
	    get: function () {
	      return this._depthTest;
	    },
	    set: function (value) {
	      this._depthTest = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates the attributes to apply to the placemark's label, if any. If null, the placemark's label is
	   * not drawn.
	   * @type {TextAttributes}
	   * @default The defaults of {@link TextAttributes}.
	   * @memberof PlacemarkAttributes.prototype
	   */
	  labelAttributes: {
	    get: function () {
	      return this._labelAttributes;
	    },
	    set: function (value) {
	      this._labelAttributes = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * Indicates whether to draw a line from the placemark's geographic position to the ground.
	   * @type {Boolean}
	   * @default false
	   * @memberof PlacemarkAttributes.prototype
	   */
	  drawLeaderLine: {
	    get: function () {
	      return this._drawLeaderLine;
	    },
	    set: function (value) {
	      this._drawLeaderLine = value;
	      this.stateKeyInvalid = true;
	    }
	  },

	  /**
	   * The attributes to apply to the leader line if it's drawn. If null, the placemark's leader line is
	   * not drawn.
	   * @type {ShapeAttributes}
	   * @default The defaults of {@link ShapeAttributes}
	   * @memberof PlacemarkAttributes.prototype
	   */
	  leaderLineAttributes: {
	    get: function () {
	      return this._leaderLineAttributes;
	    },
	    set: function (value) {
	      this._leaderLineAttributes = value;
	      this.stateKeyInvalid = true;
	    }
	  }
	});

	/**
	 * @exports Placemark
	 */
	/**
	 * Constructs a placemark.
	 * @alias Placemark
	 * @constructor
	 * @augments Renderable
	 * @classdesc Represents a Placemark shape. A placemark displays an image, a label and a leader line connecting
	 * the placemark's geographic position to the ground. All three of these items are optional. By default, the
	 * leader line is not pickable. See [enableLeaderLinePicking]{@link Placemark#enableLeaderLinePicking}.
	 * <p>
	 * Placemarks may be drawn with either an image or as single-color square with a specified size. When the
	 * placemark attributes indicate a valid image, the placemark's image is drawn as a rectangle in the
	 * image's original dimensions, scaled by the image scale attribute. Otherwise, the placemark is drawn as a
	 * square with width and height equal to the value of the image scale attribute, in pixels, and color equal
	 * to the image color attribute.
	 * <p>
	 * By default, placemarks participate in decluttering with a [declutterGroupID]{@link Placemark#declutterGroup}
	 * of 2. Only placemark labels are decluttered relative to other placemark labels. The placemarks themselves
	 * are optionally scaled with eye distance to achieve decluttering of the placemark as a whole.
	 * See [eyeDistanceScaling]{@link Placemark#eyeDistanceScaling}.
	 * @param {Position} position The placemark's geographic position.
	 * @param {Boolean} eyeDistanceScaling Indicates whether the size of this placemark scales with eye distance.
	 * See [eyeDistanceScalingThreshold]{@link Placemark#eyeDistanceScalingThreshold} and
	 * [eyeDistanceScalingLabelThreshold]{@link Placemark#eyeDistanceScalingLabelThreshold}.
	 * @param {PlacemarkAttributes} attributes The attributes to associate with this placemark. May be null,
	 * in which case default attributes are associated.
	 * @throws {ArgumentError} If the specified position is null or undefined.
	 */

	function Placemark(position, eyeDistanceScaling, attributes) {
	  if (!position) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Placemark", "constructor", "missingPosition"));
	  }

	  Renderable.call(this);
	  /**
	   * The placemark's attributes. If null and this placemark is not highlighted, this placemark is not
	   * drawn.
	   * @type {PlacemarkAttributes}
	   * @default see [PlacemarkAttributes]{@link PlacemarkAttributes}
	   */

	  this.attributes = attributes ? attributes : new PlacemarkAttributes(null);
	  /**
	   * The attributes used when this placemark's highlighted flag is true. If null and the
	   * highlighted flag is true, this placemark's normal attributes are used. If they, too, are null, this
	   * placemark is not drawn.
	   * @type {PlacemarkAttributes}
	   * @default null
	   */

	  this.highlightAttributes = null;
	  /**
	   * Indicates whether this placemark uses its highlight attributes rather than its normal attributes.
	   * @type {Boolean}
	   * @default false
	   */

	  this.highlighted = false;
	  /**
	   * This placemark's geographic position.
	   * @type {Position}
	   */

	  this.position = position;
	  /**
	   * Indicates whether this placemark's size is reduced at higher eye distances. If true, this placemark's
	   * size is scaled inversely proportional to the eye distance if the eye distance is greater than the
	   * value of the [eyeDistanceScalingThreshold]{@link Placemark#eyeDistanceScalingThreshold} property.
	   * When the eye distance is below the threshold, this placemark is scaled only according to the
	   * [imageScale]{@link PlacemarkAttributes#imageScale}.
	   * @type {Boolean}
	   */

	  this.eyeDistanceScaling = eyeDistanceScaling;
	  /**
	   * The eye distance above which to reduce the size of this placemark, in meters. If
	   * [eyeDistanceScaling]{@link Placemark#eyeDistanceScaling} is true, this placemark's image, label and leader
	   * line sizes are reduced as the eye distance increases beyond this threshold.
	   * @type {Number}
	   * @default 1e6 (meters)
	   */

	  this.eyeDistanceScalingThreshold = 1e6;
	  /**
	   * The eye altitude above which this placemark's label is not displayed.
	   * @type {number}
	   */

	  this.eyeDistanceScalingLabelThreshold = 1.5 * this.eyeDistanceScalingThreshold;
	  /**
	   * This placemark's textual label. If null, no label is drawn.
	   * @type {String}
	   * @default null
	   */

	  this.label = null;
	  /**
	   * This placemark's altitude mode. May be one of
	   * <ul>
	   *  <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	   *  <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	   *  <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	   * </ul>
	   * @default WorldWind.ABSOLUTE
	   */

	  this.altitudeMode = WorldWind.ABSOLUTE;
	  /**
	   * Indicates whether this placemark has visual priority over other shapes in the scene.
	   * @type {Boolean}
	   * @default false
	   */

	  this.alwaysOnTop = false;
	  /**
	   * Indicates whether this placemark's leader line, if any, is pickable.
	   * @type {Boolean}
	   * @default false
	   */

	  this.enableLeaderLinePicking = false;
	  /**
	   * Indicates whether this placemark's image should be re-retrieved even if it has already been retrieved.
	   * Set this property to true when the image has changed but has the same image path.
	   * The property is set to false when the image is re-retrieved.
	   * @type {Boolean}
	   */

	  this.updateImage = true;
	  /**
	   * Indicates the group ID of the declutter group to include this placemark. If non-zero, this placemark
	   * is decluttered relative to all other shapes within its group.
	   * @type {Number}
	   * @default 2
	   */

	  this.declutterGroup = 2;
	  /**
	   * This placemark's target label visibility, a value between 0 and 1. During ordered rendering this
	   * placemark modifies its [current visibility]{@link Placemark#currentVisibility} towards its target
	   * visibility at the rate specified by the draw context's [fade time]{@link DrawContext#fadeTime} property.
	   * The target visibility and current visibility are used to control the fading in and out of this
	   * placemark's label.
	   * @type {Number}
	   * @default 1
	   */

	  this.targetVisibility = 1;
	  /**
	   * This placemark's current label visibility, a value between 0 and 1. This property scales the placemark's
	   * effective label opacity. It is incremented or decremented each frame according to the draw context's
	   * [fade time]{@link DrawContext#fadeTime} property in order to achieve this placemark's
	   * [target visibility]{@link Placemark#targetVisibility}. This current visibility and target visibility are
	   * used to control the fading in and out of this placemark's label.
	   * @type {Number}
	   * @default 1
	   * @readonly
	   */

	  this.currentVisibility = 1;
	  /**
	   * The amount of rotation to apply to the image, measured in degrees clockwise and relative to this
	   * placemark's [imageRotationReference]{@link Placemark#imageRotationReference}.
	   * @type {Number}
	   * @default 0
	   */

	  this.imageRotation = 0;
	  /**
	   * The amount of tilt to apply to the image, measured in degrees away from the eye point and relative
	   * to this placemark's [imageTiltReference]{@link Placemark#imageTiltReference}. While any positive or
	   * negative number may be specified, values outside the range [0. 90] cause some or all of the image to
	   * be clipped.
	   * @type {Number}
	   * @default 0
	   */

	  this.imageTilt = 0;
	  /**
	   * Indicates whether to apply this placemark's image rotation relative to the screen or the globe.
	   * If WorldWind.RELATIVE_TO_SCREEN, this placemark's image is rotated in the plane of the screen and
	   * its orientation relative to the globe changes as the view changes.
	   * If WorldWind.RELATIVE_TO_GLOBE, this placemark's image is rotated in a plane tangent to the globe
	   * at this placemark's position and retains its orientation relative to the globe.
	   * @type {String}
	   * @default WorldWind.RELATIVE_TO_SCREEN
	   */

	  this.imageRotationReference = WorldWind.RELATIVE_TO_SCREEN;
	  /**
	   * Indicates whether to apply this placemark's image tilt relative to the screen or the globe.
	   * If WorldWind.RELATIVE_TO_SCREEN, this placemark's image is tilted inwards (for positive tilts)
	   * relative to the plane of the screen, and its orientation relative to the globe changes as the view
	   * changes. If WorldWind.RELATIVE_TO_GLOBE, this placemark's image is tilted towards the globe's surface,
	   * and retains its orientation relative to the surface.
	   * @type {string}
	   * @default WorldWind.RELATIVE_TO_SCREEN
	   */

	  this.imageTiltReference = WorldWind.RELATIVE_TO_SCREEN; // Internal use only. Intentionally not documented.

	  this.activeAttributes = null; // Internal use only. Intentionally not documented.

	  this.activeTexture = null; // Internal use only. Intentionally not documented.

	  this.labelTexture = null; // Internal use only. Intentionally not documented.

	  this.placePoint = new Vec3$1(0, 0, 0); // Cartesian point corresponding to this placemark's geographic position
	  // Internal use only. Intentionally not documented.

	  this.groundPoint = new Vec3$1(0, 0, 0); // Cartesian point corresponding to ground position below this placemark
	  // Internal use only. Intentionally not documented.

	  this.imageTransform = Matrix.fromIdentity(); // Internal use only. Intentionally not documented.

	  this.labelTransform = Matrix.fromIdentity(); // Internal use only. Intentionally not documented.

	  this.texCoordMatrix = Matrix.fromIdentity(); // Internal use only. Intentionally not documented.

	  this.imageBounds = null; // Internal use only. Intentionally not documented.

	  this.layer = null; // Internal use only. Intentionally not documented.

	  this.depthOffset = -0.003;
	} // Internal use only. Intentionally not documented.


	Placemark.screenPoint = new Vec3$1(0, 0, 0); // scratch variable

	Placemark.matrix = Matrix.fromIdentity(); // scratch variable

	Placemark.scratchPoint = new Vec3$1(0, 0, 0); // scratch variable

	Placemark.prototype = Object.create(Renderable.prototype);
	Object.defineProperties(Placemark.prototype, {
	  /**
	   * Indicates the screen coordinate bounds of this shape during ordered rendering.
	   * @type {Rectangle}
	   * @readonly
	   * @memberof Placemark.prototype
	   */
	  screenBounds: {
	    get: function () {
	      return this.labelBounds;
	    }
	  }
	});
	/**
	 * Copies the contents of a specified placemark to this placemark.
	 * @param {Placemark} that The placemark to copy.
	 */

	Placemark.prototype.copy = function (that) {
	  this.position = that.position;
	  this.attributes = that.attributes;
	  this.highlightAttributes = that.highlightAttributes;
	  this.highlighted = that.highlighted;
	  this.enabled = that.enabled;
	  this.label = that.label;
	  this.altitudeMode = that.altitudeMode;
	  this.pickDelegate = that.pickDelegate;
	  this.alwaysOnTop = that.alwaysOnTop;
	  this.depthOffset = that.depthOffset;
	  this.targetVisibility = that.targetVisibility;
	  this.currentVisibility = that.currentVisibility;
	  this.imageRotation = that.imageRotation;
	  this.imageTilt = that.imageTilt;
	  this.imageRotationReference = that.imageRotationReference;
	  this.imageTiltReference = that.imageTiltReference;
	  return this;
	};
	/**
	 * Creates a new placemark that is a copy of this placemark.
	 * @returns {Placemark} The new placemark.
	 */


	Placemark.prototype.clone = function () {
	  var clone = new Placemark(this.position);
	  clone.copy(this);
	  clone.pickDelegate = this.pickDelegate ? this.pickDelegate : this;
	  return clone;
	};
	/**
	 * Renders this placemark. This method is typically not called by applications but is called by
	 * {@link RenderableLayer} during rendering. For this shape this method creates and
	 * enques an ordered renderable with the draw context and does not actually draw the placemark.
	 * @param {DrawContext} dc The current draw context.
	 */


	Placemark.prototype.render = function (dc) {
	  if (!this.enabled) {
	    return;
	  }

	  if (!dc.accumulateOrderedRenderables) {
	    return;
	  }

	  if (dc.globe.projectionLimits && !dc.globe.projectionLimits.containsLocation(this.position.latitude, this.position.longitude)) {
	    return;
	  } // Create an ordered renderable for this placemark. If one has already been created this frame then we're
	  // in 2D-continuous mode and another needs to be created for one of the alternate globe offsets.


	  var orderedPlacemark;

	  if (this.lastFrameTime !== dc.timestamp) {
	    orderedPlacemark = this.makeOrderedRenderable(dc);
	  } else {
	    var placemarkCopy = this.clone();
	    orderedPlacemark = placemarkCopy.makeOrderedRenderable(dc);
	  }

	  if (!orderedPlacemark) {
	    return;
	  }

	  if (!orderedPlacemark.isVisible(dc)) {
	    return;
	  }

	  orderedPlacemark.layer = dc.currentLayer;
	  this.lastFrameTime = dc.timestamp;
	  dc.addOrderedRenderable(orderedPlacemark);
	};
	/**
	 * Draws this shape as an ordered renderable. Applications do not call this function. It is called by
	 * [WorldWindow]{@link WorldWindow} during rendering.
	 * @param {DrawContext} dc The current draw context.
	 */


	Placemark.prototype.renderOrdered = function (dc) {
	  this.drawOrderedPlacemark(dc);

	  if (dc.pickingMode) {
	    var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this, this.position, this.layer, false);

	    if (dc.pickPoint && this.mustDrawLabel()) {
	      if (this.labelBounds.containsPoint(dc.convertPointToViewport(dc.pickPoint, Placemark.scratchPoint))) {
	        po.labelPicked = true;
	      }
	    }

	    dc.resolvePick(po);
	  }
	};
	/* INTENTIONALLY NOT DOCUMENTED
	 * Creates an ordered renderable for this shape.
	 * @protected
	 * @param {DrawContext} dc The current draw context.
	 * @returns {OrderedRenderable} The ordered renderable. May be null, in which case an ordered renderable
	 * cannot be created or should not be created at the time this method is called.
	 */


	Placemark.prototype.makeOrderedRenderable = function (dc) {
	  var w, h, s, offset;
	  this.determineActiveAttributes(dc);

	  if (!this.activeAttributes) {
	    return null;
	  } // Compute the placemark's model point and corresponding distance to the eye point. If the placemark's
	  // position is terrain-dependent but off the terrain, then compute it ABSOLUTE so that we have a point for
	  // the placemark and are thus able to draw it. Otherwise its image and label portion that are potentially
	  // over the terrain won't get drawn, and would disappear as soon as there is no terrain at the placemark's
	  // position. This can occur at the window edges.


	  dc.surfacePointForMode(this.position.latitude, this.position.longitude, this.position.altitude, this.altitudeMode, this.placePoint);
	  this.eyeDistance = this.alwaysOnTop ? 0 : dc.eyePoint.distanceTo(this.placePoint);

	  if (this.mustDrawLeaderLine(dc)) {
	    dc.surfacePointForMode(this.position.latitude, this.position.longitude, 0, this.altitudeMode, this.groundPoint);
	  } // Compute the placemark's screen point in the OpenGL coordinate system of the WorldWindow by projecting its model
	  // coordinate point onto the viewport. Apply a depth offset in order to cause the placemark to appear above nearby
	  // terrain. When a placemark is displayed near the terrain portions of its geometry are often behind the terrain,
	  // yet as a screen element the placemark is expected to be visible. We adjust its depth values rather than moving
	  // the placemark itself to avoid obscuring its actual position.


	  if (!dc.projectWithDepth(this.placePoint, this.depthOffset, Placemark.screenPoint)) {
	    return null;
	  }

	  var visibilityScale = this.eyeDistanceScaling ? Math.max(0.0, Math.min(1, this.eyeDistanceScalingThreshold / this.eyeDistance)) : 1; // Compute the placemark's transform matrix and texture coordinate matrix according to its screen point, image size,
	  // image offset and image scale. The image offset is defined with its origin at the image's bottom-left corner and
	  // axes that extend up and to the right from the origin point. When the placemark has no active texture the image
	  // scale defines the image size and no other scaling is applied.

	  if (this.activeTexture) {
	    w = this.activeTexture.originalImageWidth;
	    h = this.activeTexture.originalImageHeight;
	    s = this.activeAttributes.imageScale * visibilityScale;
	    offset = this.activeAttributes.imageOffset.offsetForSize(w, h);
	    this.imageTransform.setTranslation(Placemark.screenPoint[0] - offset[0] * s, Placemark.screenPoint[1] - offset[1] * s, Placemark.screenPoint[2]);
	    this.imageTransform.setScale(w * s, h * s, 1);
	  } else {
	    s = this.activeAttributes.imageScale * visibilityScale;
	    offset = this.activeAttributes.imageOffset.offsetForSize(s, s);
	    this.imageTransform.setTranslation(Placemark.screenPoint[0] - offset[0], Placemark.screenPoint[1] - offset[1], Placemark.screenPoint[2]);
	    this.imageTransform.setScale(s, s, 1);
	  }

	  this.imageBounds = WWMath.boundingRectForUnitQuad(this.imageTransform); // If there's a label, perform these same operations for the label texture.

	  if (this.mustDrawLabel()) {
	    this.labelTexture = dc.createTextTexture(this.label, this.activeAttributes.labelAttributes);
	    w = this.labelTexture.imageWidth;
	    h = this.labelTexture.imageHeight;
	    s = this.activeAttributes.labelAttributes.scale * visibilityScale;
	    offset = this.activeAttributes.labelAttributes.offset.offsetForSize(w, h);
	    this.labelTransform.setTranslation(Placemark.screenPoint[0] - offset[0] * s, Placemark.screenPoint[1] - offset[1] * s, Placemark.screenPoint[2]);
	    this.labelTransform.setScale(w * s, h * s, 1);
	    this.labelBounds = WWMath.boundingRectForUnitQuad(this.labelTransform);
	  }

	  return this;
	}; // Internal. Intentionally not documented.


	Placemark.prototype.determineActiveAttributes = function (dc) {
	  if (this.highlighted && this.highlightAttributes) {
	    this.activeAttributes = this.highlightAttributes;
	  } else {
	    this.activeAttributes = this.attributes;
	  }

	  if (this.activeAttributes && this.activeAttributes.imageSource) {
	    this.activeTexture = dc.gpuResourceCache.resourceForKey(this.activeAttributes.imageSource);

	    if (!this.activeTexture || this.updateImage) {
	      this.activeTexture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this.activeAttributes.imageSource);
	      this.updateImage = false;
	    }
	  }
	}; // Internal. Intentionally not documented.


	Placemark.prototype.isVisible = function (dc) {
	  if (dc.pickingMode) {
	    return dc.pickRectangle && (this.imageBounds.intersects(dc.pickRectangle) || this.mustDrawLabel() && this.labelBounds.intersects(dc.pickRectangle) || this.mustDrawLeaderLine(dc) && dc.pickFrustum.intersectsSegment(this.groundPoint, this.placePoint));
	  } else {
	    return this.imageBounds.intersects(dc.viewport) || this.mustDrawLabel() && this.labelBounds.intersects(dc.viewport) || this.mustDrawLeaderLine(dc) && dc.frustumInModelCoordinates.intersectsSegment(this.groundPoint, this.placePoint);
	  }
	}; // Internal. Intentionally not documented.


	Placemark.prototype.drawOrderedPlacemark = function (dc) {
	  this.beginDrawing(dc);

	  try {
	    this.doDrawOrderedPlacemark(dc);

	    if (!dc.pickingMode) {
	      this.drawBatchOrderedPlacemarks(dc);
	    }
	  } finally {
	    this.endDrawing(dc);
	  }
	}; // Internal. Intentionally not documented.


	Placemark.prototype.drawBatchOrderedPlacemarks = function (dc) {
	  // Draw any subsequent placemarks in the ordered renderable queue, removing each from the queue as it's
	  // processed. This avoids the overhead of setting up and tearing down OpenGL state for each placemark.
	  var or;

	  while ((or = dc.peekOrderedRenderable()) && or.doDrawOrderedPlacemark) {
	    dc.popOrderedRenderable(); // remove it from the queue

	    try {
	      or.doDrawOrderedPlacemark(dc);
	    } catch (e) {
	      Logger$1.logMessage(Logger$1.LEVEL_WARNING, 'Placemark', 'drawBatchOrderedPlacemarks', "Error occurred while rendering placemark using batching: " + e.message);
	    } // Keep going. Render the rest of the ordered renderables.

	  }
	}; // Internal. Intentionally not documented.


	Placemark.prototype.beginDrawing = function (dc) {
	  var gl = dc.currentGlContext,
	      program;
	  dc.findAndBindProgram(BasicTextureProgram); // Configure GL to use the draw context's unit quad VBOs for both model coordinates and texture coordinates.
	  // Most browsers can share the same buffer for vertex and texture coordinates, but Internet Explorer requires
	  // that they be in separate buffers, so the code below uses the 3D buffer for vertex coords and the 2D
	  // buffer for texture coords.

	  program = dc.currentProgram;
	  gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer());
	  gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, 0, 0);
	  gl.enableVertexAttribArray(program.vertexPointLocation);
	  gl.enableVertexAttribArray(program.vertexTexCoordLocation); // Tell the program which texture unit to use.

	  program.loadTextureUnit(gl, gl.TEXTURE0);
	  program.loadModulateColor(gl, dc.pickingMode);
	}; // Internal. Intentionally not documented.


	Placemark.prototype.endDrawing = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram; // Clear the vertex attribute state.

	  gl.disableVertexAttribArray(program.vertexPointLocation);
	  gl.disableVertexAttribArray(program.vertexTexCoordLocation); // Clear GL bindings.

	  gl.bindBuffer(gl.ARRAY_BUFFER, null);
	  gl.bindTexture(gl.TEXTURE_2D, null);
	}; // Internal. Intentionally not documented.


	Placemark.prototype.doDrawOrderedPlacemark = function (dc) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram,
	      depthTest = true,
	      textureBound;

	  if (dc.pickingMode) {
	    this.pickColor = dc.uniquePickColor();
	  }

	  if (this.eyeDistanceScaling && this.eyeDistance > this.eyeDistanceScalingLabelThreshold) {
	    // Target visibility is set to 0 to cause the label to be faded in or out. Nothing else
	    // here uses target visibility.
	    this.targetVisibility = 0;
	  } // Compute the effective visibility. Use the current value if picking.


	  if (!dc.pickingMode && this.mustDrawLabel()) {
	    if (this.currentVisibility != this.targetVisibility) {
	      var visibilityDelta = (dc.timestamp - dc.previousRedrawTimestamp) / dc.fadeTime;

	      if (this.currentVisibility < this.targetVisibility) {
	        this.currentVisibility = Math.min(1, this.currentVisibility + visibilityDelta);
	      } else {
	        this.currentVisibility = Math.max(0, this.currentVisibility - visibilityDelta);
	      }

	      dc.redrawRequested = true;
	    }
	  }

	  program.loadOpacity(gl, dc.pickingMode ? 1 : this.layer.opacity); // Draw the leader line first so that the image and label have visual priority.

	  if (this.mustDrawLeaderLine(dc)) {
	    if (!this.leaderLinePoints) {
	      this.leaderLinePoints = new Float32Array(6);
	    }

	    this.leaderLinePoints[0] = this.groundPoint[0]; // computed during makeOrderedRenderable

	    this.leaderLinePoints[1] = this.groundPoint[1];
	    this.leaderLinePoints[2] = this.groundPoint[2];
	    this.leaderLinePoints[3] = this.placePoint[0]; // computed during makeOrderedRenderable

	    this.leaderLinePoints[4] = this.placePoint[1];
	    this.leaderLinePoints[5] = this.placePoint[2];

	    if (!this.leaderLineCacheKey) {
	      this.leaderLineCacheKey = dc.gpuResourceCache.generateCacheKey();
	    }

	    var leaderLineVboId = dc.gpuResourceCache.resourceForKey(this.leaderLineCacheKey);

	    if (!leaderLineVboId) {
	      leaderLineVboId = gl.createBuffer();
	      dc.gpuResourceCache.putResource(this.leaderLineCacheKey, leaderLineVboId, this.leaderLinePoints.length * 4);
	    }

	    program.loadTextureEnabled(gl, false);
	    program.loadColor(gl, dc.pickingMode ? this.pickColor : this.activeAttributes.leaderLineAttributes.outlineColor);
	    Placemark.matrix.copy(dc.modelviewProjection);
	    program.loadModelviewProjection(gl, Placemark.matrix);

	    if (!this.activeAttributes.leaderLineAttributes.depthTest) {
	      gl.disable(gl.DEPTH_TEST);
	    }

	    gl.lineWidth(this.activeAttributes.leaderLineAttributes.outlineWidth);
	    gl.bindBuffer(gl.ARRAY_BUFFER, leaderLineVboId);
	    gl.bufferData(gl.ARRAY_BUFFER, this.leaderLinePoints, gl.STATIC_DRAW);
	    dc.frameStatistics.incrementVboLoadCount(1);
	    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	    gl.drawArrays(gl.LINES, 0, 2);
	  } // Turn off depth testing for the placemark image if requested. The placemark label and leader line have
	  // their own depth-test controls.


	  if (!this.activeAttributes.depthTest) {
	    depthTest = false;
	    gl.disable(gl.DEPTH_TEST);
	  } // Suppress frame buffer writes for the placemark image and its label.
	  // tag, 6/17/15: It's not clear why this call was here. It was carried over from WWJ.
	  //gl.depthMask(false);


	  gl.bindBuffer(gl.ARRAY_BUFFER, dc.unitQuadBuffer3());
	  gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0); // Compute and specify the MVP matrix.

	  Placemark.matrix.copy(dc.screenProjection);
	  Placemark.matrix.multiplyMatrix(this.imageTransform);
	  var actualRotation = this.imageRotationReference === WorldWind.RELATIVE_TO_GLOBE ? dc.navigator.heading - this.imageRotation : -this.imageRotation;
	  Placemark.matrix.multiplyByTranslation(0.5, 0.5, 0);
	  Placemark.matrix.multiplyByRotation(0, 0, 1, actualRotation);
	  Placemark.matrix.multiplyByTranslation(-0.5, -0.5, 0); // Perform the tilt before applying the rotation so that the image tilts back from its base into
	  // the view volume.

	  var actualTilt = this.imageTiltReference === WorldWind.RELATIVE_TO_GLOBE ? dc.navigator.tilt + this.imageTilt : this.imageTilt;
	  Placemark.matrix.multiplyByRotation(-1, 0, 0, actualTilt);
	  program.loadModelviewProjection(gl, Placemark.matrix); // Enable texture for both normal display and for picking. If picking is enabled in the shader (set in
	  // beginDrawing() above) then the texture's alpha component is still needed in order to modulate the
	  // pick color to mask off transparent pixels.

	  program.loadTextureEnabled(gl, true);

	  if (dc.pickingMode) {
	    program.loadColor(gl, this.pickColor);
	  } else {
	    program.loadColor(gl, this.activeAttributes.imageColor);
	  }

	  this.texCoordMatrix.setToIdentity();

	  if (this.activeTexture) {
	    this.texCoordMatrix.multiplyByTextureTransform(this.activeTexture);
	  }

	  program.loadTextureMatrix(gl, this.texCoordMatrix);

	  if (this.activeTexture) {
	    textureBound = this.activeTexture.bind(dc); // returns false if active texture is null or cannot be bound

	    program.loadTextureEnabled(gl, textureBound);
	  } else {
	    program.loadTextureEnabled(gl, false);
	  } // Draw the placemark's image quad.


	  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

	  if (this.mustDrawLabel() && this.currentVisibility > 0) {
	    program.loadOpacity(gl, dc.pickingMode ? 1 : this.layer.opacity * this.currentVisibility);
	    Placemark.matrix.copy(dc.screenProjection);
	    Placemark.matrix.multiplyMatrix(this.labelTransform);
	    program.loadModelviewProjection(gl, Placemark.matrix);

	    if (!dc.pickingMode && this.labelTexture) {
	      this.texCoordMatrix.setToIdentity();
	      this.texCoordMatrix.multiplyByTextureTransform(this.labelTexture);
	      program.loadTextureMatrix(gl, this.texCoordMatrix);
	      program.loadColor(gl, Color.WHITE);
	      textureBound = this.labelTexture.bind(dc);
	      program.loadTextureEnabled(gl, textureBound);
	    } else {
	      program.loadTextureEnabled(gl, false);
	      program.loadColor(gl, this.pickColor);
	    }

	    if (this.activeAttributes.labelAttributes.depthTest) {
	      if (!depthTest) {
	        depthTest = true;
	        gl.enable(gl.DEPTH_TEST);
	      }
	    } else {
	      depthTest = false;
	      gl.disable(gl.DEPTH_TEST);
	    }

	    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
	  }

	  if (!depthTest) {
	    gl.enable(gl.DEPTH_TEST);
	  } // tag, 6/17/15: See note on depthMask above in this function.
	  //gl.depthMask(true);

	}; // Internal. Intentionally not documented.


	Placemark.prototype.mustDrawLabel = function () {
	  return this.label && this.label.length > 0 && this.activeAttributes.labelAttributes;
	}; // Internal. Intentionally not documented.


	Placemark.prototype.mustDrawLeaderLine = function (dc) {
	  return this.activeAttributes.drawLeaderLine && this.activeAttributes.leaderLineAttributes && (!dc.pickingMode || this.enableLeaderLinePicking);
	}; // Internal use only. Intentionally not documented.


	Placemark.prototype.getReferencePosition = function () {
	  return this.position;
	}; // Internal use only. Intentionally not documented.


	Placemark.prototype.moveTo = function (globe, position) {
	  this.position = position;
	};

	/**
	 * @exports Polygon
	 */
	/**
	 * Constructs a Polygon.
	 * @alias Polygon
	 * @constructor
	 * @augments AbstractShape
	 * @classdesc Represents a 3D polygon. The polygon may be extruded to the ground to form a prism. It may have
	 * multiple boundaries defining empty portions. See also {@link SurfacePolygon}.
	 * <p>
	 *     Altitudes within the polygon's positions are interpreted according to the polygon's altitude mode, which
	 *     can be one of the following:
	 * <ul>
	 *     <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	 *     <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	 *     <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	 * </ul>
	 * If the latter, the polygon positions' altitudes are ignored. (If the polygon should be draped onto the
	 * terrain, you might want to use {@link SurfacePolygon} instead.)
	 * <p>
	 *     Polygons have separate attributes for normal display and highlighted display. They use the interior and
	 *     outline attributes of {@link ShapeAttributes}. If those attributes identify an image, that image is
	 *     applied to the polygon.
	 * <p>
	 *     A polygon displays as a vertical prism if its [extrude]{@link Polygon#extrude} property is true. A
	 *     curtain is formed around its boundaries and extends from the polygon's edges to the ground.
	 * <p>
	 *     A polygon can be textured, including its extruded boundaries. The textures are specified via the
	 *     [imageSource]{@link ShapeAttributes#imageSource} property of the polygon's attributes. If that
	 *     property is a single string or {@link ImageSource}, then it identifies the image source for the
	 *     polygon's texture. If that property is an array of strings, {@link ImageSource}s or a combination of
	 *     those, then the first entry in the array specifies the polygon's image source and subsequent entries
	 *     specify the image sources of the polygon's extruded boundaries. If the array contains two entries, the
	 *     first is the polygon's image source and the second is the common image source for all extruded
	 *     boundaries. If the array contains more than two entries, then the first entry is the polygon's image
	 *     source and each subsequent entry is the image source for consecutive extruded boundary segments. A null
	 *     value for any entry indicates that no texture is applied for the corresponding polygon or extruded edge
	 *     segment. If fewer image sources are specified then there are boundary segments, the last image source
	 *     specified is applied to the remaining segments. Texture coordinates for the polygon's texture are
	 *     specified via this polygon's [textureCoordinates]{@link Polygon#textureCoordinates} property. Texture
	 *     coordinates for extruded boundary segments are implicitly defined to fit the full texture to each
	 *     boundary segment.
	 * <p>
	 *     When displayed on a 2D globe, this polygon displays as a {@link SurfacePolygon} if its
	 *     [useSurfaceShapeFor2D]{@link AbstractShape#useSurfaceShapeFor2D} property is true.
	 *
	 * @param {Position[][] | Position[]} boundaries A two-dimensional array containing the polygon boundaries.
	 * Each entry of the array specifies the vertices of one boundary.
	 * This argument may also be a simple array of positions,
	 * in which case the polygon is assumed to have only one boundary.
	 * Each boundary is considered implicitly closed, so the last position of the boundary need not and should not
	 * duplicate the first position of the boundary.
	 * @param {ShapeAttributes} attributes The attributes to associate with this polygon. May be null, in which case
	 * default attributes are associated.
	 *
	 * @throws {ArgumentError} If the specified boundaries array is null or undefined.
	 */

	function Polygon(boundaries, attributes) {
	  if (!boundaries) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Polygon", "constructor", "missingBoundaries"));
	  }

	  AbstractShape.call(this, attributes);

	  if (boundaries.length > 0 && boundaries[0].latitude) {
	    boundaries = [boundaries];
	    this._boundariesSpecifiedSimply = true;
	  } // Private. Documentation is with the defined property below and the constructor description above.


	  this._boundaries = boundaries;
	  this._textureCoordinates = null;
	  this.referencePosition = this.determineReferencePosition(this._boundaries);
	  this._extrude = false;
	  this.scratchPoint = new Vec3$1(0, 0, 0); // scratch variable
	}

	Polygon.prototype = Object.create(AbstractShape.prototype);
	Object.defineProperties(Polygon.prototype, {
	  /**
	   * This polygon's boundaries. A two-dimensional array containing the polygon boundaries. Each entry of the
	   * array specifies the vertices of one boundary. This property may also be a simple
	   * array of positions, in which case the polygon is assumed to have only one boundary.
	   * @type {Position[][] | Position[]}
	   * @memberof Polygon.prototype
	   */
	  boundaries: {
	    get: function () {
	      return this._boundariesSpecifiedSimply ? this._boundaries[0] : this._boundaries;
	    },
	    set: function (boundaries) {
	      if (!boundaries) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "Polygon", "boundaries", "missingBoundaries"));
	      }

	      if (boundaries.length > 0 && boundaries[0].latitude) {
	        boundaries = [boundaries];
	        this._boundariesSpecifiedSimply = true;
	      }

	      this._boundaries = boundaries;
	      this.referencePosition = this.determineReferencePosition(this._boundaries);
	      this.reset();
	    }
	  },

	  /**
	   * This polygon's texture coordinates if this polygon is to be textured. A texture coordinate must be
	   * provided for each boundary position. The texture coordinates are specified as a two-dimensional array,
	   * each entry of which specifies the texture coordinates for one boundary. Each texture coordinate is a
	   * {@link Vec2} containing the s and t coordinates.
	   * @type {Vec2[][]}
	   * @default null
	   * @memberof Polygon.prototype
	   */
	  textureCoordinates: {
	    get: function () {
	      return this._textureCoordinates;
	    },
	    set: function (value) {
	      this._textureCoordinates = value;
	      this.reset();
	    }
	  },

	  /**
	   * Specifies whether to extrude this polygon to the ground by drawing a filled interior from the polygon
	   * to the terrain. The filled interior uses this polygon's interior attributes.
	   * @type {Boolean}
	   * @default false
	   * @memberof Polygon.prototype
	   */
	  extrude: {
	    get: function () {
	      return this._extrude;
	    },
	    set: function (extrude) {
	      this._extrude = extrude;
	      this.reset();
	    }
	  }
	}); // Intentionally not documented.

	Polygon.prototype.determineReferencePosition = function (boundaries) {
	  // Assign the first position as the reference position.
	  return boundaries.length > 0 && boundaries[0].length > 2 ? boundaries[0][0] : null;
	}; // Internal. Determines whether this shape's geometry must be re-computed.


	Polygon.prototype.mustGenerateGeometry = function (dc) {
	  if (!this.currentData.boundaryPoints) {
	    return true;
	  }

	  if (this.currentData.drawInterior !== this.activeAttributes.drawInterior) {
	    return true;
	  }

	  if (this.altitudeMode === WorldWind.ABSOLUTE) {
	    return false;
	  }

	  return this.currentData.isExpired;
	}; // Internal. Indicates whether this polygon should be textured.


	Polygon.prototype.hasCapTexture = function () {
	  return this.textureCoordinates && this.capImageSource();
	}; // Internal. Determines source of this polygon's cap texture. See the class description above for the policy.


	Polygon.prototype.capImageSource = function () {
	  if (!this.activeAttributes.imageSource) {
	    return null;
	  }

	  if (typeof this.activeAttributes.imageSource === "string" || this.activeAttributes.imageSource instanceof ImageSource) {
	    return this.activeAttributes.imageSource;
	  }

	  if (Array.isArray(this.activeAttributes.imageSource) && this.activeAttributes.imageSource[0] && (typeof this.activeAttributes.imageSource[0] === "string" || this.activeAttributes.imageSource instanceof ImageSource)) {
	    return this.activeAttributes.imageSource[0];
	  }

	  return null;
	}; // Internal. Indicates whether this polygon has side textures defined.


	Polygon.prototype.hasSideTextures = function () {
	  return this.activeAttributes.imageSource && Array.isArray(this.activeAttributes.imageSource) && this.activeAttributes.imageSource.length > 1;
	}; // Internal. Determines the side texture for a specified side. See the class description above for the policy.


	Polygon.prototype.sideImageSource = function (side) {
	  if (side === 0 || this.activeAttributes.imageSource.length === 2) {
	    return this.activeAttributes.imageSource[1];
	  }

	  var numSideTextures = this.activeAttributes.imageSource.length - 1;
	  side = Math.min(side + 1, numSideTextures);
	  return this.activeAttributes.imageSource[side];
	};

	Polygon.prototype.createSurfaceShape = function () {
	  return new SurfacePolygon(this.boundaries, null);
	}; // Overridden from AbstractShape base class.


	Polygon.prototype.doMakeOrderedRenderable = function (dc) {
	  // A null reference position is a signal that there are no boundaries to render.
	  if (!this.referencePosition) {
	    return null;
	  }

	  if (!this.activeAttributes.drawInterior && !this.activeAttributes.drawOutline) {
	    return null;
	  } // See if the current shape data can be re-used.


	  if (!this.mustGenerateGeometry(dc)) {
	    return this;
	  }

	  var currentData = this.currentData; // Set the transformation matrix to correspond to the reference position.

	  var refPt = currentData.referencePoint;
	  dc.surfacePointForMode(this.referencePosition.latitude, this.referencePosition.longitude, this.referencePosition.altitude, this._altitudeMode, refPt);
	  currentData.transformationMatrix.setToTranslation(refPt[0], refPt[1], refPt[2]); // Close the boundaries.

	  var fullBoundaries = [];

	  for (var b = 0; b < this._boundaries.length; b++) {
	    fullBoundaries[b] = this._boundaries[b].slice(0); // clones the array

	    fullBoundaries[b].push(this._boundaries[b][0]); // appends the first position to the boundary
	  } // Convert the geographic coordinates to the Cartesian coordinates that will be rendered.


	  var boundaryPoints = this.computeBoundaryPoints(dc, fullBoundaries); // Tessellate the polygon if its interior is to be drawn.

	  if (this.activeAttributes.drawInterior) {
	    var capVertices = this.tessellatePolygon(dc, boundaryPoints);

	    if (capVertices) {
	      // Must copy the vertices to a typed array. (Can't use typed array to begin with because its size
	      // is unknown prior to tessellation.)
	      currentData.capTriangles = new Float32Array(capVertices.length);

	      for (var i = 0, len = capVertices.length; i < len; i++) {
	        currentData.capTriangles[i] = capVertices[i];
	      }
	    }
	  }

	  currentData.boundaryPoints = boundaryPoints;
	  currentData.drawInterior = this.activeAttributes.drawInterior; // remember for validation

	  this.resetExpiration(currentData);
	  currentData.refreshBuffers = true; // causes VBOs to be reloaded
	  // Create the extent from the Cartesian points. Those points are relative to this path's reference point,
	  // so translate the computed extent to the reference point.

	  if (!currentData.extent) {
	    currentData.extent = new BoundingBox();
	  }

	  if (boundaryPoints.length === 1) {
	    currentData.extent.setToPoints(boundaryPoints[0]);
	  } else {
	    var allPoints = [];

	    for (b = 0; b < boundaryPoints.length; b++) {
	      for (var p = 0; p < boundaryPoints[b].length; p++) {
	        allPoints.push(boundaryPoints[b][p]);
	      }
	    }

	    currentData.extent.setToPoints(allPoints);
	  }

	  currentData.extent.translate(currentData.referencePoint);
	  return this;
	}; // Private. Intentionally not documented.


	Polygon.prototype.computeBoundaryPoints = function (dc, boundaries) {
	  var eyePoint = dc.eyePoint,
	      boundaryPoints = [],
	      stride = this._extrude ? 6 : 3,
	      pt = new Vec3$1(0, 0, 0),
	      numBoundaryPoints,
	      pos,
	      k,
	      dSquared;

	  for (var b = 0; b < boundaries.length; b++) {
	    numBoundaryPoints = (this._extrude ? 2 : 1) * boundaries[b].length;
	    boundaryPoints[b] = new Float32Array(numBoundaryPoints * 3);

	    for (var i = 0, len = boundaries[b].length; i < len; i++) {
	      pos = boundaries[b][i];
	      dc.surfacePointForMode(pos.latitude, pos.longitude, pos.altitude, this.altitudeMode, pt);
	      dSquared = pt.distanceToSquared(eyePoint);

	      pt.subtract(this.currentData.referencePoint);
	      k = stride * i;
	      boundaryPoints[b][k] = pt[0];
	      boundaryPoints[b][k + 1] = pt[1];
	      boundaryPoints[b][k + 2] = pt[2];

	      if (this._extrude) {
	        dc.surfacePointForMode(pos.latitude, pos.longitude, 0, WorldWind.CLAMP_TO_GROUND, pt);
	        dSquared = pt.distanceToSquared(eyePoint);

	        pt.subtract(this.currentData.referencePoint);
	        boundaryPoints[b][k + 3] = pt[0];
	        boundaryPoints[b][k + 4] = pt[1];
	        boundaryPoints[b][k + 5] = pt[2];
	      }
	    }
	  }

	  this.currentData.eyeDistance = 0;
	  /*DO NOT COMMITMath.sqrt(eyeDistSquared);*/

	  return boundaryPoints;
	};

	Polygon.prototype.tessellatePolygon = function (dc, boundaryPoints) {
	  var triangles = [],
	      // the output list of triangles
	  error = 0,
	      stride = this._extrude ? 6 : 3,
	      includeTextureCoordinates = this.hasCapTexture(),
	      coords,
	      normal;

	  if (!this.polygonTessellator) {
	    this.polygonTessellator = new libtess.GluTesselator();
	    this.polygonTessellator.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA, function (data, tris) {
	      tris[tris.length] = data[0];
	      tris[tris.length] = data[1];
	      tris[tris.length] = data[2];

	      if (includeTextureCoordinates) {
	        tris[tris.length] = data[3];
	        tris[tris.length] = data[4];
	      }
	    });
	    this.polygonTessellator.gluTessCallback(libtess.gluEnum.GLU_TESS_COMBINE, function (coords, data, weight) {
	      var newCoords = [coords[0], coords[1], coords[2]];

	      if (includeTextureCoordinates) {
	        for (var i = 3; i <= 4; i++) {
	          var value = 0;

	          for (var w = 0; w < 4; w++) {
	            if (weight[w] > 0) {
	              value += weight[w] * data[w][i];
	            }
	          }

	          newCoords[i] = value;
	        }
	      }

	      return newCoords;
	    });
	    this.polygonTessellator.gluTessCallback(libtess.gluEnum.GLU_TESS_ERROR, function (errno) {
	      error = errno;
	      Logger$1.logMessage(Logger$1.LEVEL_WARNING, "Polygon", "tessellatePolygon", "Tessellation error " + errno + ".");
	    });
	  } // Compute a normal vector for the polygon.


	  normal = Vec3$1.computeBufferNormal(boundaryPoints[0], stride);

	  if (!normal) {
	    normal = new Vec3$1(0, 0, 0); // The first boundary is colinear. Fall back to the surface normal.

	    dc.globe.surfaceNormalAtLocation(this.referencePosition.latitude, this.referencePosition.longitude, normal);
	  }

	  this.polygonTessellator.gluTessNormal(normal[0], normal[1], normal[2]);
	  this.currentData.capNormal = normal; // Tessellate the polygon.

	  this.polygonTessellator.gluTessBeginPolygon(triangles);

	  for (var b = 0; b < boundaryPoints.length; b++) {
	    var t = 0;
	    this.polygonTessellator.gluTessBeginContour();
	    var contour = boundaryPoints[b];

	    for (var c = 0; c < contour.length; c += stride) {
	      coords = [contour[c], contour[c + 1], contour[c + 2]];

	      if (includeTextureCoordinates) {
	        if (t < this.textureCoordinates[b].length) {
	          coords[3] = this.textureCoordinates[b][t][0];
	          coords[4] = this.textureCoordinates[b][t][1];
	        } else {
	          coords[3] = this.textureCoordinates[b][0][0];
	          coords[4] = this.textureCoordinates[b][1][1];
	        }

	        ++t;
	      }

	      this.polygonTessellator.gluTessVertex(coords, coords);
	    }

	    this.polygonTessellator.gluTessEndContour();
	  }

	  this.polygonTessellator.gluTessEndPolygon();
	  return error === 0 ? triangles : null;
	}; // Private. Intentionally not documented.


	Polygon.prototype.mustDrawVerticals = function (dc) {
	  return this._extrude && this.activeAttributes.drawOutline && this.activeAttributes.drawVerticals && this.altitudeMode !== WorldWind.CLAMP_TO_GROUND;
	}; // Overridden from AbstractShape base class.


	Polygon.prototype.doRenderOrdered = function (dc) {
	  var currentData = this.currentData,
	      pickColor;

	  if (dc.pickingMode) {
	    pickColor = dc.uniquePickColor();
	  } // Draw the cap if the interior requested and we were able to tessellate the polygon.


	  if (this.activeAttributes.drawInterior && currentData.capTriangles && currentData.capTriangles.length > 0) {
	    this.drawCap(dc, pickColor);
	  }

	  if (this._extrude && this.activeAttributes.drawInterior) {
	    this.drawSides(dc, pickColor);
	  }

	  if (this.activeAttributes.drawOutline) {
	    this.drawOutline(dc, pickColor);
	  }

	  currentData.refreshBuffers = false;

	  if (dc.pickingMode) {
	    var po = new PickedObject(pickColor, this.pickDelegate ? this.pickDelegate : this, null, this.layer, false);
	    dc.resolvePick(po);
	  }
	};

	Polygon.prototype.drawCap = function (dc, pickColor) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram,
	      currentData = this.currentData,
	      refreshBuffers = currentData.refreshBuffers,
	      hasCapTexture = !!this.hasCapTexture(),
	      applyLighting = this.activeAttributes.applyLighting,
	      numCapVertices = currentData.capTriangles.length / (hasCapTexture ? 5 : 3),
	      vboId,
	      color,
	      stride,
	      textureBound,
	      capBuffer; // Assume no cap texture.

	  program.loadTextureEnabled(gl, false);
	  this.applyMvpMatrix(dc);

	  if (!currentData.capVboCacheKey) {
	    currentData.capVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	  }

	  vboId = dc.gpuResourceCache.resourceForKey(currentData.capVboCacheKey);

	  if (!vboId) {
	    vboId = gl.createBuffer();
	    dc.gpuResourceCache.putResource(currentData.capVboCacheKey, vboId, currentData.capTriangles.length * 4);
	    refreshBuffers = true;
	  }

	  gl.bindBuffer(gl.ARRAY_BUFFER, vboId);

	  if (refreshBuffers) {
	    capBuffer = applyLighting ? this.makeCapBufferWithNormals() : currentData.capTriangles;
	    gl.bufferData(gl.ARRAY_BUFFER, capBuffer, gl.STATIC_DRAW);
	    dc.frameStatistics.incrementVboLoadCount(1);
	  }

	  color = this.activeAttributes.interiorColor; // Disable writing the shape's fragments to the depth buffer when the interior is semi-transparent.

	  gl.depthMask(color.alpha * this.layer.opacity >= 1 || dc.pickingMode);
	  program.loadColor(gl, dc.pickingMode ? pickColor : color);
	  program.loadOpacity(gl, dc.pickingMode ? 1 : this.layer.opacity);
	  stride = 12 + (hasCapTexture ? 8 : 0) + (applyLighting ? 12 : 0);

	  if (hasCapTexture && !dc.pickingMode) {
	    this.activeTexture = dc.gpuResourceCache.resourceForKey(this.capImageSource());

	    if (!this.activeTexture) {
	      this.activeTexture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this.capImageSource());
	    }

	    textureBound = this.activeTexture && this.activeTexture.bind(dc);

	    if (textureBound) {
	      gl.enableVertexAttribArray(program.vertexTexCoordLocation);
	      gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, stride, 12);
	      this.scratchMatrix.setToIdentity();
	      this.scratchMatrix.multiplyByTextureTransform(this.activeTexture);
	      program.loadTextureEnabled(gl, true);
	      program.loadTextureUnit(gl, gl.TEXTURE0);
	      program.loadTextureMatrix(gl, this.scratchMatrix);
	      program.loadModulateColor(gl, dc.pickingMode);
	    }
	  }

	  if (applyLighting && !dc.pickingMode) {
	    program.loadApplyLighting(gl, true);
	    gl.enableVertexAttribArray(program.normalVectorLocation);
	    gl.vertexAttribPointer(program.normalVectorLocation, 3, gl.FLOAT, false, stride, stride - 12);
	  }

	  gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, stride, 0);
	  gl.drawArrays(gl.TRIANGLES, 0, numCapVertices);
	};

	Polygon.prototype.makeCapBufferWithNormals = function () {
	  var currentData = this.currentData,
	      normal = currentData.capNormal,
	      numFloatsIn = this.hasCapTexture() ? 5 : 3,
	      numFloatsOut = numFloatsIn + 3,
	      numVertices = currentData.capTriangles.length / numFloatsIn,
	      bufferIn = currentData.capTriangles,
	      bufferOut = new Float32Array(numVertices * numFloatsOut),
	      k = 0;

	  for (var i = 0; i < numVertices; i++) {
	    for (var j = 0; j < numFloatsIn; j++) {
	      bufferOut[k++] = bufferIn[i * numFloatsIn + j];
	    }

	    bufferOut[k++] = normal[0];
	    bufferOut[k++] = normal[1];
	    bufferOut[k++] = normal[2];
	  }

	  return bufferOut;
	};

	Polygon.prototype.drawSides = function (dc, pickColor) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram,
	      currentData = this.currentData,
	      refreshBuffers = currentData.refreshBuffers,
	      hasSideTextures = this.hasSideTextures(),
	      applyLighting = this.activeAttributes.applyLighting,
	      numFloatsPerVertex = 3 + (hasSideTextures ? 2 : 0) + (applyLighting ? 3 : 0),
	      numBytesPerVertex = 4 * numFloatsPerVertex,
	      vboId,
	      color,
	      textureBound,
	      sidesBuffer,
	      numSides;
	  numSides = 0;

	  for (var b = 0; b < currentData.boundaryPoints.length; b++) {
	    // for each boundary}
	    numSides += currentData.boundaryPoints[b].length / 6 - 1; // 6 floats per boundary point: top + bottom
	  }

	  if (!currentData.sidesVboCacheKey) {
	    currentData.sidesVboCacheKey = dc.gpuResourceCache.generateCacheKey();
	  }

	  vboId = dc.gpuResourceCache.resourceForKey(currentData.sidesVboCacheKey);

	  if (!vboId || refreshBuffers) {
	    sidesBuffer = this.makeSidesBuffer(numSides);
	    currentData.numSideVertices = sidesBuffer.length / numFloatsPerVertex;

	    if (!vboId) {
	      vboId = gl.createBuffer();
	    }

	    dc.gpuResourceCache.putResource(currentData.sidesVboCacheKey, vboId, sidesBuffer.length * 4);
	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	    gl.bufferData(gl.ARRAY_BUFFER, sidesBuffer, gl.STATIC_DRAW);
	    dc.frameStatistics.incrementVboLoadCount(1);
	  } else {
	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	  }

	  color = this.activeAttributes.interiorColor; // Disable writing the shape's fragments to the depth buffer when the interior is semi-transparent.

	  gl.depthMask(color.alpha * this.layer.opacity >= 1 || dc.pickingMode);
	  program.loadColor(gl, dc.pickingMode ? pickColor : color);
	  program.loadOpacity(gl, dc.pickingMode ? 1 : this.layer.opacity);

	  if (hasSideTextures && !dc.pickingMode) {
	    if (applyLighting) {
	      program.loadApplyLighting(gl, true);
	      gl.enableVertexAttribArray(program.normalVectorLocation);
	    } else {
	      program.loadApplyLighting(gl, false);
	    } // Step through the sides buffer rendering each side independently but from the same buffer.


	    for (var side = 0; side < numSides; side++) {
	      var sideImageSource = this.sideImageSource(side),
	          sideTexture = dc.gpuResourceCache.resourceForKey(sideImageSource),
	          coordByteOffset = side * 6 * numBytesPerVertex; // 6 vertices (2 triangles) per side

	      if (sideImageSource && !sideTexture) {
	        sideTexture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, sideImageSource);
	      }

	      textureBound = sideTexture && sideTexture.bind(dc);

	      if (textureBound) {
	        gl.enableVertexAttribArray(program.vertexTexCoordLocation);
	        gl.vertexAttribPointer(program.vertexTexCoordLocation, 2, gl.FLOAT, false, numBytesPerVertex, coordByteOffset + 12);
	        this.scratchMatrix.setToIdentity();
	        this.scratchMatrix.multiplyByTextureTransform(sideTexture);
	        program.loadTextureEnabled(gl, true);
	        program.loadTextureUnit(gl, gl.TEXTURE0);
	        program.loadTextureMatrix(gl, this.scratchMatrix);
	      } else {
	        program.loadTextureEnabled(gl, false);
	        gl.disableVertexAttribArray(program.vertexTexCoordLocation);
	      }

	      if (applyLighting) {
	        gl.vertexAttribPointer(program.normalVectorLocation, 3, gl.FLOAT, false, numBytesPerVertex, coordByteOffset + 20);
	      }

	      gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, numBytesPerVertex, coordByteOffset);
	      gl.drawArrays(gl.TRIANGLES, 0, 6); // 6 vertices per side
	    }
	  } else {
	    program.loadTextureEnabled(gl, false);

	    if (applyLighting && !dc.pickingMode) {
	      program.loadApplyLighting(gl, true);
	      gl.enableVertexAttribArray(program.normalVectorLocation);
	      gl.vertexAttribPointer(program.normalVectorLocation, 3, gl.FLOAT, false, numBytesPerVertex, numBytesPerVertex - 12);
	    } else {
	      program.loadApplyLighting(gl, false);
	    }

	    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, numBytesPerVertex, 0);
	    gl.drawArrays(gl.TRIANGLES, 0, currentData.numSideVertices);
	  }
	};

	Polygon.prototype.makeSidesBuffer = function (numSides) {
	  var currentData = this.currentData,
	      hasSideTextures = this.hasSideTextures(),
	      applyLighting = this.activeAttributes.applyLighting,
	      numFloatsPerVertex = 3 + (hasSideTextures ? 2 : 0) + (applyLighting ? 3 : 0),
	      sidesBuffer,
	      sidesBufferIndex,
	      numBufferFloats,
	      v0,
	      v1,
	      v2,
	      v3,
	      t0,
	      t1,
	      t2,
	      t3;
	  numBufferFloats = numSides * 2 * 3 * numFloatsPerVertex; // 2 triangles per side, 3 vertices per triangle

	  sidesBuffer = new Float32Array(numBufferFloats);
	  sidesBufferIndex = 0;
	  v0 = new Vec3$1(0, 0, 0);
	  v1 = new Vec3$1(0, 0, 0);
	  v2 = new Vec3$1(0, 0, 0);
	  v3 = new Vec3$1(0, 0, 0);

	  if (hasSideTextures) {
	    t0 = new Vec2(0, 1);
	    t1 = new Vec2(0, 0);
	    t2 = new Vec2(1, 1);
	    t3 = new Vec2(1, 0);
	  } else {
	    t0 = t1 = t2 = t3 = null;
	  }

	  for (var b = 0; b < currentData.boundaryPoints.length; b++) {
	    // for each boundary}
	    var boundaryPoints = currentData.boundaryPoints[b],
	        sideNormal;

	    for (var i = 0; i < boundaryPoints.length - 6; i += 6) {
	      v0[0] = boundaryPoints[i];
	      v0[1] = boundaryPoints[i + 1];
	      v0[2] = boundaryPoints[i + 2];
	      v1[0] = boundaryPoints[i + 3];
	      v1[1] = boundaryPoints[i + 4];
	      v1[2] = boundaryPoints[i + 5];
	      v2[0] = boundaryPoints[i + 6];
	      v2[1] = boundaryPoints[i + 7];
	      v2[2] = boundaryPoints[i + 8];
	      v3[0] = boundaryPoints[i + 9];
	      v3[1] = boundaryPoints[i + 10];
	      v3[2] = boundaryPoints[i + 11];
	      sideNormal = applyLighting ? Vec3$1.computeTriangleNormal(v0, v1, v2) : null; // First triangle.

	      this.addVertexToBuffer(v0, t0, sideNormal, sidesBuffer, sidesBufferIndex);
	      sidesBufferIndex += numFloatsPerVertex;
	      this.addVertexToBuffer(v1, t1, sideNormal, sidesBuffer, sidesBufferIndex);
	      sidesBufferIndex += numFloatsPerVertex;
	      this.addVertexToBuffer(v2, t2, sideNormal, sidesBuffer, sidesBufferIndex);
	      sidesBufferIndex += numFloatsPerVertex; // Second triangle.

	      this.addVertexToBuffer(v1, t1, sideNormal, sidesBuffer, sidesBufferIndex);
	      sidesBufferIndex += numFloatsPerVertex;
	      this.addVertexToBuffer(v3, t3, sideNormal, sidesBuffer, sidesBufferIndex);
	      sidesBufferIndex += numFloatsPerVertex;
	      this.addVertexToBuffer(v2, t2, sideNormal, sidesBuffer, sidesBufferIndex);
	      sidesBufferIndex += numFloatsPerVertex;
	    }
	  }

	  return sidesBuffer;
	};

	Polygon.prototype.addVertexToBuffer = function (v, texCoord, normal, buffer, bufferIndex) {
	  buffer[bufferIndex++] = v[0];
	  buffer[bufferIndex++] = v[1];
	  buffer[bufferIndex++] = v[2];

	  if (texCoord) {
	    buffer[bufferIndex++] = texCoord[0];
	    buffer[bufferIndex++] = texCoord[1];
	  }

	  if (normal) {
	    buffer[bufferIndex++] = normal[0];
	    buffer[bufferIndex++] = normal[1];
	    buffer[bufferIndex] = normal[2];
	  }
	};

	Polygon.prototype.drawOutline = function (dc, pickColor) {
	  var gl = dc.currentGlContext,
	      program = dc.currentProgram,
	      currentData = this.currentData,
	      refreshBuffers = currentData.refreshBuffers,
	      numBoundaryPoints,
	      vboId,
	      color,
	      stride,
	      nPts;
	  program.loadTextureEnabled(gl, false);
	  program.loadApplyLighting(gl, false);

	  if (this.hasCapTexture()) {
	    gl.disableVertexAttribArray(program.vertexTexCoordLocation); // we're not texturing the outline
	  }

	  if (this.activeAttributes.applyLighting) {
	    gl.disableVertexAttribArray(program.normalVectorLocation); // we're not lighting the outline
	  }

	  if (!currentData.boundaryVboCacheKeys) {
	    this.currentData.boundaryVboCacheKeys = [];
	  } // Make the outline stand out from the interior.


	  this.applyMvpMatrixForOutline(dc);
	  program.loadTextureEnabled(gl, false);
	  gl.disableVertexAttribArray(program.vertexTexCoordLocation);

	  for (var b = 0; b < currentData.boundaryPoints.length; b++) {
	    // for each boundary}
	    numBoundaryPoints = currentData.boundaryPoints[b].length / 3;

	    if (!currentData.boundaryVboCacheKeys[b]) {
	      currentData.boundaryVboCacheKeys[b] = dc.gpuResourceCache.generateCacheKey();
	    }

	    vboId = dc.gpuResourceCache.resourceForKey(currentData.boundaryVboCacheKeys[b]);

	    if (!vboId) {
	      vboId = gl.createBuffer();
	      dc.gpuResourceCache.putResource(currentData.boundaryVboCacheKeys[b], vboId, numBoundaryPoints * 12);
	      refreshBuffers = true;
	    }

	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);

	    if (refreshBuffers) {
	      gl.bufferData(gl.ARRAY_BUFFER, currentData.boundaryPoints[b], gl.STATIC_DRAW);
	      dc.frameStatistics.incrementVboLoadCount(1);
	    }

	    color = this.activeAttributes.outlineColor; // Disable writing the shape's fragments to the depth buffer when the interior is semi-transparent.

	    gl.depthMask(color.alpha * this.layer.opacity >= 1 || dc.pickingMode);
	    program.loadColor(gl, dc.pickingMode ? pickColor : color);
	    program.loadOpacity(gl, dc.pickingMode ? 1 : this.layer.opacity);
	    gl.lineWidth(this.activeAttributes.outlineWidth);

	    if (this._extrude) {
	      stride = 24;
	      nPts = numBoundaryPoints / 2;
	    } else {
	      stride = 12;
	      nPts = numBoundaryPoints;
	    }

	    gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, stride, 0);
	    gl.drawArrays(gl.LINE_STRIP, 0, nPts);

	    if (this.mustDrawVerticals(dc)) {
	      gl.vertexAttribPointer(program.vertexPointLocation, 3, gl.FLOAT, false, 0, 0);
	      gl.drawArrays(gl.LINES, 0, numBoundaryPoints - 2);
	    }
	  }
	}; // Overridden from AbstractShape base class.


	Polygon.prototype.beginDrawing = function (dc) {
	  var gl = dc.currentGlContext;

	  if (this.activeAttributes.drawInterior) {
	    gl.disable(gl.CULL_FACE);
	  }

	  dc.findAndBindProgram(BasicTextureProgram);
	  gl.enableVertexAttribArray(dc.currentProgram.vertexPointLocation);
	  var applyLighting = !dc.pickMode && this.activeAttributes.applyLighting;

	  if (applyLighting) {
	    dc.currentProgram.loadModelviewInverse(gl, dc.modelviewNormalTransform);
	  }
	}; // Overridden from AbstractShape base class.


	Polygon.prototype.endDrawing = function (dc) {
	  var gl = dc.currentGlContext;
	  gl.disableVertexAttribArray(dc.currentProgram.vertexPointLocation);
	  gl.disableVertexAttribArray(dc.currentProgram.normalVectorLocation);
	  gl.depthMask(true);
	  gl.lineWidth(1);
	  gl.enable(gl.CULL_FACE);
	};

	/**
	 * @exports ProjectionGnomonic
	 */
	/**
	 * Constructs a gnomonic geographic projection.
	 * @alias ProjectionGnomonic
	 * @constructor
	 * @augments GeographicProjection
	 * @classdesc Represents a polar gnomonic geographic projection.
	 * @param {String} pole Indicates the north or south aspect. Specify "North" for the north aspect or "South"
	 * for the south aspect.
	 */

	function ProjectionGnomonic(pole) {
	  // Internal. Intentionally not documented. See "pole" property accessor below for public interface.
	  // Internal. Intentionally not documented.
	  this.north = !(pole === "South");
	  var limits = this.north ? new Sector(30, 90, -180, 180) : new Sector(-90, -30, -180, 180);
	  GeographicProjection.call(this, "Polar Gnomonic", false, limits); // Internal. Intentionally not documented. See "pole" property accessor below for public interface.

	  this._pole = pole; // Documented in superclass.

	  this.displayName = this.north ? "North Gnomonic" : "South Gnomonic"; // Internal. Intentionally not documented. See "stateKey" property accessor below for public interface.

	  this._stateKey = "projection polar gnomonic " + this._pole + " ";
	}

	ProjectionGnomonic.prototype = Object.create(GeographicProjection.prototype);
	Object.defineProperties(ProjectionGnomonic.prototype, {
	  /**
	   * Indicates the north or south aspect. Specify "North" or "South".
	   * @memberof ProjectionGnomonic.prototype
	   * @type {String}
	   */
	  pole: {
	    get: function () {
	      return this._pole;
	    },
	    set: function (pole) {
	      this._pole = pole;
	      this.north = !(this._pole === "South");
	      this.projectionLimits = this.north ? new Sector(30, 90, -180, 180) : new Sector(-90, -30, -180, 180);
	      this._stateKey = "projection polar gnomonic " + this._pole + " ";
	    }
	  },

	  /**
	   * A string identifying this projection's current state. Used to compare states during rendering to
	   * determine whether globe-state dependent cached values must be updated. Applications typically do not
	   * interact with this property.
	   * @memberof ProjectionGnomonic.prototype
	   * @readonly
	   * @type {String}
	   */
	  stateKey: {
	    get: function () {
	      return this._stateKey;
	    }
	  }
	}); // Documented in base class.

	ProjectionGnomonic.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionGnomonic", "geographicToCartesian", "missingGlobe"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionGnomonic", "geographicToCartesian", "missingResult"));
	  } // Formulae taken from "Map Projections -- A Working Manual", Snyder, USGS paper 1395, pg. 167.


	  if (this.north && latitude === 90 || !this.north && latitude === -90) {
	    result[0] = 0;
	    result[1] = 0;
	    result[2] = elevation;
	  } else {
	    var poleFactor = this.north ? 1 : -1,
	        a = globe.equatorialRadius / Math.tan(latitude * Angle.DEGREES_TO_RADIANS); // R cot(phi)

	    result[0] = a * Math.sin(longitude * Angle.DEGREES_TO_RADIANS) * poleFactor; // eqs. 22-6, 22-10

	    result[1] = a * -Math.cos(longitude * Angle.DEGREES_TO_RADIANS); // eqs. 22-7, 22-11

	    result[2] = elevation;
	  }

	  return result;
	}; // Documented in base class.


	ProjectionGnomonic.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations, referencePoint, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionGnomonic", "geographicToCartesianGrid", "missingGlobe"));
	  }

	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionGnomonic", "geographicToCartesianGrid", "missingSector"));
	  }

	  if (!elevations || elevations.length < numLat * numLon) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionGnomonic", "geographicToCartesianGrid", "The specified elevations array is null, undefined or insufficient length"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionGnomonic", "geographicToCartesianGrid", "missingResult"));
	  }

	  var minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,
	      maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,
	      minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,
	      maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,
	      deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
	      deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
	      minLatLimit = this.projectionLimits.minLatitude * Angle.DEGREES_TO_RADIANS,
	      maxLatLimit = this.projectionLimits.maxLatitude * Angle.DEGREES_TO_RADIANS,
	      poleFactor = this.north ? 1 : -1,
	      refPoint = referencePoint ? referencePoint : new Vec3(0, 0, 0),
	      latIndex,
	      lonIndex,
	      elevIndex = 0,
	      resultIndex = 0,
	      lat,
	      lon,
	      clampedLat,
	      a;

	  for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {
	    if (latIndex === numLat - 1) {
	      lat = maxLat; // explicitly set the last lat to the max latitude to ensure alignment
	    } // Latitude is constant for each row. Values that are a function of latitude can be computed once per row.


	    clampedLat = WWMath.clamp(lat, minLatLimit, maxLatLimit);
	    a = globe.equatorialRadius / Math.tan(clampedLat);

	    if (this.north && clampedLat === Math.PI / 2 || !this.north && clampedLat === -Math.PI / 2) {
	      a = 0;
	    }

	    for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {
	      if (lonIndex === numLon - 1) {
	        lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
	      } // Formulae taken from "Map Projections -- A Working Manual", Snyder, USGS paper 1395, pg. 167.


	      result[resultIndex++] = a * Math.sin(lon) * poleFactor - refPoint[0]; // eqs. 22-6, 22-10

	      result[resultIndex++] = a * -Math.cos(lon) - refPoint[1]; // eqs. 22-7, 22-11

	      result[resultIndex++] = elevations[elevIndex++] - refPoint[2];
	    }
	  }

	  return result;
	}; // Documented in base class.


	ProjectionGnomonic.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionGnomonic", "cartesianToGeographic", "missingGlobe"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionGnomonic", "cartesianToGeographic", "missingResult"));
	  } // Formulae taken from "Map Projections -- A Working Manual", Snyder, USGS paper 1395, pg. 167.


	  var rho = Math.sqrt(x * x + y * y),
	      // eq. 20-18
	  c;

	  if (rho < 1.0e-4) {
	    result.latitude = this.north ? 90 : -90;
	    result.longitude = 0;
	    result.altitude = z;
	  } else {
	    c = Math.atan2(rho, globe.equatorialRadius); // eq. 22-16

	    if (c > Math.PI) {
	      c = Math.PI; // map cartesian points beyond the projection's radius to the edge of the projection
	    }

	    result.latitude = Math.asin(Math.cos(c) * (this.north ? 1 : -1)) * Angle.RADIANS_TO_DEGREES; // eq. 20-14

	    result.longitude = Math.atan2(x, y * (this.north ? -1 : 1)) * Angle.RADIANS_TO_DEGREES; // use atan2(x,y) instead of atan(x/y). 20-16, 20-17

	    result.altitude = z;
	  }

	  return result;
	}; // Documented in base class.


	ProjectionGnomonic.prototype.northTangentAtLocation = function (globe, latitude, longitude, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionGnomonic", "northTangentAtLocation", "missingResult"));
	  } // The north pointing tangent depends on the pole. With the south pole, the north pointing tangent points in
	  // the same direction as the vector returned by cartesianToGeographic. With the north pole, the north
	  // pointing tangent has the opposite direction.


	  result[0] = Math.sin(longitude * Angle.DEGREES_TO_RADIANS) * (this.north ? -1 : 1);
	  result[1] = Math.cos(longitude * Angle.DEGREES_TO_RADIANS);
	  result[2] = 0;
	  return result;
	}; // Documented in base class.


	ProjectionGnomonic.prototype.northTangentAtPoint = function (globe, x, y, z, offset, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionGnomonic", "northTangentAtLocation", "missingResult"));
	  } // The north pointing tangent depends on the pole. With the south pole, the north pointing tangent points in
	  // the same direction as the vector returned by cartesianToGeographic. With the north pole, the north
	  // pointing tangent has the opposite direction.


	  var rho = Math.sqrt(x * x + y * y);

	  if (rho < 1.0e-4) {
	    result[0] = 0;
	    result[1] = 1;
	    result[2] = 0;
	  } else {
	    result[0] = x / rho * (this.north ? -1 : 1);
	    result[1] = y / rho * (this.north ? -1 : 1);
	    result[2] = 0;
	  }

	  return result;
	};

	/**
	 * @exports ProjectionMercator
	 */
	/**
	 * Constructs a Mercator geographic projection.
	 * @alias ProjectionMercator
	 * @constructor
	 * @augments GeographicProjection
	 * @classdesc Represents a Mercator geographic projection.
	 */

	function ProjectionMercator() {
	  GeographicProjection.call(this, "Mercator", true, new Sector(-78, 78, -180, 180));
	}

	ProjectionMercator.prototype = Object.create(GeographicProjection.prototype); // Documented in base class.

	ProjectionMercator.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionMercator", "geographicToCartesian", "missingGlobe"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionMercator", "geographicToCartesian", "missingResult"));
	  }

	  if (latitude > this.projectionLimits.maxLatitude) {
	    latitude = this.projectionLimits.maxLatitude;
	  }

	  if (latitude < this.projectionLimits.minLatitude) {
	    latitude = this.projectionLimits.minLatitude;
	  } // See "Map Projections: A Working Manual", page 44 for the source of the below formulas.


	  var ecc = Math.sqrt(globe.eccentricitySquared),
	      sinLat = Math.sin(latitude * Angle.DEGREES_TO_RADIANS),
	      s = (1 + sinLat) / (1 - sinLat) * Math.pow((1 - ecc * sinLat) / (1 + ecc * sinLat), ecc);
	  result[0] = globe.equatorialRadius * longitude * Angle.DEGREES_TO_RADIANS + (offset ? offset[0] : 0);
	  result[1] = 0.5 * globe.equatorialRadius * Math.log(s);
	  result[2] = elevation;
	  return result;
	};

	Object.defineProperties(ProjectionMercator.prototype, {
	  /**
	   * A string identifying this projection's current state. Used to compare states during rendering to
	   * determine whether globe-state dependent cached values must be updated. Applications typically do not
	   * interact with this property.
	   * @memberof ProjectionMercator.prototype
	   * @readonly
	   * @type {String}
	   */
	  stateKey: {
	    get: function () {
	      return "projection mercator ";
	    }
	  }
	}); // Documented in base class.

	ProjectionMercator.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations, referencePoint, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionMercator", "geographicToCartesianGrid", "missingGlobe"));
	  }

	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionMercator", "geographicToCartesianGrid", "missingSector"));
	  }

	  if (!elevations || elevations.length < numLat * numLon) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionMercator", "geographicToCartesianGrid", "The specified elevations array is null, undefined or insufficient length"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionMercator", "geographicToCartesianGrid", "missingResult"));
	  }

	  var eqr = globe.equatorialRadius,
	      ecc = Math.sqrt(globe.eccentricitySquared),
	      minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,
	      maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,
	      minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,
	      maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,
	      deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
	      deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
	      minLatLimit = this.projectionLimits.minLatitude * Angle.DEGREES_TO_RADIANS,
	      maxLatLimit = this.projectionLimits.maxLatitude * Angle.DEGREES_TO_RADIANS,
	      refCenter = referencePoint ? referencePoint : new Vec3$1(0, 0, 0),
	      offsetX = offset ? offset[0] : 0,
	      latIndex,
	      lonIndex,
	      elevIndex = 0,
	      resultIndex = 0,
	      lat,
	      lon,
	      clampedLat,
	      sinLat,
	      s,
	      y; // Iterate over the latitude and longitude coordinates in the specified sector, computing the Cartesian point
	  // corresponding to each latitude and longitude.

	  for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {
	    if (latIndex === numLat - 1) {
	      lat = maxLat; // explicitly set the last lat to the max latitude to ensure alignment
	    } // Latitude is constant for each row. Values that are a function of latitude can be computed once per row.


	    clampedLat = WWMath.clamp(lat, minLatLimit, maxLatLimit);
	    sinLat = Math.sin(clampedLat);
	    s = (1 + sinLat) / (1 - sinLat) * Math.pow((1 - ecc * sinLat) / (1 + ecc * sinLat), ecc);
	    y = eqr * Math.log(s) * 0.5 - refCenter[1];

	    for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {
	      if (lonIndex === numLon - 1) {
	        lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
	      }

	      result[resultIndex++] = eqr * lon - refCenter[0] + offsetX;
	      result[resultIndex++] = y;
	      result[resultIndex++] = elevations[elevIndex++] - refCenter[2];
	    }
	  }

	  return result;
	}; // Documented in base class.


	ProjectionMercator.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionMercator", "cartesianToGeographic", "missingGlobe"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionMercator", "cartesianToGeographic", "missingResult"));
	  } // See "Map Projections: A Working Manual", pages 45 and 19 for the source of the below formulas.


	  var ecc2 = globe.eccentricitySquared,
	      ecc4 = ecc2 * ecc2,
	      ecc6 = ecc4 * ecc2,
	      ecc8 = ecc6 * ecc2,
	      t = Math.pow(Math.E, -y / globe.equatorialRadius),
	      A = Math.PI / 2 - 2 * Math.atan(t),
	      B = ecc2 / 2 + 5 * ecc4 / 24 + ecc6 / 12 + 13 * ecc8 / 360,
	      C = 7 * ecc4 / 48 + 29 * ecc6 / 240 + 811 * ecc8 / 11520,
	      D = 7 * ecc6 / 120 + 81 * ecc8 / 1120,
	      E = 4279 * ecc8 / 161280,
	      Ap = A - C + E,
	      Bp = B - 3 * D,
	      Cp = 2 * C - 8 * E,
	      Dp = 4 * D,
	      Ep = 8 * E,
	      s2p = Math.sin(2 * A),
	      lat = Ap + s2p * (Bp + s2p * (Cp + s2p * (Dp + Ep * s2p)));
	  result.latitude = lat * Angle.RADIANS_TO_DEGREES;
	  result.longitude = (x - (offset ? offset[0] : 0)) / globe.equatorialRadius * Angle.RADIANS_TO_DEGREES;
	  result.altitude = z;
	  return result;
	};

	/**
	 * @exports ProjectionPolarEquidistant
	 */
	/**
	 * Constructs a polar equidistant geographic projection.
	 * @alias ProjectionPolarEquidistant
	 * @constructor
	 * @augments GeographicProjection
	 * @classdesc Represents a polar equidistant geographic projection.
	 * @param {String} pole Indicates the north or south aspect. Specify "North" for the north aspect or "South"
	 * for the south aspect.
	 */

	function ProjectionPolarEquidistant(pole) {
	  GeographicProjection.call(this, "Polar Equidistant", false, null); // Internal. Intentionally not documented. See "pole" property accessor below for public interface.

	  this._pole = pole; // Internal. Intentionally not documented.

	  this.north = !(pole === "South"); // Documented in superclass.

	  this.displayName = this.north ? "North Polar" : "South Polar"; // Internal. Intentionally not documented. See "stateKey" property accessor below for public interface.

	  this._stateKey = "projection polar equidistant " + this._pole + " ";
	}

	ProjectionPolarEquidistant.prototype = Object.create(GeographicProjection.prototype);
	Object.defineProperties(ProjectionPolarEquidistant.prototype, {
	  /**
	   * Indicates the north or south aspect. Specify "North" or "South".
	   * @memberof ProjectionPolarEquidistant.prototype
	   * @type {String}
	   */
	  pole: {
	    get: function () {
	      return this._pole;
	    },
	    set: function (pole) {
	      this._pole = pole;
	      this.north = !(this._pole === "South");
	      this._stateKey = "projection polar equidistant " + this._pole + " ";
	    }
	  },

	  /**
	   * A string identifying this projection's current state. Used to compare states during rendering to
	   * determine whether globe-state dependent cached values must be updated. Applications typically do not
	   * interact with this property.
	   * @memberof ProjectionPolarEquidistant.prototype
	   * @readonly
	   * @type {String}
	   */
	  stateKey: {
	    get: function () {
	      return this._stateKey;
	    }
	  }
	}); // Documented in base class.

	ProjectionPolarEquidistant.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionPolarEquidistant", "geographicToCartesian", "missingGlobe"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionPolarEquidistant", "geographicToCartesian", "missingResult"));
	  } // Formulae taken from "Map Projections -- A Working Manual", Snyder, USGS paper 1395, pg. 195.


	  if (this.north && latitude === 90 || !this.north && latitude === -90) {
	    result[0] = 0;
	    result[1] = 0;
	    result[2] = elevation;
	  } else {
	    var northSouthFactor = this.north ? -1 : 1,
	        a = globe.equatorialRadius * (Math.PI / 2 + latitude * Angle.DEGREES_TO_RADIANS * northSouthFactor);
	    result[0] = a * Math.sin(longitude * Angle.DEGREES_TO_RADIANS);
	    result[1] = a * Math.cos(longitude * Angle.DEGREES_TO_RADIANS) * northSouthFactor;
	    result[2] = elevation;
	  }

	  return result;
	}; // Documented in base class.


	ProjectionPolarEquidistant.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations, referencePoint, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionPolarEquidistant", "geographicToCartesianGrid", "missingGlobe"));
	  }

	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionPolarEquidistant", "geographicToCartesianGrid", "missingSector"));
	  }

	  if (!elevations || elevations.length < numLat * numLon) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionPolarEquidistant", "geographicToCartesianGrid", "The specified elevations array is null, undefined or insufficient length"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionPolarEquidistant", "geographicToCartesianGrid", "missingResult"));
	  }

	  var eqr = globe.equatorialRadius,
	      minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,
	      maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,
	      minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,
	      maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,
	      deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
	      deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
	      northSouthFactor = this.north ? -1 : 1,
	      refPoint = referencePoint ? referencePoint : new Vec3(0, 0, 0),
	      pi_2 = Math.PI / 2,
	      latIndex,
	      lonIndex,
	      elevIndex = 0,
	      resultIndex = 0,
	      cosLon = new Float64Array(numLon),
	      sinLon = new Float64Array(numLon),
	      lat,
	      lon,
	      a; // Compute and save values that are a function of each unique longitude value in the specified sector. This
	  // eliminates the need to re-compute these values for each column of constant longitude.

	  for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {
	    if (lonIndex === numLon - 1) {
	      lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
	    }

	    cosLon[lonIndex] = Math.cos(lon);
	    sinLon[lonIndex] = Math.sin(lon);
	  } // Iterate over the latitude and longitude coordinates in the specified sector, computing the Cartesian point
	  // corresponding to each latitude and longitude.


	  for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {
	    if (latIndex === numLat - 1) {
	      lat = maxLat; // explicitly set the last lat to the max latitude to ensure alignment
	    } // Latitude is constant for each row. Values that are a function of latitude can be computed once per row.


	    a = eqr * (pi_2 + lat * northSouthFactor);

	    if (this.north && lat === pi_2 || !this.north && lat === -pi_2) {
	      a = 0;
	    }

	    for (lonIndex = 0; lonIndex < numLon; lonIndex++) {
	      result[resultIndex++] = a * sinLon[lonIndex] - refPoint[0];
	      result[resultIndex++] = a * cosLon[lonIndex] * northSouthFactor - refPoint[1];
	      result[resultIndex++] = elevations[elevIndex++] - refPoint[2];
	    }
	  }

	  return result;
	}; // Documented in base class.


	ProjectionPolarEquidistant.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionPolarEquidistant", "cartesianToGeographic", "missingGlobe"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionPolarEquidistant", "cartesianToGeographic", "missingResult"));
	  } // Formulae taken from "Map Projections -- A Working Manual", Snyder, USGS paper 1395, pg. 196.


	  var rho = Math.sqrt(x * x + y * y),
	      c;

	  if (rho < 1.0e-4) {
	    result.latitude = this.north ? 90 : -90;
	    result.longitude = 0;
	    result.altitude = z;
	  } else {
	    c = rho / globe.equatorialRadius;

	    if (c > Math.PI) {
	      c = Math.PI; // map cartesian points beyond the projection's radius to the edge of the projection
	    }

	    result.latitude = Math.asin(Math.cos(c) * (this.north ? 1 : -1)) * Angle.RADIANS_TO_DEGREES;
	    result.longitude = Math.atan2(x, y * (this.north ? -1 : 1)) * Angle.RADIANS_TO_DEGREES; // use atan2(x,y) instead of atan(x/y)

	    result.altitude = z;
	  } //console.log(x + ", " + y + ", " + z + " --> " + result.toString());


	  return result;
	}; // Documented in base class.


	ProjectionPolarEquidistant.prototype.northTangentAtLocation = function (globe, latitude, longitude, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionPolarEquidistant", "northTangentAtLocation", "missingResult"));
	  } // The north pointing tangent depends on the pole. With the south pole, the north pointing tangent points in
	  // the same direction as the vector returned by cartesianToGeographic. With the north pole, the north
	  // pointing tangent has the opposite direction.


	  result[0] = Math.sin(longitude * Angle.DEGREES_TO_RADIANS) * (this.north ? -1 : 1);
	  result[1] = Math.cos(longitude * Angle.DEGREES_TO_RADIANS);
	  result[2] = 0;
	  return result;
	}; // Documented in base class.


	ProjectionPolarEquidistant.prototype.northTangentAtPoint = function (globe, x, y, z, offset, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionPolarEquidistant", "northTangentAtLocation", "missingResult"));
	  } // The north pointing tangent depends on the pole. With the south pole, the north pointing tangent points in
	  // the same direction as the vector returned by cartesianToGeographic. With the north pole, the north
	  // pointing tangent has the opposite direction.


	  var rho = Math.sqrt(x * x + y * y);

	  if (rho < 1.0e-4) {
	    result[0] = 0;
	    result[1] = 1;
	    result[2] = 0;
	  } else {
	    result[0] = x / rho * (this.north ? -1 : 1);
	    result[1] = y / rho * (this.north ? -1 : 1);
	    result[2] = 0;
	  }

	  return result;
	};

	/**
	 * @exports ProjectionUPS
	 */
	/**
	 * Constructs a Uniform Polar Stereographic geographic projection.
	 * @alias ProjectionUPS
	 * @constructor
	 * @augments GeographicProjection
	 * @classdesc Represents a Uniform Polar Stereographic geographic projection.
	 * @param {String} pole Indicates the north or south aspect. Specify "North" for the north aspect or "South"
	 * for the south aspect.
	 */

	function ProjectionUPS(pole) {
	  // Internal. Intentionally not documented.
	  this.north = !(pole === "South");
	  var limits = this.north ? new Sector(0, 90, -180, 180) : new Sector(-90, 0, -180, 180);
	  GeographicProjection.call(this, "Uniform Polar Stereographic", false, limits); // Internal. Intentionally not documented. See "pole" property accessor below for public interface.

	  this._pole = pole; // Documented in superclass.

	  this.displayName = this.north ? "North UPS" : "South UPS"; // Internal. Intentionally not documented. See "stateKey" property accessor below for public interface.

	  this._stateKey = "projection ups " + this._pole + " ";
	}

	ProjectionUPS.prototype = Object.create(GeographicProjection.prototype);
	Object.defineProperties(ProjectionUPS.prototype, {
	  /**
	   * Indicates the north or south aspect. Specify "North" or "South".
	   * @memberof ProjectionPolarEquidistant.prototype
	   * @type {String}
	   */
	  pole: {
	    get: function () {
	      return this._pole;
	    },
	    set: function (pole) {
	      this._pole = pole;
	      this.north = !(this._pole === "South");
	      this.projectionLimits = this.north ? new Sector(0, 90, -180, 180) : new Sector(-90, 0, -180, 180);
	      this._stateKey = "projection ups " + this._pole + " ";
	    }
	  },

	  /**
	   * A string identifying this projection's current state. Used to compare states during rendering to
	   * determine whether globe-state dependent cached values must be updated. Applications typically do not
	   * interact with this property.
	   * @memberof ProjectionPolarEquidistant.prototype
	   * @readonly
	   * @type {String}
	   */
	  stateKey: {
	    get: function () {
	      return this._stateKey;
	    }
	  }
	}); // Documented in base class.

	ProjectionUPS.prototype.geographicToCartesian = function (globe, latitude, longitude, elevation, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionUPS", "geographicToCartesian", "missingGlobe"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionUPS", "geographicToCartesian", "missingResult"));
	  } // Formulas taken from "Map Projections -- A Working Manual", Snyder, USGS paper 1395, pg. 161.


	  if (this.north && latitude === 90 || !this.north && latitude === -90) {
	    result[0] = 0;
	    result[1] = 0;
	    result[2] = elevation;
	  } else {
	    var poleFactor = this.north ? 1 : -1,
	        lat = latitude * Angle.DEGREES_TO_RADIANS,
	        lon = longitude * Angle.DEGREES_TO_RADIANS,
	        k0 = 0.994,
	        // standard UPS scale factor -- see above reference pg.157, pp 2.
	    ecc = Math.sqrt(globe.eccentricitySquared),
	        s = Math.sqrt(Math.pow(1 + ecc, 1 + ecc) * Math.pow(1 - ecc, 1 - ecc)),
	        sp,
	        t,
	        r;

	    if (this.north && lat < 0 || !this.north && lat > 0) {
	      lat = 0;
	    }

	    sp = Math.sin(lat * poleFactor);
	    t = Math.sqrt((1 - sp) / (1 + sp) * Math.pow((1 + ecc * sp) / (1 - ecc * sp), ecc));
	    r = 2 * globe.equatorialRadius * k0 * t / s;
	    result[0] = r * Math.sin(lon);
	    result[1] = -r * Math.cos(lon) * poleFactor;
	    result[2] = elevation;
	  }

	  return result;
	}; // Documented in base class.


	ProjectionUPS.prototype.geographicToCartesianGrid = function (globe, sector, numLat, numLon, elevations, referencePoint, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionUPS", "geographicToCartesianGrid", "missingGlobe"));
	  }

	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionUPS", "geographicToCartesianGrid", "missingSector"));
	  }

	  if (!elevations || elevations.length < numLat * numLon) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionUPS", "geographicToCartesianGrid", "The specified elevations array is null, undefined or insufficient length"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionUPS", "geographicToCartesianGrid", "missingResult"));
	  } // Formulas taken from "Map Projections -- A Working Manual", Snyder, USGS paper 1395, pg. 161.


	  var eqr = globe.equatorialRadius,
	      minLat = sector.minLatitude * Angle.DEGREES_TO_RADIANS,
	      maxLat = sector.maxLatitude * Angle.DEGREES_TO_RADIANS,
	      minLon = sector.minLongitude * Angle.DEGREES_TO_RADIANS,
	      maxLon = sector.maxLongitude * Angle.DEGREES_TO_RADIANS,
	      deltaLat = (maxLat - minLat) / (numLat > 1 ? numLat - 1 : 1),
	      deltaLon = (maxLon - minLon) / (numLon > 1 ? numLon - 1 : 1),
	      minLatLimit = this.projectionLimits.minLatitude * Angle.DEGREES_TO_RADIANS,
	      maxLatLimit = this.projectionLimits.maxLatitude * Angle.DEGREES_TO_RADIANS,
	      k0 = 0.994,
	      // standard UPS scale factor -- see above reference pg.157, pp 2.
	  ecc = Math.sqrt(globe.eccentricitySquared),
	      s = Math.sqrt(Math.pow(1 + ecc, 1 + ecc) * Math.pow(1 - ecc, 1 - ecc)),
	      poleFactor = this.north ? 1 : -1,
	      refPoint = referencePoint ? referencePoint : new Vec3$1(0, 0, 0),
	      latIndex,
	      lonIndex,
	      elevIndex = 0,
	      resultIndex = 0,
	      lat,
	      lon,
	      clampedLat,
	      sp,
	      t,
	      r; // Iterate over the latitude and longitude coordinates in the specified sector, computing the Cartesian point
	  // corresponding to each latitude and longitude.

	  for (latIndex = 0, lat = minLat; latIndex < numLat; latIndex++, lat += deltaLat) {
	    if (latIndex === numLat - 1) {
	      lat = maxLat; // explicitly set the last lat to the max latitude to ensure alignment
	    } // Latitude is constant for each row. Values that are a function of latitude can be computed once per row.


	    clampedLat = WWMath.clamp(lat, minLatLimit, maxLatLimit);
	    sp = Math.sin(clampedLat * poleFactor);
	    t = Math.sqrt((1 - sp) / (1 + sp) * Math.pow((1 + ecc * sp) / (1 - ecc * sp), ecc));
	    r = 2 * eqr * k0 * t / s;

	    for (lonIndex = 0, lon = minLon; lonIndex < numLon; lonIndex++, lon += deltaLon) {
	      if (lonIndex === numLon - 1) {
	        lon = maxLon; // explicitly set the last lon to the max longitude to ensure alignment
	      }

	      result[resultIndex++] = r * Math.sin(lon) - refPoint[0];
	      result[resultIndex++] = -r * Math.cos(lon) * poleFactor - refPoint[1];
	      result[resultIndex++] = elevations[elevIndex++] - refPoint[2];
	    }
	  }

	  return result;
	}; // Documented in base class.


	ProjectionUPS.prototype.cartesianToGeographic = function (globe, x, y, z, offset, result) {
	  if (!globe) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionUPS", "cartesianToGeographic", "missingGlobe"));
	  }

	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionUPS", "cartesianToGeographic", "missingResult"));
	  }

	  var lon = Math.atan2(x, y * (this.north ? -1 : 1)),
	      k0 = 0.994,
	      ecc = Math.sqrt(globe.eccentricitySquared),
	      r = Math.sqrt(x * x + y * y),
	      s = Math.sqrt(Math.pow(1 + ecc, 1 + ecc) * Math.pow(1 - ecc, 1 - ecc)),
	      t = r * s / (2 * globe.equatorialRadius * k0),
	      ecc2 = globe.eccentricitySquared,
	      ecc4 = ecc2 * ecc2,
	      ecc6 = ecc4 * ecc2,
	      ecc8 = ecc6 * ecc2,
	      A = Math.PI / 2 - 2 * Math.atan(t),
	      B = ecc2 / 2 + 5 * ecc4 / 24 + ecc6 / 12 + 13 * ecc8 / 360,
	      C = 7 * ecc4 / 48 + 29 * ecc6 / 240 + 811 * ecc8 / 11520,
	      D = 7 * ecc6 / 120 + 81 * ecc8 / 1120,
	      E = 4279 * ecc8 / 161280,
	      Ap = A - C + E,
	      Bp = B - 3 * D,
	      Cp = 2 * C - 8 * E,
	      Dp = 4 * D,
	      Ep = 8 * E,
	      s2p = Math.sin(2 * A),
	      lat = Ap + s2p * (Bp + s2p * (Cp + s2p * (Dp + Ep * s2p)));
	  lat *= this.north ? 1 : -1;
	  result.latitude = lat * Angle.RADIANS_TO_DEGREES;
	  result.longitude = lon * Angle.RADIANS_TO_DEGREES;
	  result.altitude = z;
	  return result;
	}; // Documented in base class.


	ProjectionUPS.prototype.northTangentAtLocation = function (globe, latitude, longitude, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionUPS", "northTangentAtLocation", "missingResult"));
	  } // The north pointing tangent depends on the pole. With the south pole, the north pointing tangent points in
	  // the same direction as the vector returned by cartesianToGeographic. With the north pole, the north
	  // pointing tangent has the opposite direction.


	  result[0] = Math.sin(longitude * Angle.DEGREES_TO_RADIANS) * (this.north ? -1 : 1);
	  result[1] = Math.cos(longitude * Angle.DEGREES_TO_RADIANS);
	  result[2] = 0;
	  return result;
	}; // Documented in base class.


	ProjectionUPS.prototype.northTangentAtPoint = function (globe, x, y, z, offset, result) {
	  if (!result) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "ProjectionPolarEquidistant", "northTangentAtLocation", "missingResult"));
	  }

	  var r = Math.sqrt(x * x + y * y);

	  if (r < 1.0e-4) {
	    result[0] = 0;
	    result[1] = 1;
	    result[2] = 0;
	  } else {
	    result[0] = x / r * (this.north ? -1 : 1);
	    result[1] = y / r * (this.north ? -1 : 1);
	    result[2] = 0;
	  }

	  return result;
	};

	var StarFieldVertex = "\r\n//.x = declination\r\n//.y = right ascension\r\n//.z = point size\r\n//.w = magnitude\r\nattribute vec4 vertexPoint;\r\n\r\nuniform mat4 mvpMatrix;\r\n// number of days (positive or negative) since Greenwich noon, Terrestrial Time,\r\n// on 1 January 2000 (J2000.0)\r\nuniform float numDays;\r\nuniform vec2 magnitudeRange;\r\n\r\nvarying float magnitudeWeight;\r\n\r\n// normalizes an angle between 0.0 and 359.0\r\nfloat normalizeAngle(float angle) {\r\n    float angleDivisions = angle / 360.0;\r\n    return 360.0 * (angleDivisions - floor(angleDivisions));\r\n}\r\n\r\n// transforms declination and right ascension in cartesian coordinates\r\nvec3 computePosition(float dec, float ra) {\r\n    float GMST = normalizeAngle(280.46061837 + 360.98564736629 * numDays);\r\n    float GHA = normalizeAngle(GMST - ra);\r\n    float lon = -GHA + 360.0 * step(180.0, GHA);\r\n    float latRad = radians(dec);\r\n    float lonRad = radians(lon);\r\n    float radCosLat = cos(latRad);\r\n    return vec3(radCosLat * sin(lonRad), sin(latRad), radCosLat * cos(lonRad));\r\n}\r\n\r\n// normalizes a value between 0.0 and 1.0\r\nfloat normalizeScalar(float value, float minValue, float maxValue){\r\n    return (value - minValue) / (maxValue - minValue);\r\n}\r\n\r\nvoid main() {\r\n    vec3 vertexPosition = computePosition(vertexPoint.x, vertexPoint.y);\r\n    gl_Position = mvpMatrix * vec4(vertexPosition.xyz, 1.0);\r\n    gl_Position.z = gl_Position.w - 0.00001;\r\n    gl_PointSize = vertexPoint.z;\r\n    magnitudeWeight = normalizeScalar(vertexPoint.w, magnitudeRange.x, magnitudeRange.y);\r\n}";

	var StarFieldFragment = "\r\nprecision mediump float;\r\n\r\nuniform sampler2D textureSampler;\r\nuniform int textureEnabled;\r\n\r\nvarying float magnitudeWeight;\r\n\r\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\r\nconst vec4 grey = vec4(0.5, 0.5, 0.5, 1.0);\r\n\r\nvoid main() {\r\n    if (textureEnabled == 1) {\r\n        gl_FragColor = texture2D(textureSampler, gl_PointCoord);\r\n    } else {\r\n        // paint the starts in shades of grey, where the brightest star is white and the dimmest star is grey\r\n        gl_FragColor = mix(white, grey, magnitudeWeight);\r\n    }\r\n}";

	/**
	 * @exports StarFieldProgram
	 */
	/**
	 * Constructs a new program.
	 * Initializes, compiles and links this GLSL program with the source code for its vertex and fragment shaders.
	 * <p>
	 * This method creates WebGL shaders for the program's shader sources and attaches them to a new GLSL program.
	 * This method then compiles the shaders and then links the program if compilation is successful.
	 * Use the bind method to make the program current during rendering.
	 *
	 * @alias StarFieldProgram
	 * @constructor
	 * @augments GpuProgram
	 * @classdesc StarFieldProgram is a GLSL program that draws points representing stars.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @throws {ArgumentError} If the shaders cannot be compiled, or linking of the compiled shaders into a program
	 * fails.
	 */

	function StarFieldProgram(gl) {
	  var vertexShaderSource = StarFieldVertex,
	      fragmentShaderSource = StarFieldFragment; // Call to the superclass, which performs shader program compiling and linking.

	  GpuProgram.call(this, gl, vertexShaderSource, fragmentShaderSource, ["vertexPoint"]);
	  /**
	   * The WebGL location for this program's 'vertexPoint' attribute.
	   * @type {Number}
	   * @readonly
	   */

	  this.vertexPointLocation = this.attributeLocation(gl, "vertexPoint");
	  /**
	   * The WebGL location for this program's 'mvpMatrix' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.mvpMatrixLocation = this.uniformLocation(gl, "mvpMatrix");
	  /**
	   * The WebGL location for this program's 'numDays' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.numDaysLocation = this.uniformLocation(gl, "numDays");
	  /**
	   * The WebGL location for this program's 'magnitudeRangeLocation' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.magnitudeRangeLocation = this.uniformLocation(gl, "magnitudeRange");
	  /**
	   * The WebGL location for this program's 'textureSampler' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.textureUnitLocation = this.uniformLocation(gl, "textureSampler");
	  /**
	   * The WebGL location for this program's 'textureEnabled' uniform.
	   * @type {WebGLUniformLocation}
	   * @readonly
	   */

	  this.textureEnabledLocation = this.uniformLocation(gl, "textureEnabled");
	}
	/**
	 * A string that uniquely identifies this program.
	 * @type {string}
	 * @readonly
	 */


	StarFieldProgram.key = "WorldWindGpuStarFieldProgram"; // Inherit from GpuProgram.

	StarFieldProgram.prototype = Object.create(GpuProgram.prototype);
	/**
	 * Loads the specified matrix as the value of this program's 'mvpMatrix' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Matrix} matrix The matrix to load.
	 * @throws {ArgumentError} If the specified matrix is null or undefined.
	 */

	StarFieldProgram.prototype.loadModelviewProjection = function (gl, matrix) {
	  if (!matrix) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "StarFieldProgram", "loadModelviewProjection", "missingMatrix"));
	  }

	  this.loadUniformMatrix(gl, matrix, this.mvpMatrixLocation);
	};
	/**
	 * Loads the specified number as the value of this program's 'numDays' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} numDays The number of days (positive or negative) since Greenwich noon, Terrestrial Time,
	 * on 1 January 2000 (J2000.0)
	 * @throws {ArgumentError} If the specified number is null or undefined.
	 */


	StarFieldProgram.prototype.loadNumDays = function (gl, numDays) {
	  if (numDays == null) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "StarFieldProgram", "loadNumDays", "missingNumDays"));
	  }

	  gl.uniform1f(this.numDaysLocation, numDays);
	};
	/**
	 * Loads the specified numbers as the value of this program's 'magnitudeRange' uniform variable.
	 *
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} minMag
	 * @param {Number} maxMag
	 * @throws {ArgumentError} If the specified numbers are null or undefined.
	 */


	StarFieldProgram.prototype.loadMagnitudeRange = function (gl, minMag, maxMag) {
	  if (minMag == null) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "StarFieldProgram", "loadMagRange", "missingMinMag"));
	  }

	  if (maxMag == null) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "StarFieldProgram", "loadMagRange", "missingMaxMag"));
	  }

	  gl.uniform2f(this.magnitudeRangeLocation, minMag, maxMag);
	};
	/**
	 * Loads the specified number as the value of this program's 'textureSampler' uniform variable.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Number} unit The texture unit.
	 */


	StarFieldProgram.prototype.loadTextureUnit = function (gl, unit) {
	  gl.uniform1i(this.textureUnitLocation, unit - gl.TEXTURE0);
	};
	/**
	 * Loads the specified boolean as the value of this program's 'textureEnabledLocation' uniform variable.
	 * @param {WebGLRenderingContext} gl The current WebGL context.
	 * @param {Boolean} value
	 */


	StarFieldProgram.prototype.loadTextureEnabled = function (gl, value) {
	  gl.uniform1i(this.textureEnabledLocation, value ? 1 : 0);
	};

	/**
	 * @exports StarFieldLayer
	 */
	/**
	 * Constructs a layer showing stars and the Sun around the Earth.
	 * If used together with the AtmosphereLayer, the StarFieldLayer must be inserted before the AtmosphereLayer.
	 *
	 * If you want to use your own star data, the file provided must be .json
	 * and the fields 'ra', 'dec' and 'vmag' must be present in the metadata.
	 * ra and dec must be expressed in degrees.
	 *
	 * This layer uses J2000.0 as the ref epoch.
	 *
	 * If the star data .json file is too big, consider enabling gzip compression on your web server.
	 * For more info about enabling gzip compression consult the configuration for your web server.
	 *
	 * @alias StarFieldLayer
	 * @constructor
	 * @classdesc Provides a layer showing stars, and the Sun around the Earth
	 * @param {URL} starDataSource optional url for the stars data
	 * @augments Layer
	 */

	function StarFieldLayer(starDataSource) {
	  Layer.call(this, 'StarField'); // The StarField Layer is not pickable.

	  this.pickEnabled = false;
	  /**
	   * The size of the Sun in pixels.
	   * This can not exceed the maximum allowed pointSize of the GPU.
	   * A warning will be given if the size is too big and the allowed max size will be used.
	   * @type {Number}
	   * @default 128
	   */

	  this.sunSize = 128;
	  /**
	   * Indicates weather to show or hide the Sun
	   * @type {Boolean}
	   * @default true
	   */

	  this.showSun = true; //Documented in defineProperties below.

	  this._starDataSource = starDataSource || WorldWind.configuration.baseUrl + 'images/stars.json';
	  this._sunImageSource = WorldWind.configuration.baseUrl + 'images/sunTexture.png'; //Internal use only.
	  //The MVP matrix of this layer.

	  this._matrix = Matrix.fromIdentity(); //Internal use only.
	  //gpu cache key for the stars vbo.

	  this._starsPositionsVboCacheKey = null; //Internal use only.

	  this._numStars = 0; //Internal use only.

	  this._starData = null; //Internal use only.

	  this._minMagnitude = Number.MAX_VALUE;
	  this._maxMagnitude = Number.MIN_VALUE; //Internal use only.
	  //A flag to indicate the star data is currently being retrieved.

	  this._loadStarted = false; //Internal use only.

	  this._minScale = 10e6; //Internal use only.

	  this._sunPositionsCacheKey = '';
	  this._sunBufferView = new Float32Array(4); //Internal use only.

	  this._MAX_GL_POINT_SIZE = 0;
	}

	StarFieldLayer.prototype = Object.create(Layer.prototype);
	Object.defineProperties(StarFieldLayer.prototype, {
	  /**
	   * Url for the stars data.
	   * @memberof StarFieldLayer.prototype
	   * @type {URL}
	   */
	  starDataSource: {
	    get: function () {
	      return this._starDataSource;
	    },
	    set: function (value) {
	      this._starDataSource = value;
	      this.invalidateStarData();
	    }
	  },

	  /**
	   * Url for the sun texture image.
	   * @memberof StarFieldLayer.prototype
	   * @type {URL}
	   */
	  sunImageSource: {
	    get: function () {
	      return this._sunImageSource;
	    },
	    set: function (value) {
	      this._sunImageSource = value;
	    }
	  }
	}); // Documented in superclass.

	StarFieldLayer.prototype.doRender = function (dc) {
	  if (dc.globe.is2D()) {
	    return;
	  }

	  if (!this.haveResources(dc)) {
	    this.loadResources(dc);
	    return;
	  }

	  this.beginRendering(dc);

	  try {
	    this.doDraw(dc);
	  } finally {
	    this.endRendering(dc);
	  }
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.haveResources = function (dc) {
	  var sunTexture = dc.gpuResourceCache.resourceForKey(this._sunImageSource);
	  return this._starData != null && sunTexture != null;
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.loadResources = function (dc) {
	  var gl = dc.currentGlContext;
	  var gpuResourceCache = dc.gpuResourceCache;

	  if (!this._starData) {
	    this.fetchStarData();
	  }

	  var sunTexture = gpuResourceCache.resourceForKey(this._sunImageSource);

	  if (!sunTexture) {
	    gpuResourceCache.retrieveTexture(gl, this._sunImageSource);
	  }
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.beginRendering = function (dc) {
	  var gl = dc.currentGlContext;
	  dc.findAndBindProgram(StarFieldProgram);
	  gl.enableVertexAttribArray(0);
	  gl.depthMask(false);
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.doDraw = function (dc) {
	  this.loadCommonUniforms(dc);
	  this.renderStars(dc);

	  if (this.showSun) {
	    this.renderSun(dc);
	  }
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.loadCommonUniforms = function (dc) {
	  var gl = dc.currentGlContext;
	  var program = dc.currentProgram;
	  var eyePoint = dc.eyePoint;
	  var eyePosition = dc.globe.computePositionFromPoint(eyePoint[0], eyePoint[1], eyePoint[2], {});
	  var scale = Math.max(eyePosition.altitude * 1.5, this._minScale);

	  this._matrix.copy(dc.modelviewProjection);

	  this._matrix.multiplyByScale(scale, scale, scale);

	  program.loadModelviewProjection(gl, this._matrix); //this subtraction does not work properly on the GPU, it must be done on the CPU
	  //possibly due to precision loss
	  //number of days (positive or negative) since Greenwich noon, Terrestrial Time, on 1 January 2000 (J2000.0)

	  var julianDate = SunPosition.computeJulianDate(this.time || new Date());
	  program.loadNumDays(gl, julianDate - 2451545.0);
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.renderStars = function (dc) {
	  var gl = dc.currentGlContext;
	  var gpuResourceCache = dc.gpuResourceCache;
	  var program = dc.currentProgram;

	  if (!this._starsPositionsVboCacheKey) {
	    this._starsPositionsVboCacheKey = gpuResourceCache.generateCacheKey();
	  }

	  var vboId = gpuResourceCache.resourceForKey(this._starsPositionsVboCacheKey);

	  if (!vboId) {
	    vboId = gl.createBuffer();
	    var positions = this.createStarsGeometry();
	    gpuResourceCache.putResource(this._starsPositionsVboCacheKey, vboId, positions.length * 4);
	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
	  } else {
	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	  }

	  dc.frameStatistics.incrementVboLoadCount(1);
	  gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);
	  program.loadMagnitudeRange(gl, this._minMagnitude, this._maxMagnitude);
	  program.loadTextureEnabled(gl, false);
	  gl.drawArrays(gl.POINTS, 0, this._numStars);
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.renderSun = function (dc) {
	  var gl = dc.currentGlContext;
	  var program = dc.currentProgram;
	  var gpuResourceCache = dc.gpuResourceCache;

	  if (!this._MAX_GL_POINT_SIZE) {
	    this._MAX_GL_POINT_SIZE = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE)[1];
	  }

	  if (this.sunSize > this._MAX_GL_POINT_SIZE) {
	    Logger$1.log(Logger$1.LEVEL_WARNING, 'StarFieldLayer - sunSize is to big, max size allowed is: ' + this._MAX_GL_POINT_SIZE);
	  }

	  var sunCelestialLocation = SunPosition.getAsCelestialLocation(this.time || new Date()); //.x = declination
	  //.y = right ascension
	  //.z = point size
	  //.w = magnitude

	  this._sunBufferView[0] = sunCelestialLocation.declination;
	  this._sunBufferView[1] = sunCelestialLocation.rightAscension;
	  this._sunBufferView[2] = Math.min(this.sunSize, this._MAX_GL_POINT_SIZE);
	  this._sunBufferView[3] = 1;

	  if (!this._sunPositionsCacheKey) {
	    this._sunPositionsCacheKey = gpuResourceCache.generateCacheKey();
	  }

	  var vboId = gpuResourceCache.resourceForKey(this._sunPositionsCacheKey);

	  if (!vboId) {
	    vboId = gl.createBuffer();
	    gpuResourceCache.putResource(this._sunPositionsCacheKey, vboId, this._sunBufferView.length * 4);
	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	    gl.bufferData(gl.ARRAY_BUFFER, this._sunBufferView, gl.DYNAMIC_DRAW);
	  } else {
	    gl.bindBuffer(gl.ARRAY_BUFFER, vboId);
	    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._sunBufferView);
	  }

	  dc.frameStatistics.incrementVboLoadCount(1);
	  gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);
	  program.loadTextureEnabled(gl, true);
	  var sunTexture = dc.gpuResourceCache.resourceForKey(this._sunImageSource);
	  sunTexture.bind(dc);
	  gl.drawArrays(gl.POINTS, 0, 1);
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.endRendering = function (dc) {
	  var gl = dc.currentGlContext;
	  gl.depthMask(true);
	  gl.disableVertexAttribArray(0);
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.fetchStarData = function () {
	  if (this._loadStarted) {
	    return;
	  }

	  this._loadStarted = true;
	  var self = this;
	  var xhr = new XMLHttpRequest();

	  xhr.onload = function () {
	    if (this.status >= 200 && this.status < 300) {
	      try {
	        self._starData = JSON.parse(this.response);
	        self.sendRedrawRequest();
	      } catch (e) {
	        Logger$1.log(Logger$1.LEVEL_SEVERE, 'StarFieldLayer unable to parse JSON for star data ' + e.toString());
	      }
	    } else {
	      Logger$1.log(Logger$1.LEVEL_SEVERE, 'StarFieldLayer unable to fetch star data. Status: ' + this.status + ' ' + this.statusText);
	    }

	    self._loadStarted = false;
	  };

	  xhr.onerror = function () {
	    Logger$1.log(Logger$1.LEVEL_SEVERE, 'StarFieldLayer unable to fetch star data');
	    self._loadStarted = false;
	  };

	  xhr.ontimeout = function () {
	    Logger$1.log(Logger$1.LEVEL_SEVERE, 'StarFieldLayer fetch star data has timeout');
	    self._loadStarted = false;
	  };

	  xhr.open('GET', this._starDataSource, true);
	  xhr.send();
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.createStarsGeometry = function () {
	  var indexes = this.parseStarsMetadata(this._starData.metadata);

	  if (indexes.raIndex === -1) {
	    throw new Error(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, 'StarFieldLayer', 'createStarsGeometry', 'Missing ra field in star data.'));
	  }

	  if (indexes.decIndex === -1) {
	    throw new Error(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, 'StarFieldLayer', 'createStarsGeometry', 'Missing dec field in star data.'));
	  }

	  if (indexes.magIndex === -1) {
	    throw new Error(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, 'StarFieldLayer', 'createStarsGeometry', 'Missing vmag field in star data.'));
	  }

	  var data = this._starData.data;
	  var positions = [];
	  this._minMagnitude = Number.MAX_VALUE;
	  this._maxMagnitude = Number.MIN_VALUE;

	  for (var i = 0, len = data.length; i < len; i++) {
	    var starInfo = data[i];
	    var declination = starInfo[indexes.decIndex]; //for latitude

	    var rightAscension = starInfo[indexes.raIndex]; //for longitude

	    var magnitude = starInfo[indexes.magIndex];
	    var pointSize = magnitude < 2 ? 2 : 1;
	    positions.push(declination, rightAscension, pointSize, magnitude);
	    this._minMagnitude = Math.min(this._minMagnitude, magnitude);
	    this._maxMagnitude = Math.max(this._maxMagnitude, magnitude);
	  }

	  this._numStars = Math.floor(positions.length / 4);
	  return positions;
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.parseStarsMetadata = function (metadata) {
	  var raIndex = -1,
	      decIndex = -1,
	      magIndex = -1;

	  for (var i = 0, len = metadata.length; i < len; i++) {
	    var starMetaInfo = metadata[i];

	    if (starMetaInfo.name === 'ra') {
	      raIndex = i;
	    }

	    if (starMetaInfo.name === 'dec') {
	      decIndex = i;
	    }

	    if (starMetaInfo.name === 'vmag') {
	      magIndex = i;
	    }
	  }

	  return {
	    raIndex: raIndex,
	    decIndex: decIndex,
	    magIndex: magIndex
	  };
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.invalidateStarData = function () {
	  this._starData = null;
	  this._starsPositionsVboCacheKey = null;
	}; // Internal. Intentionally not documented.


	StarFieldLayer.prototype.sendRedrawRequest = function () {
	  var e = document.createEvent('Event');
	  e.initEvent(WorldWind.REDRAW_EVENT_TYPE, true, true);
	  window.dispatchEvent(e);
	};

	/**
	 * @exports SurfaceTile
	 */
	/**
	 * Constructs a surface tile for a specified sector.
	 * @alias SurfaceTile
	 * @constructor
	 * @classdesc Defines an abstract base class for imagery to be rendered on terrain. Applications typically
	 * do not interact with this class.
	 * @param {Sector} sector The sector of this surface tile.
	 * @throws {ArgumentError} If the specified sector is null or undefined.
	 */

	function SurfaceTile(sector) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceTile", "constructor", "missingSector"));
	  }
	  /**
	   * The sector spanned by this surface tile.
	   * @type {Sector}
	   */


	  this.sector = sector;
	}
	/**
	 * Causes this surface tile to be active, typically by binding the tile's texture in WebGL.
	 * Subclasses must override this function.
	 * @param {DrawContext} dc The current draw context.
	 * @returns {Boolean} true if the resource was successfully bound, otherwise false.
	 */


	SurfaceTile.prototype.bind = function (dc) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceTile", "bind", "abstractInvocation"));
	};
	/**
	 * Applies this surface tile's internal transform, typically a texture transform to align the associated
	 * resource with the terrain.
	 * Subclasses must override this function.
	 * @param {DrawContext} dc The current draw context.
	 * @param {Matrix} matrix The transform to apply.
	 */


	SurfaceTile.prototype.applyInternalTransform = function (dc, matrix) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceTile", "applyInternalTransform", "abstractInvocation"));
	};

	/**
	 * @exports SurfaceImage
	 */
	/**
	 * Constructs a surface image shape for a specified sector and image path.
	 * @alias SurfaceImage
	 * @constructor
	 * @augments SurfaceTile
	 * @classdesc Represents an image drawn on the terrain.
	 * @param {Sector} sector The sector spanned by this surface image.
	 * @param {String|ImageSource} imageSource The image source of the image to draw on the terrain.
	 * May be either a string identifying the URL of the image, or an {@link ImageSource} object identifying a
	 * dynamically created image.
	 * @throws {ArgumentError} If either the specified sector or image source is null or undefined.
	 */

	function SurfaceImage(sector, imageSource) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceImage", "constructor", "missingSector"));
	  }

	  if (!imageSource) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceImage", "constructor", "missingImage"));
	  }

	  SurfaceTile.call(this, sector);
	  /**
	   * Indicates whether this surface image is drawn.
	   * @type {boolean}
	   * @default true
	   */

	  this.enabled = true;
	  /**
	   * The path to the image.
	   * @type {String}
	   */

	  this._imageSource = imageSource;
	  /**
	   * This surface image's resampling mode. Indicates the sampling algorithm used to display this image when it
	   * is larger on screen than its native resolution. May be one of:
	   * <ul>
	   *  <li>WorldWind.FILTER_LINEAR</li>
	   *  <li>WorldWind.FILTER_NEAREST</li>
	   * </ul>
	   * @default WorldWind.FILTER_LINEAR
	   */

	  this.resamplingMode = WorldWind.FILTER_LINEAR;
	  /**
	   * This surface image's opacity. When this surface image is drawn, the actual opacity is the product of
	   * this opacity and the opacity of the layer containing this surface image.
	   * @type {number}
	   */

	  this.opacity = 1;
	  /**
	   * This surface image's display name;
	   * @type {string}
	   */

	  this.displayName = "Surface Image"; // Internal. Indicates whether the image needs to be updated in the GPU resource cache.

	  this.imageSourceWasUpdated = true;
	}

	SurfaceImage.prototype = Object.create(SurfaceTile.prototype);
	Object.defineProperties(SurfaceImage.prototype, {
	  /**
	   * The source of the image to display.
	   * May be either a string identifying the URL of the image, or an {@link ImageSource} object identifying a
	   * dynamically created image.
	   * @type {String|ImageSource}
	   * @default null
	   * @memberof SurfaceImage.prototype
	   */
	  imageSource: {
	    get: function () {
	      return this._imageSource;
	    },
	    set: function (imageSource) {
	      if (!imageSource) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceImage", "imageSource", "missingImage"));
	      }

	      this._imageSource = imageSource;
	      this.imageSourceWasUpdated = true;
	    }
	  }
	});

	SurfaceImage.prototype.bind = function (dc) {
	  var texture = dc.gpuResourceCache.resourceForKey(this._imageSource);

	  if (texture && !this.imageSourceWasUpdated) {
	    return this.bindTexture(dc, texture);
	  } else {
	    texture = dc.gpuResourceCache.retrieveTexture(dc.currentGlContext, this._imageSource);
	    this.imageSourceWasUpdated = false;

	    if (texture) {
	      return this.bindTexture(dc, texture);
	    }
	  }
	};

	SurfaceImage.prototype.bindTexture = function (dc, texture) {
	  var gl = dc.currentGlContext;
	  texture.setTexParameter(gl.TEXTURE_MAG_FILTER, this.resamplingMode === WorldWind.FILTER_NEAREST ? gl.NEAREST : gl.LINEAR);
	  return texture.bind(dc);
	};

	SurfaceImage.prototype.applyInternalTransform = function (dc, matrix) {// No need to apply the transform.
	};
	/**
	 * Displays this surface image. Called by the layer containing this surface image.
	 * @param {DrawContext} dc The current draw context.
	 */


	SurfaceImage.prototype.render = function (dc) {
	  if (!this.enabled) {
	    return;
	  }

	  if (!dc.terrain) {
	    return;
	  }

	  if (!this.sector.overlaps(dc.terrain.sector)) {
	    return;
	  }

	  if (dc.pickingMode) {
	    this.pickColor = dc.uniquePickColor();
	  }

	  dc.surfaceTileRenderer.renderTiles(dc, [this], this.opacity * dc.currentLayer.opacity);

	  if (dc.pickingMode) {
	    var po = new PickedObject(this.pickColor.clone(), this.pickDelegate ? this.pickDelegate : this, null, this.layer, false);
	    dc.resolvePick(po);
	  }

	  dc.currentLayer.inCurrentFrame = true;
	};

	/**
	 * @exports SurfaceCircle
	 */
	/**
	 * Constructs a surface circle with a specified center and radius and an optional attributes bundle.
	 * @alias SurfaceCircle
	 * @constructor
	 * @augments SurfaceShape
	 * @classdesc Represents a circle draped over the terrain surface.
	 * <p>
	 *     SurfaceCircle uses the following attributes from its associated shape attributes bundle:
	 *     <ul>
	 *         <li>Draw interior</li>
	 *         <li>Draw outline</li>
	 *         <li>Interior color</li>
	 *         <li>Outline color</li>
	 *         <li>Outline width</li>
	 *         <li>Outline stipple factor</li>
	 *         <li>Outline stipple pattern</li>
	 *     </ul>
	 * @param {Location} center The circle's center location.
	 * @param {Number} radius The circle's radius in meters.
	 * @param {ShapeAttributes} attributes The attributes to apply to this shape. May be null, in which case
	 * attributes must be set directly before the shape is drawn.
	 * @throws {ArgumentError} If the specified center location is null or undefined or the specified radius
	 * is negative.
	 */

	function SurfaceCircle(center, radius, attributes) {
	  if (!center) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceCircle", "constructor", "missingLocation"));
	  }

	  if (radius < 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceCircle", "constructor", "Radius is negative"));
	  }

	  SurfaceShape.call(this, attributes); // All these are documented with their property accessors below.

	  this._center = center;
	  this._radius = radius;
	  this._intervals = SurfaceCircle.DEFAULT_NUM_INTERVALS;
	}

	SurfaceCircle.prototype = Object.create(SurfaceShape.prototype);
	Object.defineProperties(SurfaceCircle.prototype, {
	  /**
	   * This shape's center location.
	   * @memberof SurfaceCircle.prototype
	   * @type {Location}
	   */
	  center: {
	    get: function () {
	      return this._center;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._center = value;
	    }
	  },

	  /**
	   * This shape's radius, in meters.
	   * @memberof SurfaceCircle.prototype
	   * @type {Number}
	   */
	  radius: {
	    get: function () {
	      return this._radius;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._radius = value;
	    }
	  },

	  /**
	   * The number of intervals to generate locations for.
	   * @type {Number}
	   * @memberof SurfaceCircle.prototype
	   * @default SurfaceCircle.DEFAULT_NUM_INTERVALS
	   */
	  intervals: {
	    get: function () {
	      return this._intervals;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._intervals = value;
	    }
	  }
	}); // Internal use only. Intentionally not documented.

	SurfaceCircle.staticStateKey = function (shape) {
	  var shapeStateKey = SurfaceShape.staticStateKey(shape);
	  return shapeStateKey + " ce " + shape.center.toString() + " ra " + shape.radius.toString();
	}; // Internal use only. Intentionally not documented.


	SurfaceCircle.prototype.computeStateKey = function () {
	  return SurfaceCircle.staticStateKey(this);
	}; // Internal. Intentionally not documented.


	SurfaceCircle.prototype.computeBoundaries = function (dc) {
	  if (this.radius === 0) {
	    return null;
	  }

	  var numLocations = 1 + Math.max(SurfaceCircle.MIN_NUM_INTERVALS, this.intervals),
	      da = 360 / (numLocations - 1),
	      arcLength = this.radius / dc.globe.radiusAt(this.center.latitude, this.center.longitude);
	  this._boundaries = new Array(numLocations);

	  for (var i = 0; i < numLocations; i++) {
	    var azimuth = i !== numLocations - 1 ? i * da : 0;
	    this._boundaries[i] = Location.greatCircleLocation(this.center, azimuth, // In degrees
	    arcLength, // In radians
	    new Location(0, 0));
	  }
	}; // Internal use only. Intentionally not documented.


	SurfaceCircle.prototype.getReferencePosition = function () {
	  return this.center;
	}; // Internal use only. Intentionally not documented.


	SurfaceCircle.prototype.moveTo = function (globe, position) {
	  this.center = position;
	};
	/**
	 * The minimum number of intervals the circle generates.
	 * @type {Number}
	 */


	SurfaceCircle.MIN_NUM_INTERVALS = 8;
	/**
	 * The default number of intervals the circle generates.
	 * @type {Number}
	 */

	SurfaceCircle.DEFAULT_NUM_INTERVALS = 64;

	/**
	 * @exports SurfaceEllipse
	 */
	/**
	 * Constructs a surface ellipse with a specified center and radii and an optional attributes bundle.
	 * @alias SurfaceEllipse
	 * @constructor
	 * @augments SurfaceShape
	 * @classdesc Represents an ellipse draped over the terrain surface.
	 * <p>
	 * SurfaceEllipse uses the following attributes from its associated shape attributes bundle:
	 * <ul>
	 *         <li>Draw interior</li>
	 *         <li>Draw outline</li>
	 *         <li>Interior color</li>
	 *         <li>Outline color</li>
	 *         <li>Outline width</li>
	 *         <li>Outline stipple factor</li>
	 *         <li>Outline stipple pattern</li>
	 * </ul>
	 * @param {Location} center The ellipse's center location.
	 * @param {Number} majorRadius The ellipse's major radius in meters.
	 * @param {Number} minorRadius The ellipse's minor radius in meters.
	 * @param {Number} heading The heading of the major axis in degrees.
	 * @param {ShapeAttributes} attributes The attributes to apply to this shape. May be null, in which case
	 * attributes must be set directly before the shape is drawn.
	 * @throws {ArgumentError} If the specified center location is null or undefined or if either specified radii
	 * is negative.
	 */

	function SurfaceEllipse(center, majorRadius, minorRadius, heading, attributes) {
	  if (!center) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceEllipse", "constructor", "missingLocation"));
	  }

	  if (majorRadius < 0 || minorRadius < 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceEllipse", "constructor", "Radius is negative."));
	  }

	  SurfaceShape.call(this, attributes); // All these are documented with their property accessors below.

	  this._center = center;
	  this._majorRadius = majorRadius;
	  this._minorRadius = minorRadius;
	  this._heading = heading;
	  this._intervals = SurfaceEllipse.DEFAULT_NUM_INTERVALS;
	}

	SurfaceEllipse.prototype = Object.create(SurfaceShape.prototype);
	Object.defineProperties(SurfaceEllipse.prototype, {
	  /**
	   * This shape's center location.
	   * @memberof SurfaceEllipse.prototype
	   * @type {Location}
	   */
	  center: {
	    get: function () {
	      return this._center;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._center = value;
	    }
	  },

	  /**
	   * This shape's major radius, in meters.
	   * @memberof SurfaceEllipse.prototype
	   * @type {Number}
	   */
	  majorRadius: {
	    get: function () {
	      return this._majorRadius;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._majorRadius = value;
	    }
	  },

	  /**
	   * This shape's minor radius in meters.
	   * @memberof SurfaceEllipse.prototype
	   * @type {Number}
	   */
	  minorRadius: {
	    get: function () {
	      return this._minorRadius;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._minorRadius = value;
	    }
	  },

	  /**
	   * The heading of the major axis, specified as degrees clockwise from North.
	   * @type {Number}
	   * @memberof SurfaceEllipse.prototype
	   * @default 0
	   */
	  heading: {
	    get: function () {
	      return this._heading;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._heading = value;
	    }
	  },

	  /**
	   * The number of intervals to generate locations for.
	   * @type {Number}
	   * @memberof SurfaceEllipse.prototype
	   * @default SurfaceEllipse.DEFAULT_NUM_INTERVALS
	   */
	  intervals: {
	    get: function () {
	      return this._intervals;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._intervals = value;
	    }
	  }
	}); // Internal use only. Intentionally not documented.

	SurfaceEllipse.staticStateKey = function (shape) {
	  var shapeStateKey = SurfaceShape.staticStateKey(shape);
	  return shapeStateKey + " ce " + shape.center.toString() + " ma " + shape.majorRadius.toString() + " mi " + shape.minorRadius.toString() + " he " + shape.heading.toString() + " in " + shape.intervals.toString();
	}; // Internal use only. Intentionally not documented.


	SurfaceEllipse.prototype.computeStateKey = function () {
	  return SurfaceEllipse.staticStateKey(this);
	}; // Internal. Intentionally not documented.


	SurfaceEllipse.prototype.computeBoundaries = function (dc) {
	  if (this.majorRadius == 0 && this.minorRadius == 0) {
	    return null;
	  }

	  var globe = dc.globe,
	      numLocations = 1 + Math.max(SurfaceEllipse.MIN_NUM_INTERVALS, this.intervals),
	      da = 2 * Math.PI / (numLocations - 1),
	      globeRadius = globe.radiusAt(this.center.latitude, this.center.longitude);
	  this._boundaries = new Array(numLocations);

	  for (var i = 0; i < numLocations; i++) {
	    var angle = i != numLocations - 1 ? i * da : 0,
	        xLength = this.majorRadius * Math.cos(angle),
	        yLength = this.minorRadius * Math.sin(angle),
	        distance = Math.sqrt(xLength * xLength + yLength * yLength); // azimuth runs positive clockwise from north and through 360 degrees.

	    var azimuth = Math.PI / 2.0 - (Math.acos(xLength / distance) * WWMath.signum(yLength) - this.heading * Angle.DEGREES_TO_RADIANS);
	    this._boundaries[i] = Location.greatCircleLocation(this.center, azimuth * Angle.RADIANS_TO_DEGREES, distance / globeRadius, new Location(0, 0));
	  }
	}; // Internal use only. Intentionally not documented.


	SurfaceEllipse.prototype.getReferencePosition = function () {
	  return this.center;
	}; // Internal use only. Intentionally not documented.


	SurfaceEllipse.prototype.moveTo = function (globe, position) {
	  this.center = position;
	};
	/**
	 * The minimum number of intervals the ellipse generates.
	 * @type {Number}
	 */


	SurfaceEllipse.MIN_NUM_INTERVALS = 8;
	/**
	 * The default number of intervals the ellipse generates.
	 * @type {Number}
	 */

	SurfaceEllipse.DEFAULT_NUM_INTERVALS = 64;

	/**
	 * @exports SurfaceRectangle
	 */
	/**
	 * Constructs a surface rectangle with a specified center and size and an optional attributes bundle.
	 * @alias SurfaceRectangle
	 * @constructor
	 * @augments SurfaceShape
	 * @classdesc Represents a rectangle draped over the terrain surface.
	 * <p>
	 * SurfaceRectangle uses the following attributes from its associated shape attributes bundle:
	 * <ul>
	 *         <li>Draw interior</li>
	 *         <li>Draw outline</li>
	 *         <li>Interior color</li>
	 *         <li>Outline color</li>
	 *         <li>Outline width</li>
	 *         <li>Outline stipple factor</li>
	 *         <li>Outline stipple pattern</li>
	 * </ul>
	 * @param {Location} center The rectangle's center location.
	 * @param {Number} width The rectangle's width in meters.
	 * @param {Number} height The rectangle's height in meters.
	 * @param {Number} heading The rectangle's heading.
	 * @param {ShapeAttributes} attributes The attributes to apply to this shape. May be null, in which case
	 * attributes must be set directly before the shape is drawn.
	 * @throws {ArgumentError} If the specified center location is null or undefined or if either specified width
	 * or height is negative.
	 */

	function SurfaceRectangle(center, width, height, heading, attributes) {
	  if (!center) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceRectangle", "constructor", "missingLocation"));
	  }

	  if (width < 0 || height < 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceRectangle", "constructor", "Size is negative."));
	  }

	  SurfaceShape.call(this, attributes); // All these are documented with their property accessors below.

	  this._center = center;
	  this._width = width;
	  this._height = height;
	  this._heading = heading;
	}

	SurfaceRectangle.prototype = Object.create(SurfaceShape.prototype);
	Object.defineProperties(SurfaceRectangle.prototype, {
	  /**
	   * This shape's center location.
	   * @memberof SurfaceRectangle.prototype
	   * @type {Location}
	   */
	  center: {
	    get: function () {
	      return this._center;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._center = value;
	    }
	  },

	  /**
	   * This shape's width, in meters.
	   * @memberof SurfaceRectangle.prototype
	   * @type {Number}
	   */
	  width: {
	    get: function () {
	      return this._width;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._width = value;
	    }
	  },

	  /**
	   * This shape's height in meters.
	   * @memberof SurfaceRectangle.prototype
	   * @type {Number}
	   */
	  height: {
	    get: function () {
	      return this._height;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._height = value;
	    }
	  },

	  /**
	   * The shape's heading, specified as degrees clockwise from North. This shape's height and width are
	   * relative to its heading.
	   * @memberof SurfaceRectangle.prototype
	   * @type {number}
	   * @default 0
	   */
	  heading: {
	    get: function () {
	      return this._heading;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._heading = value;
	    }
	  }
	}); // Internal use only. Intentionally not documented.

	SurfaceRectangle.staticStateKey = function (shape) {
	  var shapeStateKey = SurfaceShape.staticStateKey(shape);
	  return shapeStateKey + " ce " + shape.center.toString() + " wi " + shape.width.toString() + " he " + shape.height.toString() + " hd " + shape.heading.toString();
	}; // Internal use only. Intentionally not documented.


	SurfaceRectangle.prototype.computeStateKey = function () {
	  return SurfaceRectangle.staticStateKey(this);
	}; // Internal. Intentionally not documented.


	SurfaceRectangle.prototype.computeBoundaries = function (dc) {
	  var halfWidth = 0.5 * this.width,
	      halfHeight = 0.5 * this.height,
	      globeRadius = dc.globe.radiusAt(this.center.latitude, this.center.longitude);
	  this._boundaries = new Array(4);
	  this.addLocation(0, -halfWidth, -halfHeight, globeRadius);
	  this.addLocation(1, halfWidth, -halfHeight, globeRadius);
	  this.addLocation(2, halfWidth, halfHeight, globeRadius);
	  this.addLocation(3, -halfWidth, halfHeight, globeRadius);
	};

	SurfaceRectangle.prototype.addLocation = function (idx, xLength, yLength, globeRadius) {
	  var distance = Math.sqrt(xLength * xLength + yLength * yLength); // azimuth runs positive clockwise from north and through 360 degrees.

	  var azimuth = Math.PI / 2.0 - (Math.acos(xLength / distance) * WWMath.signum(yLength) - this.heading * Angle.DEGREES_TO_RADIANS);
	  this._boundaries[idx] = Location.greatCircleLocation(this.center, azimuth * Angle.RADIANS_TO_DEGREES, distance / globeRadius, new Location(0, 0));
	}; // Internal use only. Intentionally not documented.


	SurfaceRectangle.prototype.getReferencePosition = function () {
	  return this.center;
	}; // Internal use only. Intentionally not documented.


	SurfaceRectangle.prototype.moveTo = function (globe, position) {
	  this.center = this.computeShiftedLocations(globe, this.getReferencePosition(), position, [this.center])[0];
	};

	/**
	 * @exports SurfaceRenderable
	 */
	/**
	 * Applications must not call this constructor. It is an interface class and is not meant to be instantiated
	 * directly.
	 * @alias SurfaceRenderable
	 * @constructor
	 * @classdesc Represents a surface renderable.
	 * This is an interface class and is not meant to be instantiated directly.
	 */

	function SurfaceRenderable() {
	  /**
	   * This surface renderable's display name.
	   * @type {String}
	   * @default Renderable
	   */
	  this.displayName = "Renderable";
	  /**
	   * Indicates whether this surface renderable is enabled.
	   * @type {Boolean}
	   * @default true
	   */

	  this.enabled = true;
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceRenderable", "constructor", "abstractInvocation"));
	}
	/**
	 * Renders this surface renderable.
	 * @param {DrawContext} dc The current draw context.
	 */


	SurfaceRenderable.prototype.renderSurface = function (dc) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceRenderable", "renderSurface", "abstractInvocation"));
	};

	/**
	 * @exports SurfaceSector
	 */
	/**
	 * Constructs a surface sector.
	 * @alias SurfaceSector
	 * @constructor
	 * @augments SurfaceShape
	 * @classdesc Represents a sector draped over the terrain surface. The sector is specified as a rectangular
	 * region in geographic coordinates. By default, a surface sector is drawn with a linear path, see
	 * {@link SurfaceShape#pathType}.
	 * <p>
	 * SurfaceSector uses the following attributes from its associated shape attributes bundle:
	 * <ul>
	 *         <li>Draw interior</li>
	 *         <li>Draw outline</li>
	 *         <li>Interior color</li>
	 *         <li>Outline color</li>
	 *         <li>Outline width</li>
	 *         <li>Outline stipple factor</li>
	 *         <li>Outline stipple pattern</li>
	 * </ul>
	 * @param {Sector} sector This surface sector's sector.
	 * @param {ShapeAttributes} attributes The attributes to apply to this shape. May be null, in which case
	 * attributes must be set directly before the shape is drawn.
	 * @throws {ArgumentError} If the specified boundaries are null or undefined.
	 */

	function SurfaceSector(sector, attributes) {
	  if (!sector) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "SurfaceSector", "constructor", "missingSector"));
	  }

	  SurfaceShape.call(this, attributes);
	  /**
	   * This shape's sector.
	   * @type {Sector}
	   */

	  this._sector = sector; // The default path type for a surface sector is linear so that it represents a bounding box by default.

	  this._pathType = WorldWind.LINEAR;
	}

	SurfaceSector.prototype = Object.create(SurfaceShape.prototype);
	Object.defineProperties(SurfaceSector.prototype, {
	  /**
	   * This shape's sector.
	   * @memberof SurfaceSector.prototype
	   * @type {Sector}
	   */
	  sector: {
	    get: function () {
	      return this._sector;
	    },
	    set: function (value) {
	      this.stateKeyInvalid = true;
	      this.resetBoundaries();
	      this._sector = value;
	    }
	  }
	}); // Internal use only. Intentionally not documented.

	SurfaceSector.staticStateKey = function (shape) {
	  var shapeStateKey = SurfaceShape.staticStateKey(shape);
	  return shapeStateKey;
	}; // Internal use only. Intentionally not documented.


	SurfaceSector.prototype.computeStateKey = function () {
	  return SurfaceSector.staticStateKey(this);
	}; // Internal. Intentionally not documented.


	SurfaceSector.prototype.computeBoundaries = function (dc) {
	  var sector = this._sector;
	  this._boundaries = new Array(4);
	  this._boundaries[0] = new Location(sector.minLatitude, sector.minLongitude);
	  this._boundaries[1] = new Location(sector.maxLatitude, sector.minLongitude);
	  this._boundaries[2] = new Location(sector.maxLatitude, sector.maxLongitude);
	  this._boundaries[3] = new Location(sector.minLatitude, sector.maxLongitude);
	}; // Internal use only. Intentionally not documented.


	SurfaceSector.prototype.getReferencePosition = function () {
	  return new Location(this.sector.centroidLatitude(), this.sector.centroidLongitude());
	}; // Internal use only. Intentionally not documented.


	SurfaceSector.prototype.moveTo = function (globe, position) {
	  var sector = this._sector;
	  var locations = new Array(3);
	  locations[0] = new Location(sector.minLatitude, sector.minLongitude);
	  locations[1] = new Location(sector.maxLatitude, sector.minLongitude);
	  locations[2] = new Location(sector.maxLatitude, sector.maxLongitude);
	  locations = this.computeShiftedLocations(globe, this.getReferencePosition(), position, locations);
	  this.sector = new WorldWind.Sector(locations[0].latitude, locations[1].latitude, locations[1].longitude, locations[2].longitude);
	};

	/**
	 * @exports TapRecognizer
	 */
	/**
	 * Constructs a tap gesture recognizer.
	 * @alias TapRecognizer
	 * @constructor
	 * @augments GestureRecognizer
	 * @classdesc A concrete gesture recognizer subclass that looks for single or multiple taps.
	 * @param {EventTarget} target The document element this gesture recognizer observes for mouse and touch events.
	 * @param {Function} callback An optional function to call when this gesture is recognized. If non-null, the
	 * function is called when this gesture is recognized, and is passed a single argument: this gesture recognizer,
	 * e.g., <code>gestureCallback(recognizer)</code>.
	 * @throws {ArgumentError} If the specified target is null or undefined.
	 */

	function TapRecognizer(target, callback) {
	  GestureRecognizer.call(this, target, callback);
	  /**
	   *
	   * @type {Number}
	   */

	  this.numberOfTaps = 1;
	  /**
	   *
	   * @type {Number}
	   */

	  this.numberOfTouches = 1; // Intentionally not documented.

	  this.maxTouchMovement = 20; // Intentionally not documented.

	  this.maxTapDuration = 500; // Intentionally not documented.

	  this.maxTapInterval = 400; // Intentionally not documented.

	  this.taps = []; // Intentionally not documented.

	  this.timeout = null;
	}

	TapRecognizer.prototype = Object.create(GestureRecognizer.prototype); // Documented in superclass.

	TapRecognizer.prototype.reset = function () {
	  GestureRecognizer.prototype.reset.call(this);
	  this.taps = [];
	  this.cancelFailAfterDelay();
	}; // Documented in superclass.


	TapRecognizer.prototype.mouseDown = function (event) {
	  if (this.state != WorldWind.POSSIBLE) {
	    return;
	  }

	  this.state = WorldWind.FAILED; // touch gestures fail upon receiving a mouse event
	}; // Documented in superclass.


	TapRecognizer.prototype.touchStart = function (touch) {
	  if (this.state != WorldWind.POSSIBLE) {
	    return;
	  }

	  var tap;

	  if (this.touchCount > this.numberOfTouches) {
	    this.state = WorldWind.FAILED;
	  } else if (this.touchCount == 1) {
	    // first touch started
	    tap = {
	      touchCount: this.touchCount,
	      clientX: this.clientX,
	      clientY: this.clientY
	    };
	    this.taps.push(tap);
	    this.failAfterDelay(this.maxTapDuration); // fail if the tap is down too long
	  } else {
	    tap = this.taps[this.taps.length - 1];
	    tap.touchCount = this.touchCount; // max number of simultaneous touches

	    tap.clientX = this.clientX; // touch centroid

	    tap.clientY = this.clientY;
	  }
	}; // Documented in superclass.


	TapRecognizer.prototype.touchMove = function (touch) {
	  if (this.state != WorldWind.POSSIBLE) {
	    return;
	  }

	  var dx = this.translationX,
	      dy = this.translationY,
	      distance = Math.sqrt(dx * dx + dy * dy);

	  if (distance > this.maxTouchMovement) {
	    this.state = WorldWind.FAILED;
	  }
	}; // Documented in superclass.


	TapRecognizer.prototype.touchEnd = function (touch) {
	  if (this.state != WorldWind.POSSIBLE) {
	    return;
	  }

	  if (this.touchCount != 0) {
	    return; // wait until the last touch ends
	  }

	  var tapCount = this.taps.length,
	      tap = this.taps[tapCount - 1];

	  if (tap.touchCount != this.numberOfTouches) {
	    this.state = WorldWind.FAILED; // wrong number of touches
	  } else if (tapCount == this.numberOfTaps) {
	    this.clientX = this.taps[0].clientX;
	    this.clientY = this.taps[0].clientY;
	    this.state = WorldWind.RECOGNIZED;
	  } else {
	    this.failAfterDelay(this.maxTapInterval); // fail if the interval between taps is too long
	  }
	}; // Documented in superclass.


	TapRecognizer.prototype.touchCancel = function (touch) {
	  if (this.state != WorldWind.POSSIBLE) {
	    return;
	  }

	  this.state = WorldWind.FAILED;
	}; // Intentionally not documented.


	TapRecognizer.prototype.failAfterDelay = function (delay) {
	  var self = this;

	  if (self.timeout) {
	    window.clearTimeout(self.timeout);
	  }

	  self.timeout = window.setTimeout(function () {
	    self.timeout = null;

	    if (self.state == WorldWind.POSSIBLE) {
	      self.state = WorldWind.FAILED; // fail if we haven't already reached a terminal state
	    }
	  }, delay);
	}; // Intentionally not documented.


	TapRecognizer.prototype.cancelFailAfterDelay = function () {
	  var self = this;

	  if (self.timeout) {
	    window.clearTimeout(self.timeout);
	    self.timeout = null;
	  }
	};

	/**
	 * @exports TileFactory
	 */
	/**
	 * Applications must not call this constructor. It is an interface class and is not meant to be instantiated
	 * directly.
	 * @alias TileFactory
	 * @constructor
	 * @classdesc
	 * Represents a tile factory.
	 * This is an interface class and is not meant to be instantiated directly.
	 */

	function TileFactory() {}
	/**
	 * Creates a tile for a specified sector, level and row and column within that level.
	 * Implementers of this interface must implement this function.
	 * @param {Sector} sector The sector the tile spans.
	 * @param {Level} level The level the tile is a member of.
	 * @param {Number} row The tile's row within the specified level.
	 * @param {Number} column The tile's column within the specified level.
	 * @throws {ArgumentError} If the specified sector is null or undefined.
	 */


	TileFactory.prototype.createTile = function (sector, level, row, column) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TileFactory", "createTile", "abstractInvocation"));
	};

	/**
	 * @exports TriangleMesh
	 */
	/**
	 * Constructs a triangle mesh.
	 * @alias TriangleMesh
	 * @constructor
	 * @augments AbstractMesh
	 * @classdesc Represents a 3D triangle mesh.
	 * <p>
	 *     Altitudes within the mesh's positions are interpreted according to the mesh's altitude mode, which
	 *     can be one of the following:
	 * <ul>
	 *     <li>[WorldWind.ABSOLUTE]{@link WorldWind#ABSOLUTE}</li>
	 *     <li>[WorldWind.RELATIVE_TO_GROUND]{@link WorldWind#RELATIVE_TO_GROUND}</li>
	 *     <li>[WorldWind.CLAMP_TO_GROUND]{@link WorldWind#CLAMP_TO_GROUND}</li>
	 * </ul>
	 * If the latter, the mesh positions' altitudes are ignored. (If the mesh should be draped onto the
	 * terrain, you might want to use {@link SurfacePolygon} instead.)
	 * <p>
	 *     Meshes have separate attributes for normal display and highlighted display. They use the interior and
	 *     outline attributes of {@link ShapeAttributes}. If those attributes identify an image, that image is
	 *     applied to the mesh. Texture coordinates for the image may be specified, but if not specified the full
	 *     image is stretched over the full mesh. If texture coordinates are specified, there must be one texture
	 *     coordinate for each vertex in the mesh.
	 *
	 * @param {Position[]} positions An array containing the mesh vertices.
	 * There must be no more than 65536 positions. Use [split]{@link TriangleMesh#split} to subdivide large meshes
	 * into smaller ones that fit this limit.
	 * @param {Number[]} indices An array of integers identifying the positions of each mesh triangle.
	 * Each sequence of three indices defines one triangle in the mesh. The indices identify the index of the
	 * position in the associated positions array. The indices for each triangle should be in counter-clockwise
	 * order to identify the triangles as front-facing.
	 * @param {ShapeAttributes} attributes The attributes to associate with this mesh. May be null, in which case
	 * default attributes are associated.
	 *
	 * @throws {ArgumentError} If the specified positions array is null, empty or undefined, the number of indices
	 * is less than 3 or too many positions are specified (limit is 65536).
	 */

	function TriangleMesh(positions, indices, attributes) {
	  if (!positions) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TriangleMesh", "constructor", "missingPositions"));
	  }

	  if (positions.length < 1) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TriangleMesh", "constructor", "missingPositions"));
	  } // Check for size limit, which is the max number of available indices for a 16-bit unsigned int.


	  if (positions.length > 65536) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TriangleMesh", "constructor", "Too many positions. Must be fewer than 65537. Use TriangleMesh.split to split the shape."));
	  }

	  if (!indices) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TriangleMesh", "constructor", "Indices array is null or undefined"));
	  }

	  if (indices.length < 3) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TriangleMesh", "constructor", "Too few indices."));
	  }

	  AbstractMesh.call(this, attributes); // Private. Documentation is with the defined property below and the constructor description above.

	  this._positions = positions; // Private. Documentation is with the defined property below and the constructor description above.

	  this._indices = indices;
	  this.referencePosition = this._positions[0];
	}

	TriangleMesh.prototype = Object.create(AbstractMesh.prototype);
	Object.defineProperties(TriangleMesh.prototype, {
	  /**
	   * This mesh's positions.
	   *
	   * @type {Position[]}
	   * @memberof TriangleMesh.prototype
	   */
	  positions: {
	    get: function () {
	      return this._positions;
	    },
	    set: function (positions) {
	      if (!positions) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TriangleMesh", "positions", "missingPositions"));
	      }

	      this._positions = positions;
	      this.referencePosition = this._positions[0];
	      this.reset();
	    }
	  },

	  /**
	   * The mesh indices, an array of integers identifying the indexes of each triangle. Each index in this
	   * array identifies the index of the corresponding position in the [positions]{@link TriangleMesh#positions}
	   * array. Each group of three indices in this array identifies the positions of one triangle.
	   *
	   *
	   * @type {Number[]}
	   * @memberof TriangleMesh.prototype
	   */
	  indices: {
	    get: function () {
	      return this._indices;
	    },
	    set: function (indices) {
	      if (!indices) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TriangleMesh", "indices", "Indices array is null or undefined"));
	      }

	      this._indices = indices;
	      this.meshIndices = null;
	      this.reset();
	    }
	  },

	  /**
	   * The mesh outline indices, an array of integers identifying the positions in the outline. Each index in
	   * this array identifies the index of the corresponding position in the
	   * [positions]{@link TriangleMesh#positions} array. The collection of these positions forms the outline
	   * of this mesh. May be null, in which case no outline is drawn.
	   *
	   * @type {Number[]}
	   * @default null
	   * @memberof TriangleMesh.prototype
	   */
	  outlineIndices: {
	    get: function () {
	      return this._outlineIndices;
	    },
	    set: function (indices) {
	      this._outlineIndices = indices;
	      this.meshOutlineIndices = null;
	      this.reset();
	    }
	  },

	  /**
	   * This mesh's texture coordinates if this mesh is textured. A texture coordinate must be
	   * provided for each mesh position. Each texture coordinate is a {@link Vec2} containing the s and t
	   * coordinates, in that order. If no texture coordinates are specified then texture is not applied to
	   * this mesh.
	   * @type {Vec2[]}
	   * @default null
	   * @memberof TriangleMesh.prototype
	   */
	  textureCoordinates: {
	    get: function () {
	      return this._textureCoordinates;
	    },
	    set: function (coords) {
	      if (coords && coords.length != this._positions.length) {
	        throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "TriangleMesh", "textureCoordinates", "Number of texture coordinates is inconsistent with the currently specified positions."));
	      }

	      this._textureCoordinates = coords;
	      this.reset();
	      this.texCoords = null;
	    }
	  }
	}); // Overridden from AbstractShape base class.

	TriangleMesh.prototype.createSurfaceShape = function () {
	  if (this._outlineIndices) {
	    var boundaries = [];

	    for (var i = 0; i < this._outlineIndices.length; i++) {
	      boundaries.push(this._positions[this._outlineIndices[i]]);
	    }

	    return new SurfacePolygon(boundaries, null);
	  } else {
	    return null;
	  }
	}; // Overridden from AbstractShape base class.


	TriangleMesh.prototype.computeMeshPoints = function (dc, currentData) {
	  var eyeDistSquared = Number.MAX_VALUE,
	      eyePoint = dc.eyePoint,
	      meshPoints = new Float32Array(this._positions.length * 3),
	      pt = new Vec3$1(0, 0, 0),
	      k = 0,
	      pos,
	      dSquared;

	  for (var i = 0; i < this._positions.length; i++) {
	    pos = this._positions[i];
	    dc.surfacePointForMode(pos.latitude, pos.longitude, pos.altitude * this._altitudeScale, this.altitudeMode, pt);
	    dSquared = pt.distanceToSquared(eyePoint);

	    if (dSquared < eyeDistSquared) {
	      eyeDistSquared = dSquared;
	    }

	    pt.subtract(this.currentData.referencePoint);
	    meshPoints[k++] = pt[0];
	    meshPoints[k++] = pt[1];
	    meshPoints[k++] = pt[2];
	  }

	  currentData.eyeDistance = Math.sqrt(eyeDistSquared);
	  return meshPoints;
	}; // Overridden from AbstractShape base class.


	TriangleMesh.prototype.computeTexCoords = function () {
	  if (!this._textureCoordinates) {
	    return null;
	  } else {
	    // Capture the texture coordinates to a single array parallel to the mesh points array.
	    var texCoords = new Float32Array(2 * this._textureCoordinates.length),
	        k = 0;

	    for (var i = 0, len = this._textureCoordinates.length; i < len; i++) {
	      var texCoord = this._textureCoordinates[i];
	      texCoords[k++] = texCoord[0];
	      texCoords[k++] = texCoord[1];
	    }

	    return texCoords;
	  }
	}; // Overridden from AbstractShape base class.


	TriangleMesh.prototype.computeMeshIndices = function () {
	  var meshIndices = new Uint16Array(this._indices.length);

	  for (var i = 0, len = this._indices.length; i < len; i++) {
	    meshIndices[i] = this._indices[i];
	  }

	  return meshIndices;
	}; // Overridden from AbstractShape base class.


	TriangleMesh.prototype.computeOutlineIndices = function () {
	  if (!this._outlineIndices) {
	    return null;
	  } else {
	    var meshOutlineIndices = new Uint16Array(this._outlineIndices.length);

	    for (var i = 0; i < this._outlineIndices.length; i++) {
	      meshOutlineIndices[i] = this._outlineIndices[i];
	    }

	    return meshOutlineIndices;
	  }
	};
	/**
	 * Splits a triangle mesh into several meshes, each of which contains fewer than 65536 positions.
	 * @param {Position[]} positions An array containing the mesh vertices.
	 * @param {Number[]} indices An array of integers identifying the positions of each mesh triangle.
	 * Each sequence of three indices defines one triangle in the mesh. The indices identify the index of the
	 * position in the associated positions array.
	 * @param {Vec2[]} textureCoords The mesh's texture coordinates.
	 * @param {Number[]} outlineIndices The mesh's outline indices.
	 * @returns {Object[]} An array of objects, each of which defines one subdivision of the full mesh. Each object
	 * in the array has the properties of the same name as the input arguments.
	 */


	TriangleMesh.split = function (positions, indices, textureCoords, outlineIndices) {
	  var splitPositions = [],
	      splitTexCoords = [],
	      splitIndices = [],
	      indexMap = [],
	      result = [],
	      originalIndex,
	      mappedIndex;

	  for (var i = 0; i <= indices.length; i++) {
	    if (i === indices.length || splitPositions.length > 65533 && splitIndices.length % 3 === 0) {
	      if (splitPositions.length > 0) {
	        var shape = {
	          positions: splitPositions,
	          indices: splitIndices
	        };

	        if (textureCoords) {
	          shape.textureCoords = splitTexCoords;
	        }

	        if (outlineIndices) {
	          var splitOutline = [];

	          for (var j = 0; j < outlineIndices.length; j++) {
	            originalIndex = outlineIndices[j];
	            mappedIndex = indexMap[originalIndex];

	            if (mappedIndex) {
	              splitOutline.push(indexMap[outlineIndices[j]]);
	            }
	          }

	          shape.outlineIndices = splitOutline;
	        }

	        result.push(shape);
	      }

	      if (i === indices.length) {
	        break;
	      }

	      splitPositions = [];
	      splitIndices = [];
	      indexMap = [];
	    }

	    originalIndex = indices[i];
	    mappedIndex = indexMap[originalIndex];

	    if (!mappedIndex) {
	      mappedIndex = splitPositions.length;
	      indexMap[originalIndex] = mappedIndex;
	      splitPositions.push(positions[originalIndex]);

	      if (textureCoords) {
	        splitTexCoords.push(textureCoords[originalIndex]);
	      }
	    }

	    splitIndices.push(mappedIndex);
	  }

	  return result;
	};

	/**
	 * @exports UrlBuilder
	 */
	/**
	 * Applications must not call this constructor. It is an interface class and is not meant to be instantiated.
	 * @alias UrlBuilder
	 * @constructor
	 * @classdesc
	 * Defines an interface for tile URL builders. This is an interface class and not meant to be instantiated.
	 */

	function UrlBuilder() {}
	/**
	 * Creates the URL string for a resource.
	 * @param {Tile} tile The tile for which to create the URL.
	 * @param {String} format The format to request.
	 * @returns {String} A string identifying the URL for the specified tile's resource.
	 * @throws {ArgumentError} If either the specified tile or format is null or undefined.
	 */


	UrlBuilder.prototype.urlForTile = function (tile, format) {
	  throw new UnsupportedOperationError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "UrlBuilder", "urlForTile", "abstractInvocation"));
	};

	/**
	 * @exports WcsTileUrlBuilder
	 */
	/**
	 * Constructs a WCS tile URL builder.
	 * @alias WcsTileUrlBuilder
	 * @constructor
	 * @classdesc Provides a factory to create URLs for WCS Get Coverage requests.
	 * @param {String} serviceAddress The address of the WCS server.
	 * @param {String} coverageName The name of the coverage to retrieve.
	 * @param {String} wcsVersion The version of the WCS server. May be null, in which case version 1.0.0 is
	 * assumed.
	 * @constructor
	 * @deprecated
	 */

	function WcsTileUrlBuilder(serviceAddress, coverageName, wcsVersion) {
	  if (!serviceAddress || serviceAddress.length === 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WcsTileUrlBuilder", "constructor", "The WCS service address is missing."));
	  }

	  if (!coverageName || coverageName.length === 0) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WcsTileUrlBuilder", "constructor", "The WCS coverage name is missing."));
	  }
	  /**
	   * The address of the WCS server.
	   * @type {String}
	   */


	  this.serviceAddress = serviceAddress;
	  /**
	   * The name of the coverage to retrieve.
	   * @type {String}
	   */

	  this.coverageName = coverageName;
	  /**
	   * The WCS version to specify when requesting resources.
	   * @type {String}
	   * @default 1.0.0
	   */

	  this.wcsVersion = wcsVersion && wcsVersion.length > 0 ? wcsVersion : "1.0.0";
	  /**
	   * The coordinate reference system to use when requesting coverages.
	   * @type {String}
	   * @default EPSG:4326
	   */

	  this.crs = "EPSG:4326";
	}
	/**
	 * Creates the URL string for a WCS Get Coverage request.
	 * @param {Tile} tile The tile for which to create the URL.
	 * @param {String} coverageFormat The coverage format to request.
	 * @throws {ArgumentError} If the specified tile or coverage format are null or undefined.
	 */


	WcsTileUrlBuilder.prototype.urlForTile = function (tile, coverageFormat) {
	  if (!tile) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WcsUrlBuilder", "urlForTile", "missingTile"));
	  }

	  if (!coverageFormat) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WcsUrlBuilder", "urlForTile", "The coverage format is null or undefined."));
	  }

	  var sector = tile.sector;
	  var sb = WcsTileUrlBuilder.fixGetCoverageString(this.serviceAddress);

	  if (sb.search(/service=wcs/i) < 0) {
	    sb = sb + "service=WCS";
	  }

	  sb = sb + "&request=GetCoverage";
	  sb = sb + "&version=" + this.wcsVersion;
	  sb = sb + "&coverage=" + this.coverageName;
	  sb = sb + "&format=" + coverageFormat;
	  sb = sb + "&width=" + tile.tileWidth;
	  sb = sb + "&height=" + tile.tileHeight;
	  sb = sb + "&crs=" + this.crs;
	  sb = sb + "&bbox=";
	  sb = sb + sector.minLongitude + "," + sector.minLatitude + ",";
	  sb = sb + sector.maxLongitude + "," + sector.maxLatitude;
	  sb = sb.replace(" ", "%20");
	  return sb;
	}; // Intentionally not documented.


	WcsTileUrlBuilder.fixGetCoverageString = function (serviceAddress) {
	  if (!serviceAddress) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WcsTileUrlBuilder", "fixGetCoverageString", "The specified service address is null or undefined."));
	  }

	  var index = serviceAddress.indexOf("?");

	  if (index < 0) {
	    // if string contains no question mark
	    serviceAddress = serviceAddress + "?"; // add one
	  } else if (index !== serviceAddress.length - 1) {
	    // else if question mark not at end of string
	    index = serviceAddress.search(/&$/);

	    if (index < 0) {
	      serviceAddress = serviceAddress + "&"; // add a parameter separator
	    }
	  }

	  return serviceAddress;
	};

	/**
	 * @exports WcsEarthElevationCoverage
	 */
	/**
	 * Constructs an Earth elevation model.
	 * @alias WcsEarthElevationCoverage
	 * @constructor
	 * @augments TiledElevationCoverage
	 * @classdesc Provides elevations for Earth. Elevations are drawn from the NASA WorldWind elevation service.
	 * @deprecated
	 */

	function WcsEarthElevationCoverage() {
	  TiledElevationCoverage.call(this, {
	    coverageSector: Sector.FULL_SPHERE,
	    resolution: 0.008333333333333,
	    retrievalImageFormat: "image/tiff",
	    minElevation: -11000,
	    maxElevation: 8850,
	    urlBuilder: new WcsTileUrlBuilder("https://worldwind26.arc.nasa.gov/wms2", "NASA_SRTM30_900m_Tiled", "1.0.0")
	  });
	  this.displayName = "WCS Earth Elevation Coverage";
	}

	WcsEarthElevationCoverage.prototype = Object.create(TiledElevationCoverage.prototype);

	/**
	 * @exports WorldWindow
	 */
	/**
	 * Constructs a WorldWind window for an HTML canvas.
	 * @alias WorldWindow
	 * @constructor
	 * @classdesc Represents a WorldWind window for an HTML canvas.
	 * @param {WebGLRenderingContext} gl The ID assigned to the HTML canvas in the document or the canvas
	 * element itself.
	 */

	function WorldWindow(gl) {
	  var canvas = gl.canvas; // Internal. Intentionally not documented.

	  this.drawContext = new DrawContext(gl); // Internal. Intentionally not documented. Must be initialized before the navigator is created.

	  this.eventListeners = {}; // Internal. Intentionally not documented. Initially true in order to redraw at least once.

	  this.redrawRequested = true; // Internal. Intentionally not documented.

	  this.redrawRequestId = null; // Internal. Intentionally not documented.

	  this.scratchModelview = Matrix.fromIdentity(); // Internal. Intentionally not documented.

	  this.scratchProjection = Matrix.fromIdentity(); // Internal. Intentionally not documented.

	  this.hasStencilBuffer = gl.getContextAttributes().stencil;
	  /**
	   * The HTML canvas associated with this WorldWindow.
	   * @type {HTMLElement}
	   * @readonly
	   */

	  this.canvas = canvas;
	  /**
	   * The number of bits in the depth buffer associated with this WorldWindow.
	   * @type {number}
	   * @readonly
	   */

	  this.depthBits = gl.getParameter(gl.DEPTH_BITS);
	  /**
	   * The current viewport of this WorldWindow.
	   * @type {Rectangle}
	   * @readonly
	   */

	  this.viewport = new Rectangle(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	  /**
	   * The globe displayed.
	   * @type {Globe}
	   */

	  this.globe = new Globe(new EarthElevationModel());
	  /**
	   * The layers to display in this WorldWindow.
	   * This property is read-only. Use [addLayer]{@link WorldWindow#addLayer} or
	   * [insertLayer]{@link WorldWindow#insertLayer} to add layers to this WorldWindow.
	   * Use [removeLayer]{@link WorldWindow#removeLayer} to remove layers from this WorldWindow.
	   * @type {Layer[]}
	   * @readonly
	   */

	  this.layers = [];
	  /**
	   * The navigator used to manipulate the globe.
	   * @type {LookAtNavigator}
	   * @default [LookAtNavigator]{@link LookAtNavigator}
	   */

	  this.navigator = new LookAtNavigator();
	  /**
	   * The controller used to manipulate the globe.
	   * @type {WorldWindowController}
	   * @default [BasicWorldWindowController]{@link BasicWorldWindowController}
	   */

	  this.worldWindowController = new BasicWorldWindowController(this);
	  /**
	   * The vertical exaggeration to apply to the terrain.
	   * @type {Number}
	   */

	  this.verticalExaggeration = 1;
	  /**
	   * Indicates that picking will return all objects at the pick point, if any. The top-most object will have
	   * its isOnTop flag set to true.
	   * If deep picking is false, the default, only the top-most object is returned, plus
	   * the picked-terrain object if the pick point is over the terrain.
	   * @type {boolean}
	   * @default false
	   */

	  this.deepPicking = false;
	  /**
	   * Indicates whether this WorldWindow should be configured for sub-surface rendering. If true, shapes
	   * below the terrain can be seen when the terrain is made transparent. If false, sub-surface shapes are
	   * not visible, however, performance is slightly increased.
	   * @type {boolean}
	   * @default false
	   */

	  this.subsurfaceMode = false;
	  /**
	   * The opacity to apply to terrain and surface shapes. This property is typically used when viewing
	   * the sub-surface. It modifies the opacity of the terrain and surface shapes as a whole. It should be
	   * a number between 0 and 1. It is compounded with the individual opacities of the image layers and
	   * surface shapes on the terrain.
	   * @type {Number}
	   * @default 1
	   */

	  this.surfaceOpacity = 1;
	  /**
	   * Performance statistics for this WorldWindow.
	   * @type {FrameStatistics}
	   */

	  this.frameStatistics = new FrameStatistics();
	  /**
	   * The {@link GoToAnimator} used by this WorldWindow to respond to its goTo method.
	   * @type {GoToAnimator}
	   */

	  this.goToAnimator = new GoToAnimator(this); // Documented with its property accessor below.

	  this._redrawCallbacks = []; // Documented with its property accessor below.

	  this._orderedRenderingFilters = [function (dc) {
	    thisWindow.declutter(dc, 1);
	  }, function (dc) {
	    thisWindow.declutter(dc, 2);
	  }]; // Intentionally not documented.

	  this.pixelScale = 1; // Prevent the browser's default actions in response to mouse and touch events, which interfere with
	  // navigation. Register these event listeners  before any others to ensure that they're called last.

	  function preventDefaultListener(event) {
	    event.preventDefault();
	  }

	  this.addEventListener("mousedown", preventDefaultListener);
	  this.addEventListener("touchstart", preventDefaultListener);
	  this.addEventListener("contextmenu", preventDefaultListener);
	  this.addEventListener("wheel", preventDefaultListener);
	  var thisWindow = this; // Redirect various UI interactions to the appropriate handler.

	  function onGestureEvent(event) {
	    thisWindow.onGestureEvent(event);
	  }

	  if (window.PointerEvent) {
	    // Prevent the browser's default actions in response to pointer events which interfere with navigation.
	    // This CSS style property is configured here to ensure that it's set for all applications.
	    this.canvas.style.setProperty("touch-action", "none");
	    this.addEventListener("pointerdown", onGestureEvent, false);
	    window.addEventListener("pointermove", onGestureEvent, false); // get pointermove events outside event target

	    window.addEventListener("pointercancel", onGestureEvent, false); // get pointercancel events outside event target

	    window.addEventListener("pointerup", onGestureEvent, false); // get pointerup events outside event target
	  } else {
	    this.addEventListener("mousedown", onGestureEvent, false);
	    window.addEventListener("mousemove", onGestureEvent, false); // get mousemove events outside event target

	    window.addEventListener("mouseup", onGestureEvent, false); // get mouseup events outside event target

	    this.addEventListener("touchstart", onGestureEvent, false);
	    this.addEventListener("touchmove", onGestureEvent, false);
	    this.addEventListener("touchend", onGestureEvent, false);
	    this.addEventListener("touchcancel", onGestureEvent, false);
	  } // Register wheel event listeners on the WorldWindow's canvas.


	  this.addEventListener("wheel", function (event) {
	    onGestureEvent(event);
	  }); // Set up to handle WebGL context lost events.

	  function handleContextLost(event) {
	    thisWindow.handleContextLost(event);
	  }

	  this.canvas.addEventListener("webglcontextlost", handleContextLost, false); // Set up to handle WebGL context restored events.

	  function handleContextRestored(event) {
	    thisWindow.handleContextRestored(event);
	  }

	  this.canvas.addEventListener("webglcontextrestored", handleContextRestored, false); // Set up to handle WebGL context events and WorldWind redraw request events. Imagery uses the canvas
	  // redraw events because images are generally specific to the WebGL context associated with the canvas.
	  // Elevation models use the global window redraw events because they can be shared among WorldWindows.

	  function handleRedrawEvent(event) {
	    thisWindow.handleRedrawEvent(event);
	  }

	  this.canvas.addEventListener(WorldWind.REDRAW_EVENT_TYPE, handleRedrawEvent, false);
	  window.addEventListener(WorldWind.REDRAW_EVENT_TYPE, handleRedrawEvent, false); // Render to the WebGL context in an animation frame loop until the WebGL context is lost.

	  this.animationFrameLoop();
	}

	Object.defineProperties(WorldWindow.prototype, {
	  /**
	   * An array of functions to call during ordered rendering prior to rendering the ordered renderables.
	   * Each function is passed one argument, the current draw context. The function may modify the
	   * ordered renderables in the draw context's ordered renderable list, which has been sorted from front
	   * to back when the filter function is called. Ordered rendering filters are typically used to apply
	   * decluttering. The default set of filter functions contains one function that declutters shapes with
	   * declutter group ID of 1 ({@link GeographicText} by default) and one function that declutters shapes
	   * with declutter group ID 2 ({@link Placemark} by default). Applications can add functions to this
	   * array or remove them.
	   * @type {Function[]}
	   * @default [WorldWindow.declutter]{@link WorldWindow#declutter} with a group ID of 1
	   * @readonly
	   * @memberof WorldWindow.prototype
	   */
	  orderedRenderingFilters: {
	    get: function () {
	      return this._orderedRenderingFilters;
	    }
	  },

	  /**
	   * The list of callbacks to call immediately before and immediately after performing a redraw. The callbacks
	   * have two arguments: this WorldWindow and the redraw stage, e.g., <code style='white-space:nowrap'>redrawCallback(worldWindow, stage);</code>.
	   * The stage will be either WorldWind.BEFORE_REDRAW or WorldWind.AFTER_REDRAW indicating whether the
	   * callback has been called either immediately before or immediately after a redraw, respectively.
	   * Applications may add functions to this array or remove them.
	   * @type {Function[]}
	   * @readonly
	   * @memberof WorldWindow.prototype
	   */
	  redrawCallbacks: {
	    get: function () {
	      return this._redrawCallbacks;
	    }
	  }
	});
	/**
	 * Converts window coordinates to coordinates relative to this WorldWindow's canvas.
	 * @param {Number} x The X coordinate to convert.
	 * @param {Number} y The Y coordinate to convert.
	 * @returns {Vec2} The converted coordinates.
	 */

	WorldWindow.prototype.canvasCoordinates = function (x, y) {
	  var bbox = this.canvas.getBoundingClientRect(),
	      xc = x - (bbox.left + this.canvas.clientLeft),
	      // * (this.canvas.width / bbox.width),
	  yc = y - (bbox.top + this.canvas.clientTop); // * (this.canvas.height / bbox.height);

	  return new Vec2(xc, yc);
	};

	WorldWindow.prototype.onGestureEvent = function (event) {
	  this.worldWindowController.onGestureEvent(event);
	};
	/**
	 * Registers an event listener for the specified event type on this WorldWindow's canvas. This function
	 * delegates the processing of events to the WorldWindow's canvas. For details on this function and its
	 * arguments, see the W3C [EventTarget]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}
	 * documentation.
	 *
	 * Registering event listeners using this function enables applications to prevent the WorldWindow's default
	 * navigation behavior. To prevent default navigation behavior, call the [Event]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Event}'s
	 * preventDefault method from within an event listener for any events the navigator should not respond to.
	 *
	 * When an event occurs, this calls the registered event listeners in order of reverse registration. Since the
	 * WorldWindow registers its navigator event listeners first, application event listeners are called before
	 * navigator event listeners.
	 *
	 * @param type The event type to listen for.
	 * @param listener The function to call when the event occurs.
	 * @throws {ArgumentError} If any argument is null or undefined.
	 */


	WorldWindow.prototype.addEventListener = function (type, listener) {
	  if (!type) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindow", "addEventListener", "missingType"));
	  }

	  if (!listener) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindow", "addEventListener", "missingListener"));
	  }

	  var thisWorldWindow = this;
	  var entry = this.eventListeners[type];

	  if (!entry) {
	    entry = {
	      listeners: [],
	      callback: function (event) {
	        // calls listeners in reverse registration order
	        event.worldWindow = thisWorldWindow;

	        for (var i = 0, len = entry.listeners.length; i < len; i++) {
	          entry.listeners[i](event);
	        }
	      }
	    };
	    this.eventListeners[type] = entry;
	  }

	  var index = entry.listeners.indexOf(listener);

	  if (index == -1) {
	    // suppress duplicate listeners
	    entry.listeners.splice(0, 0, listener); // insert the listener at the beginning of the list

	    if (entry.listeners.length == 1) {
	      // first listener added, add the event listener callback
	      this.canvas.addEventListener(type, entry.callback, false);
	    }
	  }
	};
	/**
	 * Removes an event listener for the specified event type from this WorldWindow's canvas. The listener must be
	 * the same object passed to addEventListener. Calling removeEventListener with arguments that do not identify a
	 * currently registered listener has no effect.
	 *
	 * @param type Indicates the event type the listener registered for.
	 * @param listener The listener to remove. Must be the same function object passed to addEventListener.
	 * @throws {ArgumentError} If any argument is null or undefined.
	 */


	WorldWindow.prototype.removeEventListener = function (type, listener) {
	  if (!type) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindow", "removeEventListener", "missingType"));
	  }

	  if (!listener) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindow", "removeEventListener", "missingListener"));
	  }

	  var entry = this.eventListeners[type];

	  if (!entry) {
	    return; // no entry for the specified type
	  }

	  var index = entry.listeners.indexOf(listener);

	  if (index != -1) {
	    entry.listeners.splice(index, 1); // remove the listener from the list

	    if (entry.listeners.length == 0) {
	      // last listener removed, remove the event listener callback
	      this.canvas.removeEventListener(type, entry.callback, false);
	    }
	  }
	};
	/**
	 * Causes this WorldWindow to redraw itself at the next available opportunity. The redraw occurs on the main
	 * thread at a time of the browser's discretion. Applications should call redraw after changing the World
	 * Window's state, but should not expect that change to be reflected on screen immediately after this function
	 * returns. This is the preferred method for requesting a redraw of the WorldWindow.
	 */


	WorldWindow.prototype.redraw = function () {
	  this.redrawRequested = true; // redraw during the next animation frame
	};
	/**
	 * Requests the WorldWind objects displayed at a specified screen-coordinate point.
	 *
	 * If the point intersects the terrain, the returned list contains an object identifying the associated geographic
	 * position. This returns an empty list when nothing in the WorldWind scene intersects the specified point.
	 *
	 * @param pickPoint The point to examine in this WorldWindow's screen coordinates.
	 * @returns {PickedObjectList} A list of picked WorldWind objects at the specified pick point.
	 * @throws {ArgumentError} If the specified pick point is null or undefined.
	 */


	WorldWindow.prototype.pick = function (pickPoint) {
	  if (!pickPoint) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindow", "pick", "missingPoint"));
	  } // Suppress the picking operation and return an empty list when the WebGL context has been lost.


	  if (this.drawContext.currentGlContext.isContextLost()) {
	    return new PickedObjectList();
	  }

	  this.resize();
	  this.resetDrawContext();
	  this.drawContext.pickingMode = true;
	  this.drawContext.pickPoint = pickPoint;
	  this.drawContext.pickRay = this.rayThroughScreenPoint(pickPoint);
	  this.drawFrame();
	  return this.drawContext.objectsAtPickPoint;
	};
	/**
	 * Requests the position of the WorldWind terrain at a specified screen-coordinate point. If the point
	 * intersects the terrain, the returned list contains a single object identifying the associated geographic
	 * position. Otherwise this returns an empty list.
	 * @param pickPoint The point to examine in this WorldWindow's screen coordinates.
	 * @returns {PickedObjectList} A list containing the picked WorldWind terrain position at the specified point,
	 * or an empty list if the point does not intersect the terrain.
	 * @throws {ArgumentError} If the specified pick point is null or undefined.
	 */


	WorldWindow.prototype.pickTerrain = function (pickPoint) {
	  if (!pickPoint) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindow", "pickTerrain", "missingPoint"));
	  } // Suppress the picking operation and return an empty list when the WebGL context has been lost.


	  if (this.drawContext.currentGlContext.isContextLost()) {
	    return new PickedObjectList();
	  }

	  this.resize();
	  this.resetDrawContext();
	  this.drawContext.pickingMode = true;
	  this.drawContext.pickTerrainOnly = true;
	  this.drawContext.pickPoint = pickPoint;
	  this.drawContext.pickRay = this.rayThroughScreenPoint(pickPoint);
	  this.drawFrame();
	  return this.drawContext.objectsAtPickPoint;
	};
	/**
	 * Requests the WorldWind objects displayed within a specified screen-coordinate region. This returns all
	 * objects that intersect the specified region, regardless of whether or not an object is actually visible, and
	 * marks objects that are visible as on top.
	 * @param {Rectangle} rectangle The screen coordinate rectangle identifying the region to search.
	 * @returns {PickedObjectList} A list of visible WorldWind objects within the specified region.
	 * @throws {ArgumentError} If the specified rectangle is null or undefined.
	 */


	WorldWindow.prototype.pickShapesInRegion = function (rectangle) {
	  if (!rectangle) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindow", "pickShapesInRegion", "missingRectangle"));
	  } // Suppress the picking operation and return an empty list when the WebGL context has been lost.


	  if (this.drawContext.currentGlContext.isContextLost()) {
	    return new PickedObjectList();
	  }

	  this.resize();
	  this.resetDrawContext();
	  this.drawContext.pickingMode = true;
	  this.drawContext.regionPicking = true;
	  this.drawContext.pickRectangle = new Rectangle(rectangle.x, this.canvas.height - rectangle.y, rectangle.width, rectangle.height);
	  this.drawFrame();
	  return this.drawContext.objectsAtPickPoint;
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.createContext = function (canvas) {
	  // Request a WebGL context with antialiasing is disabled. Antialiasing causes gaps to appear at the edges of
	  // terrain tiles.
	  var glAttrs = {
	    antialias: false,
	    stencil: true
	  },
	      gl = canvas.getContext("webgl", glAttrs);

	  if (!gl) {
	    gl = canvas.getContext("experimental-webgl", glAttrs);
	  } // uncomment to debug WebGL
	  //var gl = WebGLDebugUtils.makeDebugContext(this.canvas.getContext("webgl"),
	  //        this.throwOnGLError,
	  //        this.logAndValidate
	  //);


	  return gl;
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.handleContextLost = function (event) {
	  Logger$1.log(Logger$1.LEVEL_INFO, "WebGL context event: " + event.statusMessage); // Inform WebGL that we handle context restoration, enabling the context restored event to be delivered.

	  event.preventDefault(); // Notify the draw context that the WebGL rendering context has been lost.

	  this.drawContext.contextLost(); // Stop the rendering animation frame loop, resuming only if the WebGL context is restored.

	  window.cancelAnimationFrame(this.redrawRequestId);
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.handleContextRestored = function (event) {
	  Logger$1.log(Logger$1.LEVEL_INFO, "WebGL context event: " + event.statusMessage); // Notify the draw context that the WebGL rendering context has been restored.

	  this.drawContext.contextRestored(); // Resume the rendering animation frame loop until the WebGL context is lost.

	  this.redraw();
	  this.animationFrameLoop();
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.handleRedrawEvent = function (event) {
	  this.redraw(); // redraw in the next animation frame
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.animationFrameLoop = function () {
	  // Render to the WebGL context as needed.
	  this.redrawIfNeeded(); // Continue the animation frame loop until the WebGL context is lost.

	  var thisWindow = this;

	  function animationFrameCallback() {
	    thisWindow.animationFrameLoop();
	  }

	  this.redrawRequestId = window.requestAnimationFrame(animationFrameCallback);
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.redrawIfNeeded = function () {
	  // Check if the drawing buffer needs to resize to match its screen size, which requires a redraw.
	  this.resize(); // Redraw the WebGL drawing buffer only when necessary.

	  if (!this.redrawRequested) {
	    return;
	  }

	  try {
	    // Prepare to redraw and notify the redraw callbacks that a redraw is about to occur.
	    this.redrawRequested = false;
	    this.drawContext.previousRedrawTimestamp = this.drawContext.timestamp;
	    this.callRedrawCallbacks(WorldWind.BEFORE_REDRAW); // Redraw the WebGL drawing buffer.

	    this.resetDrawContext();
	    this.drawFrame();
	  } catch (e) {
	    Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindow", "redrawIfNeeded", "Exception occurred during redrawing.\n" + e.toString());
	  } finally {
	    // Notify the redraw callbacks that a redraw has completed.
	    this.callRedrawCallbacks(WorldWind.AFTER_REDRAW); // Handle rendering code redraw requests.

	    if (this.drawContext.redrawRequested) {
	      this.redrawRequested = true;
	    }
	  }
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.resize = function () {
	  var gl = this.drawContext.currentGlContext,
	      width = gl.canvas.clientWidth * this.pixelScale,
	      height = gl.canvas.clientHeight * this.pixelScale;

	  if (gl.canvas.width != width || gl.canvas.height != height) {
	    // Make the canvas drawing buffer size match its screen size.
	    gl.canvas.width = width;
	    gl.canvas.height = height; // Set the WebGL viewport to match the canvas drawing buffer size.

	    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	    this.viewport = new Rectangle(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); // Cause this WorldWindow to redraw with the new size.

	    this.redrawRequested = true;
	  }
	}; // Internal. Intentionally not documented.


	WorldWindow.prototype.computeViewingTransform = function (projection, modelview) {
	  if (!modelview) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindow", "computeViewingTransform", "missingModelview"));
	  }

	  modelview.setToIdentity();
	  this.worldWindowController.applyLimits();
	  var globe = this.globe;
	  var navigator = this.navigator;
	  var lookAtPosition = new Position(navigator.lookAtLocation.latitude, navigator.lookAtLocation.longitude, 0);
	  modelview.multiplyByLookAtModelview(lookAtPosition, navigator.range, navigator.heading, navigator.tilt, navigator.roll, globe);

	  if (projection) {
	    projection.setToIdentity();
	    var globeRadius = WWMath.max(globe.equatorialRadius, globe.polarRadius),
	        eyePoint = modelview.extractEyePoint(new Vec3$1(0, 0, 0)),
	        eyePos = globe.computePositionFromPoint(eyePoint[0], eyePoint[1], eyePoint[2], new Position(0, 0, 0)),
	        eyeHorizon = WWMath.horizonDistanceForGlobeRadius(globeRadius, eyePos.altitude),
	        atmosphereHorizon = WWMath.horizonDistanceForGlobeRadius(globeRadius, 160000),
	        viewport = this.viewport; // Set the far clip distance to the smallest value that does not clip the atmosphere.
	    // TODO adjust the clip plane distances based on the navigator's orientation - shorter distances when the
	    // TODO horizon is not in view
	    // TODO parameterize the object altitude for horizon distance

	    var farDistance = eyeHorizon + atmosphereHorizon;
	    if (farDistance < 1e3) farDistance = 1e3; // Compute the near clip distance in order to achieve a desired depth resolution at the far clip distance.
	    // This computed distance is limited such that it does not intersect the terrain when possible and is never
	    // less than a predetermined minimum (usually one). The computed near distance automatically scales with the
	    // resolution of the WebGL depth buffer.

	    var nearDistance = WWMath.perspectiveNearDistanceForFarDistance(farDistance, 10, this.depthBits); // Prevent the near clip plane from intersecting the terrain.

	    var distanceToSurface = eyePos.altitude - globe.elevationAtLocation(eyePos.latitude, eyePos.longitude);

	    if (distanceToSurface > 0) {
	      var maxNearDistance = WWMath.perspectiveNearDistance(viewport.width, viewport.height, distanceToSurface);

	      if (nearDistance > maxNearDistance) {
	        nearDistance = maxNearDistance;
	      }
	    }

	    if (nearDistance < 1) {
	      nearDistance = 1;
	    } // Compute the current projection matrix based on this navigator's perspective properties and the current
	    // WebGL viewport.


	    projection.setToPerspectiveProjection(viewport.width, viewport.height, nearDistance, farDistance);
	  }
	}; // Internal. Intentionally not documented.


	WorldWindow.prototype.computePixelMetrics = function (projection) {
	  var projectionInv = Matrix.fromIdentity();
	  projectionInv.invertMatrix(projection); // Compute the eye coordinate rectangles carved out of the frustum by the near and far clipping planes, and
	  // the distance between those planes and the eye point along the -Z axis. The rectangles are determined by
	  // transforming the bottom-left and top-right points of the frustum from clip coordinates to eye
	  // coordinates.

	  var nbl = new Vec3$1(-1, -1, -1),
	      ntr = new Vec3$1(+1, +1, -1),
	      fbl = new Vec3$1(-1, -1, +1),
	      ftr = new Vec3$1(+1, +1, +1); // Convert each frustum corner from clip coordinates to eye coordinates by multiplying by the inverse
	  // projection matrix.

	  nbl.multiplyByMatrix(projectionInv);
	  ntr.multiplyByMatrix(projectionInv);
	  fbl.multiplyByMatrix(projectionInv);
	  ftr.multiplyByMatrix(projectionInv);
	  var nrRectWidth = WWMath.fabs(ntr[0] - nbl[0]),
	      frRectWidth = WWMath.fabs(ftr[0] - fbl[0]),
	      nrDistance = -nbl[2],
	      frDistance = -fbl[2]; // Compute the scale and offset used to determine the width of a pixel on a rectangle carved out of the
	  // frustum at a distance along the -Z axis in eye coordinates. These values are found by computing the scale
	  // and offset of a frustum rectangle at a given distance, then dividing each by the viewport width.

	  var frustumWidthScale = (frRectWidth - nrRectWidth) / (frDistance - nrDistance),
	      frustumWidthOffset = nrRectWidth - frustumWidthScale * nrDistance;
	  return {
	    pixelSizeFactor: frustumWidthScale / this.viewport.width,
	    pixelSizeOffset: frustumWidthOffset / this.viewport.height
	  };
	};
	/**
	 * Computes the approximate size of a pixel at a specified distance from the eye point.
	 * <p>
	 * This method assumes rectangular pixels, where pixel coordinates denote
	 * infinitely thin spaces between pixels. The units of the returned size are in model coordinates per pixel
	 * (usually meters per pixel). This returns 0 if the specified distance is zero. The returned size is undefined
	 * if the distance is less than zero.
	 *
	 * @param {Number} distance The distance from the eye point at which to determine pixel size, in model
	 * coordinates.
	 * @returns {Number} The approximate pixel size at the specified distance from the eye point, in model
	 * coordinates per pixel.
	 */


	WorldWindow.prototype.pixelSizeAtDistance = function (distance) {
	  this.computeViewingTransform(this.scratchProjection, this.scratchModelview);
	  var pixelMetrics = this.computePixelMetrics(this.scratchProjection);
	  return pixelMetrics.pixelSizeFactor * distance + pixelMetrics.pixelSizeOffset;
	}; // Internal. Intentionally not documented.


	WorldWindow.prototype.computeDrawContext = function () {
	  var dc = this.drawContext;
	  this.computeViewingTransform(dc.projection, dc.modelview);
	  dc.viewport = this.viewport;
	  dc.eyePoint = dc.modelview.extractEyePoint(new Vec3$1(0, 0, 0));
	  dc.modelviewProjection.setToIdentity();
	  dc.modelviewProjection.setToMultiply(dc.projection, dc.modelview);
	  var pixelMetrics = this.computePixelMetrics(dc.projection);
	  dc.pixelSizeFactor = pixelMetrics.pixelSizeFactor;
	  dc.pixelSizeOffset = pixelMetrics.pixelSizeOffset; // Compute the inverse of the modelview, projection, and modelview-projection matrices. The inverse matrices
	  // are used to support operations on navigator state.

	  var modelviewInv = Matrix.fromIdentity();
	  modelviewInv.invertOrthonormalMatrix(dc.modelview);
	  dc.modelviewNormalTransform = Matrix.fromIdentity().setToTransposeOfMatrix(modelviewInv.upper3By3()); // Compute the frustum in model coordinates. Start by computing the frustum in eye coordinates from the
	  // projection matrix, then transform this frustum to model coordinates by multiplying its planes by the
	  // transpose of the modelview matrix. We use the transpose of the modelview matrix because planes are
	  // transformed by the inverse transpose of a matrix, and we want to transform from eye coordinates to model
	  // coordinates.

	  var modelviewTranspose = Matrix.fromIdentity();
	  modelviewTranspose.setToTransposeOfMatrix(dc.modelview);
	  dc.frustumInModelCoordinates = Frustum.fromProjectionMatrix(dc.projection);
	  dc.frustumInModelCoordinates.transformByMatrix(modelviewTranspose);
	  dc.frustumInModelCoordinates.normalize();
	}; // Internal. Intentionally not documented.


	WorldWindow.prototype.resetDrawContext = function () {
	  this.globe.offset = 0;
	  var dc = this.drawContext;
	  dc.reset();
	  dc.globe = this.globe;
	  dc.navigator = this.navigator;
	  dc.layers = this.layers.slice();
	  dc.layers.push(dc.screenCreditController);
	  this.computeDrawContext();
	  dc.verticalExaggeration = this.verticalExaggeration;
	  dc.surfaceOpacity = this.surfaceOpacity;
	  dc.deepPicking = this.deepPicking;
	  dc.frameStatistics = this.frameStatistics;
	  dc.pixelScale = this.pixelScale;
	  dc.update();
	};
	/* useful stuff to debug WebGL */

	/*
	 function logGLCall(functionName, args) {
	 console.log("gl." + functionName + "(" +
	 WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");
	 };

	 function validateNoneOfTheArgsAreUndefined(functionName, args) {
	 for (var ii = 0; ii < args.length; ++ii) {
	 if (args[ii] === undefined) {
	 console.error("undefined passed to gl." + functionName + "(" +
	 WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");
	 }
	 }
	 };

	 WorldWindow.prototype.logAndValidate = function logAndValidate(functionName, args) {
	 logGLCall(functionName, args);
	 validateNoneOfTheArgsAreUndefined (functionName, args);
	 };

	 WorldWindow.prototype.throwOnGLError = function throwOnGLError(err, funcName, args) {
	 throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
	 };
	 */
	// Internal function. Intentionally not documented.


	WorldWindow.prototype.drawFrame = function () {
	  try {
	    this.drawContext.frameStatistics.beginFrame();
	    this.beginFrame();

	    if (this.drawContext.globe.is2D() && this.drawContext.globe.continuous) {
	      this.do2DContiguousRepaint();
	    } else {
	      this.doNormalRepaint();
	    }
	  } finally {
	    this.endFrame();
	    this.drawContext.frameStatistics.endFrame(); //console.log(this.drawContext.frameStatistics.frameTime);
	  }
	};

	WorldWindow.prototype.doNormalRepaint = function () {
	  this.createTerrain();
	  this.clearFrame();
	  this.deferOrderedRendering = false;

	  if (this.drawContext.pickingMode) {
	    if (this.drawContext.makePickFrustum()) {
	      this.doPick();
	      this.resolvePick();
	    }
	  } else {
	    this.doDraw();

	    if (this.subsurfaceMode && this.hasStencilBuffer) {
	      this.redrawSurface();
	      this.drawScreenRenderables();
	    }
	  }
	};

	WorldWindow.prototype.do2DContiguousRepaint = function () {
	  this.createTerrain2DContiguous();
	  this.clearFrame();

	  if (this.drawContext.pickingMode) {
	    if (this.drawContext.makePickFrustum()) {
	      this.pick2DContiguous();
	      this.resolvePick();
	    }
	  } else {
	    this.draw2DContiguous();
	  }
	};

	WorldWindow.prototype.resolvePick = function () {
	  if (this.drawContext.pickTerrainOnly) {
	    this.resolveTerrainPick();
	  } else if (this.drawContext.regionPicking) {
	    this.resolveRegionPick();
	  } else {
	    this.resolveTopPick();
	  }
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.beginFrame = function () {
	  var gl = this.drawContext.currentGlContext;
	  gl.enable(gl.BLEND);
	  gl.enable(gl.CULL_FACE);
	  gl.enable(gl.DEPTH_TEST);
	  gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	  gl.depthFunc(gl.LEQUAL);

	  if (this.drawContext.pickingMode) {
	    this.drawContext.makePickFramebuffer();
	    this.drawContext.bindFramebuffer(this.drawContext.pickFramebuffer);
	  }
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.endFrame = function () {
	  var gl = this.drawContext.currentGlContext;
	  gl.disable(gl.BLEND);
	  gl.disable(gl.CULL_FACE);
	  gl.disable(gl.DEPTH_TEST);
	  gl.blendFunc(gl.ONE, gl.ZERO);
	  gl.depthFunc(gl.LESS);
	  gl.clearColor(0, 0, 0, 1);
	  this.drawContext.bindFramebuffer(null);
	  this.drawContext.bindProgram(null);
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.clearFrame = function () {
	  var dc = this.drawContext,
	      gl = dc.currentGlContext;
	  gl.clearColor(dc.clearColor.red, dc.clearColor.green, dc.clearColor.blue, dc.clearColor.alpha);
	  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.doDraw = function () {
	  this.drawContext.renderShapes = true;

	  if (this.subsurfaceMode && this.hasStencilBuffer) {
	    // Draw the surface and collect the ordered renderables.
	    this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);
	    this.drawContext.surfaceShapeTileBuilder.clear();
	    this.drawLayers(true);
	    this.drawSurfaceRenderables();
	    this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

	    if (!this.deferOrderedRendering) {
	      // Clear the depth and stencil buffers prior to rendering the ordered renderables. This allows
	      // sub-surface renderables to be drawn beneath the terrain. Turn on stenciling to capture the
	      // fragments that ordered renderables draw. The terrain and surface shapes will be subsequently
	      // drawn again, and the stencil buffer will ensure that they are drawn only where they overlap
	      // the fragments drawn by the ordered renderables.
	      this.drawContext.currentGlContext.clear(this.drawContext.currentGlContext.DEPTH_BUFFER_BIT | this.drawContext.currentGlContext.STENCIL_BUFFER_BIT);
	      this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);
	      this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.ALWAYS, 1, 1);
	      this.drawContext.currentGlContext.stencilOp(this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE);
	      this.drawOrderedRenderables();
	    }
	  } else {
	    this.drawContext.surfaceShapeTileBuilder.clear();
	    this.drawLayers(true);
	    this.drawSurfaceRenderables();
	    this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

	    if (!this.deferOrderedRendering) {
	      this.drawOrderedRenderables();
	      this.drawScreenRenderables();
	    }
	  }
	};

	WorldWindow.prototype.redrawSurface = function () {
	  // Draw the terrain and surface shapes but only where the current stencil buffer is non-zero.
	  // The non-zero fragments are from drawing the ordered renderables previously.
	  this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);
	  this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.EQUAL, 1, 1);
	  this.drawContext.currentGlContext.stencilOp(this.drawContext.currentGlContext.KEEP, this.drawContext.currentGlContext.KEEP, this.drawContext.currentGlContext.KEEP);
	  this.drawContext.surfaceShapeTileBuilder.clear();
	  this.drawLayers(false);
	  this.drawSurfaceRenderables();
	  this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);
	  this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.doPick = function () {
	  if (this.drawContext.terrain) {
	    this.drawContext.terrain.pick(this.drawContext);
	  }

	  if (!this.drawContext.pickTerrainOnly) {
	    if (this.subsurfaceMode && this.hasStencilBuffer) {
	      // Draw the surface and collect the ordered renderables.
	      this.drawContext.currentGlContext.disable(this.drawContext.currentGlContext.STENCIL_TEST);
	      this.drawContext.surfaceShapeTileBuilder.clear();
	      this.drawLayers(true);
	      this.drawSurfaceRenderables();
	      this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

	      if (!this.deferOrderedRendering) {
	        // Clear the depth and stencil buffers prior to rendering the ordered renderables. This allows
	        // sub-surface renderables to be drawn beneath the terrain. Turn on stenciling to capture the
	        // fragments that ordered renderables draw. The terrain and surface shapes will be subsequently
	        // drawn again, and the stencil buffer will ensure that they are drawn only where they overlap
	        // the fragments drawn by the ordered renderables.
	        this.drawContext.currentGlContext.clear(this.drawContext.currentGlContext.DEPTH_BUFFER_BIT | this.drawContext.currentGlContext.STENCIL_BUFFER_BIT);
	        this.drawContext.currentGlContext.enable(this.drawContext.currentGlContext.STENCIL_TEST);
	        this.drawContext.currentGlContext.stencilFunc(this.drawContext.currentGlContext.ALWAYS, 1, 1);
	        this.drawContext.currentGlContext.stencilOp(this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE, this.drawContext.currentGlContext.REPLACE);
	        this.drawOrderedRenderables();
	        this.drawContext.terrain.pick(this.drawContext);
	        this.drawScreenRenderables();
	      }
	    } else {
	      this.drawContext.surfaceShapeTileBuilder.clear();
	      this.drawLayers(true);
	      this.drawSurfaceRenderables();
	      this.drawContext.surfaceShapeTileBuilder.doRender(this.drawContext);

	      if (!this.deferOrderedRendering) {
	        this.drawOrderedRenderables();
	        this.drawScreenRenderables();
	      }
	    }
	  }
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.createTerrain = function () {
	  var dc = this.drawContext;
	  dc.terrain = this.globe.tessellator.tessellate(dc);
	  dc.frameStatistics.setTerrainTileCount(dc.terrain ? dc.terrain.surfaceGeometry.length : 0);
	};

	WorldWindow.prototype.makeCurrent = function (offset) {
	  var dc = this.drawContext;
	  dc.globe.offset = offset;
	  dc.globeStateKey = dc.globe.stateKey;

	  switch (offset) {
	    case -1:
	      dc.terrain = this.terrainLeft;
	      break;

	    case 0:
	      dc.terrain = this.terrainCenter;
	      break;

	    case 1:
	      dc.terrain = this.terrainRight;
	      break;
	  }
	};

	WorldWindow.prototype.createTerrain2DContiguous = function () {
	  var dc = this.drawContext;
	  this.terrainCenter = null;
	  dc.globe.offset = 0;
	  dc.globeStateKey = dc.globe.stateKey;

	  if (dc.globe.intersectsFrustum(dc.frustumInModelCoordinates)) {
	    this.terrainCenter = dc.globe.tessellator.tessellate(dc);
	  }

	  this.terrainRight = null;
	  dc.globe.offset = 1;
	  dc.globeStateKey = dc.globe.stateKey;

	  if (dc.globe.intersectsFrustum(dc.frustumInModelCoordinates)) {
	    this.terrainRight = dc.globe.tessellator.tessellate(dc);
	  }

	  this.terrainLeft = null;
	  dc.globe.offset = -1;
	  dc.globeStateKey = dc.globe.stateKey;

	  if (dc.globe.intersectsFrustum(dc.frustumInModelCoordinates)) {
	    this.terrainLeft = dc.globe.tessellator.tessellate(dc);
	  }
	};

	WorldWindow.prototype.draw2DContiguous = function () {

	  if (this.terrainCenter) {
	    this.makeCurrent(0);
	    this.deferOrderedRendering = this.terrainLeft || this.terrainRight;
	    this.doDraw();
	  }

	  if (this.terrainRight) {
	    this.makeCurrent(1);
	    this.deferOrderedRendering = this.terrainLeft || this.terrainLeft;
	    this.doDraw();
	  }

	  this.deferOrderedRendering = false;

	  if (this.terrainLeft) {
	    this.makeCurrent(-1);
	    this.doDraw();
	  } //
	  //console.log(drawing);


	  if (this.subsurfaceMode && this.hasStencilBuffer) {
	    this.deferOrderedRendering = true;

	    if (this.terrainCenter) {
	      this.makeCurrent(0);
	      this.redrawSurface();
	    }

	    if (this.terrainRight) {
	      this.makeCurrent(1);
	      this.redrawSurface();
	    }

	    if (this.terrainLeft) {
	      this.makeCurrent(-1);
	      this.redrawSurface();
	    }
	  }

	  this.drawScreenRenderables();
	};

	WorldWindow.prototype.pick2DContiguous = function () {
	  if (this.terrainCenter) {
	    this.makeCurrent(0);
	    this.deferOrderedRendering = this.terrainLeft || this.terrainRight;
	    this.doPick();
	  }

	  if (this.terrainRight) {
	    this.makeCurrent(1);
	    this.deferOrderedRendering = this.terrainLeft || this.terrainLeft;
	    this.doPick();
	  }

	  this.deferOrderedRendering = false;

	  if (this.terrainLeft) {
	    this.makeCurrent(-1);
	    this.doPick();
	  }
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.drawLayers = function (accumulateOrderedRenderables) {
	  // Draw all the layers attached to this WorldWindow.
	  var beginTime = Date.now(),
	      dc = this.drawContext,
	      layers = dc.layers,
	      layer;
	  dc.accumulateOrderedRenderables = accumulateOrderedRenderables;

	  for (var i = 0, len = layers.length; i < len; i++) {
	    layer = layers[i];

	    if (layer) {
	      dc.currentLayer = layer;

	      try {
	        layer.render(dc);
	      } catch (e) {
	        Logger$1.log(Logger$1.LEVEL_SEVERE, "Error while rendering layer " + layer.displayName + ".\n" + e.toString()); // Keep going. Render the rest of the layers.
	      }
	    }
	  }

	  dc.currentLayer = null;
	  var now = Date.now();
	  dc.frameStatistics.layerRenderingTime = now - beginTime;
	};
	/**
	 * Adds a specified layer to the end of this WorldWindow.
	 * @param {Layer} layer The layer to add. May be null or undefined, in which case this WorldWindow is not
	 * modified.
	 */


	WorldWindow.prototype.addLayer = function (layer) {
	  if (layer) {
	    this.layers.push(layer);
	  }
	};
	/**
	 * Removes the first instance of a specified layer from this WorldWindow.
	 * @param {Layer} layer The layer to remove. May be null or undefined, in which case this WorldWindow is not
	 * modified. This WorldWindow is also not modified if the specified layer does not exist in this WorldWindow's
	 * layer list.
	 */


	WorldWindow.prototype.removeLayer = function (layer) {
	  var index = this.indexOfLayer(layer);

	  if (index >= 0) {
	    this.layers.splice(index, 1);
	  }
	};
	/**
	 * Inserts a specified layer at a specified position in this WorldWindow.
	 * @param {Number} index The index at which to insert the layer. May be negative to specify the position
	 * from the end of the array.
	 * @param {Layer} layer The layer to insert. May be null or undefined, in which case this WorldWindow is not
	 * modified.
	 */


	WorldWindow.prototype.insertLayer = function (index, layer) {
	  if (layer) {
	    this.layers.splice(index, 0, layer);
	  }
	};
	/**
	 * Returns the index of a specified layer in this WorldWindow.
	 * @param {Layer} layer The layer to search for.
	 * @returns {Number} The index of the specified layer or -1 if it doesn't exist in this WorldWindow.
	 */


	WorldWindow.prototype.indexOfLayer = function (layer) {
	  return this.layers.indexOf(layer);
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.drawSurfaceRenderables = function () {
	  var dc = this.drawContext,
	      sr;
	  dc.reverseSurfaceRenderables();

	  while (sr = dc.popSurfaceRenderable()) {
	    try {
	      sr.renderSurface(dc);
	    } catch (e) {
	      Logger$1.logMessage(Logger$1.LEVEL_WARNING, "WorldWindow", "drawSurfaceRenderables", "Error while rendering a surface renderable.\n" + e.message); // Keep going. Render the rest of the surface renderables.
	    }
	  }
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.drawOrderedRenderables = function () {
	  var beginTime = Date.now(),
	      dc = this.drawContext,
	      or;
	  dc.sortOrderedRenderables();

	  if (this._orderedRenderingFilters) {
	    for (var f = 0; f < this._orderedRenderingFilters.length; f++) {
	      this._orderedRenderingFilters[f](this.drawContext);
	    }
	  }

	  dc.orderedRenderingMode = true;

	  while (or = dc.popOrderedRenderable()) {
	    try {
	      or.renderOrdered(dc);
	    } catch (e) {
	      Logger$1.logMessage(Logger$1.LEVEL_WARNING, "WorldWindow", "drawOrderedRenderables", "Error while rendering an ordered renderable.\n" + e.message); // Keep going. Render the rest of the ordered renderables.
	    }
	  }

	  dc.orderedRenderingMode = false;
	  dc.frameStatistics.orderedRenderingTime = Date.now() - beginTime;
	};

	WorldWindow.prototype.drawScreenRenderables = function () {
	  var dc = this.drawContext,
	      or;

	  while (or = dc.nextScreenRenderable()) {
	    try {
	      or.renderOrdered(dc);
	    } catch (e) {
	      Logger$1.logMessage(Logger$1.LEVEL_WARNING, "WorldWindow", "drawOrderedRenderables", "Error while rendering a screen renderable.\n" + e.message); // Keep going. Render the rest of the screen renderables.
	    }
	  }
	}; // Internal function. Intentionally not documented.


	WorldWindow.prototype.resolveTopPick = function () {
	  if (this.drawContext.objectsAtPickPoint.objects.length == 0) {
	    return; // nothing picked; avoid calling readPickColor unnecessarily
	  } // Make a last reading to determine what's on top.


	  var pickedObjects = this.drawContext.objectsAtPickPoint,
	      pickColor = this.drawContext.readPickColor(this.drawContext.pickPoint),
	      topObject = null,
	      terrainObject = null;

	  if (pickColor) {
	    // Find the picked object with the top color code and set its isOnTop flag.
	    for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {
	      var po = pickedObjects.objects[i];

	      if (po.isTerrain) {
	        terrainObject = po;
	      }

	      if (po.color.equals(pickColor)) {
	        po.isOnTop = true;
	        topObject = po;

	        if (terrainObject) {
	          break; // no need to search for more than the top object and the terrain object
	        }
	      }
	    } // In single-pick mode provide only the top-most object and the terrain object, if any.


	    if (!this.drawContext.deepPicking) {
	      pickedObjects.clear();

	      if (topObject) {
	        pickedObjects.add(topObject);
	      }

	      if (terrainObject && terrainObject != topObject) {
	        pickedObjects.add(terrainObject);
	      }
	    }
	  } else {
	    pickedObjects.clear(); // nothing drawn at the pick point
	  }
	}; // Internal. Intentionally not documented.


	WorldWindow.prototype.resolveTerrainPick = function () {
	  var pickedObjects = this.drawContext.objectsAtPickPoint,
	      po; // Mark the first picked terrain object as "on top". The picked object list should contain only one entry
	  // indicating the picked terrain object, but we iterate over the list contents anyway.

	  for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {
	    po = pickedObjects.objects[i];

	    if (po.isTerrain) {
	      po.isOnTop = true;
	      break;
	    }
	  }
	}; // Internal. Intentionally not documented.


	WorldWindow.prototype.resolveRegionPick = function () {
	  if (this.drawContext.objectsAtPickPoint.objects.length == 0) {
	    return; // nothing picked; avoid calling readPickColors unnecessarily
	  } // Mark every picked object with a color in the pick buffer as "on top".


	  var pickedObjects = this.drawContext.objectsAtPickPoint,
	      uniquePickColors = this.drawContext.readPickColors(this.drawContext.pickRectangle),
	      po,
	      color;

	  for (var i = 0, len = pickedObjects.objects.length; i < len; i++) {
	    po = pickedObjects.objects[i];
	    if (!po) continue;
	    var poColor = po.color.toByteString();
	    color = uniquePickColors[poColor];

	    if (color) {
	      po.isOnTop = true;
	    } else if (po.userObject instanceof SurfaceShape) {
	      // SurfaceShapes ALWAYS get added to the pick list, since their rendering is deferred
	      // until the tile they are cached by is rendered. So a SurfaceShape may be in the pick list
	      // but is not seen in the pick rectangle.
	      //
	      // Remove the SurfaceShape that was not visible to the pick rectangle.
	      pickedObjects.objects.splice(i, 1);
	      i -= 1;
	    }
	  }
	}; // Internal. Intentionally not documented.


	WorldWindow.prototype.callRedrawCallbacks = function (stage) {
	  for (var i = 0, len = this._redrawCallbacks.length; i < len; i++) {
	    try {
	      this._redrawCallbacks[i](this, stage);
	    } catch (e) {
	      Logger$1.log(Logger$1.LEVEL_SEVERE, "Exception calling redraw callback.\n" + e.toString()); // Keep going. Execute the rest of the callbacks.
	    }
	  }
	};
	/**
	 * Moves this WorldWindow's navigator to a specified location or position.
	 * @param {Location | Position} position The location or position to move the navigator to. If this
	 * argument contains an "altitude" property, as {@link Position} does, the end point of the navigation is
	 * at the specified altitude. Otherwise the end point is at the current altitude of the navigator.
	 *
	 * This function uses this WorldWindow's {@link GoToAnimator} property to perform the move. That object's
	 * properties can be specified by the application to modify its behavior during calls to this function.
	 * It's cancel method can also be used to cancel the move initiated by this function.
	 * @param {Function} completionCallback If not null or undefined, specifies a function to call when the
	 * animation completes. The completion callback is called with a single argument, this animator.
	 * @throws {ArgumentError} If the specified location or position is null or undefined.
	 */


	WorldWindow.prototype.goTo = function (position, completionCallback) {
	  this.goToAnimator.goTo(position, completionCallback);
	};
	/**
	 * Declutters the current ordered renderables with a specified group ID. This function is not called by
	 * applications directly. It's meant to be invoked as an ordered rendering filter in this WorldWindow's
	 * [orderedRenderingFilters]{@link WorldWindow#orderedRenderingFilters} property.
	 * <p>
	 * The function operates by setting the target visibility of occluded shapes to 0 and unoccluded shapes to 1.
	 * @param {DrawContext} dc The current draw context.
	 * @param {Number} groupId The ID of the group to declutter. Must not be null, undefined or 0.
	 * @throws {ArgumentError} If the specified group ID is null, undefined or 0.
	 */


	WorldWindow.prototype.declutter = function (dc, groupId) {
	  if (!groupId) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindow", "declutter", "Group ID is null, undefined or 0."));
	  } // Collect all the declutterables in the specified group.


	  var declutterables = [];

	  for (var i = 0; i < dc.orderedRenderables.length; i++) {
	    var orderedRenderable = dc.orderedRenderables[i].orderedRenderable;

	    if (orderedRenderable.declutterGroup === groupId) {
	      declutterables.push(orderedRenderable);
	    }
	  } // Filter the declutterables by determining which are partially occluded. Since the ordered renderable
	  // list was already sorted from front to back, the front-most will represent an entire occluded group.


	  var rects = [];

	  for (var j = 0; j < declutterables.length; j++) {
	    var declutterable = declutterables[j],
	        screenBounds = declutterable.screenBounds;

	    if (screenBounds && screenBounds.intersectsRectangles(rects)) {
	      declutterable.targetVisibility = 0;
	    } else {
	      declutterable.targetVisibility = 1;

	      if (screenBounds) {
	        rects.push(screenBounds);
	      }
	    }
	  }
	};
	/**
	 * Computes a ray originating at the eyePoint and extending through the specified point in window
	 * coordinates.
	 * <p>
	 * The specified point is understood to be in the window coordinate system of the WorldWindow, with the origin
	 * in the top-left corner and axes that extend down and to the right from the origin point.
	 * <p>
	 * The results of this method are undefined if the specified point is outside of the WorldWindow's
	 * bounds.
	 *
	 * @param {Vec2} point The window coordinates point to compute a ray for.
	 * @returns {Line} A new Line initialized to the origin and direction of the computed ray, or null if the
	 * ray could not be computed.
	 */


	WorldWindow.prototype.rayThroughScreenPoint = function (point) {
	  if (!point) {
	    throw new ArgumentError$1(Logger$1.logMessage(Logger$1.LEVEL_SEVERE, "WorldWindow", "rayThroughScreenPoint", "missingPoint"));
	  } // Convert the point's xy coordinates from window coordinates to WebGL screen coordinates.


	  var screenPoint = new Vec3$1(point[0], this.viewport.height - point[1], 0),
	      nearPoint = new Vec3$1(0, 0, 0),
	      farPoint = new Vec3$1(0, 0, 0);
	  this.computeViewingTransform(this.scratchProjection, this.scratchModelview);
	  var modelviewProjection = Matrix.fromIdentity();
	  modelviewProjection.setToMultiply(this.scratchProjection, this.scratchModelview);
	  var modelviewProjectionInv = Matrix.fromIdentity();
	  modelviewProjectionInv.invertMatrix(modelviewProjection); // Compute the model coordinate point on the near clip plane with the xy coordinates and depth 0.

	  if (!modelviewProjectionInv.unProject(screenPoint, this.viewport, nearPoint)) {
	    return null;
	  } // Compute the model coordinate point on the far clip plane with the xy coordinates and depth 1.


	  screenPoint[2] = 1;

	  if (!modelviewProjectionInv.unProject(screenPoint, this.viewport, farPoint)) {
	    return null;
	  }

	  var eyePoint = this.scratchModelview.extractEyePoint(new Vec3$1(0, 0, 0)); // Compute a ray originating at the eye point and with direction pointing from the xy coordinate on the near
	  // plane to the same xy coordinate on the far plane.

	  var origin = new Vec3$1(eyePoint[0], eyePoint[1], eyePoint[2]),
	      direction = new Vec3$1(farPoint[0], farPoint[1], farPoint[2]);
	  direction.subtract(nearPoint);
	  direction.normalize();
	  return new Line(origin, direction);
	};

	/**
	 * @exports WWMessage
	 */

	/**
	 * Create a WWMessage instance.
	 * @classdesc Defines a class to hold message information.
	 * @param {String} type The message type.
	 * @param {{}} source The source of the message.
	 * @constructor
	 */
	function WWMessage(type, source) {
	  /**
	   * This object's message type.
	   * @type {String}
	   * @readonly
	   */
	  this.type = type;
	  /**
	   * The source object of this message.
	   * @type {{}}
	   * @readonly
	   */

	  this.source = source;
	}

	class URLBuilder {
	  urlForTile(tile, imageFormat) {
	    return `http://localhost:2020/api/Map/Tiles?x=${tile.column}&y=${tile.row}&z=${tile.level.levelNumber + 1}`;
	  }

	}

	class XYZLayer extends MercatorTiledImageLayer {
	  constructor() {
	    let imageSize = 256;
	    let displayName = 'Bing';
	    super(new Sector(-85.05, 85.05, -180, 180), new Location(85.05, 180), 23, "image/jpeg", displayName, imageSize, imageSize);
	    this.imageSize = imageSize;
	    this.displayName = displayName;
	    this.urlBuilder = new URLBuilder();
	  }

	  createTopLevelTiles(dc) {
	    this.topLevelTiles = [];
	    this.topLevelTiles.push(this.createTile(null, this.levels.firstLevel(), 0, 0));
	    this.topLevelTiles.push(this.createTile(null, this.levels.firstLevel(), 0, 1));
	    this.topLevelTiles.push(this.createTile(null, this.levels.firstLevel(), 1, 0));
	    this.topLevelTiles.push(this.createTile(null, this.levels.firstLevel(), 1, 1));
	  }

	  mapSizeForLevel(levelNumber) {
	    return 256 << levelNumber + 1;
	  }

	}

	/**
	 * This is the top-level WorldWind module. It is global.
	 * @exports WorldWind
	 * @global
	 */

	var WorldWind$1 = {
	  /**
	   * The WorldWind version number.
	   * @default "0.9.0"
	   * @constant
	   */
	  VERSION: "0.9.0",
	  // PLEASE KEEP THE ENTRIES BELOW IN ALPHABETICAL ORDER

	  /**
	   * Indicates an altitude mode relative to the globe's ellipsoid.
	   * @constant
	   */
	  ABSOLUTE: "absolute",

	  /**
	   * Indicates that a redraw callback has been called immediately after a redraw.
	   * @constant
	   */
	  AFTER_REDRAW: "afterRedraw",

	  /**
	   * Indicates that a redraw callback has been called immediately before a redraw.
	   * @constant
	   */
	  BEFORE_REDRAW: "beforeRedraw",

	  /**
	   * The BEGAN gesture recognizer state. Continuous gesture recognizers transition to this state from the
	   * POSSIBLE state when the gesture is first recognized.
	   * @constant
	   */
	  BEGAN: "began",

	  /**
	   * The CANCELLED gesture recognizer state. Continuous gesture recognizers may transition to this state from
	   * the BEGAN state or the CHANGED state when the touch events are cancelled.
	   * @constant
	   */
	  CANCELLED: "cancelled",

	  /**
	   * The CHANGED gesture recognizer state. Continuous gesture recognizers transition to this state from the
	   * BEGAN state or the CHANGED state, whenever an input event indicates a change in the gesture.
	   * @constant
	   */
	  CHANGED: "changed",

	  /**
	   * Indicates an altitude mode always on the terrain.
	   * @constant
	   */
	  CLAMP_TO_GROUND: "clampToGround",

	  /**
	   * The radius of Earth.
	   * @constant
	   * @deprecated Use WGS84_SEMI_MAJOR_AXIS instead.
	   */
	  EARTH_RADIUS: 6371e3,

	  /**
	   * Indicates the cardinal direction east.
	   * @constant
	   */
	  EAST: "east",

	  /**
	   * The ENDED gesture recognizer state. Continuous gesture recognizers transition to this state from either
	   * the BEGAN state or the CHANGED state when the current input no longer represents the gesture.
	   * @constant
	   */
	  ENDED: "ended",

	  /**
	   * The FAILED gesture recognizer state. Gesture recognizers transition to this state from the POSSIBLE state
	   * when the gesture cannot be recognized given the current input.
	   * @constant
	   */
	  FAILED: "failed",

	  /**
	   * Indicates a linear filter.
	   * @constant
	   */
	  FILTER_LINEAR: "filter_linear",

	  /**
	   * Indicates a nearest neighbor filter.
	   * @constant
	   */
	  FILTER_NEAREST: "filter_nearest",

	  /**
	   * Indicates a great circle path.
	   * @constant
	   */
	  GREAT_CIRCLE: "greatCircle",

	  /**
	   * Indicates a linear, straight line path.
	   * @constant
	   */
	  LINEAR: "linear",

	  /**
	   * Indicates a multi-point shape, typically within a shapefile.
	   */
	  MULTI_POINT: "multiPoint",

	  /**
	   * Indicates the cardinal direction north.
	   * @constant
	   */
	  NORTH: "north",

	  /**
	   * Indicates a null shape, typically within a shapefile.
	   * @constant
	   */
	  NULL: "null",

	  /**
	   * Indicates that the associated parameters are fractional values of the virtual rectangle's width or
	   * height in the range [0, 1], where 0 indicates the rectangle's origin and 1 indicates the corner
	   * opposite its origin.
	   * @constant
	   */
	  OFFSET_FRACTION: "fraction",

	  /**
	   * Indicates that the associated parameters are in units of pixels relative to the virtual rectangle's
	   * corner opposite its origin corner.
	   * @constant
	   */
	  OFFSET_INSET_PIXELS: "insetPixels",

	  /**
	   * Indicates that the associated parameters are in units of pixels relative to the virtual rectangle's
	   * origin.
	   * @constant
	   */
	  OFFSET_PIXELS: "pixels",

	  /**
	   * Indicates a point shape, typically within a shapefile.
	   */
	  POINT: "point",

	  /**
	   * Indicates a polyline shape, typically within a shapefile.
	   */
	  POLYLINE: "polyline",

	  /**
	   * Indicates a polygon shape, typically within a shapefile.
	   */
	  POLYGON: "polygon",

	  /**
	   * The POSSIBLE gesture recognizer state. Gesture recognizers in this state are idle when there is no input
	   * event to evaluate, or are evaluating input events to determine whether or not to transition into another
	   * state.
	   * @constant
	   */
	  POSSIBLE: "possible",

	  /**
	   * The RECOGNIZED gesture recognizer state. Discrete gesture recognizers transition to this state from the
	   * POSSIBLE state when the gesture is recognized.
	   * @constant
	   */
	  RECOGNIZED: "recognized",

	  /**
	   * The event name of WorldWind redraw events.
	   */
	  REDRAW_EVENT_TYPE: "WorldWindRedraw",

	  /**
	   * Indicates that the related value is specified relative to the globe.
	   * @constant
	   */
	  RELATIVE_TO_GLOBE: "relativeToGlobe",

	  /**
	   * Indicates an altitude mode relative to the terrain.
	   * @constant
	   */
	  RELATIVE_TO_GROUND: "relativeToGround",

	  /**
	   * Indicates that the related value is specified relative to the plane of the screen.
	   * @constant
	   */
	  RELATIVE_TO_SCREEN: "relativeToScreen",

	  /**
	   * Indicates a rhumb path -- a path of constant bearing.
	   * @constant
	   */
	  RHUMB_LINE: "rhumbLine",

	  /**
	   * Indicates the cardinal direction south.
	   * @constant
	   */
	  SOUTH: "south",

	  /**
	   * Indicates the cardinal direction west.
	   * @constant
	   */
	  WEST: "west",

	  /**
	   * WGS 84 reference value for Earth's semi-major axis: 6378137.0. Taken from NGA.STND.0036_1.0.0_WGS84,
	   * section 3.4.1.
	   * @constant
	   */
	  WGS84_SEMI_MAJOR_AXIS: 6378137.0,

	  /**
	   * WGS 84 reference value for Earth's inverse flattening: 298.257223563. Taken from
	   * NGA.STND.0036_1.0.0_WGS84, section 3.4.2.
	   * @constant
	   */
	  WGS84_INVERSE_FLATTENING: 298.257223563
	};
	WorldWind$1['AbstractError'] = AbstractError;
	WorldWind$1['Annotation'] = Annotation;
	WorldWind$1['AnnotationAttributes'] = AnnotationAttributes;
	WorldWind$1['AreaMeasurer'] = AreaMeasurer;
	WorldWind$1['ArgumentError'] = ArgumentError$1;
	WorldWind$1['AsterV2ElevationCoverage'] = AsterV2ElevationCoverage;
	WorldWind$1['AtmosphereLayer'] = AtmosphereLayer;
	WorldWind$1['AtmosphereProgram'] = AtmosphereProgram;
	WorldWind$1['BasicProgram'] = BasicProgram;
	WorldWind$1['BasicTextureProgram'] = BasicTextureProgram;
	WorldWind$1['BasicTimeSequence'] = BasicTimeSequence;
	WorldWind$1['BasicWorldWindowController'] = BasicWorldWindowController;
	WorldWind$1['BoundingBox'] = BoundingBox;
	WorldWind$1['ClickRecognizer'] = ClickRecognizer;
	WorldWind$1['Color'] = Color;
	WorldWind$1['Compass'] = Compass;
	WorldWind$1['DateWW'] = DateWW;
	WorldWind$1['DragRecognizer'] = DragRecognizer;
	WorldWind$1['DrawContext'] = DrawContext;
	WorldWind$1['EarthElevationModel'] = EarthElevationModel;
	WorldWind$1['EarthRestElevationCoverage'] = EarthRestElevationCoverage;
	WorldWind$1['ElevationCoverage'] = ElevationCoverage;
	WorldWind$1['ElevationModel'] = ElevationModel;
	WorldWind$1['Font'] = Font;
	WorldWind$1['FrameStatistics'] = FrameStatistics;
	WorldWind$1['FramebufferTexture'] = FramebufferTexture;
	WorldWind$1['FramebufferTile'] = FramebufferTile;
	WorldWind$1['FramebufferTileController'] = FramebufferTileController;
	WorldWind$1['Frustum'] = Frustum;
	WorldWind$1['GebcoElevationCoverage'] = GebcoElevationCoverage;
	WorldWind$1['GeographicMesh'] = GeographicMesh;
	WorldWind$1['GeographicProjection'] = GeographicProjection;
	WorldWind$1['GeographicText'] = GeographicText;
	WorldWind$1['GestureRecognizer'] = GestureRecognizer;
	WorldWind$1['Globe'] = Globe;
	WorldWind$1['Globe2D'] = Globe2D;
	WorldWind$1['GoToAnimator'] = GoToAnimator;
	WorldWind$1['GpuProgram'] = GpuProgram;
	WorldWind$1['GpuResourceCache'] = GpuResourceCache;
	WorldWind$1['GpuShader'] = GpuShader;
	WorldWind$1['GroundProgram'] = GroundProgram;
	WorldWind$1['HashMap'] = HashMap;
	WorldWind$1['HighlightController'] = HighlightController;
	WorldWind$1['ImageSource'] = ImageSource;
	WorldWind$1['ImageTile'] = ImageTile;
	WorldWind$1['Insets'] = Insets;
	WorldWind$1['Layer'] = Layer;
	WorldWind$1['LengthMeasurer'] = LengthMeasurer;
	WorldWind$1['Level'] = Level;
	WorldWind$1['LevelRowColumnUrlBuilder'] = LevelRowColumnUrlBuilder;
	WorldWind$1['LevelSet'] = LevelSet;
	WorldWind$1['Line'] = Line;
	WorldWind$1['Location'] = Location;
	WorldWind$1['LookAtNavigator'] = LookAtNavigator;
	WorldWind$1['Matrix'] = Matrix;
	WorldWind$1['MeasuredLocation'] = MeasuredLocation;
	WorldWind$1['MemoryCache'] = MemoryCache;
	WorldWind$1['MemoryCacheListener'] = MemoryCacheListener;
	WorldWind$1['MercatorTiledImageLayer'] = MercatorTiledImageLayer;
	WorldWind$1['Navigator'] = Navigator;
	WorldWind$1['NominatimGeocoder'] = NominatimGeocoder;
	WorldWind$1['NotYetImplementedError'] = NotYetImplementedError;
	WorldWind$1['Offset'] = Offset;
	WorldWind$1['PanRecognizer'] = PanRecognizer;
	WorldWind$1['Path'] = Path;
	WorldWind$1['PeriodicTimeSequence'] = PeriodicTimeSequence;
	WorldWind$1['PickedObject'] = PickedObject;
	WorldWind$1['PickedObjectList'] = PickedObjectList;
	WorldWind$1['PinchRecognizer'] = PinchRecognizer;
	WorldWind$1['Placemark'] = Placemark;
	WorldWind$1['PlacemarkAttributes'] = PlacemarkAttributes;
	WorldWind$1['Plane'] = Plane;
	WorldWind$1['Polygon'] = Polygon;
	WorldWind$1['Position'] = Position;
	WorldWind$1['ProjectionEquirectangular'] = ProjectionEquirectangular;
	WorldWind$1['ProjectionGnomonic'] = ProjectionGnomonic;
	WorldWind$1['ProjectionMercator'] = ProjectionMercator;
	WorldWind$1['ProjectionPolarEquidistant'] = ProjectionPolarEquidistant;
	WorldWind$1['ProjectionUPS'] = ProjectionUPS;
	WorldWind$1['ProjectionWgs84'] = ProjectionWgs84;
	WorldWind$1['Rectangle'] = Rectangle;
	WorldWind$1['Renderable'] = Renderable;
	WorldWind$1['RotationRecognizer'] = RotationRecognizer;
	WorldWind$1['ScreenText'] = ScreenText;
	WorldWind$1['ScreenImage'] = ScreenImage;
	WorldWind$1['Sector'] = Sector;
	WorldWind$1['ShapeAttributes'] = ShapeAttributes;
	WorldWind$1['SkyProgram'] = SkyProgram;
	WorldWind$1['StarFieldLayer'] = StarFieldLayer;
	WorldWind$1['StarFieldProgram'] = StarFieldProgram;
	WorldWind$1['SurfaceImage'] = SurfaceImage;
	WorldWind$1['SurfaceCircle'] = SurfaceCircle;
	WorldWind$1['SurfaceEllipse'] = SurfaceEllipse;
	WorldWind$1['SurfacePolygon'] = SurfacePolygon;
	WorldWind$1['SurfacePolyline'] = SurfacePolyline;
	WorldWind$1['SurfaceRectangle'] = SurfaceRectangle;
	WorldWind$1['SurfaceRenderable'] = SurfaceRenderable;
	WorldWind$1['SurfaceSector'] = SurfaceSector;
	WorldWind$1['SurfaceShape'] = SurfaceShape;
	WorldWind$1['SurfaceShapeTile'] = SurfaceShapeTile;
	WorldWind$1['SurfaceShapeTileBuilder'] = SurfaceShapeTileBuilder;
	WorldWind$1['SurfaceTile'] = SurfaceTile;
	WorldWind$1['SurfaceTileRenderer'] = SurfaceTileRenderer;
	WorldWind$1['SurfaceTileRendererProgram'] = SurfaceTileRendererProgram;
	WorldWind$1['TapRecognizer'] = TapRecognizer;
	WorldWind$1['Terrain'] = Terrain;
	WorldWind$1['TerrainTile'] = TerrainTile;
	WorldWind$1['TerrainTileList'] = TerrainTileList;
	WorldWind$1['Tessellator'] = Tessellator;
	WorldWind$1['Text'] = Text;
	WorldWind$1['TextAttributes'] = TextAttributes;
	WorldWind$1['TextRenderer'] = TextRenderer;
	WorldWind$1['Texture'] = Texture$1;
	WorldWind$1['TextureTile'] = TextureTile;
	WorldWind$1['Tile'] = Tile;
	WorldWind$1['TiledElevationCoverage'] = TiledElevationCoverage;
	WorldWind$1['TiledImageLayer'] = TiledImageLayer;
	WorldWind$1['TileFactory'] = TileFactory;
	WorldWind$1['TiltRecognizer'] = TiltRecognizer;
	WorldWind$1['Touch'] = Touch;
	WorldWind$1['TriangleMesh'] = TriangleMesh;
	WorldWind$1['UsgsNedElevationCoverage'] = UnsupportedOperationError$1;
	WorldWind$1['UsgsNedHiElevationCoverage'] = UsgsNedElevationCoverage;
	WorldWind$1['UnsupportedOperationError'] = UsgsNedHiElevationCoverage;
	WorldWind$1['UrlBuilder'] = UrlBuilder;
	WorldWind$1['Vec2'] = Vec2;
	WorldWind$1['Vec3'] = Vec3$1;
	WorldWind$1['WcsEarthElevationCoverage'] = WcsEarthElevationCoverage;
	WorldWind$1['WcsTileUrlBuilder'] = WcsTileUrlBuilder;
	WorldWind$1['WmsUrlBuilder'] = WmsUrlBuilder;
	WorldWind$1['WWMessage'] = WWMessage;
	WorldWind$1['WorldWindow'] = WorldWindow;
	WorldWind$1['WorldWindowController'] = WorldWindowController;
	WorldWind$1['XYZLayer'] = XYZLayer;
	/**
	 * Holds configuration parameters for WorldWind. Applications may modify these parameters prior to creating
	 * their first WorldWind objects. Configuration properties are:
	 * <ul>
	 *     <li><code>gpuCacheSize</code>: A Number indicating the size in bytes to allocate from GPU memory for
	 *     resources such as textures, GLSL programs and buffer objects. Default is 250e6 (250 MB).</li>
	 *     <li><code>baseUrl</code>: The URL of the directory containing the WorldWind Library and its resources.</li>
	 *     <li><code>layerRetrievalQueueSize</code>: The number of concurrent tile requests allowed per layer. The default is 16.</li>
	 *     <li><code>coverageRetrievalQueueSize</code>: The number of concurrent tile requests allowed per elevation coverage. The default is 16.</li>
	 *     <li><code>bingLogoPlacement</code>: An {@link Offset} to place a Bing logo attribution. The default is a 7px margin inset from the lower right corner of the screen.</li>
	 *     <li><code>bingLogoAlignment</code>: An {@link Offset} to align the Bing logo relative to its placement position. The default is the lower right corner of the logo.</li>
	 * </ul>
	 * @type {{gpuCacheSize: number}}
	 */

	WorldWind$1.configuration = {
	  gpuCacheSize: 250e6,
	  baseUrl: WWUtil.worldwindlibLocation() || WWUtil.currentUrlSansFilePart() + '/',
	  layerRetrievalQueueSize: 16,
	  coverageRetrievalQueueSize: 16,
	  bingLogoPlacement: new Offset(WorldWind$1.OFFSET_INSET_PIXELS, 7, WorldWind$1.OFFSET_PIXELS, 7),
	  bingLogoAlignment: new Offset(WorldWind$1.OFFSET_FRACTION, 1, WorldWind$1.OFFSET_FRACTION, 0)
	};
	/**
	 * Indicates the Bing Maps key to use when requesting Bing Maps resources.
	 * @type {String}
	 * @default null
	 */

	WorldWind$1.BingMapsKey = null;
	window.WorldWind = WorldWind$1;

	/**
	 * 场景菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class SceneMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleCreateEmptyScene = this.handleCreateEmptyScene.bind(this);
	    this.handleCreateDistrictAndIndoor = this.handleCreateDistrictAndIndoor.bind(this);
	    this.handleCreateGISScene = this.handleCreateGISScene.bind(this);
	    this.handleSaveScene = this.handleSaveScene.bind(this);
	    this.handleSaveAsScene = this.handleSaveAsScene.bind(this);
	    this.handleExportSceneToJson = this.handleExportSceneToJson.bind(this);
	    this.handleExportSceneToCollada = this.handleExportSceneToCollada.bind(this);
	    this.handleExportSceneToGltf = this.handleExportSceneToGltf.bind(this);
	    this.handleExportSceneToOBJ = this.handleExportSceneToOBJ.bind(this);
	    this.handleExportSceneToPLY = this.handleExportSceneToPLY.bind(this);
	    this.handleExportSceneToSTL = this.handleExportSceneToSTL.bind(this);
	    this.handlePublishScene = this.handlePublishScene.bind(this);
	  }

	  render() {
	    const {
	      enableAuthority,
	      isLogin,
	      authorities
	    } = app.server;
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Scene')
	    }, !enableAuthority || isLogin ? /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('New')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Empty Scene'),
	      onClick: this.handleCreateEmptyScene
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('District (Test)'),
	      onClick: this.handleCreateDistrictAndIndoor
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('GIS Scene (Test)'),
	      onClick: this.handleCreateGISScene
	    })) : null, !enableAuthority || authorities.includes('SAVE_SCENE') ? /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Save'),
	      onClick: this.handleSaveScene
	    }) : null, !enableAuthority || authorities.includes('SAVE_SCENE') ? /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Save As'),
	      onClick: this.handleSaveAsScene
	    }) : null, !enableAuthority || authorities.includes('SAVE_SCENE') ? /*#__PURE__*/React.createElement(MenuItemSeparator, null) : null, !enableAuthority || isLogin ? /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Export Scene')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('To JSON File'),
	      onClick: this.handleExportSceneToJson
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('To Collada File'),
	      onClick: this.handleExportSceneToCollada
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('To GLTF File'),
	      onClick: this.handleExportSceneToGltf
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('To OBJ File'),
	      onClick: this.handleExportSceneToOBJ
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('To PLY File'),
	      onClick: this.handleExportSceneToPLY
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('To STL File'),
	      onClick: this.handleExportSceneToSTL
	    })) : null, !enableAuthority || authorities.includes('PUBLISH_SCENE') ? /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Publish Scene'),
	      onClick: this.handlePublishScene
	    }) : null);
	  }
	  /**
	   * 创建场景前询问
	   * @returns {Promise} 是否创建成功
	   */


	  queryBeforeCreateScene() {
	    const editor = app.editor;
	    return new Promise(resolve => {
	      if (editor.sceneID === null) {
	        resolve();
	      } else {
	        app.confirm({
	          title: _t('Confirm'),
	          content: _t('All unsaved data will be lost. Are you sure?'),
	          onOK: () => {
	            resolve();
	          }
	        });
	      }
	    });
	  }
	  /**
	   * 新建空场景
	   */


	  handleCreateEmptyScene() {
	    this.queryBeforeCreateScene().then(() => {
	      const scene = new EmptySceneTemplate();
	      scene.clear();
	      scene.create();
	      app.call('editorCleared', this);
	      app.call('scriptChanged', this);
	      app.call('animationChanged', this);
	      app.toast(_t('Create empty scene successfully.'), 'success');
	    });
	  }
	  /**
	   * 新建小区和室内
	   */


	  handleCreateDistrictAndIndoor() {
	    let editor = app.editor;
	    this.queryBeforeCreateScene().then(() => {
	      editor.clear();
	      editor.sceneID = null;
	      editor.sceneName = null;
	      app.options.sceneType = 'Empty';
	      document.title = _t('District and Indoor');
	      app.editor.camera.userData.control = 'OrbitControls'; // 添加地面

	      let geometry = new THREE.PlaneBufferGeometry(100, 100);
	      let map = new THREE.TextureLoader().load('assets/textures/grid.png');
	      map.wrapS = map.wrapT = THREE.RepeatWrapping;
	      map.repeat.set(64, 64);
	      let material = new THREE.MeshBasicMaterial({
	        map
	      });
	      let mesh = new THREE.Mesh(geometry, material);
	      mesh.rotation.x = -Math.PI / 2;
	      mesh.name = _t('Ground');
	      app.editor.addObject(mesh);
	      app.toast(_t('Create district successfully.'), 'success');
	    });
	  }
	  /**
	   * 新建GIS场景
	   */


	  handleCreateGISScene() {
	    if (app.editor.gis) {
	      app.editor.gis.stop();
	    }

	    let context = app.editor.renderer.getContext();
	    context.activeTexture(context.TEXTURE0);
	    let map = new WorldWind$1.WorldWindow(context);
	    map.addLayer(new WorldWind$1.StarFieldLayer());
	    map.addLayer(new WorldWind$1.AtmosphereLayer());
	    map.addLayer(new WorldWind$1.XYZLayer());
	    window.map = map;
	    app.options.sceneType = 'GIS';
	    app.editor.camera.userData.control = '';
	    app.call(`sceneGraphChanged`, this);
	  } // --------------------------- 保存场景 ----------------------------------------


	  handleSaveScene() {
	    // 保存场景
	    var editor = app.editor;
	    var id = editor.sceneID;
	    var sceneName = editor.sceneName;

	    if (id) {
	      // 编辑场景
	      this.commitSave(id, sceneName);
	    } else {
	      // 新建场景
	      const win = app.createElement(SaveSceneWindow);
	      app.addElement(win);
	    }
	  }

	  commitSave(id, sceneName) {
	    var editor = app.editor; // 记录选中物体，以便载入时还原场景选中

	    var selected = app.editor.selected;

	    if (selected) {
	      app.options.selected = selected.uuid;
	    }

	    app.mask(_t('Waiting...'));
	    var obj = new Converter().toJSON({
	      options: app.options,
	      camera: editor.camera,
	      renderer: editor.renderer,
	      scripts: editor.scripts,
	      animations: editor.animations,
	      scene: editor.scene,
	      visual: editor.visual
	    });
	    var params = {
	      Name: sceneName,
	      Data: JSON.stringify(obj)
	    };

	    if (id) {
	      params.ID = id;
	    }

	    Ajax.post(`${app.options.server}/api/Scene/Save`, params, result => {
	      var obj = JSON.parse(result);
	      app.unmask();

	      if (obj.Code === 200) {
	        editor.sceneID = obj.ID;
	        editor.sceneName = sceneName;
	        document.title = sceneName;
	        app.call(`sceneSaved`, this);
	        app.toast(_t(obj.Msg), 'success');
	      } else {
	        app.toast(_t(obj.Msg), 'warn');
	      }
	    });
	  } // --------------------------- 另存为场景 -------------------------------------


	  handleSaveAsScene() {
	    const win = app.createElement(SaveSceneWindow);
	    app.addElement(win);
	  } // ---------------------- 导出场景为json文件 --------------------------


	  querySceneName() {
	    var sceneName = app.editor.sceneName;

	    if (!sceneName) {
	      sceneName = _t(`Scene{{Time}}`, {
	        Time: TimeUtils.getDateTime()
	      });
	    }

	    return new Promise(resolve => {
	      app.prompt({
	        title: _t('Input File Name'),
	        content: _t('Name'),
	        value: sceneName,
	        onOK: name => {
	          resolve(name);
	        }
	      });
	    });
	  }

	  handleExportSceneToJson() {
	    this.querySceneName().then(name => {
	      var output = app.editor.scene.toJSON();

	      try {
	        output = JSON.stringify(output, StringUtils.parseNumber, '\t'); // eslint-disable-next-line

	        output = output.replace(/[\n\t]+([\d\.e\-\[\]]+)/g, '$1');
	      } catch (e) {
	        output = JSON.stringify(output);
	      }

	      StringUtils.saveString(output, `${name}.json`);
	    });
	  } // ----------------------- 导出场景为Collada文件 ----------------------


	  handleExportSceneToCollada() {
	    this.querySceneName().then(name => {
	      app.require('ColladaExporter').then(() => {
	        var exporter = new THREE.ColladaExporter();
	        exporter.parse(app.editor.scene, function (result) {
	          StringUtils.saveString(result.data, `${name}.dae`);
	        });
	      });
	    });
	  } // ----------------------- 导出场景为gltf文件 -------------------------


	  handleExportSceneToGltf() {
	    this.querySceneName().then(name => {
	      app.require('GLTFExporter').then(() => {
	        var exporter = new THREE.GLTFExporter();
	        exporter.parse(app.editor.scene, result => {
	          StringUtils.saveString(JSON.stringify(result), `${name}.gltf`);
	        });
	      });
	    });
	  } // ---------------------- 导出场景为OBJ文件 -------------------------------


	  handleExportSceneToOBJ() {
	    this.querySceneName().then(name => {
	      app.require('OBJExporter').then(() => {
	        var exporter = new THREE.OBJExporter();
	        StringUtils.saveString(exporter.parse(app.editor.scene), `${name}.obj`);
	      });
	    });
	  } // ----------------------- 导出场景为PLY文件 ---------------------------------


	  handleExportSceneToPLY() {
	    this.querySceneName().then(name => {
	      app.require('PLYExporter').then(() => {
	        var exporter = new THREE.PLYExporter();
	        StringUtils.saveString(exporter.parse(app.editor.scene, {
	          excludeAttributes: ['normal', 'uv', 'color', 'index']
	        }), `${name}.ply`);
	      });
	    });
	  } // ------------------------ 导出场景为STL文件 --------------------------------


	  handleExportSceneToSTL() {
	    this.querySceneName().then(name => {
	      app.require('STLExporter').then(() => {
	        var exporter = new THREE.STLExporter();
	        StringUtils.saveString(exporter.parse(app.editor.scene), `${name}.stl`);
	      });
	    });
	  } // -------------------------- 发布场景 --------------------------------


	  handlePublishScene() {
	    var sceneID = app.editor.sceneID;

	    if (!sceneID) {
	      app.toast(_t('Please open scene first.'), 'warn');
	      return;
	    }

	    app.confirm({
	      title: _t('Query'),
	      content: _t('Are you sure to publish the current scene?'),
	      onOK: () => {
	        app.mask(_t('Publishing...'));
	        fetch(`${app.options.server}/api/ExportScene/Run?ID=${sceneID}`, {
	          method: 'POST'
	        }).then(response => {
	          if (response.ok) {
	            response.json().then(obj => {
	              app.unmask();

	              if (obj.Code !== 200) {
	                app.toast(_t(obj.Msg), 'warn');
	                return;
	              }

	              app.toast(_t(obj.Msg), 'success');
	              window.open(`${app.options.server}${obj.Url}`, 'export');
	            });
	          }
	        });
	      }
	    });
	  }

	}

	/**
	 * 添加物体命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 配置
	 * @constructor
	 */

	function AddObjectCommand(object) {
	  Command.call(this);
	  this.type = 'AddObjectCommand';
	  this.object = object;

	  if (object !== undefined) {
	    this.name = _t('Add Object') + object.name;
	  }
	}

	AddObjectCommand.prototype = Object.create(Command.prototype);
	Object.assign(AddObjectCommand.prototype, {
	  constructor: AddObjectCommand,
	  execute: function () {
	    this.editor.addObject(this.object);
	    this.editor.select(this.object);
	  },
	  undo: function () {
	    this.editor.removeObject(this.object);
	    this.editor.deselect();
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.object = this.object.toJSON();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.object.object.uuid);

	    if (this.object === undefined) {
	      var loader = new THREE.ObjectLoader();
	      this.object = loader.parse(json.object);
	    }
	  }
	});

	/**
	 * 移除物体命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 物体
	 * @constructor
	 */

	function RemoveObjectCommand(object) {
	  Command.call(this);
	  this.type = 'RemoveObjectCommand';
	  this.name = _t('Remove Object');
	  this.object = object;
	  this.parent = object !== undefined ? object.parent : undefined;

	  if (this.parent !== undefined) {
	    this.index = this.parent.children.indexOf(this.object);
	  }
	}

	RemoveObjectCommand.prototype = Object.create(Command.prototype);
	Object.assign(RemoveObjectCommand.prototype, {
	  constructor: RemoveObjectCommand,
	  execute: function () {
	    // var scope = this.editor;
	    this.parent.remove(this.object);

	    if (this.object === this.editor.selected) {
	      this.editor.select(null);
	    }

	    app.call('objectRemoved', this, this.object);
	  },
	  undo: function () {
	    // var scope = this.editor;
	    this.parent.children.splice(this.index, 0, this.object);
	    this.object.parent = this.parent;
	    this.editor.select(this.object);
	    app.call('objectAdded', this, this.object);
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.object = this.object.toJSON();
	    output.index = this.index;
	    output.parentUuid = this.parent.uuid;
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.parent = this.editor.objectByUuid(json.parentUuid);

	    if (this.parent === undefined) {
	      this.parent = this.editor.scene;
	    }

	    this.index = json.index;
	    this.object = this.editor.objectByUuid(json.object.object.uuid);

	    if (this.object === undefined) {
	      var loader = new THREE.ObjectLoader();
	      this.object = loader.parse(json.object);
	    }
	  }
	});

	/**
	 * 编辑菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class EditMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      enableUndo: false,
	      enableRedo: false,
	      enableClearHistory: false,
	      enableClone: false,
	      enableDelete: false
	    };
	    this.handleUndo = this.handleUndo.bind(this);
	    this.handleRedo = this.handleRedo.bind(this);
	    this.handleClearHistory = this.handleClearHistory.bind(this);
	    this.handleClone = this.handleClone.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.onHistoryChanged = this.onHistoryChanged.bind(this);
	    this.onObjectSelected = this.onObjectSelected.bind(this);
	    this.onKeyDown = this.onKeyDown.bind(this);
	  }

	  render() {
	    const {
	      enableUndo,
	      enableRedo,
	      enableClearHistory,
	      enableClone,
	      enableDelete
	    } = this.state;
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Edit')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: `${_t('Undo')}(Ctrl+Z)`,
	      disabled: !enableUndo,
	      onClick: this.handleUndo
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: `${_t('Redo')}(Ctrl+Y)`,
	      disabled: !enableRedo,
	      onClick: this.handleRedo
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Clear History'),
	      disabled: !enableClearHistory,
	      onClick: this.handleClearHistory
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: `${_t('Clone')}(Ctrl+C)`,
	      disabled: !enableClone,
	      onClick: this.handleClone
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: `${_t('Delete')}(Delete)`,
	      disabled: !enableDelete,
	      onClick: this.handleDelete
	    }));
	  }

	  componentDidMount() {
	    app.on(`undo.EditMenu`, this.handleUndo);
	    app.on(`redo.EditMenu`, this.handleRedo);
	    app.on(`clearHistory.EditMenu`, this.handleClearHistory);
	    app.on(`clone.EditMenu`, this.handleClone);
	    app.on(`delete.EditMenu`, this.handleDelete);
	    app.on(`historyChanged.EditMenu`, this.onHistoryChanged);
	    app.on(`objectSelected.EditMenu`, this.onObjectSelected);
	    app.on(`keydown.EditMenu`, this.onKeyDown);
	  } // --------------------- 撤销 --------------------------


	  handleUndo() {
	    var history = app.editor.history;

	    if (history.undos.length === 0) {
	      return;
	    }

	    app.editor.undo();
	  } // --------------------- 重做 -----------------------------


	  handleRedo() {
	    var history = app.editor.history;

	    if (history.redos.length === 0) {
	      return;
	    }

	    app.editor.redo();
	  } // -------------------- 清空历史记录 --------------------------------


	  handleClearHistory() {
	    var editor = app.editor;
	    var history = editor.history;

	    if (history.undos.length === 0 && history.redos.length === 0) {
	      return;
	    }

	    app.confirm({
	      title: _t('Confirm'),
	      content: _t('Undo/Redo history will be cleared. Are you sure?'),
	      onOK: () => {
	        editor.history.clear();
	      }
	    });
	  } // -------------------------- 复制 -----------------------------------


	  handleClone() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object === null || object.parent === null) {
	      // 避免复制场景或相机
	      return;
	    }

	    object = object.clone(); // bug: 服务端模型克隆后，userData._children不正确，导致保存后无法正常显示。

	    if (object.userData.Server && Array.isArray(object.userData._children)) {
	      object.userData._children = [];
	      MeshUtils.traverseUUID(object.children, object.userData._children); // 修复模型object.userData._children数组
	    }

	    editor.execute(new AddObjectCommand(object));
	  } // ----------------------- 删除 -----------------------------------


	  handleDelete() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object === null || object.parent === null) {
	      // 避免删除场景或相机
	      return;
	    }

	    app.confirm({
	      title: _t('Confirm'),
	      content: _t('Delete') + ' ' + object.name + '?',
	      onOK: () => {
	        editor.execute(new RemoveObjectCommand(object));
	      }
	    });
	  } // 快捷键


	  onKeyDown(event) {
	    if (event.keyCode === 46) {
	      // 删除键
	      this.handleDelete();
	    } else if (event.keyCode === 67) {
	      // c键
	      this.handleClone();
	    } else if (event.keyCode === 89) {
	      // y键
	      event.ctrlKey && this.handleRedo();
	    } else if (event.keyCode === 90) {
	      // z键
	      event.ctrlKey && this.handleUndo();
	    }
	  } // ---------------------- 事件 -----------------------


	  onHistoryChanged() {
	    const history = app.editor.history;
	    this.setState({
	      enableUndo: history.undos.length > 0,
	      enableRedo: history.redos.length > 0,
	      enableClearHistory: history.undos.length > 0 || history.redos.length > 0
	    });
	  }

	  onObjectSelected() {
	    const editor = app.editor;
	    this.setState({
	      enableClone: editor.selected && editor.selected.parent !== null,
	      enableDelete: editor.selected && editor.selected.parent !== null
	    });
	  }

	}

	var ID$8 = -1;
	/**
	 * 所有可视化组件基类
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseComponent() {
	  this.id = `VisualComponent${ID$8--}`;
	  this.type = 'VisualComponent'; // 根据此字段判断类型，进行反序列化
	}
	/**
	 * 实现该函数，可以在编辑器中拖动该控件。
	 * 原型:setTranslate(dx, dy)
	 */


	BaseComponent.prototype.setTranslate = null;
	/**
	 * 渲染组件
	 * @param {SVGElement} parent 父组件
	 */

	BaseComponent.prototype.render = function (parent) {// eslint-disable-line
	};
	/**
	 * 组件转json
	 */


	BaseComponent.prototype.toJSON = function () {};
	/**
	 * json转组件
	 * @param {Object} json JSON字符串反序列化后的对象
	 */


	BaseComponent.prototype.fromJSON = function (json) {// eslint-disable-line
	};
	/**
	 * 清空组件
	 */


	BaseComponent.prototype.clear = function () {};

	/**
	 * 按钮
	 * @author tengge / https://github.com/tengge1
	 */

	function Button$1() {
	  BaseComponent.call(this);
	  this.type = 'Button';
	  this.text = 'Button';
	  this.transform = null;
	}

	Button$1.prototype = Object.create(BaseComponent.prototype);
	Button$1.prototype.constructor = Button$1;

	Button$1.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Button$1.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var paddingLeft = 8;
	  var paddingTop = 4;
	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Button', true).style('pointer-events', 'all').style('cursor', 'pointer');
	  var rect = g.append('rect').attr('data-id', this.id).attr('x', 0).attr('y', 0).attr('stroke', '#3399ff').attr('stroke-width', 2).attr('fill', 'rgba(51,153,255,0.5)');
	  var text = g.append('text').attr('data-id', this.id).text(this.text).attr('fill', '#fff');
	  var box = text.node().getBBox();
	  var boxWidth = box.width + paddingLeft * 2;
	  var boxHeight = box.height + paddingTop * 2;
	  rect.attr('width', boxWidth).attr('height', boxHeight);
	  text.attr('x', paddingLeft).attr('y', paddingTop - box.y);

	  if (!this.transform) {
	    var left = (parent.clientWidth - boxWidth) / 2;
	    var top = (parent.clientHeight - boxHeight) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  g.on(`mouseenter.${this.id}`, this.onMouseEnter.bind(this));
	  g.on(`mouseleave.${this.id}`, this.onMouseLeave.bind(this));
	  this.dom = g;
	};

	Button$1.prototype.onMouseEnter = function () {
	  if (this.dom) {
	    this.dom.select('rect').attr('fill', 'rgba(51,153,255,0.8)');
	  }
	};

	Button$1.prototype.onMouseLeave = function () {
	  if (this.dom) {
	    this.dom.select('rect').attr('fill', 'rgba(51,153,255,0.5)');
	  }
	};

	Button$1.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    text: this.text,
	    transform
	  };
	};

	Button$1.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.text = json.text;
	  this.transform = json.transform || null;
	};

	Button$1.prototype.clear = function () {
	  this.text = 'Button';
	  this.transform = null;
	  this.dom.on(`mouseover.${this.id}`, null);
	  this.dom.on(`mouseleave.${this.id}`, null);
	  delete this.dom;
	};

	/**
	 * 标签
	 * @author tengge / https://github.com/tengge1
	 */

	function Label$1() {
	  BaseComponent.call(this);
	  this.type = 'Label';
	  this.text = 'Label';
	  this.transform = null;
	}

	Label$1.prototype = Object.create(BaseComponent.prototype);
	Label$1.prototype.constructor = Label$1;

	Label$1.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Label$1.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var padding = 2;
	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Label', true).style('pointer-events', 'all');
	  var text = g.append('text').attr('data-id', this.id).text(this.text).attr('fill', '#fff');
	  var box = text.node().getBBox();
	  var boxWidth = box.width + padding * 2;
	  var boxHeight = box.height + padding * 2;
	  text.attr('x', padding).attr('y', padding - box.y);

	  if (!this.transform) {
	    var left = (parent.clientWidth - boxWidth) / 2;
	    var top = (parent.clientHeight - boxHeight) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	Label$1.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    text: this.text,
	    transform
	  };
	};

	Label$1.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.text = json.text;
	  this.transform = json.transform || null;
	};

	Label$1.prototype.clear = function () {
	  this.text = 'Label';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 面板
	 * @author tengge / https://github.com/tengge1
	 */

	function Panel$1() {
	  BaseComponent.call(this);
	  this.type = 'Panel';
	  this.width = 302;
	  this.height = 358;
	  this.title = 'Panel';
	  this.transform = null;
	}

	Panel$1.prototype = Object.create(BaseComponent.prototype);
	Panel$1.prototype.constructor = Panel$1;

	Panel$1.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Panel$1.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Panel', true).style('pointer-events', 'all'); // 背景

	  g.append('path').attr('data-id', this.id).attr('d', 'M0,0L256,0L302,41L302,358L16,358L0,350Z').attr('fill', 'rgba(45,48,60,0.95)'); // 左边界线

	  g.append('path').attr('data-id', this.id).attr('d', 'M26,22L5,22L5,220L10,225L10,248L5,254L5,345L26,354L48,354').attr('stroke', '#2d758f').attr('stroke-width', 2).attr('fill', 'none'); // 右边界线

	  g.append('path').attr('data-id', this.id).attr('d', 'M220,22L264,22L295,56L295,354L104,354').attr('stroke', '#2d758f').attr('stroke-width', 2).attr('fill', 'none'); // 标题

	  g.append('text').attr('data-id', this.id).text(this.title).attr('x', 38).attr('y', 30).attr('font-size', 22).attr('font-weight', 'bold').attr('fill', '#498e7b');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	Panel$1.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	Panel$1.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	Panel$1.prototype.clear = function () {
	  this.title = 'Panel';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 水平线
	 * @author tengge / https://github.com/tengge1
	 */

	function HorizontalLine() {
	  BaseComponent.call(this);
	  this.type = 'HorizontalLine';
	  this.width = 240;
	  this.height = 0;
	  this.transform = null;
	}

	HorizontalLine.prototype = Object.create(BaseComponent.prototype);
	HorizontalLine.prototype.constructor = HorizontalLine;

	HorizontalLine.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	HorizontalLine.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('HorizontalLine', true).style('pointer-events', 'all'); // 可拖拽区域

	  g.append('path').attr('data-id', this.id).attr('d', 'M-4,-4L244,-4L244,4L-4,4Z').attr('stroke', '0').attr('fill', 'none');
	  g.append('line').attr('data-id', this.id).attr('x1', 0).attr('y1', 0).attr('x2', 240).attr('y2', 0).attr('stroke', 'rgba(0,0,0,0.4)').attr('stroke-width', 2);

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	HorizontalLine.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    width: this.width,
	    transform
	  };
	};

	HorizontalLine.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.width = json.width;
	  this.height = json.height;
	  this.transform = json.transform || null;
	};

	HorizontalLine.prototype.clear = function () {
	  this.width = 240;
	  this.height = 0;
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 条形图
	 * @author tengge / https://github.com/tengge1
	 */

	function BarChart() {
	  BaseComponent.call(this);
	  this.type = 'BarChart';
	  this.width = 180;
	  this.height = 212;
	  this.title = 'BarChart';
	  this.data = [{
	    text: '桌椅松动',
	    value: 100 / 105
	  }, {
	    text: '启动活门',
	    value: 100 / 105
	  }, {
	    text: '雷达系统',
	    value: 73 / 105
	  }, {
	    text: '引气系统',
	    value: 72 / 105
	  }, {
	    text: '防冰活门',
	    value: 69 / 105
	  }, {
	    text: '引擎',
	    value: 46 / 105
	  }, {
	    text: '起落架',
	    value: 42 / 105
	  }];
	  this.transform = null;
	}

	BarChart.prototype = Object.create(BaseComponent.prototype);
	BarChart.prototype.constructor = BarChart;

	BarChart.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	BarChart.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('BarChart', true).style('pointer-events', 'all'); // 面板背景

	  g.append('rect').attr('data-id', this.id).attr('x', 0).attr('y', 0).attr('width', 180).attr('height', 212).attr('fill', 'rgba(0,0,0,0.2)'); // 底部标题

	  g.append('path').attr('data-id', this.id).attr('d', 'M11,0 L72,0 L85,12 L72,24 L11,24 L0,12 Z').attr('transform', 'translate(50,200)').attr('fill', '#2d232c');
	  g.append('text').attr('data-id', this.id).text(this.title).attr('transform', 'translate(88,217)').attr('fill', '#4ccdfc').attr('font-size', 14).attr('text-anchor', 'middle'); // 面板

	  var bar = g.selectAll('.bar').data(this.data);
	  bar.exit().remove(); // 条

	  var group = bar.enter().append('g').attr('data-id', this.id).classed('bar', true).append('g');
	  group.append('text').attr('data-id', this.id).text(function (d) {
	    return d.text;
	  }).attr('x', 10).attr('y', function (d, i) {
	    return (i + 1) * 25;
	  }).attr('fill', '#4ccdfc');
	  group.append('rect').attr('data-id', this.id).attr('x', 68).attr('y', function (d, i) {
	    return (i + 1) * 25 - 10;
	  }).attr('width', 105).attr('height', 10).attr('fill', '#0c6887');
	  group.append('rect').attr('data-id', this.id).attr('x', 68).attr('y', function (d, i) {
	    return (i + 1) * 25 - 10;
	  }).attr('width', function (d) {
	    return d.value * 105;
	  }).attr('height', 10).attr('fill', '#4ccdfc');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	BarChart.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	BarChart.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	BarChart.prototype.clear = function () {
	  this.title = 'BarChart';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 时间标签
	 * @author tengge / https://github.com/tengge1
	 */

	function TimeLabel() {
	  BaseComponent.call(this);
	  this.type = 'TimeLabel';
	  this.text = '14:21';
	  this.transform = null;
	}

	TimeLabel.prototype = Object.create(BaseComponent.prototype);
	TimeLabel.prototype.constructor = TimeLabel;

	TimeLabel.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	TimeLabel.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var padding = 2;
	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('TimeLabel', true).style('pointer-events', 'all');
	  var text = g.append('text').attr('data-id', this.id).text(this.text).attr('fill', '#fff');
	  var box = text.node().getBBox();
	  var boxWidth = box.width + padding * 2;
	  var boxHeight = box.height + padding * 2;
	  text.attr('x', padding).attr('y', padding - box.y);

	  if (!this.transform) {
	    var left = (parent.clientWidth - boxWidth) / 2;
	    var top = (parent.clientHeight - boxHeight) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	TimeLabel.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    text: this.text,
	    transform
	  };
	};

	TimeLabel.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.text = json.text;
	  this.transform = json.transform || null;
	};

	TimeLabel.prototype.clear = function () {
	  this.text = '14:21';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 垂直线
	 * @author tengge / https://github.com/tengge1
	 */

	function VerticalLine() {
	  BaseComponent.call(this);
	  this.type = 'VerticalLine';
	  this.width = 0;
	  this.height = 20;
	  this.transform = null;
	}

	VerticalLine.prototype = Object.create(BaseComponent.prototype);
	VerticalLine.prototype.constructor = VerticalLine;

	VerticalLine.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	VerticalLine.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('VerticalLine', true).style('pointer-events', 'all'); // 可拖拽区域

	  g.append('path').attr('data-id', this.id).attr('d', 'M-4,-4L4,-4L4,24L-4,24Z').attr('stroke', '0').attr('fill', 'none');
	  g.append('line').attr('data-id', this.id).attr('x1', 0).attr('y1', 0).attr('x2', 0).attr('y2', 20).attr('stroke', '#4d88a7').attr('stroke-width', 2);

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	VerticalLine.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    width: this.width,
	    height: this.height,
	    transform
	  };
	};

	VerticalLine.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.width = json.width;
	  this.height = json.height;
	  this.transform = json.transform || null;
	};

	VerticalLine.prototype.clear = function () {
	  this.width = 0;
	  this.height = 20;
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 日期、周标签
	 * @author tengge / https://github.com/tengge1
	 */

	function DateWeekLabel() {
	  BaseComponent.call(this);
	  this.type = 'DateWeekLabel';
	  this.text = '14:21';
	  this.transform = null;
	}

	DateWeekLabel.prototype = Object.create(BaseComponent.prototype);
	DateWeekLabel.prototype.constructor = DateWeekLabel;

	DateWeekLabel.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	DateWeekLabel.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var padding = 2;
	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('DateWeekLabel', true).style('pointer-events', 'all'); // 星期

	  var week = g.append('text').attr('data-id', this.id).text('星期日').attr('x', padding).attr('y', padding).attr('font-size', 14).attr('fill', '#fff'); // 日期

	  var date = g.append('text').attr('data-id', this.id).text('2019-04-21').attr('x', padding).attr('y', padding).attr('font-size', 14).attr('fill', '#fff');
	  var weekBox = week.node().getBBox();
	  var dateBox = date.node().getBBox();
	  week.attr('y', padding - weekBox.y);
	  date.attr('y', weekBox.height + padding * 2 - dateBox.y);

	  if (!this.transform) {
	    var boxWidth = Math.max(weekBox.width, dateBox.width) + padding * 2;
	    var boxHeight = weekBox.height + dateBox.height + padding * 3;
	    var left = (parent.clientWidth - boxWidth) / 2;
	    var top = (parent.clientHeight - boxHeight) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	DateWeekLabel.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    text: this.text,
	    transform
	  };
	};

	DateWeekLabel.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.text = json.text;
	  this.transform = json.transform || null;
	};

	DateWeekLabel.prototype.clear = function () {
	  this.text = '14:21';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 时间圆盘
	 * @author tengge / https://github.com/tengge1
	 */

	function TimeDisk() {
	  BaseComponent.call(this);
	  this.type = 'TimeDisk';
	  this.width = 136;
	  this.height = 136;
	  this.title = 'Time';
	  this.transform = null;
	}

	TimeDisk.prototype = Object.create(BaseComponent.prototype);
	TimeDisk.prototype.constructor = TimeDisk;

	TimeDisk.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	TimeDisk.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('TimeDisk', true).style('pointer-events', 'all');
	  g.append('circle').attr('data-id', this.id).attr('cx', 0).attr('cy', 0).attr('r', 68).attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('circle').attr('data-id', this.id).attr('cx', 0).attr('cy', 0).attr('r', 48).attr('stroke', '#517496').attr('stroke-width', 2).attr('fill', 'none');
	  g.append('circle').attr('data-id', this.id).attr('cx', 48).attr('cy', 0).attr('r', 14).attr('fill', '#376899');
	  g.append('circle').attr('data-id', this.id).attr('cx', 48).attr('cy', 0).attr('r', 14).attr('stroke', '#3399ff').attr('stroke-width', 2).attr('fill', 'none');
	  g.append('image').attr('data-id', this.id).attr('x', 0).attr('y', -48).attr('transform', 'translate(-12,-12)').attr('href', 'assets/svg/sunrise.svg');
	  g.append('image').attr('data-id', this.id).attr('x', 48).attr('y', 0).attr('transform', 'translate(-12,-12)').attr('href', 'assets/svg/sun.svg');
	  g.append('image').attr('data-id', this.id).attr('x', 0).attr('y', 48).attr('transform', 'translate(-12,-12)').attr('href', 'assets/svg/sunset.svg');
	  g.append('image').attr('data-id', this.id).attr('x', -48).attr('y', 0).attr('transform', 'translate(-12,-12)').attr('href', 'assets/svg/moon.svg');
	  g.append('text').attr('data-id', this.id).text(this.title).attr('x', 0).attr('y', 0).attr('dy', 10).attr('font-size', 20).attr('text-anchor', 'middle').attr('fill', '#fff');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	TimeDisk.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	TimeDisk.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	TimeDisk.prototype.clear = function () {
	  this.title = 'Time';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 键值标签
	 * @author tengge / https://github.com/tengge1
	 */

	function KeyValueLabel() {
	  BaseComponent.call(this);
	  this.type = 'KeyValueLabel';
	  this.width = 142;
	  this.height = 24;
	  this.key = '标签';
	  this.value = '值';
	  this.transform = null;
	}

	KeyValueLabel.prototype = Object.create(BaseComponent.prototype);
	KeyValueLabel.prototype.constructor = KeyValueLabel;

	KeyValueLabel.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	KeyValueLabel.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('TimeLabel', true).style('pointer-events', 'all');
	  g.append('path').attr('data-id', this.id).attr('d', 'M0,0 L135,0 L142,8 L142,24 L12,24 L0,17 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('text').attr('data-id', this.id).text(this.key).attr('x', 18).attr('y', 17).attr('fill', '#fff').attr('font-size', 14);
	  g.append('text').attr('data-id', this.id).text(this.value).attr('x', 90).attr('y', 17).attr('fill', '#fff').attr('font-size', 14);

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	KeyValueLabel.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    key: this.key,
	    value: this.value,
	    transform
	  };
	};

	KeyValueLabel.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.key = json.key;
	  this.value = json.value;
	  this.transform = json.transform || null;
	};

	KeyValueLabel.prototype.clear = function () {
	  this.key = '键';
	  this.value = '值';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 表单面板
	 * @author tengge / https://github.com/tengge1
	 */

	function FormPanel() {
	  BaseComponent.call(this);
	  this.type = 'FormPanel';
	  this.width = 166;
	  this.height = 130;
	  this.data = [{
	    key: '键1',
	    value: '值1'
	  }, {
	    key: '键2',
	    value: '值2'
	  }, {
	    key: '键3',
	    value: '值3'
	  }, {
	    key: '键4',
	    value: '值4'
	  }];
	  this.transform = null;
	}

	FormPanel.prototype = Object.create(BaseComponent.prototype);
	FormPanel.prototype.constructor = FormPanel;

	FormPanel.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	FormPanel.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('FormPanel', true).style('pointer-events', 'all');
	  g.append('path').attr('data-id', this.id).attr('d', 'M5,0 L160,0 L166,6 L166,33 L158,38 L158,91 L166,96 L166,125 L158,130 L5,130 L0,125 L0,96 L5,91 L5,36 L0,33 L0,6 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  var update = g.selectAll('.item').data(this.data);
	  update.exit().remove();
	  var item = update.enter().append('g').attr('data-id', this.id).classed('item', true);
	  item.append('text').attr('data-id', this.id).text(function (d) {
	    return d.key;
	  }).attr('x', 17).attr('y', function (d, i) {
	    return 26 + 26 * i;
	  }).attr('fill', '#fff').attr('font-size', 14);
	  item.append('text').attr('data-id', this.id).text(function (d) {
	    return d.value;
	  }).attr('x', 140).attr('y', function (d, i) {
	    return 26 + 26 * i;
	  }).attr('fill', '#fff').attr('font-size', 14).attr('text-anchor', 'end');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	FormPanel.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    data: this.data,
	    transform
	  };
	};

	FormPanel.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	FormPanel.prototype.clear = function () {
	  this.data = [];
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 键值标签
	 * @author tengge / https://github.com/tengge1
	 */

	function Gauge() {
	  BaseComponent.call(this);
	  this.type = 'Gauge';
	  this.width = 74;
	  this.height = 74;
	  this.label = '标签';
	  this.value = '值';
	  this.unit = '单位';
	  this.transform = null;
	}

	Gauge.prototype = Object.create(BaseComponent.prototype);
	Gauge.prototype.constructor = Gauge;

	Gauge.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Gauge.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Gauge', true).style('pointer-events', 'all'); // 背景

	  g.append('circle').attr('data-id', this.id).attr('cx', 18.5).attr('cy', 18.5).attr('r', 37).attr('fill', 'rgba(0,0,0,0.5)'); // 圆圈

	  g.append('circle').attr('data-id', this.id).attr('cx', 18.5).attr('cy', 18.5).attr('r', 32).attr('stroke', '#6da2ee').attr('stroke-width', 2).attr('fill', 'none'); // 值

	  g.append('text').attr('data-id', this.id).text(this.value).attr('x', 18.5).attr('y', 8.5).attr('font-size', 22).attr('text-anchor', 'middle').attr('fill', '#4bc8f5'); // 标签

	  g.append('text').attr('data-id', this.id).text(this.label).attr('x', 18.5).attr('y', 28.5).attr('font-size', 14).attr('text-anchor', 'middle').attr('fill', '#fff'); // 单位

	  g.append('text').attr('data-id', this.id).text(this.unit).attr('x', 18.5).attr('y', 44.5).attr('font-size', 14).attr('text-anchor', 'middle').attr('fill', '#fff');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	Gauge.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    key: this.key,
	    value: this.value,
	    transform
	  };
	};

	Gauge.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.key = json.key;
	  this.value = json.value;
	  this.transform = json.transform || null;
	};

	Gauge.prototype.clear = function () {
	  this.key = '键';
	  this.value = '值';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 柱状图
	 * @author tengge / https://github.com/tengge1
	 */

	function Histogram() {
	  BaseComponent.call(this);
	  this.type = 'Histogram';
	  this.width = 132.9;
	  this.height = 123.38;
	  this.title = 'Histogram';
	  this.data = [27, 68, 44, 117, 60, 83, 101];
	  this.transform = null;
	}

	Histogram.prototype = Object.create(BaseComponent.prototype);
	Histogram.prototype.constructor = Histogram;

	Histogram.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Histogram.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Histogram', true).style('pointer-events', 'all'); // 背景

	  g.append('path').attr('data-id', this.id).attr('d', 'M16.5,0 L16.5,123.38 L0,132.9 L0,8.5 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('path').attr('data-id', this.id).attr('d', 'M23.5,0 L238,0 L238,124 L23.5,124 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('path').attr('data-id', this.id).attr('d', 'M22,127 L238,127 L225,139 L0,139 Z').attr('fill', 'rgba(0,0,0,0.5)'); // 数据

	  g.selectAll('.column').data(this.data).enter().append('rect').attr('data-id', this.id).classed('column', true).attr('x', function (d, i) {
	    return 30 * (i + 1) - 5;
	  }).attr('y', function (d) {
	    return 133.6 - d;
	  }).attr('width', function () {
	    return 10;
	  }).attr('height', function (d) {
	    return d;
	  }).attr('fill', '#4ccdfc'); // 标题

	  g.append('path').attr('data-id', this.id).attr('d', 'M11,0 L72,0 L85,12 L72,24 L11,24 L0,12 Z').attr('fill', 'rgba(23,29,48,0.5)').attr('transform', 'translate(75,128)');
	  g.append('text').attr('data-id', this.id).text(this.title).attr('x', 0).attr('y', 0).attr('dy', 4).attr('font-size', 14).attr('text-anchor', 'middle').attr('fill', '#fff').attr('transform', 'translate(117,140)');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	Histogram.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    data: this.data,
	    transform
	  };
	};

	Histogram.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data || null;
	  this.transform = json.transform || null;
	};

	Histogram.prototype.clear = function () {
	  this.title = 'Histogram';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 折线图
	 * @author tengge / https://github.com/tengge1
	 */

	function LineChart() {
	  BaseComponent.call(this);
	  this.type = 'LineChart';
	  this.width = 132.9;
	  this.height = 123.38;
	  this.title = 'LineChart';
	  var data1 = [];
	  var data2 = [];
	  var ran1 = d3.randomNormal(29, 8);
	  var ran2 = d3.randomNormal(72, 20);

	  for (var i = 0; i <= 210; i += 10) {
	    data1.push([8 + i, ran1()]);
	    data2.push([8 + i, ran2()]);
	  }

	  this.data = [data1, data2];
	  this.transform = null;
	}

	LineChart.prototype = Object.create(BaseComponent.prototype);
	LineChart.prototype.constructor = LineChart;

	LineChart.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	LineChart.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('LineChart', true).style('pointer-events', 'all'); // 背景

	  g.append('path').attr('data-id', this.id).attr('d', 'M16.5,0 L16.5,123.38 L0,132.9 L0,8.5 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('path').attr('data-id', this.id).attr('d', 'M23.5,0 L238,0 L238,124 L23.5,124 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('path').attr('data-id', this.id).attr('d', 'M22,127 L238,127 L225,139 L0,139 Z').attr('fill', 'rgba(0,0,0,0.5)'); // 数据

	  var line = d3.line();
	  var lineData1 = line(this.data[0]);
	  var lineData2 = line(this.data[1]);
	  g.append('path').attr('data-id', this.id).attr('d', lineData1 + 'L218,133.6L8,133.6Z').attr('stroke', '#458dab').attr('fill', 'rgba(76,205,252,0.2)');
	  g.append('path').attr('data-id', this.id).attr('d', lineData1).attr('stroke', '#458dab').attr('stroke-width', 2).attr('fill', 'none');
	  g.append('path').attr('data-id', this.id).attr('d', lineData2 + 'L218,133.6L8,133.6Z').attr('fill', 'rgba(182,152,132,0.2)').attr('stroke-width', 2);
	  g.append('path').attr('data-id', this.id).attr('d', lineData2).attr('stroke', '#b59784').attr('stroke-width', 2).attr('fill', 'none'); // 标签

	  var label = g.append('g').attr('transform', 'translate(117,135)');
	  label.append('path').attr('data-id', this.id).attr('d', 'M11,0 L72,0 L85,12 L72,24 L11,24 L0,12 Z').attr('fill', 'rgba(23,29,48,0.8)').attr('transform', 'translate(-42,-12)');
	  label.append('text').attr('data-id', this.id).text(this.title).attr('x', 0).attr('y', 0).attr('dy', 4).attr('font-size', 14).attr('text-anchor', 'middle').attr('fill', '#fff');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	LineChart.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    data: this.data,
	    transform
	  };
	};

	LineChart.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	LineChart.prototype.clear = function () {
	  this.title = 'LineChart';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 侧边栏
	 * @author tengge / https://github.com/tengge1
	 */

	function SideBar() {
	  BaseComponent.call(this);
	  this.type = 'SideBar';
	  this.width = 270;
	  this.height = 969;
	  this.title = 'SideBar';
	  this.transform = null;
	}

	SideBar.prototype = Object.create(BaseComponent.prototype);
	SideBar.prototype.constructor = SideBar;

	SideBar.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	SideBar.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Panel', true).style('pointer-events', 'all'); // 背景

	  g.append('rect').attr('data-id', this.id).attr('x', 0).attr('y', 0).attr('width', 270).attr('height', 969).attr('fill', 'rgba(0,0,0,0.5)'); // 边框

	  g.append('path').attr('data-id', this.id).attr('d', 'm180,11 l0,35 l-10,10 L9,56 l0,183 l40,30 l0,193 M32,472 l0,18 l-23,20 l0,310').attr('stroke', '#3a6a84').attr('stroke-width', 2).attr('fill', 'none'); // 选项卡

	  var defs = d3.select('defs');
	  defs.append('path').attr('id', 'tabDef').attr('d', 'M0,0 L32,22 L32,60 L0,38 Z').attr('fill', '#6c6f6e');
	  defs.append('path').attr('id', 'tabSelectDef').attr('d', 'M0,0 L32,22 L32,60 L0,38 Z').attr('fill', '#356899');
	  var tab1 = g.append('g').attr('data-id', this.id).attr('transform', 'translate(14,58)');
	  tab1.append('use').attr('data-id', this.id).attr('href', '#tabSelectDef');
	  tab1.append('image').attr('data-id', this.id).attr('x', 5).attr('y', 20).attr('width', 24).attr('height', 24).attr('href', 'assets/svg/home.svg');
	  var tab2 = g.append('g').attr('data-id', this.id).attr('transform', 'translate(14,104)');
	  tab2.append('use').attr('data-id', this.id).attr('href', '#tabDef');
	  tab2.append('image').attr('data-id', this.id).attr('x', 5).attr('y', 20).attr('width', 24).attr('height', 24).attr('href', 'assets/svg/plane.svg');
	  var tab3 = g.append('g').attr('data-id', this.id).attr('transform', 'translate(14,150)');
	  tab3.append('use').attr('data-id', this.id).attr('href', '#tabDef');
	  tab3.append('image').attr('data-id', this.id).attr('x', 5).attr('y', 20).attr('width', 24).attr('height', 24).attr('href', 'assets/svg/water.svg');
	  var tab4 = g.append('g').attr('data-id', this.id).attr('transform', 'translate(14,196)');
	  tab4.append('use').attr('data-id', this.id).attr('href', '#tabDef');
	  tab4.append('image').attr('data-id', this.id).attr('x', 5).attr('y', 20).attr('width', 24).attr('height', 24).attr('href', 'assets/svg/guard.svg');
	  var header = g.append('g').attr('data-id', this.id).attr('transform', 'translate(15,276)');
	  header.append('path').attr('data-id', this.id).attr('d', 'M0,0 L12,0 L25,10 L25,185 L12,195 L0,195 Z').attr('fill', '#185185');
	  header.append('text').attr('data-id', this.id).text(this.title).attr('x', 12).attr('y', 85).attr('text-anchor', 'middle').attr('writing-mode', 'tb').attr('textlength', '90px').attr('lengthAdjust', 'spacing') // spacing, spacingAndGlyphs; see: https://blog.csdn.net/huanhuanq1209/article/details/71438629
	  .attr('fill', '#fff');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	SideBar.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	SideBar.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	SideBar.prototype.clear = function () {
	  this.title = 'SideBar';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 柱状图
	 * @author tengge / https://github.com/tengge1
	 */

	function Histogram2() {
	  BaseComponent.call(this);
	  this.type = 'Histogram2';
	  this.width = 132.9;
	  this.height = 123.38;
	  this.title = 'Histogram2';
	  this.data = [27, 68, 44, 117, 60, 83, 101];
	  this.transform = null;
	}

	Histogram2.prototype = Object.create(BaseComponent.prototype);
	Histogram2.prototype.constructor = Histogram2;

	Histogram2.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Histogram2.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Histogram2', true).style('pointer-events', 'all');
	  var dataset = [50, 43, 120, 87, 99, 167, 142];
	  var xAxisWidth = 300;
	  var yAxisWidth = 300;
	  var padding = {
	    top: 20,
	    right: 20,
	    bottom: 20,
	    left: 30
	  };
	  var xScale = d3.scaleBand().domain(d3.range(dataset.length)).range([0, xAxisWidth]);
	  var yScale = d3.scaleLinear().domain([0, d3.max(dataset)]).range([0, yAxisWidth]);
	  g.selectAll('rect').data(dataset).enter().append('rect').attr('data-id', this.id).attr('fill', 'steelblue').attr('x', function (d, i) {
	    return padding.left + xScale(i);
	  }).attr('y', function (d) {
	    return padding.top + yAxisWidth - yScale(d);
	  }).attr('width', xScale.bandwidth() - 2).attr('height', function (d) {
	    return yScale(d);
	  });
	  g.selectAll('text').data(dataset).enter().append('text').attr('data-id', this.id).attr('fill', 'white').attr('font-size', '14px').attr('text-anchor', 'middle').attr('x', function (d, i) {
	    return padding.left + xScale(i);
	  }).attr('y', function (d) {
	    return padding.top + yAxisWidth - yScale(d);
	  }).attr('dx', xScale.bandwidth() / 2).attr('dy', '1em').text(function (d) {
	    return d;
	  });
	  var xAxis = d3.axisBottom().scale(xScale).tickFormat(function (d) {
	    return d + 1;
	  });
	  g.append('g').attr('transform', `translate(${padding.left}, ${padding.top + yAxisWidth})`).call(xAxis);
	  yScale.range([yAxisWidth, 0]);
	  var yAxis = d3.axisLeft().scale(yScale);
	  g.append('g').attr('transform', `translate(${padding.left},${padding.top})`).call(yAxis);

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	Histogram2.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    data: this.data,
	    transform
	  };
	};

	Histogram2.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	Histogram2.prototype.clear = function () {
	  this.title = 'Histogram2';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 散点图
	 * @author tengge / https://github.com/tengge1
	 */

	function ScatterPlot() {
	  BaseComponent.call(this);
	  this.type = 'ScatterPlot';
	  this.width = 400;
	  this.height = 400;
	  this.title = 'ScatterPlot';
	  var data1 = [];
	  var data2 = [];
	  var ran1 = d3.randomNormal(29, 8);
	  var ran2 = d3.randomNormal(72, 20);

	  for (var i = 0; i <= 210; i += 10) {
	    data1.push([8 + i, ran1()]);
	    data2.push([8 + i, ran2()]);
	  }

	  this.data = [data1, data2];
	  this.transform = null;
	}

	ScatterPlot.prototype = Object.create(BaseComponent.prototype);
	ScatterPlot.prototype.constructor = ScatterPlot;

	ScatterPlot.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	ScatterPlot.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var center = [[0.5, 0.5], [0.7, 0.8], [0.4, 0.9], [0.11, 0.32], [0.88, 0.25], [0.75, 0.12], [0.5, 0.1], [0.2, 0.3], [0.4, 0.1], [0.6, 0.7]];
	  var xAxisWidth = 400;
	  var yAxisWidth = 400;
	  var xScale = d3.scaleLinear().domain([0, 1.2 * d3.max(center, function (d) {
	    return d[0];
	  })]).range([0, xAxisWidth]);
	  var yScale = d3.scaleLinear().domain([0, 1.2 * d3.max(center, function (d) {
	    return d[1];
	  })]).range([0, yAxisWidth]);
	  var padding = {
	    top: 30,
	    right: 30,
	    bottom: 30,
	    left: 40
	  }; // var width = xAxisWidth + padding.left + padding.right;

	  var height = yAxisWidth + padding.top + padding.bottom;
	  g.selectAll('circle').data(center).enter().append('circle').attr('data-id', this.id).attr('fill', 'black').attr('cx', function (d) {
	    return padding.left + xScale(d[0]);
	  }).attr('cy', function (d) {
	    return height - padding.bottom - yScale(d[1]);
	  }).attr('r', 5);
	  var xAxis = d3.axisBottom().scale(xScale);
	  g.append('g').attr('transform', `translate(${padding.left}, ${padding.top + yAxisWidth})`).call(xAxis);
	  yScale.range([yAxisWidth, 0]);
	  var yAxis = d3.axisLeft().scale(yScale);
	  g.append('g').attr('transform', `translate(${padding.left},${padding.top})`).call(yAxis);

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	ScatterPlot.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    data: this.data,
	    transform
	  };
	};

	ScatterPlot.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	ScatterPlot.prototype.clear = function () {
	  this.title = 'ScatterPlot';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 饼状图
	 * @author tengge / https://github.com/tengge1
	 */

	function PieChart() {
	  BaseComponent.call(this);
	  this.type = 'PieChart';
	  this.width = 500;
	  this.height = 500;
	  this.title = 'PieChart';
	  this.transform = null;
	}

	PieChart.prototype = Object.create(BaseComponent.prototype);
	PieChart.prototype.constructor = PieChart;

	PieChart.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	PieChart.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var dataset = [['小米', 60.8], ['三星', 58.4], ['联想', 47.3], ['苹果', 46.6], ['华为', 41.3], ['酷派', 40.1], ['其他', 111.5]];
	  var pie = d3.pie().value(function (d) {
	    return d[1];
	  });
	  var width = 500;
	  var height = 500;
	  var piedata = pie(dataset);
	  var outerRadius = width / 3;
	  var innerRadius = 0;
	  var arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
	  var color = d3.schemeCategory10;
	  var arcs = g.selectAll('g').data(piedata).enter().append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');
	  arcs.append('path').attr('data-id', this.id).attr('fill', function (d, i) {
	    return color[i];
	  }).attr('d', function (d) {
	    return arc(d);
	  });
	  arcs.append('text').attr('data-id', this.id).attr('transform', function (d) {
	    var x = arc.centroid(d)[0] * 1.4;
	    var y = arc.centroid(d)[1] * 1.4;
	    return 'translate(' + x + ',' + y + ')';
	  }).attr('text-anchor', 'middle').text(function (d) {
	    var percent = Number(d.value) / d3.sum(dataset, function (d) {
	      return d[1];
	    }) * 100;
	    return percent.toFixed(1) + '%';
	  });
	  arcs.append('line').attr('data-id', this.id).attr('stroke', 'black').attr('x1', function (d) {
	    return arc.centroid(d)[0] * 2;
	  }).attr('y1', function (d) {
	    return arc.centroid(d)[1] * 2;
	  }).attr('x2', function (d) {
	    return arc.centroid(d)[0] * 2.2;
	  }).attr('y2', function (d) {
	    return arc.centroid(d)[1] * 2.2;
	  });
	  arcs.append('text').attr('data-id', this.id).attr('transform', function (d) {
	    var x = arc.centroid(d)[0] * 2.5;
	    var y = arc.centroid(d)[1] * 2.5;
	    return 'translate(' + x + ',' + y + ')';
	  }).attr('text-anchor', 'middle').text(function (d) {
	    return d.data[0];
	  });

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	PieChart.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	PieChart.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	PieChart.prototype.clear = function () {
	  this.title = 'PieChart';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 弦图
	 * @author tengge / https://github.com/tengge1
	 */

	function ChordGraph() {
	  BaseComponent.call(this);
	  this.type = 'ChordGraph';
	  this.width = 400;
	  this.height = 400;
	  this.title = 'ChordGraph';
	  var data1 = [];
	  var data2 = [];
	  var ran1 = d3.randomNormal(29, 8);
	  var ran2 = d3.randomNormal(72, 20);

	  for (var i = 0; i <= 210; i += 10) {
	    data1.push([8 + i, ran1()]);
	    data2.push([8 + i, ran2()]);
	  }

	  this.data = [data1, data2];
	  this.transform = null;
	}

	ChordGraph.prototype = Object.create(BaseComponent.prototype);
	ChordGraph.prototype.constructor = ChordGraph;

	ChordGraph.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	ChordGraph.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var continent = ['亚洲', '欧洲', '非洲', '美洲', '大洋洲'];
	  var population = [[9000, 870, 3000, 1000, 5200], [3400, 8000, 2300, 4922, 374], [2000, 2000, 7700, 4881, 1050], [3000, 8012, 5531, 500, 400], [3540, 4310, 1500, 1900, 300]];
	  var chord = d3.chord().padAngle(0.03).sortSubgroups(d3.ascending);
	  var chordData = chord(population);
	  var width = 500;
	  var height = 500; // 弦图的<g>元素

	  var gChord = g.append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')'); // 节点的<g>元素

	  var gOuter = gChord.append('g'); // 弦的<g>元素

	  var gInner = gChord.append('g'); // 颜色比例器

	  var color = d3.schemeCategory10;
	  var innerRadius = width / 2 * 0.7;
	  var outerRadius = innerRadius * 1.1; // 弦生成器

	  var arcOuter = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
	  gOuter.selectAll('.outerPath').data(chordData.groups).enter().append('path').attr('data-id', this.id).attr('class', 'outerPath').style('fill', function (d, i) {
	    return color[i];
	  }).attr('d', arcOuter);
	  gOuter.selectAll('.outerText').data(chordData.groups).enter().append('text').attr('data-id', this.id).each(function (d, i) {
	    d.angle = (d.startAngle + d.endAngle) / 2;
	    d.name = continent[i];
	  }).attr('class', 'outerText').attr('dy', '.35em').attr('transform', function (d) {
	    var result = 'rotate(' + d.angle * 180 / Math.PI + ')';
	    result += ' translate(0,' + -1.0 * (outerRadius + 10) + ')';

	    if (d.angle > Math.PI * 3 / 4 && d.angle < Math.PI * 5 / 4) {
	      result += ' rotate(180)';
	    }

	    return result;
	  }).text(function (d) {
	    return d.name;
	  });
	  var ribbon = d3.ribbon().radius(innerRadius);
	  gInner.selectAll('.innerPath').data(chordData).enter().append('path').attr('data-id', this.id).attr('class', 'innerPath').attr('d', ribbon).style('fill', function (d) {
	    return color[d.source.index];
	  });
	  gOuter.selectAll('.outerPath').on('mouseover', fade(0.0)).on('mouseout', fade(1.0));

	  function fade(opacity) {
	    return function (g, i) {
	      gInner.selectAll('.innerPath').filter(function (d) {
	        return d.source.index !== i && d.target.index !== i;
	      }).transition().style('opacity', opacity);
	    };
	  }

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	ChordGraph.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    data: this.data,
	    transform
	  };
	};

	ChordGraph.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	ChordGraph.prototype.clear = function () {
	  this.title = 'ChordGraph';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 饼状图
	 * @author tengge / https://github.com/tengge1
	 */

	function ForceDirectedGraph() {
	  BaseComponent.call(this);
	  this.type = 'ForceDirectedGraph';
	  this.width = 500;
	  this.height = 500;
	  this.title = 'ForceDirectedGraph';
	  this.transform = null;
	}

	ForceDirectedGraph.prototype = Object.create(BaseComponent.prototype);
	ForceDirectedGraph.prototype.constructor = ForceDirectedGraph;

	ForceDirectedGraph.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	ForceDirectedGraph.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var dataset = {
	    nodes: [{
	      name: "Adam"
	    }, {
	      name: "Bob"
	    }, {
	      name: "Carrie"
	    }, {
	      name: "Donovan"
	    }, {
	      name: "Edward"
	    }, {
	      name: "Felicity"
	    }, {
	      name: "George"
	    }, {
	      name: "Hannah"
	    }, {
	      name: "Iris"
	    }, {
	      name: "Jerry"
	    }],
	    links: [{
	      source: 0,
	      target: 1
	    }, {
	      source: 0,
	      target: 2
	    }, {
	      source: 0,
	      target: 3
	    }, {
	      source: 0,
	      target: 4
	    }, {
	      source: 1,
	      target: 5
	    }, {
	      source: 2,
	      target: 5
	    }, {
	      source: 2,
	      target: 5
	    }, {
	      source: 3,
	      target: 4
	    }, {
	      source: 5,
	      target: 8
	    }, {
	      source: 5,
	      target: 9
	    }, {
	      source: 6,
	      target: 7
	    }, {
	      source: 7,
	      target: 8
	    }, {
	      source: 8,
	      target: 9
	    }]
	  };
	  var width = 500;
	  var height = 500;
	  var colors = d3.scaleOrdinal(d3.schemeCategory10);
	  var simulation = d3.forceSimulation(dataset.nodes).force('charge', d3.forceManyBody()).force('link', d3.forceLink(dataset.links)).force('center', d3.forceCenter(width / 2, height / 2));
	  var link = g.append('g').attr('class', 'links').selectAll('line').data(dataset.links).enter().append('line').attr('stroke', '#ccc').attr('stroke-width', 1);
	  var node = g.append('g').attr('class', 'nodes').selectAll('circle').data(dataset.nodes).enter().append('circle').attr('r', 10).attr('fill', function (d, i) {
	    return colors(i);
	  }).call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));
	  node.append('title').text(function (d) {
	    return d.name;
	  });
	  simulation.nodes(dataset.nodes).on('tick', ticked);
	  simulation.force('link').links(dataset.links);

	  function ticked() {
	    link.attr('x1', function (d) {
	      return d.source.x;
	    }).attr('y1', function (d) {
	      return d.source.y;
	    }).attr('x2', function (d) {
	      return d.target.x;
	    }).attr('y2', function (d) {
	      return d.target.y;
	    });
	    node.attr('cx', function (d) {
	      return d.x;
	    }).attr('cy', function (d) {
	      return d.y;
	    });
	  }

	  function dragstarted(d) {
	    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
	    d.fx = d.x;
	    d.fy = d.y;
	  }

	  function dragged(d) {
	    d.fx = d3.event.x;
	    d.fy = d3.event.y;
	  }

	  function dragended(d) {
	    if (!d3.event.active) simulation.alphaTarget(0);
	    d.fx = null;
	    d.fy = null;
	  }

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	ForceDirectedGraph.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	ForceDirectedGraph.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	ForceDirectedGraph.prototype.clear = function () {
	  this.title = 'ForceDirectedGraph';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 树状图
	 * @author tengge / https://github.com/tengge1
	 */

	function TreeDiagram() {
	  BaseComponent.call(this);
	  this.type = 'TreeDiagram';
	  this.width = 500;
	  this.height = 500;
	  this.title = 'TreeDiagram';
	  this.transform = null;
	}

	TreeDiagram.prototype = Object.create(BaseComponent.prototype);
	TreeDiagram.prototype.constructor = TreeDiagram;

	TreeDiagram.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	TreeDiagram.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var root = {
	    name: '中国',
	    children: [{
	      name: '浙江',
	      children: [{
	        name: '杭州'
	      }, {
	        name: '宁波'
	      }, {
	        name: '温州'
	      }, {
	        name: '绍兴'
	      }]
	    }, {
	      name: '广西',
	      children: [{
	        name: '桂林',
	        children: [{
	          name: '秀峰区'
	        }, {
	          name: '叠彩区'
	        }, {
	          name: '象山区'
	        }, {
	          name: '七星区'
	        }]
	      }, {
	        name: '南宁'
	      }, {
	        name: '柳州'
	      }, {
	        name: '防城港'
	      }]
	    }]
	  };
	  var width = 500;
	  var height = 500;
	  var tree = d3.tree().size([width, height - 200]).separation(function (a, b) {
	    return a.parent === b.parent ? 1 : 2;
	  });
	  var hierachyData = d3.hierarchy(root).sum(function (d) {
	    return d.value;
	  });
	  var g1 = g.append('g').attr('transform', 'translate(40, 40)');
	  tree(hierachyData);
	  var nodes = hierachyData.descendants();
	  var links = hierachyData.links();
	  g1.selectAll('.link').data(links).enter().append('path').attr('data-id', this.id).attr('class', 'link').attr('fill', 'none').attr('stroke', '#000').attr('d', function (d) {
	    return `M${d.source.y},${d.source.x} L${d.target.y},${d.target.x}`;
	  });
	  g1.selectAll('.node').data(nodes).enter().append('g').attr('class', 'node').attr('transform', function (d) {
	    // 这样写是为了 让数据横向显示
	    return `translate(${d.y}, ${d.x})`;
	  });
	  g1.selectAll('.node').append('circle').attr('data-id', this.id).attr('r', 5).attr('fill', 'green'); // 绘制文字

	  g1.selectAll('.node').append('text').attr('data-id', this.id).attr('dy', 3).attr('x', function (d) {
	    return d.children ? -8 : 8;
	  }).attr('text-anchor', function (d) {
	    return d.children ? 'end' : 'start';
	  }).text(function (d) {
	    return d.data.name;
	  }).style('font-size', '18px');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	TreeDiagram.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	TreeDiagram.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	TreeDiagram.prototype.clear = function () {
	  this.title = 'TreeDiagram';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 集群图
	 * @author tengge / https://github.com/tengge1
	 */

	function ClusterDiagram() {
	  BaseComponent.call(this);
	  this.type = 'ClusterDiagram';
	  this.width = 500;
	  this.height = 500;
	  this.title = 'ClusterDiagram';
	  this.transform = null;
	}

	ClusterDiagram.prototype = Object.create(BaseComponent.prototype);
	ClusterDiagram.prototype.constructor = ClusterDiagram;

	ClusterDiagram.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	ClusterDiagram.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var root = {
	    name: '中国',
	    children: [{
	      name: '浙江',
	      children: [{
	        name: '杭州'
	      }, {
	        name: '宁波'
	      }, {
	        name: '温州'
	      }, {
	        name: '绍兴'
	      }]
	    }, {
	      name: '广西',
	      children: [{
	        name: '桂林',
	        children: [{
	          name: '秀峰区'
	        }, {
	          name: '叠彩区'
	        }, {
	          name: '象山区'
	        }, {
	          name: '七星区'
	        }]
	      }, {
	        name: '南宁'
	      }, {
	        name: '柳州'
	      }, {
	        name: '防城港'
	      }]
	    }]
	  };
	  var width = 500;
	  var height = 500;
	  var tree = d3.cluster().size([width, height - 200]).separation(function (a, b) {
	    return a.parent === b.parent ? 1 : 2;
	  });
	  var hierachyData = d3.hierarchy(root).sum(function (d) {
	    return d.value;
	  });
	  var g1 = g.append('g').attr('transform', 'translate(40, 40)');
	  tree(hierachyData);
	  var nodes = hierachyData.descendants();
	  var links = hierachyData.links();
	  g1.selectAll('.link').data(links).enter().append('path').attr('data-id', this.id).attr('class', 'link').attr('fill', 'none').attr('stroke', '#000').attr('d', function (d) {
	    return `M${d.source.y},${d.source.x} L${d.target.y},${d.target.x}`;
	  });
	  g1.selectAll('.node').data(nodes).enter().append('g').attr('class', 'node').attr('transform', function (d) {
	    // 这样写是为了 让数据横向显示
	    return `translate(${d.y}, ${d.x})`;
	  });
	  g1.selectAll('.node').append('circle').attr('data-id', this.id).attr('r', 5).attr('fill', 'green'); // 绘制文字

	  g1.selectAll('.node').append('text').attr('data-id', this.id).attr('dy', 3).attr('x', function (d) {
	    return d.children ? -8 : 8;
	  }).attr('text-anchor', function (d) {
	    return d.children ? 'end' : 'start';
	  }).text(function (d) {
	    return d.data.name;
	  }).style('font-size', '18px');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	ClusterDiagram.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	ClusterDiagram.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	ClusterDiagram.prototype.clear = function () {
	  this.title = 'ClusterDiagram';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 包图
	 * @author tengge / https://github.com/tengge1
	 */

	function PackDiagram() {
	  BaseComponent.call(this);
	  this.type = 'PackDiagram';
	  this.width = 500;
	  this.height = 500;
	  this.title = 'PackDiagram';
	  this.transform = null;
	}

	PackDiagram.prototype = Object.create(BaseComponent.prototype);
	PackDiagram.prototype.constructor = PackDiagram;

	PackDiagram.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	PackDiagram.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('PackDiagram', true).style('pointer-events', 'all');
	  var city = {
	    name: '中国',
	    children: [{
	      name: '浙江',
	      children: [{
	        name: '杭州'
	      }, {
	        name: '宁波'
	      }, {
	        name: '温州'
	      }, {
	        name: '绍兴'
	      }]
	    }, {
	      name: '广西',
	      children: [{
	        name: '桂林',
	        children: [{
	          name: '秀峰区'
	        }, {
	          name: '叠彩区'
	        }, {
	          name: '象山区'
	        }, {
	          name: '七星区'
	        }]
	      }, {
	        name: '南宁'
	      }, {
	        name: '柳州'
	      }, {
	        name: '防城港'
	      }]
	    }]
	  };
	  var width = 500;
	  var height = 500;
	  var pack = d3.pack().size([width, height]).radius(function () {
	    return 30;
	  }).padding(5);
	  var hierachy = d3.hierarchy(city);
	  var packData = pack(hierachy);
	  var colors = d3.schemeCategory10;
	  g.selectAll('circle').data(packData.descendants()).enter().append('circle').attr('data-id', this.id).attr('cx', function (d) {
	    return d.x;
	  }).attr('cy', function (d) {
	    return d.y;
	  }).attr('r', function (d) {
	    return d.r;
	  }).attr('class', function (d) {
	    return d.children ? 'node' : 'leafnode';
	  }).attr('fill', function (d, i) {
	    return colors[i];
	  });

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	PackDiagram.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	PackDiagram.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	PackDiagram.prototype.clear = function () {
	  this.title = 'PackDiagram';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 分区图
	 * @author tengge / https://github.com/tengge1
	 */

	function PartitionDiagram() {
	  BaseComponent.call(this);
	  this.type = 'PartitionDiagram';
	  this.width = 800;
	  this.height = 500;
	  this.title = 'PartitionDiagram';
	  this.transform = null;
	}

	PartitionDiagram.prototype = Object.create(BaseComponent.prototype);
	PartitionDiagram.prototype.constructor = PartitionDiagram;

	PartitionDiagram.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	PartitionDiagram.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('PartitionDiagram', true).style('pointer-events', 'all');
	  var city = {
	    name: '中国',
	    value: 1,
	    children: [{
	      name: '浙江',
	      value: 1,
	      children: [{
	        name: '杭州',
	        value: 1
	      }, {
	        name: '宁波',
	        value: 1
	      }, {
	        name: '温州',
	        value: 1
	      }, {
	        name: '绍兴',
	        value: 1
	      }]
	    }, {
	      name: '广西',
	      value: 1,
	      children: [{
	        name: '桂林',
	        value: 1,
	        children: [{
	          name: '秀峰区',
	          value: 1
	        }, {
	          name: '叠彩区',
	          value: 1
	        }, {
	          name: '象山区',
	          value: 1
	        }, {
	          name: '七星区',
	          value: 1
	        }]
	      }, {
	        name: '南宁',
	        value: 1
	      }, {
	        name: '柳州',
	        value: 1
	      }, {
	        name: '防城港',
	        value: 1
	      }]
	    }]
	  }; // var width = 800;
	  // var height = 500;

	  var hierarchy = d3.hierarchy(city);
	  var partition = d3.partition();
	  var partitionData = partition(hierarchy).descendants();
	  var colors = d3.schemeCategory10;
	  g.selectAll('rect').data(partitionData).enter().append('rect').attr('data-id', this.id).attr('x', function (d) {
	    return d.x0 * 100;
	  }).attr('y', function (d) {
	    return d.y0 * 100;
	  }).attr('width', function (d) {
	    return d.x1 * 100 - d.x0 * 100;
	  }).attr('height', function (d) {
	    return d.y1 * 100 - d.y0 * 100;
	  }).attr('fill', function (d, i) {
	    return colors[i % 10];
	  });

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	PartitionDiagram.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	PartitionDiagram.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	PartitionDiagram.prototype.clear = function () {
	  this.title = 'PartitionDiagram';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 2D菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class TwoDMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleAddButton = this.handleAddButton.bind(this);
	    this.handleAddLabel = this.handleAddLabel.bind(this);
	    this.handleAddPanel = this.handleAddPanel.bind(this);
	    this.handleAddHorizontalLine = this.handleAddHorizontalLine.bind(this);
	    this.handleAddBarChart = this.handleAddBarChart.bind(this);
	    this.handleAddTimeLabel = this.handleAddTimeLabel.bind(this);
	    this.handleAddVerticalLine = this.handleAddVerticalLine.bind(this);
	    this.handleAddDateWeek = this.handleAddDateWeek.bind(this);
	    this.handleAddTimeDisk = this.handleAddTimeDisk.bind(this);
	    this.handleAddKeyValueLabel = this.handleAddKeyValueLabel.bind(this);
	    this.handleAddFormPanel = this.handleAddFormPanel.bind(this);
	    this.handleAddGauge = this.handleAddGauge.bind(this);
	    this.handleAddHistogram = this.handleAddHistogram.bind(this);
	    this.handleAddLineChart = this.handleAddLineChart.bind(this);
	    this.handleAddSideBar = this.handleAddSideBar.bind(this);
	    this.handleAddHistogram2 = this.handleAddHistogram2.bind(this);
	    this.handleAddScatterPlot = this.handleAddScatterPlot.bind(this);
	    this.handleAddPieChart = this.handleAddPieChart.bind(this);
	    this.handleAddChordGraph = this.handleAddChordGraph.bind(this);
	    this.handleAddForceDirectedGraph = this.handleAddForceDirectedGraph.bind(this);
	    this.handleAddTreeDiagram = this.handleAddTreeDiagram.bind(this);
	    this.handleAddClusterDiagram = this.handleAddClusterDiagram.bind(this);
	    this.handleAddPackDiagram = this.handleAddPackDiagram.bind(this);
	    this.handleAddPartitionDiagram = this.handleAddPartitionDiagram.bind(this);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('2D'),
	      show: app.debug === true
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Button'),
	      onClick: this.handleAddButton
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Label'),
	      onClick: this.handleAddLabel
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Panel'),
	      onClick: this.handleAddPanel
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Horizontal Line'),
	      onClick: this.handleAddHorizontalLine
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Bar Chart'),
	      onClick: this.handleAddBarChart
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Time'),
	      onClick: this.handleAddTimeLabel
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Vertical Line'),
	      onClick: this.handleAddVerticalLine
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Date'),
	      onClick: this.handleAddDateWeek
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Time Disk'),
	      onClick: this.handleAddTimeDisk
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Key Value Label'),
	      onClick: this.handleAddKeyValueLabel
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Form Panel'),
	      onClick: this.handleAddFormPanel
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Gauge'),
	      onClick: this.handleAddGauge
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Histogram'),
	      onClick: this.handleAddHistogram
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Line Chart'),
	      onClick: this.handleAddLineChart
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Sidebar'),
	      onClick: this.handleAddSideBar
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: `${_t('Histogram')}2`,
	      onClick: this.handleAddHistogram2
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Scatter Plot'),
	      onClick: this.handleAddScatterPlot
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Pie Chart'),
	      onClick: this.handleAddPieChart
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Chord Graph'),
	      onClick: this.handleAddChordGraph
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Force Directed Graph'),
	      onClick: this.handleAddForceDirectedGraph
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Tree Diagram'),
	      onClick: this.handleAddTreeDiagram
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Cluster Diagram'),
	      onClick: this.handleAddClusterDiagram
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Pack Diagram'),
	      onClick: this.handleAddPackDiagram
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Partition Diagram'),
	      onClick: this.handleAddPartitionDiagram
	    }));
	  } // ------------------------------ 按钮 --------------------------------


	  handleAddButton() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Button$1());
	    visual.render(svg);
	  } // ---------------------------- 标签 -----------------------------------


	  handleAddLabel() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Label$1());
	    visual.render(svg);
	  } // ---------------------------- 面板 ------------------------------------


	  handleAddPanel() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Panel$1());
	    visual.render(svg);
	  } // --------------------------- 水平线 -------------------------------------


	  handleAddHorizontalLine() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new HorizontalLine());
	    visual.render(svg);
	  } // ---------------------------- 条形图 -------------------------------------


	  handleAddBarChart() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new BarChart());
	    visual.render(svg);
	  } // --------------------------- 时间标签 --------------------------------------


	  handleAddTimeLabel() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new TimeLabel());
	    visual.render(svg);
	  } // --------------------------- 垂直线 ------------------------------------------


	  handleAddVerticalLine() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new VerticalLine());
	    visual.render(svg);
	  } // -------------------------- 日期时间 -------------------------------------------


	  handleAddDateWeek() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new DateWeekLabel());
	    visual.render(svg);
	  } // ------------------------- 时间圆盘 -----------------------------------------------


	  handleAddTimeDisk() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new TimeDisk());
	    visual.render(svg);
	  } // -------------------------- 键值标签 -------------------------------------------------


	  handleAddKeyValueLabel() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new KeyValueLabel());
	    visual.render(svg);
	  } // --------------------------- 表单 ------------------------------------------------------


	  handleAddFormPanel() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new FormPanel());
	    visual.render(svg);
	  } // ---------------------------- 仪表 --------------------------------------------


	  handleAddGauge() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Gauge());
	    visual.render(svg);
	  } // --------------------------- 柱状图 ----------------------------------------------


	  handleAddHistogram() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Histogram());
	    visual.render(svg);
	  } // ------------------------------- 折线图 ----------------------------------------------


	  handleAddLineChart() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new LineChart());
	    visual.render(svg);
	  } // -------------------------------- 侧边栏 ---------------------------------------------


	  handleAddSideBar() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new SideBar());
	    visual.render(svg);
	  } // ------------------------------- 柱状图2 ------------------------------------------------


	  handleAddHistogram2() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Histogram2());
	    visual.render(svg);
	  } // -------------------------------- 散点图 ---------------------------------------------------


	  handleAddScatterPlot() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new ScatterPlot());
	    visual.render(svg);
	  } // --------------------------------- 饼状图 --------------------------------------------------


	  handleAddPieChart() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new PieChart());
	    visual.render(svg);
	  } // --------------------------------- 弦图 --------------------------------------------------


	  handleAddChordGraph() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new ChordGraph());
	    visual.render(svg);
	  } // ----------------------------------- 力导向图 ---------------------------------------------


	  handleAddForceDirectedGraph() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new ForceDirectedGraph());
	    visual.render(svg);
	  } // ----------------------------------- 树状图 -----------------------------------------------


	  handleAddTreeDiagram() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new TreeDiagram());
	    visual.render(svg);
	  } // ---------------------------------- 集群图 -----------------------------------------------------


	  handleAddClusterDiagram() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new ClusterDiagram());
	    visual.render(svg);
	  } // ------------------------------- 包图 -----------------------------------------


	  handleAddPackDiagram() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new PackDiagram());
	    visual.render(svg);
	  } // --------------------------------- 分区图 --------------------------------------------


	  handleAddPartitionDiagram() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new PartitionDiagram());
	    visual.render(svg);
	  }

	}

	/**
	 * 组
	 */
	function Group() {
	  THREE.Group.call(this);
	  this.name = _t('Group');
	}

	Group.prototype = Object.create(THREE.Group.prototype);
	Group.prototype.constructor = Group;

	/**
	 * 平面
	 * @param {THREE.PlaneBufferGeometry} geometry 几何体
	 * @param {THREE.MeshStandardMaterial} material 材质
	 */
	function Plane$1(geometry = new THREE.PlaneBufferGeometry(50, 50), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Plane');
	  this.rotation.x = -Math.PI / 2;
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: true,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 0,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Plane$1.prototype = Object.create(THREE.Mesh.prototype);
	Plane$1.prototype.constructor = Plane$1;

	/**
	 * 正方体
	 * @param {THREE.BoxBufferGeometry} geometry 几何体
	 * @param {THREE.MeshStandardMaterial} material 材质
	 */
	function Box(geometry = new THREE.BoxBufferGeometry(1, 1, 1), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Box');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: true,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Box.prototype = Object.create(THREE.Mesh.prototype);
	Box.prototype.constructor = Box;

	/**
	 * 圆
	 * @param {THREE.CircleBufferGeometry} geometry 几何体
	 * @param {THREE.MeshStandardMaterial} material 材质
	 */
	function Circle(geometry = new THREE.CircleBufferGeometry(1, 32), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Circle');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: true,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1.0,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Circle.prototype = Object.create(THREE.Mesh.prototype);
	Circle.prototype.constructor = Circle;

	/**
	 * 圆柱体
	 * @param {THREE.CylinderBufferGeometry} geometry 几何体
	 * @param {THREE.MeshStandardMaterial} material 材质
	 */
	function Cylinder(geometry = new THREE.CylinderBufferGeometry(1, 1, 2, 32, 1, false), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Cylinder');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: true,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Cylinder.prototype = Object.create(THREE.Mesh.prototype);
	Cylinder.prototype.constructor = Cylinder;

	/**
	 * 球体
	 * @param {THREE.SphereBufferGeometry} geometry 几何体
	 * @param {THREE.MeshStandardMaterial} material 材质
	 */
	function Sphere(geometry = new THREE.SphereBufferGeometry(1, 32, 16, 0, Math.PI * 2, 0, Math.PI), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Sphere');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: true,
	    type: 'rigidBody',
	    shape: 'btSphereShape',
	    mass: 0,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Sphere.prototype = Object.create(THREE.Mesh.prototype);
	Sphere.prototype.constructor = Sphere;

	/**
	 * 二十面体
	 * @param {THREE.IcosahedronBufferGeometry} geometry 几何体
	 * @param {THREE.MeshStandardMaterial} material 材质
	 */
	function Icosahedron(geometry = new THREE.IcosahedronBufferGeometry(1, 2), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Icosahedron');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: true,
	    type: 'rigidBody',
	    shape: 'btSphereShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Icosahedron.prototype = Object.create(THREE.Mesh.prototype);
	Icosahedron.prototype.constructor = Icosahedron;

	/**
	 * 轮胎
	 * @param {THREE.TorusBufferGeometry} geometry 几何体
	 * @param {THREE.MeshStandardMaterial} material 材质
	 */
	function Torus(geometry = new THREE.TorusBufferGeometry(2, 1, 32, 32, Math.PI * 2), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Torus');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: true,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Torus.prototype = Object.create(THREE.Mesh.prototype);
	Torus.prototype.constructor = Torus;

	/**
	 * 纽结
	 * @param {THREE.TorusKnotBufferGeometry} geometry 几何体
	 * @param {THREE.MeshStandardMaterial} material 材质
	 */
	function TorusKnot(geometry = new THREE.TorusKnotBufferGeometry(2, 0.8, 64, 12, 2, 3), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Torus Knot');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: true,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	TorusKnot.prototype = Object.create(THREE.Mesh.prototype);
	TorusKnot.prototype.constructor = TorusKnot;

	/**
	 * 茶壶
	 * @param {THREE.TeapotBufferGeometry} geometry 几何体
	 * @param {THREE.MeshStandardMaterial} material 材质
	 */
	function Teapot(geometry = new THREE.TeapotBufferGeometry(3, 10, true, true, true, true, true), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material); // 修改TeapotBufferGeometry类型错误问题，原来是BufferGeometry

	  geometry.type = 'TeapotBufferGeometry'; // 修复TeapotBufferGeometry缺少parameters参数问题

	  geometry.parameters = {
	    size: 3,
	    segments: 10,
	    bottom: true,
	    lid: true,
	    body: true,
	    fitLid: true,
	    blinn: true
	  };
	  this.name = _t('Teapot');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: true,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Teapot.prototype = Object.create(THREE.Mesh.prototype);
	Teapot.prototype.constructor = Teapot;

	var points = [new THREE.Vector2(0, 0), new THREE.Vector2(4, 0), new THREE.Vector2(3.5, 0.5), new THREE.Vector2(1, 0.75), new THREE.Vector2(0.8, 1), new THREE.Vector2(0.8, 4), new THREE.Vector2(1, 4.2), new THREE.Vector2(1.4, 4.8), new THREE.Vector2(2, 5), new THREE.Vector2(2.5, 5.4), new THREE.Vector2(3, 12)];
	/**
	 * 酒杯
	 * @param {THREE.LatheBufferGeometry} geometry 几何体
	 * @param {THREE.MeshStandardMaterial} material 材质
	 */

	function Lathe(geometry = new THREE.LatheBufferGeometry(points, 20, 0, 2 * Math.PI), material = new THREE.MeshStandardMaterial({
	  side: THREE.DoubleSide
	})) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Lathe');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: true,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Lathe.prototype = Object.create(THREE.Mesh.prototype);
	Lathe.prototype.constructor = Lathe;

	/**
	 * 字体工具类
	 * @author tengge / https://github.com/tengge1
	 * @author gero3 / https://github.com/gero3
	 */
	const TypefaceUtils = {
	  /**
	   * 将字体(.ttf)转换成(.json)格式，用于创建三维文字
	   * @param {ArrayBuffer} arrayBuffer .ttf字体二进制数据
	   * @param {Boolean} reverseDirection 是否反转方向
	   * @param {String} characterSet 需要哪些字符
	   * @returns {String} json数据
	   */
	  convertTtfToJson(arrayBuffer, reverseDirection = false, characterSet = '') {
	    return new Promise(resolve => {
	      app.require('opentype').then(() => {
	        const font = opentype.parse(arrayBuffer);

	        let result = this._convert(font, reverseDirection, characterSet);

	        resolve({
	          result,
	          font
	        });
	      });
	    });
	  },

	  // url https://github.com/gero3/facetype.js
	  _convert(font, reverseDirection, characterSet) {
	    var scale = 1000 * 100 / ((font.unitsPerEm || 2048) * 72);
	    var result = {};
	    result.glyphs = {};
	    var restriction = {
	      range: null,
	      set: null
	    };

	    if (characterSet.length > 0) {
	      var restrictContent = characterSet;
	      var rangeSeparator = '-';

	      if (restrictContent.indexOf(rangeSeparator) !== -1) {
	        var rangeParts = restrictContent.split(rangeSeparator);

	        if (rangeParts.length === 2 && !isNaN(rangeParts[0]) && !isNaN(rangeParts[1])) {
	          restriction.range = [parseInt(rangeParts[0]), parseInt(rangeParts[1])];
	        }
	      }

	      if (restriction.range === null) {
	        restriction.set = restrictContent;
	      }
	    }

	    font.glyphs.forEach(function (glyph) {
	      if (glyph.unicode !== undefined) {
	        var glyphCharacter = String.fromCharCode(glyph.unicode);
	        var needToExport = true;

	        if (restriction.range !== null) {
	          needToExport = glyph.unicode >= restriction.range[0] && glyph.unicode <= restriction.range[1];
	        } else if (restriction.set !== null) {
	          needToExport = characterSet.indexOf(glyphCharacter) !== -1;
	        }

	        if (needToExport) {
	          var token = {};
	          token.ha = Math.round(glyph.advanceWidth * scale);
	          token.x_min = Math.round(glyph.xMin * scale);
	          token.x_max = Math.round(glyph.xMax * scale);
	          token.o = "";

	          if (reverseDirection) {
	            glyph.path.commands = this._reverseCommands(glyph.path.commands);
	          }

	          glyph.path.commands.forEach(function (command) {
	            if (command.type.toLowerCase() === "c") {
	              command.type = "b";
	            }

	            token.o += command.type.toLowerCase();
	            token.o += " ";

	            if (command.x !== undefined && command.y !== undefined) {
	              token.o += Math.round(command.x * scale);
	              token.o += " ";
	              token.o += Math.round(command.y * scale);
	              token.o += " ";
	            }

	            if (command.x1 !== undefined && command.y1 !== undefined) {
	              token.o += Math.round(command.x1 * scale);
	              token.o += " ";
	              token.o += Math.round(command.y1 * scale);
	              token.o += " ";
	            }

	            if (command.x2 !== undefined && command.y2 !== undefined) {
	              token.o += Math.round(command.x2 * scale);
	              token.o += " ";
	              token.o += Math.round(command.y2 * scale);
	              token.o += " ";
	            }
	          });
	          result.glyphs[String.fromCharCode(glyph.unicode)] = token;
	        }
	      }
	    });
	    result.familyName = font.familyName;
	    result.ascender = Math.round(font.ascender * scale);
	    result.descender = Math.round(font.descender * scale);
	    result.underlinePosition = Math.round(font.tables.post.underlinePosition * scale);
	    result.underlineThickness = Math.round(font.tables.post.underlineThickness * scale);
	    result.boundingBox = {
	      "yMin": Math.round(font.tables.head.yMin * scale),
	      "xMin": Math.round(font.tables.head.xMin * scale),
	      "yMax": Math.round(font.tables.head.yMax * scale),
	      "xMax": Math.round(font.tables.head.xMax * scale)
	    };
	    result.resolution = 1000;
	    result.original_font_information = font.tables.name;

	    if (font.styleName.toLowerCase().indexOf("bold") > -1) {
	      result.cssFontWeight = "bold";
	    } else {
	      result.cssFontWeight = "normal";
	    }

	    if (font.styleName.toLowerCase().indexOf("italic") > -1) {
	      result.cssFontStyle = "italic";
	    } else {
	      result.cssFontStyle = "normal";
	    }

	    return JSON.stringify(result);
	  },

	  // url: https://github.com/gero3/facetype.js
	  _reverseCommands(commands) {
	    var paths = [];
	    var path;
	    commands.forEach(function (c) {
	      if (c.type.toLowerCase() === "m") {
	        path = [c];
	        paths.push(path);
	      } else if (c.type.toLowerCase() !== "z") {
	        path.push(c);
	      }
	    });
	    var reversed = [];
	    paths.forEach(function (p) {
	      var result = {
	        "type": "m",
	        "x": p[p.length - 1].x,
	        "y": p[p.length - 1].y
	      };
	      reversed.push(result);

	      for (var i = p.length - 1; i > 0; i--) {
	        var command = p[i];
	        result = {
	          "type": command.type
	        };

	        if (command.x2 !== undefined && command.y2 !== undefined) {
	          result.x1 = command.x2;
	          result.y1 = command.y2;
	          result.x2 = command.x1;
	          result.y2 = command.y1;
	        } else if (command.x1 !== undefined && command.y1 !== undefined) {
	          result.x1 = command.x1;
	          result.y1 = command.y1;
	        }

	        result.x = p[i - 1].x;
	        result.y = p[i - 1].y;
	        reversed.push(result);
	      }
	    });
	    return reversed;
	  }

	};

	/**
	 * 添加3D文字窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class Add3DTextWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.fonts = [];
	    this.state = {
	      text: _t('Some Words'),
	      fonts: {},
	      // 所有字体
	      font: '',
	      // 字体
	      size: 4,
	      // 尺寸
	      color: '#ffffff',
	      // 颜色
	      height: 2,
	      // 厚度
	      bevelEnabled: true,
	      // 倒角
	      bevelSize: 0.1,
	      // 倒角尺寸
	      bevelThickness: 0.1 // 倒角厚度

	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleSave = this.handleSave.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      text,
	      fonts,
	      font,
	      size,
	      color,
	      height,
	      bevelEnabled,
	      bevelSize,
	      bevelThickness
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'Add3DTextWindow',
	      title: _t('Add 3D Text'),
	      style: {
	        width: '400px',
	        height: '320px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Text')), /*#__PURE__*/React.createElement(Input, {
	      name: 'text',
	      value: text,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Font')), /*#__PURE__*/React.createElement(Select, {
	      name: 'font',
	      value: font,
	      options: fonts,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Size')), /*#__PURE__*/React.createElement(Input, {
	      name: 'size',
	      type: 'number',
	      value: size,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Color')), /*#__PURE__*/React.createElement(Input, {
	      name: 'color',
	      type: 'color',
	      value: color,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Thickness')), /*#__PURE__*/React.createElement(Input, {
	      name: 'height',
	      type: 'number',
	      value: height,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Enable Bevel')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'bevelEnabled',
	      checked: bevelEnabled,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Bevel Size')), /*#__PURE__*/React.createElement(Input, {
	      name: 'bevelSize',
	      type: 'number',
	      value: bevelSize,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Bevel Thickness')), /*#__PURE__*/React.createElement(Input, {
	      name: 'bevelThickness',
	      type: 'number',
	      value: bevelThickness,
	      onChange: this.handleChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  componentDidMount() {
	    this.updateFonts();
	  }

	  updateFonts() {
	    fetch(`${app.options.server}/api/Typeface/List`).then(response => {
	      response.json().then(json => {
	        if (json.Code !== 200) {
	          app.toast(_t(json.Msg), 'warn');
	          return;
	        }

	        this.fonts = json.Data;

	        if (this.fonts.length === 0) {
	          app.toast(_t('Pleast upload typeface first.'), 'warn');
	          return;
	        }

	        let fonts = {};
	        this.fonts.forEach(n => {
	          fonts[n.ID] = n.Name;
	        });
	        this.setState({
	          fonts,
	          font: this.fonts[0].ID
	        });
	      });
	    });
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleSave() {
	    const {
	      text,
	      font,
	      size,
	      color,
	      height,
	      bevelEnabled,
	      bevelSize,
	      bevelThickness
	    } = this.state;

	    if (font === '') {
	      app.toast(_t('Pleast upload typeface first.'), 'warn');
	      return;
	    }

	    app.mask();
	    const fontData = this.fonts.filter(n => n.ID === font)[0];
	    fetch(`${app.options.server}${fontData.Url}`).then(response => {
	      response.arrayBuffer().then(buffer => {
	        TypefaceUtils.convertTtfToJson(buffer, false, text).then(obj => {
	          app.editor.execute(new AddObjectCommand(new ThreeDText(text, {
	            font: obj.result,
	            size,
	            color,
	            height,
	            bevelEnabled,
	            bevelSize,
	            bevelThickness
	          })));
	          app.unmask();
	          this.handleClose();
	        });
	      });
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	var ID$9 = -1;
	/**
	 * 工具基类
	 * @author tengge / https://github.com/tengge1
	 */

	class BaseTool {
	  constructor() {
	    this.id = `EditorTool${ID$9--}`;
	    this.dispatch = dispatch('end');
	    this.call = this.dispatch.call.bind(this.dispatch);
	    this.on = this.dispatch.on.bind(this.dispatch);
	  }

	  start() {}

	  stop() {}

	  clear() {}

	}

	/**
	 * 点标注工具
	 */

	class PointMarkTool extends BaseTool {
	  constructor() {
	    super();
	    this.onRaycast = this.onRaycast.bind(this);
	    this.onGpuPick = this.onGpuPick.bind(this);
	  }

	  start() {
	    this.marker = new PointMarker('', {
	      domWidth: app.editor.renderer.domElement.width,
	      domHeight: app.editor.renderer.domElement.height
	    });
	    app.editor.sceneHelpers.add(this.marker);
	    app.toast(_t('Please click on the marked position.'));
	    app.on(`raycast.${this.id}`, this.onRaycast);
	    app.on(`gpuPick.${this.id}`, this.onGpuPick);
	  }

	  stop() {
	    this.marker = null;
	    app.on(`raycast.${this.id}`, null);
	    app.on(`gpuPick.${this.id}`, null);
	  }

	  onRaycast(obj) {
	    // 点击鼠标，放置标注
	    if (!obj.point) {
	      return;
	    }

	    const value = obj.object && obj.object.name ? obj.object.name : '';
	    this.marker.position.copy(obj.point); // 标注要沿着平面法线方向

	    if (obj.face) {
	      this.marker.lookAt(this.marker.position.clone().add(obj.face.normal));
	    }

	    app.prompt({
	      title: _t('Input marker name:'),
	      content: _t('Marker name'),
	      value,
	      mask: true,
	      onOK: text => {
	        this.marker.setText(text);
	        app.editor.sceneHelpers.remove(this.marker);
	        app.editor.addObject(this.marker);
	        this.stop();
	        this.call(`end`, this);
	      },
	      onClose: () => {
	        if (this.marker) {
	          app.editor.removeObject(this.marker);
	        }

	        this.stop();
	        this.call(`end`, this);
	      }
	    });
	  }

	  onGpuPick(obj) {
	    // 预览标注放置效果
	    if (!obj.point || !this.marker) {
	      return;
	    }

	    if (obj.object && this.marker.name !== obj.object.name) {
	      this.marker.setText(obj.object.name);
	    } else {
	      this.marker.setText('');
	    }

	    this.marker.position.copy(obj.point);
	  }

	}

	/**
	 * 精灵
	 * @param {THREE.SpriteMaterial} material 材质
	 */
	function Sprite(material = new THREE.SpriteMaterial()) {
	  THREE.Sprite.call(this, material);
	  this.name = _t('Sprite');
	}

	Sprite.prototype = Object.create(THREE.Sprite.prototype);
	Sprite.prototype.constructor = Sprite;

	/**
	 * 物体菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class ObjectMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleAddGroup = this.handleAddGroup.bind(this);
	    this.handleAddPlane = this.handleAddPlane.bind(this);
	    this.handleAddBox = this.handleAddBox.bind(this);
	    this.handleAddCircle = this.handleAddCircle.bind(this);
	    this.handleAddCylinder = this.handleAddCylinder.bind(this);
	    this.handleAddSphere = this.handleAddSphere.bind(this);
	    this.handleAddIcosahedron = this.handleAddIcosahedron.bind(this);
	    this.handleAddTorus = this.handleAddTorus.bind(this);
	    this.handleAddTorusKnot = this.handleAddTorusKnot.bind(this);
	    this.handleAddTeaport = this.handleAddTeaport.bind(this);
	    this.handleAddLathe = this.handleAddLathe.bind(this);
	    this.handleAddUnscaledText = this.handleAddUnscaledText.bind(this);
	    this.handleAdd3DText = this.handleAdd3DText.bind(this);
	    this.handleAddLineCurve = this.handleAddLineCurve.bind(this);
	    this.handleAddCatmullRomCurve = this.handleAddCatmullRomCurve.bind(this);
	    this.handleAddQuadraticBezierCurve = this.handleAddQuadraticBezierCurve.bind(this);
	    this.handleAddCubicBezierCurve = this.handleAddCubicBezierCurve.bind(this);
	    this.handleAddEllipseCurve = this.handleAddEllipseCurve.bind(this);
	    this.handleAddPointMark = this.handleAddPointMark.bind(this);
	    this.handleAddOrthographicCamera = this.handleAddOrthographicCamera.bind(this);
	    this.handleAddPerspectiveCamera = this.handleAddPerspectiveCamera.bind(this);
	    this.handleAddArrowHelper = this.handleAddArrowHelper.bind(this);
	    this.handleAddAxesHelper = this.handleAddAxesHelper.bind(this);
	    this.handleAddSprite = this.handleAddSprite.bind(this);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Object')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Group'),
	      onClick: this.handleAddGroup
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Basic Geometry')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Plane'),
	      onClick: this.handleAddPlane
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Box'),
	      onClick: this.handleAddBox
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Circle'),
	      onClick: this.handleAddCircle
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Cylinder'),
	      onClick: this.handleAddCylinder
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Sphere'),
	      onClick: this.handleAddSphere
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Icosahedron'),
	      onClick: this.handleAddIcosahedron
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Torus'),
	      onClick: this.handleAddTorus
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Torus Knot'),
	      onClick: this.handleAddTorusKnot
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Teapot'),
	      onClick: this.handleAddTeaport
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Lathe'),
	      onClick: this.handleAddLathe
	    })), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Text')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Unscaled Text'),
	      onClick: this.handleAddUnscaledText
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('3D Text'),
	      onClick: this.handleAdd3DText
	    })), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Curve')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Line Curve'),
	      onClick: this.handleAddLineCurve
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('CatmullRom Curve'),
	      onClick: this.handleAddCatmullRomCurve
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('QuadraticBezier Curve'),
	      onClick: this.handleAddQuadraticBezierCurve
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('CubicBezier Curve'),
	      onClick: this.handleAddCubicBezierCurve
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Ellipse Curve'),
	      onClick: this.handleAddEllipseCurve
	    })), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Mark')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Point Mark'),
	      onClick: this.handleAddPointMark
	    })), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Camera')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Orthographic Camera'),
	      onClick: this.handleAddOrthographicCamera
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Perspective Camera'),
	      onClick: this.handleAddPerspectiveCamera
	    })), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Helper')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Arrow Helper'),
	      onClick: this.handleAddArrowHelper
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Axes Helper'),
	      onClick: this.handleAddAxesHelper
	    })), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Sprite'),
	      onClick: this.handleAddSprite
	    }));
	  } // ------------------------- 组 ---------------------------------


	  handleAddGroup() {
	    app.editor.execute(new AddObjectCommand(new Group()));
	  } // ------------------------- 平板 -------------------------------


	  handleAddPlane() {
	    app.editor.execute(new AddObjectCommand(new Plane$1()));
	  } // ------------------------ 正方体 -----------------------------


	  handleAddBox() {
	    app.editor.execute(new AddObjectCommand(new Box()));
	  } // ------------------------ 圆 ----------------------------------


	  handleAddCircle() {
	    app.editor.execute(new AddObjectCommand(new Circle()));
	  } // ------------------------圆柱体 -------------------------------


	  handleAddCylinder() {
	    app.editor.execute(new AddObjectCommand(new Cylinder()));
	  } // ------------------------ 球体 -------------------------------


	  handleAddSphere() {
	    app.editor.execute(new AddObjectCommand(new Sphere()));
	  } // ----------------------- 二十面体 -----------------------------


	  handleAddIcosahedron() {
	    app.editor.execute(new AddObjectCommand(new Icosahedron()));
	  } // ----------------------- 轮胎 ---------------------------------


	  handleAddTorus() {
	    app.editor.execute(new AddObjectCommand(new Torus()));
	  } // ----------------------- 纽结 ---------------------------------


	  handleAddTorusKnot() {
	    app.editor.execute(new AddObjectCommand(new TorusKnot()));
	  } // ---------------------- 茶壶 ----------------------------------


	  handleAddTeaport() {
	    app.editor.execute(new AddObjectCommand(new Teapot()));
	  } // ---------------------- 酒杯 ----------------------------------


	  handleAddLathe() {
	    app.editor.execute(new AddObjectCommand(new Lathe()));
	  } // ---------------------- 不缩放文字 ----------------------------------


	  handleAddUnscaledText() {
	    app.prompt({
	      title: _t('Please input'),
	      value: _t('Some Words'),
	      onOK: value => {
	        app.editor.execute(new AddObjectCommand(new UnscaledText(value, {
	          domWidth: app.editor.renderer.domElement.width,
	          domHeight: app.editor.renderer.domElement.height
	        })));
	      }
	    });
	  } // ---------------------- 3D文字 ---------------------------------------


	  handleAdd3DText() {
	    let win = app.createElement(Add3DTextWindow);
	    app.addElement(win);
	  } // ---------------------- 线段 ----------------------------------


	  handleAddLineCurve() {
	    var line = new LineCurve();
	    app.editor.execute(new AddObjectCommand(line));
	  } // ---------------------- CatmullRom曲线 ----------------------------------


	  handleAddCatmullRomCurve() {
	    var line = new CatmullRomCurve();
	    app.editor.execute(new AddObjectCommand(line));
	  } // ----------------------- 二次贝塞尔曲线 ---------------------------------


	  handleAddQuadraticBezierCurve() {
	    var line = new QuadraticBezierCurve();
	    app.editor.execute(new AddObjectCommand(line));
	  } // ----------------------- 三次贝塞尔曲线 ---------------------------------


	  handleAddCubicBezierCurve() {
	    var line = new CubicBezierCurve();
	    app.editor.execute(new AddObjectCommand(line));
	  } // --------------------- 椭圆曲线 ------------------------------------------


	  handleAddEllipseCurve() {
	    var line = new EllipseCurve();
	    app.editor.execute(new AddObjectCommand(line));
	  } // -------------------- 点状标注 ----------------------------------


	  handleAddPointMark() {
	    if (this.pointMarkTool === undefined) {
	      this.pointMarkTool = new PointMarkTool();
	      this.pointMarkTool.on(`end`, () => {
	        this.setState({
	          isAddPointMark: false
	        });
	      });
	    }

	    this.pointMarkTool.start();
	    this.setState({
	      isAddPointMark: true
	    });
	  } // ------------------------- 相机 --------------------------------


	  handleAddOrthographicCamera() {
	    let camera = new THREE.OrthographicCamera();
	    camera.name = _t('Orthographic Camera');
	    app.editor.addObject(camera);
	  }

	  handleAddPerspectiveCamera() {
	    let camera = new THREE.PerspectiveCamera();
	    camera.name = _t('Perspective Camera');
	    app.editor.addObject(camera);
	  } // ---------------------- 帮助器 ---------------------------------


	  handleAddArrowHelper() {
	    let helper = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(), 10);
	    helper.name = _t('Arrow Helper');
	    app.editor.addObject(helper);
	  }

	  handleAddAxesHelper() {
	    let helper = new THREE.AxesHelper(10);
	    helper.name = _t('Axes Helper');
	    helper.position.y = 1;
	    app.editor.addObject(helper);
	  } // ---------------------- 精灵 -----------------------------------


	  handleAddSprite() {
	    app.editor.execute(new AddObjectCommand(new Sprite()));
	  }

	}

	/**
	 * 点光源帮助器
	 */
	class PointLightHelper extends THREE.Object3D {
	  constructor(color) {
	    super();
	    this.name = _t('Helper');
	    var geometry = new THREE.SphereBufferGeometry(0.2, 16, 8);
	    var material = new THREE.MeshBasicMaterial({
	      color
	    });
	    var mesh = new THREE.Mesh(geometry, material); // 帮助器

	    mesh.name = _t('Helper');
	    mesh.userData.type = 'helper';
	    this.add(mesh); // 光晕

	    var textureLoader = new THREE.TextureLoader();
	    var textureFlare0 = textureLoader.load('assets/textures/lensflare/lensflare0.png');
	    var textureFlare3 = textureLoader.load('assets/textures/lensflare/lensflare3.png'); // 光晕

	    var lensflare = new THREE.Lensflare();
	    lensflare.addElement(new THREE.LensflareElement(textureFlare0, 40, 0.01, new THREE.Color(color)));
	    lensflare.addElement(new THREE.LensflareElement(textureFlare3, 60, 0.2));
	    lensflare.addElement(new THREE.LensflareElement(textureFlare3, 35, 0.4));
	    lensflare.addElement(new THREE.LensflareElement(textureFlare3, 60, 0.6));
	    lensflare.addElement(new THREE.LensflareElement(textureFlare3, 45, 0.8));
	    lensflare.name = _t('Halo');
	    lensflare.userData.type = 'lensflare';
	    this.add(lensflare);
	  }

	}

	var vertexShader$1 = "varying vec3 vWorldPosition;\r\n\r\nvoid main() {\r\n\tvec4 worldPosition = modelMatrix * vec4(position, 1.0);\r\n\tvWorldPosition = worldPosition.xyz;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}";

	var fragmentShader$1 = "uniform vec3 topColor;\r\nuniform vec3 bottomColor;\r\nuniform float offset;\r\nuniform float exponent;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\nvoid main() {\r\n\tfloat h = normalize(vWorldPosition + offset).y;\r\n\tgl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h , 0.0), exponent), 0.0)), 1.0);\r\n}";

	/**
	 * 半球光帮助器
	 */

	class HemisphereLightHelper extends THREE.Object3D {
	  constructor(skyColor, groundColor) {
	    super();
	    this.name = _t('Helper');
	    var uniforms = {
	      topColor: {
	        value: new THREE.Color(skyColor)
	      },
	      bottomColor: {
	        value: new THREE.Color(groundColor)
	      },
	      offset: {
	        value: 33
	      },
	      exponent: {
	        value: 0.6
	      }
	    };
	    var skyGeo = new THREE.SphereBufferGeometry(4000, 32, 15);
	    var skyMat = new THREE.ShaderMaterial({
	      vertexShader: vertexShader$1,
	      fragmentShader: fragmentShader$1,
	      uniforms: uniforms,
	      side: THREE.BackSide
	    });
	    var sky = new THREE.Mesh(skyGeo, skyMat);
	    sky.name = _t('Sky');
	    sky.userData.type = 'sky';
	    this.add(sky);
	  }

	}

	/**
	 * 矩形光源帮助器
	 */
	class RectAreaLightHelper extends THREE.Object3D {
	  constructor(width, height) {
	    super();
	    this.name = _t('Helper'); // 正面

	    var rectLightMesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(), new THREE.MeshBasicMaterial());
	    rectLightMesh.scale.x = width;
	    rectLightMesh.scale.y = height;
	    rectLightMesh.name = _t('FrontSide');
	    rectLightMesh.userData.type = 'frontSide';
	    this.add(rectLightMesh); // 背面

	    var rectLightMeshBack = new THREE.Mesh(new THREE.PlaneBufferGeometry(), new THREE.MeshBasicMaterial({
	      color: 0x080808
	    }));
	    rectLightMeshBack.scale.x = width;
	    rectLightMeshBack.scale.y = height;
	    rectLightMeshBack.rotation.y = Math.PI;
	    rectLightMesh.name = _t('BackSide');
	    rectLightMesh.userData.type = 'backSide';
	    this.add(rectLightMeshBack);
	  }

	}

	/**
	 * 光源菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class LightMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleAddAmbientLight = this.handleAddAmbientLight.bind(this);
	    this.handleAddDirectionalLight = this.handleAddDirectionalLight.bind(this);
	    this.handleAddPointLight = this.handleAddPointLight.bind(this);
	    this.handleAddSpotLight = this.handleAddSpotLight.bind(this);
	    this.handleAddHemisphereLight = this.handleAddHemisphereLight.bind(this);
	    this.handleAddRectAreaLight = this.handleAddRectAreaLight.bind(this);
	    this.handleAddPointLightHelper = this.handleAddPointLightHelper.bind(this);
	    this.handleAddHemisphereLightHelper = this.handleAddHemisphereLightHelper.bind(this);
	    this.handleAddRectAreaLightHelper = this.handleAddRectAreaLightHelper.bind(this);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Light')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Ambient Light'),
	      onClick: this.handleAddAmbientLight
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Directional Light'),
	      onClick: this.handleAddDirectionalLight
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Point Light'),
	      onClick: this.handleAddPointLight
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Spot Light'),
	      onClick: this.handleAddSpotLight
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Hemisphere Light'),
	      onClick: this.handleAddHemisphereLight
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Rect Area Light'),
	      onClick: this.handleAddRectAreaLight
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Point Light Helper'),
	      onClick: this.handleAddPointLightHelper
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Hemisphere Light Helper'),
	      onClick: this.handleAddHemisphereLightHelper
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Rect Area Light Helper'),
	      onClick: this.handleAddRectAreaLightHelper
	    }));
	  } // ------------------------- 环境光 ------------------------------


	  handleAddAmbientLight() {
	    var editor = app.editor;
	    var color = 0xaaaaaa;
	    var light = new THREE.AmbientLight(color);
	    light.name = _t('Ambient Light');
	    editor.execute(new AddObjectCommand(light));
	  } // ------------------------- 平行光 ------------------------------


	  handleAddDirectionalLight() {
	    var editor = app.editor;
	    var color = 0xffffff;
	    var intensity = 1;
	    var light = new THREE.DirectionalLight(color, intensity);
	    light.name = _t('Directional Light');
	    light.castShadow = true;
	    light.shadow.mapSize.x = 2048;
	    light.shadow.mapSize.y = 2048;
	    light.shadow.camera.left = -100;
	    light.shadow.camera.right = 100;
	    light.shadow.camera.top = 100;
	    light.shadow.camera.bottom = -100;
	    light.position.set(5, 10, 7.5);
	    editor.execute(new AddObjectCommand(light));
	  } // ------------------------- 点光源 ------------------------------


	  handleAddPointLight() {
	    var editor = app.editor;
	    var color = 0xffffff;
	    var intensity = 1;
	    var distance = 0;
	    var light = new THREE.PointLight(color, intensity, distance);
	    light.name = _t('Point Light');
	    light.position.y = 5;
	    light.castShadow = true;
	    editor.execute(new AddObjectCommand(light));
	  } // ------------------------- 聚光灯 ------------------------------


	  handleAddSpotLight() {
	    var editor = app.editor;
	    var color = 0xffffff;
	    var intensity = 1;
	    var distance = 0;
	    var angle = Math.PI * 0.1;
	    var penumbra = 0;
	    var light = new THREE.SpotLight(color, intensity, distance, angle, penumbra);
	    light.name = _t('Spot Light');
	    light.castShadow = true;
	    light.position.set(5, 10, 7.5);
	    editor.execute(new AddObjectCommand(light));
	  } // ------------------------- 半球光 ------------------------------


	  handleAddHemisphereLight() {
	    var editor = app.editor;
	    var skyColor = 0x00aaff;
	    var groundColor = 0xffaa00;
	    var intensity = 1;
	    var light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
	    light.name = _t('Hemisphere Light');
	    light.position.set(0, 10, 0);
	    editor.execute(new AddObjectCommand(light));
	  } // ------------------------- 矩形光 ------------------------------


	  handleAddRectAreaLight() {
	    var editor = app.editor;
	    var color = 0xffffff;
	    var intensity = 1;
	    var width = 20;
	    var height = 10;
	    var light = new THREE.RectAreaLight(color, intensity, width, height);
	    light.name = _t('Rect Area Light');
	    light.position.set(0, 6, 0);
	    editor.execute(new AddObjectCommand(light));
	  } // -------------------------- 点光源帮助器 -------------------------------


	  handleAddPointLightHelper() {
	    let selected = app.editor.selected;

	    if (!(selected instanceof THREE.PointLight)) {
	      app.toast(_t('The selected object is not a point light.'), 'warn');
	      return;
	    }

	    selected.add(new PointLightHelper(selected.color));
	    app.call('sceneGraphChanged', this);
	  } // --------------------------- 半球光帮助器 --------------------------------


	  handleAddHemisphereLightHelper() {
	    let selected = app.editor.selected;

	    if (!(selected instanceof THREE.HemisphereLight)) {
	      app.toast(_t('The selected object is not a hemisphere light.'), 'warn');
	      return;
	    }

	    selected.add(new HemisphereLightHelper(selected.color, selected.groundColor));
	    app.call('sceneGraphChanged', this);
	  } // ---------------------------- 矩形光帮助器 -------------------------------------


	  handleAddRectAreaLightHelper() {
	    let selected = app.editor.selected;

	    if (!(selected instanceof THREE.RectAreaLight)) {
	      app.toast(_t('The selected object is not a rect area light.'), 'warn');
	      return;
	    }

	    selected.add(new RectAreaLightHelper(selected.width, selected.height));
	    app.call('sceneGraphChanged', this);
	  }

	}

	/**
	 * 资源菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class AssetsMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleExportGeometry = this.handleExportGeometry.bind(this);
	    this.handleExportObject = this.handleExportObject.bind(this);
	    this.handleExportCollada = this.handleExportCollada.bind(this);
	    this.handleExportDRACO = this.handleExportDRACO.bind(this);
	    this.handleExportGLTF = this.handleExportGLTF.bind(this);
	    this.handleExportOBJ = this.handleExportOBJ.bind(this);
	    this.handleExportPLY = this.handleExportPLY.bind(this);
	    this.handleExportSTLB = this.handleExportSTLB.bind(this);
	    this.handleExportSTL = this.handleExportSTL.bind(this);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Assets')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Export Geometry JSON File'),
	      onClick: this.handleExportGeometry
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Export Object JSON File'),
	      onClick: this.handleExportObject
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Export Collada'),
	      onClick: this.handleExportCollada
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Export DRACO'),
	      onClick: this.handleExportDRACO
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Export GLTF'),
	      onClick: this.handleExportGLTF
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Export OBJ'),
	      onClick: this.handleExportOBJ
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Export PLY'),
	      onClick: this.handleExportPLY
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Export STL Binary'),
	      onClick: this.handleExportSTLB
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Export STL'),
	      onClick: this.handleExportSTL
	    }));
	  } // ------------------------------- 导出几何体 ----------------------------------------


	  handleExportGeometry() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object === null) {
	      app.toast(_t('Please select object!'), 'warn');
	      return;
	    }

	    var geometry = object.geometry;

	    if (geometry === undefined) {
	      app.toast(_t('The object you selected is not geometry.'), 'warn');
	      return;
	    }

	    var output = geometry.toJSON();

	    try {
	      output = JSON.stringify(output, StringUtils.parseNumber, '\t'); // eslint-disable-next-line

	      output = output.replace(/[\n\t]+([\d\.e\-\[\]]+)/g, '$1');
	    } catch (e) {
	      output = JSON.stringify(output);
	    }

	    StringUtils.saveString(output, 'geometry.json');
	  } // ------------------------------- 导出物体 ------------------------------------------


	  handleExportObject() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object === null) {
	      app.toast(_t('Please select object!'), 'warn');
	      return;
	    }

	    var output = object.toJSON();

	    try {
	      output = JSON.stringify(output, StringUtils.parseNumber, '\t'); // eslint-disable-next-line

	      output = output.replace(/[\n\t]+([\d\.e\-\[\]]+)/g, '$1');
	    } catch (e) {
	      output = JSON.stringify(output);
	    }

	    StringUtils.saveString(output, 'model.json');
	  } // ------------------------------ 导出Collada文件 ----------------------------------------


	  handleExportCollada() {
	    app.require('ColladaExporter').then(() => {
	      var exporter = new THREE.ColladaExporter();
	      exporter.parse(app.editor.scene, function (result) {
	        StringUtils.saveString(result.data, 'model.dae');
	      });
	    });
	  } // ------------------------------ 导出DRACO文件 ----------------------------------------


	  handleExportDRACO() {
	    if (!(app.editor.selected instanceof THREE.Mesh)) {
	      app.toast(_t('Please select a mesh.'));
	      return;
	    }

	    app.require('DRACOExporter').then(() => {
	      var exporter = new THREE.DRACOExporter();
	      var data = exporter.parse(app.editor.selected.geometry);
	      StringUtils.saveString(data, 'model.drc');
	    });
	  } // ------------------------------ 导出gltf文件 ----------------------------------------


	  handleExportGLTF() {
	    app.require('GLTFExporter').then(() => {
	      var exporter = new THREE.GLTFExporter();
	      exporter.parse(app.editor.scene, function (result) {
	        StringUtils.saveString(JSON.stringify(result), 'model.gltf');
	      });
	    });
	  } // ------------------------------ 导出obj文件 -----------------------------------------


	  handleExportOBJ() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object === null) {
	      app.toast(_t('Please select object!'), 'warn');
	      return;
	    }

	    app.require('OBJExporter').then(() => {
	      var exporter = new THREE.OBJExporter();
	      StringUtils.saveString(exporter.parse(object), 'model.obj');
	    });
	  } // ------------------------------- 导出ply文件 ----------------------------------------


	  handleExportPLY() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object === null) {
	      app.toast(_t('Please select object!'), 'warn');
	      return;
	    }

	    app.require('PLYExporter').then(() => {
	      var exporter = new THREE.PLYExporter();
	      StringUtils.saveString(exporter.parse(object, {
	        excludeAttributes: ['normal', 'uv', 'color', 'index']
	      }), 'model.ply');
	    });
	  } // ------------------------------- 导出stl二进制文件 -----------------------------------


	  handleExportSTLB() {
	    var editor = app.editor;

	    app.require('STLBinaryExporter').then(() => {
	      var exporter = new THREE.STLBinaryExporter();
	      StringUtils.saveString(exporter.parse(editor.scene), 'model.stl');
	    });
	  } // ------------------------------- 导出stl文件 -----------------------------------------


	  handleExportSTL() {
	    var editor = app.editor;

	    app.require('STLExporter').then(() => {
	      var exporter = new THREE.STLExporter();
	      StringUtils.saveString(exporter.parse(editor.scene), 'model.stl');
	    });
	  }

	}

	var HeightVertexShader = "varying vec2 vUv;\r\nuniform vec2 scale;\r\nuniform vec2 offset;\r\n\r\nvoid main( void ) {\r\n    vUv = uv * scale + offset;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}";

	var HeightFragmentShader = "//\r\n// Description : Array and textureless GLSL 3D simplex noise function.\r\n//      Author : Ian McEwan, Ashima Arts.\r\n//  Maintainer : ijm\r\n//     Lastmod : 20110409 (stegu)\r\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\r\n//               Distributed under the MIT License. See LICENSE file.\r\n//\r\nuniform float time;\r\nvarying vec2 vUv;\r\n\r\nvec4 permute( vec4 x ) {\r\n\treturn mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );\r\n}\r\n\r\nvec4 taylorInvSqrt( vec4 r ) {\r\n\treturn 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nfloat snoise( vec3 v ) {\r\n\tconst vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\r\n\tconst vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\r\n\t// First corner\r\n\tvec3 i  = floor( v + dot( v, C.yyy ) );\r\n\tvec3 x0 = v - i + dot( i, C.xxx );\r\n\t// Other corners\r\n\tvec3 g = step( x0.yzx, x0.xyz );\r\n\tvec3 l = 1.0 - g;\r\n\tvec3 i1 = min( g.xyz, l.zxy );\r\n\tvec3 i2 = max( g.xyz, l.zxy );\r\n\tvec3 x1 = x0 - i1 + 1.0 * C.xxx;\r\n\tvec3 x2 = x0 - i2 + 2.0 * C.xxx;\r\n\tvec3 x3 = x0 - 1. + 3.0 * C.xxx;\r\n\t// Permutations\r\n\ti = mod( i, 289.0 );\r\n\tvec4 p = permute( permute( permute(\r\n\t\t\t i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\r\n\t\t   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\r\n\t\t   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\r\n\t// Gradients\r\n\t// ( N*N points uniformly over a square, mapped onto an octahedron.)\r\n\tfloat n_ = 1.0 / 7.0; // N=7\r\n\tvec3 ns = n_ * D.wyz - D.xzx;\r\n\tvec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)\r\n\tvec4 x_ = floor( j * ns.z );\r\n\tvec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)\r\n\tvec4 x = x_ *ns.x + ns.yyyy;\r\n\tvec4 y = y_ *ns.x + ns.yyyy;\r\n\tvec4 h = 1.0 - abs( x ) - abs( y );\r\n\tvec4 b0 = vec4( x.xy, y.xy );\r\n\tvec4 b1 = vec4( x.zw, y.zw );\r\n\tvec4 s0 = floor( b0 ) * 2.0 + 1.0;\r\n\tvec4 s1 = floor( b1 ) * 2.0 + 1.0;\r\n\tvec4 sh = -step( h, vec4( 0.0 ) );\r\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\r\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\r\n\tvec3 p0 = vec3( a0.xy, h.x );\r\n\tvec3 p1 = vec3( a0.zw, h.y );\r\n\tvec3 p2 = vec3( a1.xy, h.z );\r\n\tvec3 p3 = vec3( a1.zw, h.w );\r\n\t// Normalise gradients\r\n\tvec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\r\n\tp0 *= norm.x;\r\n\tp1 *= norm.y;\r\n\tp2 *= norm.z;\r\n\tp3 *= norm.w;\r\n\t// Mix final noise value\r\n\tvec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\r\n\tm = m * m;\r\n\treturn 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),\r\n\t\t\t\t\t\t\t\t  dot( p2, x2 ), dot( p3, x3 ) ) );\r\n}\r\n\r\nfloat surface3( vec3 coord ) {\r\n\tfloat n = 0.0;\r\n\tn += 1.0 * abs( snoise( coord ) );\r\n\tn += 0.5 * abs( snoise( coord * 2.0 ) );\r\n\tn += 0.25 * abs( snoise( coord * 4.0 ) );\r\n\tn += 0.125 * abs( snoise( coord * 8.0 ) );\r\n\treturn n;\r\n}\r\n\r\nvoid main( void ) {\r\n\tvec3 coord = vec3( vUv, -time );\r\n\tfloat n = surface3( coord );\r\n\tgl_FragColor = vec4( vec3( n, n, n ), 1.0 );\r\n}";

	/**
	 * 着色器地形
	 * @param {*} renderer 渲染器
	 */

	function ShaderTerrain(renderer) {
	  var width = renderer.domElement.width; // 画布宽度

	  var height = renderer.domElement.height; // 画布高度
	  // 地形参数

	  var rx = 256,
	      ry = 256,
	      // 分辨率
	  animDelta = 0,
	      // 动画间隔
	  animDeltaDir = -1,
	      // 动画方向
	  // lightVal = 0, // 光源强度
	  lightDir = 1; // 光源方向
	  // 场景

	  var scene = new THREE.Scene(); // 相机

	  var camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, -10000, 10000);
	  camera.position.z = 100;
	  scene.add(camera); // 高程贴图

	  var heightMap = new THREE.WebGLRenderTarget(rx, ry, {
	    minFilter: THREE.LinearFilter,
	    magFilter: THREE.LinearFilter,
	    format: THREE.RGBFormat
	  });
	  heightMap.texture.generateMipmaps = false; // 法线贴图

	  var normalMap = new THREE.WebGLRenderTarget(rx, ry, {
	    minFilter: THREE.LinearFilter,
	    magFilter: THREE.LinearFilter,
	    format: THREE.RGBFormat
	  });
	  normalMap.texture.generateMipmaps = false; // 高光贴图

	  var specularMap = new THREE.WebGLRenderTarget(2048, 2048, {
	    minFilter: THREE.LinearFilter,
	    magFilter: THREE.LinearFilter,
	    format: THREE.RGBFormat
	  });
	  specularMap.texture.generateMipmaps = false; // 下载纹理

	  var loadingManager = new THREE.LoadingManager(() => {
	    this.visible = true;
	  });
	  var textureLoader = new THREE.TextureLoader(loadingManager);
	  var diffuseTexture1 = textureLoader.load("assets/textures/terrain/grasslight-big.jpg"); // 漫反射纹理1

	  var diffuseTexture2 = textureLoader.load("assets/textures/terrain/backgrounddetailed6.jpg"); // 漫反射纹理2

	  var detailTexture = textureLoader.load("assets/textures/terrain/grasslight-big-nm.jpg"); // 细节纹理

	  diffuseTexture1.wrapS = diffuseTexture1.wrapT = THREE.RepeatWrapping;
	  diffuseTexture2.wrapS = diffuseTexture2.wrapT = THREE.RepeatWrapping;
	  detailTexture.wrapS = detailTexture.wrapT = THREE.RepeatWrapping; // 创建高程材质

	  var heightUniforms = {
	    time: {
	      value: 1.0
	    },
	    scale: {
	      value: new THREE.Vector2(1.5, 1.5)
	    },
	    offset: {
	      value: new THREE.Vector2(0, 0)
	    }
	  };
	  var hightMaterial = this.createShaderMaterial(HeightVertexShader, HeightFragmentShader, heightUniforms, false); // 创建法线材质

	  var normalUniforms = THREE.UniformsUtils.clone(THREE.NormalMapShader.uniforms);
	  normalUniforms.height.value = 0.05;
	  normalUniforms.resolution.value.set(rx, ry);
	  normalUniforms.heightMap.value = heightMap.texture;
	  var normalMaterial = this.createShaderMaterial(THREE.NormalMapShader.vertexShader, THREE.NormalMapShader.fragmentShader, normalUniforms, false); // 创建地形材质

	  var terrainShader = THREE.TerrainShader;
	  var terrainUniforms = THREE.UniformsUtils.clone(terrainShader.uniforms);
	  terrainUniforms['tDisplacement'].value = heightMap.texture; // 位移贴图

	  terrainUniforms['uDisplacementScale'].value = 375; // 位移贴图缩放

	  terrainUniforms['tNormal'].value = normalMap.texture; // 法线贴图

	  terrainUniforms['uNormalScale'].value = 3.5; // 法线贴图缩放

	  terrainUniforms['specular'].value.setHex(0xffffff); // 高光颜色

	  terrainUniforms['diffuse'].value.setHex(0xffffff); // 漫反射颜色

	  terrainUniforms['shininess'].value = 30; // 光泽

	  terrainUniforms['tSpecular'].value = specularMap.texture; // 高光贴图

	  terrainUniforms['enableSpecular'].value = true; // 是否启用高光贴图

	  terrainUniforms['tDiffuse1'].value = diffuseTexture1; // 漫反射纹理1

	  terrainUniforms['enableDiffuse1'].value = true; // 是否启用漫反射纹理1

	  terrainUniforms['tDiffuse2'].value = diffuseTexture2; // 漫反射纹理2

	  terrainUniforms['enableDiffuse2'].value = true; // 是否启用漫反射纹理2

	  terrainUniforms['tDetail'].value = detailTexture; // 细节纹理

	  terrainUniforms['uRepeatOverlay'].value.set(6, 6); // 重复叠加次数

	  var terrainMaterial = this.createShaderMaterial(terrainShader.vertexShader, terrainShader.fragmentShader, terrainUniforms, true); // 贴图生成渲染目标

	  var quadTarget = new THREE.Mesh(new THREE.PlaneBufferGeometry(width, height), new THREE.MeshBasicMaterial({
	    color: 0x000000
	  }));
	  quadTarget.position.z = -500;
	  scene.add(quadTarget); // 创建网格

	  var geometry = new THREE.PlaneBufferGeometry(6000, 6000, 256, 256);
	  THREE.BufferGeometryUtils.computeTangents(geometry);
	  THREE.Mesh.call(this, geometry, terrainMaterial);
	  this.name = _t('Terrain');
	  this.position.set(0, -30, 0);
	  this.rotation.x = -Math.PI / 2;
	  this.scale.set(0.1, 0.1, 0.1); // 动画函数

	  function update(deltaTime) {
	    if (!this.visible) {
	      return;
	    }

	    var fLow = 0.1,
	        fHigh = 0.8;
	    var lightVal = THREE.Math.clamp(lightVal + 0.5 * deltaTime * lightDir, fLow, fHigh);
	    var valNorm = (lightVal - fLow) / (fHigh - fLow);
	    terrainUniforms['uNormalScale'].value = THREE.Math.mapLinear(valNorm, 0, 1, 0.6, 3.5);
	    animDelta = THREE.Math.clamp(animDelta + 0.00075 * animDeltaDir, 0, 0.05);
	    heightUniforms['time'].value += deltaTime * animDelta;
	    heightUniforms['offset'].value.x += deltaTime * 0.05; // 生成高程贴图

	    quadTarget.material = hightMaterial;
	    renderer.render(scene, camera, heightMap, true); // 生成法线贴图

	    quadTarget.material = normalMaterial;
	    renderer.render(scene, camera, normalMap, true);
	  }

	  this.update = update.bind(this);
	}

	ShaderTerrain.prototype = Object.create(THREE.Mesh.prototype);
	ShaderTerrain.prototype.constructor = ShaderTerrain;
	/**
	 * 创建着色器材质
	 * @param {String} vertexShader 顶点着色器
	 * @param {String} fragmentShader 片源着色器
	 * @param {Object} uniforms 变量
	 * @param {Boolean} lights 是否使用光源
	 * @returns {THREE.ShaderMaterial} 地形材质
	 */

	ShaderTerrain.prototype.createShaderMaterial = function (vertexShader, fragmentShader, uniforms, lights) {
	  return new THREE.ShaderMaterial({
	    vertexShader: vertexShader,
	    fragmentShader: fragmentShader,
	    uniforms: uniforms,
	    lights: lights,
	    fog: true
	  });
	};

	var SkyBallVertex = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    gl_Position.z = gl_Position.w;\r\n    vUv = uv;\r\n}";

	var SkyBallFragment = "uniform sampler2D diffuse;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n    gl_FragColor = texture2D(diffuse, vUv);\r\n}";

	/**
	 * 天空球
	 */

	class SkyBall extends THREE.Mesh {
	  constructor(url) {
	    const geometry = new THREE.SphereBufferGeometry(10000, 64, 64);
	    const material = new THREE.ShaderMaterial({
	      vertexShader: SkyBallVertex,
	      fragmentShader: SkyBallFragment,
	      side: THREE.BackSide,
	      uniforms: {
	        diffuse: {
	          value: new THREE.TextureLoader().load(url)
	        }
	      }
	    });
	    super(geometry, material);
	  }

	}

	/**
	 * 组件菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class ComponentMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleAddBackgroundMusic = this.handleAddBackgroundMusic.bind(this);
	    this.handleParticleEmitter = this.handleParticleEmitter.bind(this);
	    this.handleAddSky = this.handleAddSky.bind(this);
	    this.handleAddFire = this.handleAddFire.bind(this);
	    this.handleAddWater = this.handleAddWater.bind(this);
	    this.handleAddSmoke = this.handleAddSmoke.bind(this);
	    this.handleAddCloth = this.handleAddCloth.bind(this);
	    this.handleAddPerlinTerrain = this.handleAddPerlinTerrain.bind(this);
	    this.handleAddSkyBall = this.handleAddSkyBall.bind(this);
	    this.handleAddShaderTerrain = this.handleAddShaderTerrain.bind(this);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Component')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Background Music'),
	      onClick: this.handleAddBackgroundMusic
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('ParticleEmitter'),
	      onClick: this.handleParticleEmitter
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Sky'),
	      onClick: this.handleAddSky
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Fire'),
	      onClick: this.handleAddFire
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Water'),
	      onClick: this.handleAddWater
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Smoke'),
	      onClick: this.handleAddSmoke
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Cloth'),
	      onClick: this.handleAddCloth
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Perlin Terrain'),
	      onClick: this.handleAddPerlinTerrain
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Sky Ball'),
	      onClick: this.handleAddSkyBall
	    }));
	  } // ---------------------------- 添加背景音乐 ----------------------------------


	  handleAddBackgroundMusic() {
	    var editor = app.editor;
	    setTimeout(() => {
	      var listener = editor.audioListener;
	      var audio = new THREE.Audio(listener);
	      audio.name = _t('Background Music');
	      audio.autoplay = false;
	      audio.setLoop(true);
	      audio.setVolume(1.0);
	      audio.userData.autoplay = true;
	      app.editor.execute(new AddObjectCommand(audio));
	    });
	  } // ---------------------------- 添加粒子发射器 --------------------------------------------


	  handleParticleEmitter() {
	    var emitter = new ParticleEmitter();
	    app.editor.execute(new AddObjectCommand(emitter));
	    emitter.userData.group.tick(0);
	  } // ---------------------------- 天空 ----------------------------------------


	  handleAddSky() {
	    var obj = new Sky();
	    obj.name = _t('Sky');
	    obj.userData.type = 'Sky';
	    app.editor.execute(new AddObjectCommand(obj));
	  } // ---------------------------- 添加火焰 -------------------------------------


	  handleAddFire() {
	    var editor = app.editor;
	    var fire = new Fire(editor.camera);
	    editor.execute(new AddObjectCommand(fire));
	    fire.userData.fire.update(0);
	  } // -------------------------- 添加水 ---------------------------------------


	  handleAddWater() {
	    var editor = app.editor;
	    var water = new Water(editor.renderer);
	    editor.execute(new AddObjectCommand(water));
	    water.update();
	  } // ------------------------------ 添加烟 ------------------------------------


	  handleAddSmoke() {
	    var editor = app.editor;
	    var camera = editor.camera;
	    var renderer = editor.renderer;
	    var smoke = new Smoke(camera, renderer);
	    smoke.position.y = 3;
	    editor.execute(new AddObjectCommand(smoke));
	    smoke.update(0);
	  } // ----------------------------- 添加布 ------------------------------------


	  handleAddCloth() {
	    var editor = app.editor;
	    var cloth = new Cloth();
	    cloth.name = _t('Cloth');
	    editor.execute(new AddObjectCommand(cloth));
	  } // ----------------------------- 添加柏林地形 -------------------------------


	  handleAddPerlinTerrain() {
	    let terrain = new PerlinTerrain();
	    terrain.name = _t('Perlin Terrain');
	    app.editor.execute(new AddObjectCommand(terrain));
	  } // ------------------------ 天空球 -------------------------------------------


	  handleAddSkyBall() {
	    app.toast(_t('Please click the sky ball in the MapPanel.'));
	    app.on(`selectMap.ComponentMenu`, obj => {
	      if (obj.Type !== 'skyBall') {
	        app.toast(_t('The map you clicked is not sky ball.'), 'warn');
	        return;
	      }

	      app.on(`selectMap.ComponentMenu`, null);
	      const ball = new SkyBall(`${app.options.server}${obj.Url}`);
	      ball.name = obj.Name;
	      app.editor.addObject(ball);
	    });
	  } // ----------------------------- 添加着色器地形 --------------------------------


	  handleAddShaderTerrain() {
	    app.require('NormalMapShader').then(() => {
	      let terrain = new ShaderTerrain(app.editor.renderer);
	      terrain.name = _t('Shader Terrain');
	      app.editor.execute(new AddObjectCommand(terrain));
	      terrain.update(0);
	    });
	  }

	}

	/**
	 * 播放菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class PlayMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      isPlaying: false
	    };
	    this.handleTogglePlay = this.handleTogglePlay.bind(this);
	    this.handlePlayFullscreen = this.handlePlayFullscreen.bind(this);
	    this.handlePlayNewWindow = this.handlePlayNewWindow.bind(this);
	  }

	  render() {
	    const {
	      isPlaying
	    } = this.state;
	    const isLogin = !app.server.enableAuthority || app.server.isLogin;
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Play')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: isPlaying ? _t('Stop') : _t('Play'),
	      onClick: this.handleTogglePlay
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Play Fullscreen'),
	      onClick: this.handlePlayFullscreen
	    }), isLogin && /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Play New Window'),
	      onClick: this.handlePlayNewWindow
	    }));
	  }

	  handleTogglePlay() {
	    if (this.state.isPlaying) {
	      this.handleStopPlay();
	    } else {
	      this.handleStartPlay();
	    }
	  }

	  handleStartPlay() {
	    // 启动播放
	    if (this.state.isPlaying) {
	      return;
	    }

	    this.setState({
	      isPlaying: true
	    }); // 将场景数据转换为字符串

	    var jsons = new Converter().toJSON({
	      options: app.options,
	      scene: app.editor.scene,
	      camera: app.editor.camera,
	      renderer: app.editor.renderer,
	      scripts: app.editor.scripts,
	      animations: app.editor.animations,
	      visual: app.editor.visual
	    });
	    app.player.start(JSON.stringify(jsons));
	  }

	  handleStopPlay() {
	    // 停止播放
	    if (!this.state.isPlaying) {
	      return;
	    }

	    this.setState({
	      isPlaying: false
	    });
	    app.player.stop();
	    this.setState;
	  }

	  handlePlayFullscreen() {
	    // 全屏播放
	    if (!this.state.isPlaying) {
	      this.handleStartPlay();
	    }

	    app.playerRef.requestFullscreen();
	  }

	  handlePlayNewWindow() {
	    // 新窗口播放
	    let sceneID = app.editor.sceneID;

	    if (!sceneID) {
	      app.toast(_t('Please save scene first.'), 'warn');
	      return;
	    }

	    window.open(`view.html?sceneID=${sceneID}`, 'ShadowPlayer');
	  }

	}

	/**
	 * 纹理生成器窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class TextureGeneratorWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.containerRef = React.createRef();
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'TextureGeneratorWindow',
	      title: _t('Texture Generator'),
	      style: {
	        width: '800px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement("div", {
	      ref: this.containerRef
	    })), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  componentDidMount() {
	    const container = this.containerRef.current;
	    let examples = [];
	    var vignette = null;
	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.XOR().tint(1, 0.5, 0.7)).add(new TG.SinX().frequency(0.004).tint(0.25, 0, 0)).sub(new TG.SinY().frequency(0.004).tint(0.25, 0, 0)).add(new TG.SinX().frequency(0.0065).tint(0.1, 0.5, 0.2)).add(new TG.SinY().frequency(0.0065).tint(0, 0.4, 0.5)).add(new TG.Noise().tint(0.1, 0.1, 0.2)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().offset(-16).frequency(0.03).tint(0.1, 0.25, 0.5)).add(new TG.SinY().offset(-16).frequency(0.03).tint(0.1, 0.25, 0.5)).add(new TG.Number().tint(0.75, 0.5, 0.5)).add(new TG.SinX().frequency(0.03).tint(0.2, 0.2, 0.2)).add(new TG.SinY().frequency(0.03).tint(0.2, 0.2, 0.2)).add(new TG.Noise().tint(0.1, 0, 0)).add(new TG.Noise().tint(0, 0.1, 0)).add(new TG.Noise().tint(0, 0, 0.1)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().frequency(0.1)).mul(new TG.SinX().frequency(0.05)).mul(new TG.SinX().frequency(0.025)).mul(new TG.SinY().frequency(0.1)).mul(new TG.SinY().frequency(0.05)).mul(new TG.SinY().frequency(0.025)).add(new TG.SinX().frequency(0.004).tint(-0.25, 0.1, 0.6)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.XOR()).mul(new TG.OR().tint(0.5, 0.8, 0.5)).mul(new TG.SinX().frequency(0.0312)).div(new TG.SinY().frequency(0.0312)).add(new TG.SinX().frequency(0.004).tint(0.5, 0, 0)).add(new TG.Noise().tint(0.1, 0.1, 0.2)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().frequency(0.01)).mul(new TG.SinY().frequency(0.0075)).add(new TG.SinX().frequency(0.0225)).mul(new TG.SinY().frequency(0.015)).add(new TG.Noise().tint(0.1, 0.1, 0.3)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().frequency(0.05)).mul(new TG.SinX().frequency(0.08)).add(new TG.SinY().frequency(0.05)).mul(new TG.SinY().frequency(0.08)).div(new TG.Number().tint(1, 2, 1)).add(new TG.SinX().frequency(0.003).tint(0.5, 0, 0)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().frequency(0.066)).add(new TG.SinY().frequency(0.066)).mul(new TG.SinX().offset(32).frequency(0.044).tint(2, 2, 2)).mul(new TG.SinY().offset(16).frequency(0.044).tint(2, 2, 2)).sub(new TG.Number().tint(0.5, 2, 4)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().frequency(0.004)).mul(new TG.SinY().frequency(0.004)).mul(new TG.SinY().offset(32).frequency(0.02)).div(new TG.SinX().frequency(0.02).tint(8, 5, 4)).add(new TG.Noise().tint(0.1, 0, 0)).add(new TG.Noise().tint(0, 0.1, 0)).add(new TG.Noise().tint(0, 0, 0.1)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard()).add(new TG.CheckerBoard().size(2, 2).tint(0.5, 0, 0)).add(new TG.CheckerBoard().size(8, 8).tint(1, 0.5, 0.5)).sub(new TG.CheckerBoard().offset(16, 16).tint(0.5, 0.5, 0)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.Rect().position(size / 4.8, size / 12).size(size / 1.7, size / 2).tint(1, 0.25, 0.25)).add(new TG.Rect().position(size / 12, size / 4).size(size / 1.21, size / 2).tint(0.25, 1, 0.25)).add(new TG.Rect().position(size / 4.8, size / 2.5).size(size / 1.7, size / 2).tint(0.25, 0.25, 1)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard().size(32, 32).tint(0.5, 0, 0)).set(new TG.SineDistort()).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard().size(32, 32).tint(0.5, 0, 0)).set(new TG.Twirl().radius(size / 2).position(size / 2, size / 2).strength(75)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.Circle().position(size / 2, size / 2).radius(size / 4)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.Circle().position(size / 2, size / 2).radius(size / 4).delta(size / 4).tint(1, 0.25, 0.25)).set(new TG.Pixelate().size(size / 32, size / 32)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard().tint(1, 1, 0)).set(new TG.Transform().offset(10, 20).angle(23).scale(2, 0.5)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard()).and(new TG.Circle().position(size / 2, size / 2).radius(size / 3)).xor(new TG.Circle().position(size / 2, size / 2).radius(size / 4)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard().size(size / 16, size / 16)).set(new TG.Twirl().radius(size / 2).strength(75).position(size / 2, size / 2)).min(new TG.Circle().position(size / 2, size / 2).radius(size / 2).delta(size / 2)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.LinearGradient().interpolation(0).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.LinearGradient().interpolation(1).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.LinearGradient().interpolation(2).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.RadialGradient().center(size / 2, size / 2).radius(size / 8).repeat(true).interpolation(0).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.RadialGradient().center(0, 0).radius(size * 2).interpolation(1).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.RadialGradient().center(size / 2, 0).radius(size).interpolation(2).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //---- Put-Texture ----

	    examples.push(function (size) {
	      vignette = new TG.Texture(size, size) // predefine a vignette-effect so it can be used later
	      .set(new TG.Circle().radius(size).position(size / 2, size / 2).delta(size * 0.7));
	      var numSamples = 6; // more samples = heavier effect

	      var base = new TG.Texture(size, size) // generating an image to be blurred
	      .set(new TG.FractalNoise().amplitude(0.46).persistence(0.78).interpolation(0)).set(new TG.Normalize());
	      var blur = new TG.Texture(size, size); // the texture the samples are put onto

	      for (var i = 0; i <= numSamples; i++) {
	        var sample = new TG.Texture(size, size).set(new TG.PutTexture(base)) // copy the base texture, so that it doesn't get modified
	        .set(new TG.Transform().scale(1 + 0.01 * i, 1 + 0.01 * i).angle(0.5 * i)); // modify the texture a bit more with each sample

	        blur.add(new TG.PutTexture(sample)); // adding the transformed sample to the result
	      }

	      blur.set(new TG.Normalize()) // since the samples are not weighted, put everything in the visible range
	      .mul(new TG.PutTexture(vignette)); // adding the predefined vignette-effect

	      base.toCanvas(); // since we copied the base texture instead of modifying it directly, we can still use it how it was before

	      var texture = blur.toCanvas();
	      return texture;
	    }); //----

	    examples.push(function (size) {
	      var subDim = Math.floor(size / 4); // generate a smaller image so it can be mirrored later

	      var pixel = new TG.Texture(subDim, subDim).set(new TG.FractalNoise().baseFrequency(subDim / 15).octaves(1).amplitude(1)) // generating a noise pattern with 15 pixels per length
	      .set(new TG.GradientMap().interpolation(0) // divide the generated values into defined colors
	      .point(0, [250, 230, 210]) //[ 251, 255, 228 ] (alternative colors)
	      .point(0.2, [255, 92, 103]) //[ 130, 198, 184 ]
	      .point(0.4, [200, 15, 17]) //[ 42, 166, 137 ]
	      .point(0.6, [140, 49, 59]) //[ 58, 131, 114 ]
	      .point(0.8, [35, 10, 12]) //[ 4, 46, 27 ]
	      .point(1, [0, 0, 0])).div(new TG.Number().tint(255, 255, 255)); // converting the 0-255 defined colors to the 0-1 space

	      var mirrored = new TG.Texture(size, size).add(new TG.PutTexture(pixel).repeat(2)) // repeat the texture to get a cool mirrored pattern effect
	      .mul(new TG.PutTexture(vignette).tint(1.2, 1.2, 1.2)); // adding the vignette from the example above

	      var texture = mirrored.toCanvas();
	      return texture;
	    });

	    function generateTexture(a) {
	      if (a >= examples.length) return;
	      container.appendChild(examples[a](256));
	      setTimeout(function () {
	        generateTexture(a + 1);
	      });
	    }

	    setTimeout(function () {
	      generateTexture(0);
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 字体管理器窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class TypefaceManagementWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      selected: null,
	      mask: false
	    };
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      data,
	      selected,
	      mask
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'TypefaceManagementWindow',
	      title: _t('Typeface Management'),
	      style: {
	        width: '400px',
	        height: '320px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(VBoxLayout, null, /*#__PURE__*/React.createElement(Toolbar, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleAdd
	    }, _t('Add')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleDelete
	    }, _t('Delete'))), /*#__PURE__*/React.createElement(DataGrid, {
	      data: data,
	      selected: selected,
	      mask: mask,
	      keyField: 'ID',
	      onSelect: this.handleSelect
	    }, /*#__PURE__*/React.createElement(Column, {
	      type: 'number'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Name',
	      title: _t('Name')
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'CreateTime',
	      title: _t('Create Time'),
	      width: 160
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  componentDidMount() {
	    this.update();
	  }

	  update() {
	    this.setState({
	      mask: true
	    });
	    fetch(`${app.options.server}/api/Typeface/List`).then(response => {
	      response.json().then(json => {
	        this.setState({
	          data: json.Data,
	          mask: false
	        });
	      });
	    });
	  }

	  handleAdd() {
	    app.upload(`${app.options.server}/api/Typeface/Add`, obj => {
	      if (obj.Code === 200) {
	        this.update();
	      }

	      app.toast(_t(obj.Msg));
	    });
	  }

	  handleDelete() {
	    const selected = this.state.selected;

	    if (!selected) {
	      app.toast(_t('Please select a record.'));
	      return;
	    }

	    app.confirm({
	      title: _t('Query'),
	      content: _t('Delete the selected record?'),
	      onOK: () => {
	        this.commitDelete(selected);
	      }
	    });
	  }

	  commitDelete(id) {
	    fetch(`${app.options.server}/api/Typeface/Delete?ID=${id}`, {
	      method: 'POST'
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.update();
	        app.toast(_t(obj.Msg), 'success');
	      });
	    });
	  }

	  handleSelect(record) {
	    this.setState({
	      selected: record.ID
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	function fakeClick(obj) {
	  let ev = document.createEvent('MouseEvents');
	  ev.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
	  obj.dispatchEvent(ev);
	}
	/**
	 * 下载工具
	 * @author tengge / https://github.com/tengge1
	 */


	const DownloadUtils = {
	  download: function (blobParts = [], options = {
	    'type': 'application/octet-stream'
	  }, fileName = 'NoName') {
	    let urlObject = window.URL || window.webkitURL || window;
	    let blob = new Blob(blobParts, options);
	    let link = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
	    link.href = urlObject.createObjectURL(blob);
	    link.download = fileName;
	    fakeClick(link);
	  }
	};

	/**
	 * 字体转换器窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class TypefaceConverterWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      file: null,
	      reverseDirection: false,
	      characterSet: '',
	      font: null
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleConvertFontType = this.handleConvertFontType.bind(this);
	    this.handleOK = this.handleOK.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      file,
	      reverseDirection,
	      characterSet
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'TypefaceConverterWindow',
	      title: _t('Typeface Converter'),
	      style: {
	        width: '400px',
	        height: '320px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Font File') + ' (.ttf)'), /*#__PURE__*/React.createElement(Input, {
	      className: 'font',
	      name: 'file',
	      type: 'file',
	      value: file,
	      accept: '.ttf',
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Reverse direction')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'reverseDirection',
	      checked: reverseDirection,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Character set')), /*#__PURE__*/React.createElement(Input, {
	      name: 'characterSet',
	      value: characterSet,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('.ttc to .ttf')), /*#__PURE__*/React.createElement(LinkButton, {
	      onClick: this.handleConvertFontType
	    }, 'https://transfonter.org/ttc-unpack')))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleOK
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  handleChange(value, name, event) {
	    if (name === 'file') {
	      this.setState({
	        [name]: value,
	        font: event.target.files[0]
	      });
	    } else {
	      this.setState({
	        [name]: value
	      });
	    }
	  }

	  handleConvertFontType() {
	    window.open('https://transfonter.org/ttc-unpack', '_blank');
	  }

	  handleOK() {
	    const {
	      font,
	      reverseDirection,
	      characterSet
	    } = this.state;

	    if (!font) {
	      app.toast(_t('Please select an file.'));
	      return;
	    }

	    app.mask(_t('Waiting...'));
	    const reader = new FileReader();
	    reader.addEventListener('load', event => {
	      TypefaceUtils.convertTtfToJson(event.target.result, reverseDirection, characterSet.trim()).then(obj => {
	        app.unmask();
	        this.handleClose();
	        DownloadUtils.download([obj.result], {
	          'type': 'application/octet-stream'
	        }, `${obj.font.familyName}_${obj.font.styleName}.json`);
	        app.toast(_t('Convert successfully!'), 'success');
	      });
	    }, false);
	    reader.readAsArrayBuffer(font);
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 插件窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class PluginsWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const attributes = app.editor.renderer.getContextAttributes();
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'PluginsWindow',
	      title: _t('Plugins'),
	      style: {
	        width: '400px',
	        height: '320px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, Object.keys(attributes).map(key => {
	      const value = attributes[key];
	      return /*#__PURE__*/React.createElement(FormControl, {
	        key: key
	      }, /*#__PURE__*/React.createElement(Label, null, _t(key)), /*#__PURE__*/React.createElement(Input, {
	        name: key,
	        value: value.toString(),
	        disabled: true
	      }));
	    }))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 工具菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class ToolMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleTextureGenerator = this.handleTextureGenerator.bind(this);
	    this.handleTypefaceManagement = this.handleTypefaceManagement.bind(this);
	    this.handleTypefaceConverter = this.handleTypefaceConverter.bind(this);
	    this.handleBackupDatabase = this.handleBackupDatabase.bind(this);
	    this.handleCleanUpScenes = this.handleCleanUpScenes.bind(this);
	    this.commitCleanUpScenes = this.commitCleanUpScenes.bind(this);
	    this.handlePlugins = this.handlePlugins.bind(this);
	    this.handleExportExamples = this.handleExportExamples.bind(this);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Tool')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Texture Generator'),
	      onClick: this.handleTextureGenerator
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Typeface Management'),
	      onClick: this.handleTypefaceManagement
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Typeface Converter'),
	      onClick: this.handleTypefaceConverter
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Backup Database'),
	      onClick: this.handleBackupDatabase
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Clean Up Scenes'),
	      onClick: this.handleCleanUpScenes
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Plugins'),
	      onClick: this.handlePlugins
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Export Examples'),
	      onClick: this.handleExportExamples
	    }));
	  }

	  handleTextureGenerator() {
	    app.require('TexGen').then(() => {
	      const win = app.createElement(TextureGeneratorWindow);
	      app.addElement(win);
	    });
	  }

	  handleTypefaceManagement() {
	    const win = app.createElement(TypefaceManagementWindow);
	    app.addElement(win);
	  }

	  handleTypefaceConverter() {
	    const win = app.createElement(TypefaceConverterWindow);
	    app.addElement(win);
	  }

	  handleBackupDatabase() {
	    app.mask(_t('Backing up, please wait.'));
	    fetch(`${app.options.server}/api/BackupDatabase/Run`, {
	      method: 'POST'
	    }).then(response => {
	      response.json().then(json => {
	        app.unmask();

	        if (json.Code === 300) {
	          app.toast(_t(json.Msg), 'error');
	        }

	        app.alert({
	          title: _t(json.Msg),
	          content: json.Path
	        });
	      });
	    });
	  }

	  handleCleanUpScenes() {
	    app.confirm({
	      title: _t('Clean Up Scenes'),
	      content: _t('Are you sure to clean up all the deleted scenes and scene histories?'),
	      onOK: this.commitCleanUpScenes
	    });
	  }

	  commitCleanUpScenes() {
	    fetch(`/api/CleanUpScenes/Run`, {
	      method: 'POST'
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        app.toast(_t(obj.Msg), 'success');
	      });
	    });
	  }

	  handlePlugins() {
	    const win = app.createElement(PluginsWindow);
	    app.addElement(win);
	  }

	  handleExportExamples() {
	    app.confirm({
	      title: _t('Query'),
	      content: _t('Are you sure to export all the examples?'),
	      onOK: () => {
	        app.mask();
	        fetch(`${app.options.server}/api/ExportExamples/Run`, {
	          method: 'POST'
	        }).then(response => {
	          app.unmask();

	          if (response.ok) {
	            response.json().then(obj => {
	              if (obj.Code !== 200) {
	                app.toast(_t(obj.Msg), 'warn');
	                return;
	              }

	              app.toast(_t(obj.Msg), 'success');
	              window.open(`${app.options.server}${obj.Url}`, 'export');
	            });
	          }
	        });
	      }
	    });
	  }

	}

	/**
	 * 视图菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class ViewMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      assetsPanelShow: app.storage.assetsPanelShow,
	      sidebarShow: app.storage.sidebarShow,
	      toolbarShow: app.storage.toolbarShow,
	      timelinePanelShow: app.storage.timelinePanelShow,
	      statusBarShow: app.storage.statusBarShow,
	      showStats: app.storage.showStats,
	      showGrid: app.storage.showGrid,
	      showViewHelper: app.storage.showViewHelper,
	      enablePhysics: app.options.enablePhysics,
	      isThrowBall: false
	    };
	    this.handleShowAssetsPanel = this.handleShowAssetsPanel.bind(this);
	    this.handleShowSidebar = this.handleShowSidebar.bind(this);
	    this.handleShowToolbar = this.handleShowToolbar.bind(this);
	    this.handleShowTimelinePanel = this.handleShowTimelinePanel.bind(this);
	    this.handleShowStatusBar = this.handleShowStatusBar.bind(this);
	    this.handleShowStats = this.handleShowStats.bind(this);
	    this.handleShowGrid = this.handleShowGrid.bind(this);
	    this.handleShowViewHelper = this.handleShowViewHelper.bind(this);
	    this.handleEnablePhysics = this.handleEnablePhysics.bind(this);
	    this.handleEnableThrowBall = this.handleEnableThrowBall.bind(this);
	  }

	  render() {
	    const {
	      assetsPanelShow,
	      sidebarShow,
	      toolbarShow,
	      timelinePanelShow,
	      statusBarShow,
	      showStats,
	      showGrid,
	      showViewHelper,
	      enablePhysics,
	      isThrowBall
	    } = this.state;
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('View')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Assets Panel'),
	      checked: assetsPanelShow,
	      onClick: this.handleShowAssetsPanel
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Sidebar'),
	      checked: sidebarShow,
	      onClick: this.handleShowSidebar
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Toolbar'),
	      checked: toolbarShow,
	      onClick: this.handleShowToolbar
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Timeline Panel'),
	      checked: timelinePanelShow,
	      onClick: this.handleShowTimelinePanel
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Status Bar'),
	      checked: statusBarShow,
	      onClick: this.handleShowStatusBar
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Stats'),
	      checked: showStats,
	      onClick: this.handleShowStats
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Grid'),
	      checked: showGrid,
	      onClick: this.handleShowGrid
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('View Helper'),
	      checked: showViewHelper,
	      onClick: this.handleShowViewHelper
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Physics Engine'),
	      checked: enablePhysics,
	      onClick: this.handleEnablePhysics
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Throw Ball'),
	      checked: isThrowBall,
	      onClick: this.handleEnableThrowBall
	    }));
	  }

	  handleShowAssetsPanel() {
	    const assetsPanelShow = !app.storage.assetsPanelShow;
	    app.storage.assetsPanelShow = assetsPanelShow;
	    this.setState({
	      assetsPanelShow
	    });
	  }

	  handleShowSidebar() {
	    const sidebarShow = !app.storage.sidebarShow;
	    app.storage.sidebarShow = sidebarShow;
	    this.setState({
	      sidebarShow
	    });
	  }

	  handleShowToolbar() {
	    const toolbarShow = !app.storage.toolbarShow;
	    app.storage.toolbarShow = toolbarShow;
	    this.setState({
	      toolbarShow
	    });
	  }

	  handleShowTimelinePanel() {
	    const timelinePanelShow = !app.storage.timelinePanelShow;
	    app.storage.timelinePanelShow = timelinePanelShow;
	    this.setState({
	      timelinePanelShow
	    });
	  }

	  handleShowStatusBar() {
	    const statusBarShow = !app.storage.statusBarShow;
	    app.storage.statusBarShow = statusBarShow;
	    this.setState({
	      statusBarShow
	    });
	  }

	  handleShowStats() {
	    const showStats = !app.storage.showStats;
	    app.storage.showStats = showStats;
	    Object.assign(app.stats.dom.style, {
	      display: showStats ? 'block' : 'none'
	    });
	    this.setState({
	      showStats
	    });
	  }

	  handleShowGrid() {
	    const showGrid = !app.storage.showGrid;
	    app.storage.showGrid = showGrid;
	    this.setState({
	      showGrid
	    });
	  }

	  handleShowViewHelper() {
	    const showViewHelper = !app.storage.showViewHelper;
	    app.storage.showViewHelper = showViewHelper;
	    this.setState({
	      showViewHelper
	    });
	  }

	  handleEnablePhysics() {
	    const enablePhysics = !app.options.enablePhysics;
	    app.options.enablePhysics = enablePhysics;
	    app.call('optionChange', this, 'enablePhysics', enablePhysics);
	    this.setState({
	      enablePhysics
	    });
	  }

	  handleEnableThrowBall() {
	    const isThrowBall = !this.state.isThrowBall;
	    app.call('enableThrowBall', this, isThrowBall);
	    this.setState({
	      isThrowBall
	    });
	  }

	}

	/**
	 * 示例菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class ExampleMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleArkanoid = this.handleArkanoid.bind(this);
	    this.handleCamera = this.handleCamera.bind(this);
	    this.handleParticle = this.handleParticle.bind(this);
	    this.handlePingPong = this.handlePingPong.bind(this);
	    this.handleShader = this.handleShader.bind(this);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Example')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Arkanoid'),
	      onClick: this.handleArkanoid
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Camera'),
	      onClick: this.handleCamera
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Particle'),
	      onClick: this.handleParticle
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Ping Pong'),
	      onClick: this.handlePingPong
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Shader'),
	      onClick: this.handleShader
	    }));
	  }

	  handleArkanoid() {
	    app.call(`load`, this, 'assets/examples/arkanoid.json', _t('Arkanoid'));
	  }

	  handleCamera() {
	    app.call(`load`, this, 'assets/examples/camera.json', _t('Camera'));
	  }

	  handleParticle() {
	    app.call(`load`, this, 'assets/examples/particle.json', _t('Particle'));
	  }

	  handlePingPong() {
	    app.call(`load`, this, 'assets/examples/pong.json', _t('Ping Pong'));
	  }

	  handleShader() {
	    app.call(`load`, this, 'assets/examples/shader.json', _t('Shader'));
	  }
	  /**
	   * 加载three.js自带编辑器示例
	   */


	  handleOldEditorScene() {
	    const loader = new THREE.FileLoader();
	    loader.load('assets/examples/shaders.app.json', text => {
	      const json = JSON.parse(text);
	      const loader = new THREE.ObjectLoader();
	      app.editor.clear(false);
	      const camera = loader.parse(json.camera);
	      app.editor.camera.copy(camera);
	      app.editor.camera.aspect = app.editor.DEFAULT_CAMERA.aspect;
	      app.editor.camera.updateProjectionMatrix();

	      if (json.scripts) {
	        for (const uuid in json.scripts) {
	          const scripts = json.scripts[uuid]; // 说明: three.js示例中，物体和脚本的uuid是一致的，
	          // 这会导致本编辑器报错。

	          scripts.forEach(script => {
	            app.editor.scripts.push({
	              id: '',
	              name: script.name,
	              type: 'javascript',
	              source: script.source,
	              uuid: THREE.Math.generateUUID()
	            });
	          });
	        }
	      }

	      app.editor.setScene(loader.parse(json.scene));
	    });
	  }

	}

	/**
	 * 显示选项窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class DisplayPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const selectedColor = app.storage.selectedColor;
	    const selectedThickness = app.storage.selectedThickness;
	    const hoverEnabled = app.storage.hoverEnabled;
	    const hoveredColor = app.storage.hoveredColor;
	    return /*#__PURE__*/React.createElement(Form, {
	      className: 'DisplayPanel'
	    }, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Selected Color')), /*#__PURE__*/React.createElement(Input, {
	      className: 'selected-color',
	      name: 'selectedColor',
	      type: 'color',
	      value: selectedColor,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Border Thickness')), /*#__PURE__*/React.createElement(Input, {
	      className: 'selected-thickness',
	      name: 'selectedThickness',
	      type: 'number',
	      min: 1,
	      max: 100,
	      precision: 1,
	      value: selectedThickness,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Enable Hover')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'hoverEnabled',
	      checked: hoverEnabled,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Hover Color')), /*#__PURE__*/React.createElement(Input, {
	      className: 'hovered-color',
	      name: 'hoveredColor',
	      type: 'color',
	      value: hoveredColor,
	      onChange: this.handleChange
	    })));
	  }

	  handleUpdate() {
	    this.forceUpdate();
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    if (name === 'hoverEnabled') {
	      if (value) {
	        app.editor.gpuPickNum++;
	      } else {
	        app.editor.gpuPickNum--;
	      }
	    }

	    app.storage[name] = value;
	    this.handleUpdate();
	  }

	}

	/**
	 * 渲染器窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class RendererPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.shadowMapType = {
	      [-1]: _t('Disabled'),
	      [THREE.BasicShadowMap]: _t('Basic Shadow'),
	      // 0
	      [THREE.PCFShadowMap]: _t('PCF Shadow'),
	      // 1
	      [THREE.PCFSoftShadowMap]: _t('PCF Soft Shadow') // 2

	    };
	    this.state = {
	      shadowMapType: -1,
	      // gammaInput: false,
	      // gammaOutput: false,
	      gammaFactor: 0
	    };
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      shadowMapType,
	      gammaFactor
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Form, {
	      className: 'RendererPanel'
	    }, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Shadow')), /*#__PURE__*/React.createElement(Select, {
	      options: this.shadowMapType,
	      name: 'shadowMapType',
	      value: shadowMapType,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Gamma Factor')), /*#__PURE__*/React.createElement(Input, {
	      type: 'number',
	      name: 'gammaFactor',
	      value: gammaFactor,
	      onChange: this.handleChange
	    })));
	  }

	  componentDidMount() {
	    app.on(`rendererChanged.RendererPanel`, this.handleUpdate);
	  }

	  handleUpdate() {
	    const renderer = app.editor.renderer;
	    this.setState({
	      shadowMapType: renderer.shadowMap.enabled ? renderer.shadowMap.type : -1,
	      gammaFactor: renderer.gammaFactor
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    let renderer = app.editor.renderer;
	    const {
	      shadowMapType,
	      gammaFactor
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (shadowMapType === '-1') {
	      renderer.shadowMap.enabled = false;
	    } else {
	      renderer.shadowMap.enabled = true;
	      renderer.shadowMap.type = parseInt(shadowMapType);
	    }

	    renderer.gammaFactor = gammaFactor;
	    renderer.dispose();
	    Object.assign(app.options, {
	      shadowMapType,
	      gammaFactor
	    });
	    app.call(`rendererChanged`, this);
	  }

	}

	/**
	 * 帮助选项窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class HelperPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      showGrid: false,
	      showCamera: false,
	      showPointLight: false,
	      showDirectionalLight: false,
	      showSpotLight: false,
	      showHemisphereLight: false,
	      showRectAreaLight: false,
	      showSkeleton: false
	    };
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      showGrid,
	      showCamera,
	      showPointLight,
	      showDirectionalLight,
	      showSpotLight,
	      showHemisphereLight,
	      showRectAreaLight,
	      showSkeleton
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Form, {
	      className: 'HelperPanel'
	    }, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Grid')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'showGrid',
	      checked: showGrid,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Camera')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'showCamera',
	      checked: showCamera,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Point Light')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'showPointLight',
	      checked: showPointLight,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Directional Light')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'showDirectionalLight',
	      checked: showDirectionalLight,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Spot Light')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'showSpotLight',
	      checked: showSpotLight,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Hemisphere Light')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'showHemisphereLight',
	      checked: showHemisphereLight,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Rect Area Light')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'showRectAreaLight',
	      checked: showRectAreaLight,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Skeleton')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'showSkeleton',
	      checked: showSkeleton,
	      onChange: this.handleChange
	    })));
	  }

	  handleUpdate() {
	    this.setState({
	      showGrid: app.storage.showGrid,
	      showCamera: app.storage.showCamera,
	      showPointLight: app.storage.showPointLight,
	      showDirectionalLight: app.storage.showDirectionalLight,
	      showSpotLight: app.storage.showSpotLight,
	      showHemisphereLight: app.storage.showHemisphereLight,
	      showRectAreaLight: app.storage.showRectAreaLight,
	      showSkeleton: app.storage.showSkeleton
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      showGrid,
	      showCamera,
	      showPointLight,
	      showDirectionalLight,
	      showSpotLight,
	      showHemisphereLight,
	      showRectAreaLight,
	      showSkeleton
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (showGrid !== app.storage.showGrid) {
	      app.storage.showGrid = showGrid;
	    }

	    if (showCamera !== app.storage.showCamera) {
	      app.storage.showCamera = showCamera;
	    }

	    if (showPointLight !== app.storage.showPointLight) {
	      app.storage.showPointLight = showPointLight;
	    }

	    if (showDirectionalLight !== app.storage.showDirectionalLight) {
	      app.storage.showDirectionalLight = showDirectionalLight;
	    }

	    if (showSpotLight !== app.storage.showSpotLight) {
	      app.storage.showSpotLight = showSpotLight;
	    }

	    if (showHemisphereLight !== app.storage.showHemisphereLight) {
	      app.storage.showHemisphereLight = showHemisphereLight;
	    }

	    if (showRectAreaLight !== app.storage.showRectAreaLight) {
	      app.storage.showRectAreaLight = showRectAreaLight;
	    }

	    if (showSkeleton !== app.storage.showSkeleton) {
	      app.storage.showSkeleton = showSkeleton;
	    }

	    this.handleUpdate();
	  }

	}

	/**
	 * 滤镜选项窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class FilterPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      hueRotate: 0,
	      saturate: 0,
	      brightness: 0,
	      blur: 0,
	      contrast: 0,
	      grayscale: 0,
	      invert: 0,
	      sepia: 0
	    };
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      hueRotate,
	      saturate,
	      brightness,
	      blur,
	      contrast,
	      grayscale,
	      invert,
	      sepia
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Form, {
	      className: 'FilterPanel'
	    }, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('HueRotate')), /*#__PURE__*/React.createElement(Input, {
	      type: 'number',
	      name: 'hueRotate',
	      value: hueRotate,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Saturate')), /*#__PURE__*/React.createElement(Input, {
	      type: 'number',
	      name: 'saturate',
	      value: saturate,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Brightness')), /*#__PURE__*/React.createElement(Input, {
	      type: 'number',
	      name: 'brightness',
	      value: brightness,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Blur')), /*#__PURE__*/React.createElement(Input, {
	      type: 'number',
	      name: 'blur',
	      value: blur,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Contrast')), /*#__PURE__*/React.createElement(Input, {
	      type: 'number',
	      name: 'contrast',
	      value: contrast,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Grayscale')), /*#__PURE__*/React.createElement(Input, {
	      type: 'number',
	      name: 'grayscale',
	      value: grayscale,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Invert')), /*#__PURE__*/React.createElement(Input, {
	      type: 'number',
	      name: 'invert',
	      value: invert,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Sepia')), /*#__PURE__*/React.createElement(Input, {
	      type: 'number',
	      name: 'sepia',
	      value: sepia,
	      onChange: this.handleChange
	    })));
	  }

	  handleUpdate() {
	    const renderer = app.editor.renderer;
	    const {
	      hueRotate,
	      saturate,
	      brightness,
	      blur,
	      contrast,
	      grayscale,
	      invert,
	      sepia
	    } = CssUtils.parseFilter(renderer.domElement.style.filter);
	    this.setState({
	      hueRotate,
	      saturate,
	      brightness,
	      blur,
	      contrast,
	      grayscale,
	      invert,
	      sepia
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      hueRotate,
	      saturate,
	      brightness,
	      blur,
	      contrast,
	      grayscale,
	      invert,
	      sepia
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    const filters = {
	      hueRotate,
	      saturate,
	      brightness,
	      blur,
	      contrast,
	      grayscale,
	      invert,
	      sepia
	    };
	    Object.assign(app.options, filters);
	    const renderer = app.editor.renderer;
	    renderer.domElement.style.filter = CssUtils.serializeFilter(filters);
	    this.handleUpdate();
	  }

	}

	/**
	 * 天气选项窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class WeatherPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.weathers = {
	      '': _t('None'),
	      rain: _t('Rain'),
	      snow: _t('Snow')
	    };
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const weather = app.options.weather;
	    return /*#__PURE__*/React.createElement(Form, {
	      className: 'WeatherPanel'
	    }, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Weather')), /*#__PURE__*/React.createElement(Select, {
	      className: 'weather',
	      name: 'weather',
	      value: weather,
	      options: this.weathers,
	      onChange: this.handleChange
	    })));
	  }

	  handleUpdate() {
	    this.forceUpdate();
	  }

	  handleChange(value, name) {
	    app.options.weather = value;
	    app.call(`optionChange`, this, name, value);
	    this.handleUpdate();
	  }

	}

	/**
	 * 选项窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class OptionsWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.displayRef = React.createRef();
	    this.rendererRef = React.createRef();
	    this.helperRef = React.createRef();
	    this.filterRef = React.createRef();
	    this.weatherRef = React.createRef();
	    this.state = {
	      activeTabIndex: props.activeTabIndex
	    };
	    this.handleClose = this.handleClose.bind(this);
	    this.handleActiveTabChange = this.handleActiveTabChange.bind(this);
	  }

	  render() {
	    const {
	      activeTabIndex
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'OptionsWindow',
	      title: _t('Settings'),
	      style: {
	        width: '300px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(TabLayout, {
	      className: 'tab',
	      activeTabIndex: activeTabIndex,
	      onActiveTabChange: this.handleActiveTabChange
	    }, /*#__PURE__*/React.createElement(DisplayPanel, {
	      title: _t('Display'),
	      ref: this.displayRef
	    }), /*#__PURE__*/React.createElement(RendererPanel, {
	      title: _t('Renderer'),
	      ref: this.rendererRef
	    }), /*#__PURE__*/React.createElement(HelperPanel, {
	      title: _t('Helpers'),
	      ref: this.helperRef
	    }), /*#__PURE__*/React.createElement(FilterPanel, {
	      title: _t('Filter'),
	      ref: this.filterRef
	    }), /*#__PURE__*/React.createElement(WeatherPanel, {
	      title: _t('Weather'),
	      ref: this.weatherRef
	    }))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  componentDidMount() {
	    const {
	      activeTabIndex
	    } = this.state;
	    this.handleActiveTabChange(activeTabIndex);
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	  handleActiveTabChange(index) {
	    const displayTab = this.displayRef.current;
	    const rendererTab = this.rendererRef.current;
	    const helperTab = this.helperRef.current;
	    const filterTab = this.filterRef.current;
	    const weatherTab = this.weatherRef.current;

	    switch (index) {
	      case 0:
	        displayTab.handleUpdate();
	        break;

	      case 1:
	        rendererTab.handleUpdate();
	        break;

	      case 2:
	        helperTab.handleUpdate();
	        break;

	      case 3:
	        filterTab.handleUpdate();
	        break;

	      case 4:
	        weatherTab.handleUpdate();
	        break;
	    }

	    this.setState({
	      activeTabIndex: index
	    });
	  }

	}

	OptionsWindow.propTypes = {
	  activeTabIndex: propTypes.number,
	  onActiveTabChange: propTypes.func
	};
	OptionsWindow.defaultProps = {
	  activeTabIndex: 0,
	  onActiveTabChange: null
	};

	/**
	 * 选项菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class OptionsMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleDisplayOptions = this.handleDisplayOptions.bind(this);
	    this.handleRendererOptions = this.handleRendererOptions.bind(this);
	    this.handleHelperOptions = this.handleHelperOptions.bind(this);
	    this.handleFilterOptions = this.handleFilterOptions.bind(this);
	    this.handleWeatherOptions = this.handleWeatherOptions.bind(this);
	    this.handleChangeControlMode = this.handleChangeControlMode.bind(this);
	    this.handleChangeSelectMode = this.handleChangeSelectMode.bind(this);
	    this.handleChangeAddMode = this.handleChangeAddMode.bind(this);
	    this.handleChangeEnglish = this.handleChangeEnglish.bind(this);
	    this.handleChangeChinese = this.handleChangeChinese.bind(this);
	    this.handleEnableDebugMode = this.handleEnableDebugMode.bind(this);
	    this.handleDisableDebugMode = this.handleDisableDebugMode.bind(this);
	  }

	  render() {
	    const isLogin = !app.server.enableAuthority || app.server.isLogin;
	    const controlMode = app.storage.controlMode;
	    const selectMode = app.storage.selectMode;
	    const addMode = app.storage.addMode;
	    const lang = window.localStorage.getItem('lang');
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Options')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Display'),
	      onClick: this.handleDisplayOptions
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Renderer'),
	      onClick: this.handleRendererOptions
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Helpers'),
	      onClick: this.handleHelperOptions
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Filter'),
	      onClick: this.handleFilterOptions
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Weather'),
	      onClick: this.handleWeatherOptions
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, null), isLogin && /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Control Mode')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      name: 'EditorControls',
	      title: _t('Editor Controls'),
	      selected: controlMode === 'EditorControls',
	      onClick: this.handleChangeControlMode
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      name: 'FreeControls',
	      title: _t('Free Controls'),
	      selected: controlMode === 'FreeControls',
	      onClick: this.handleChangeControlMode
	    })), isLogin && /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Select Mode')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      name: 'whole',
	      title: _t('Select Whole'),
	      selected: selectMode === 'whole',
	      onClick: this.handleChangeSelectMode
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      name: 'part',
	      title: _t('Select Part'),
	      selected: selectMode === 'part',
	      onClick: this.handleChangeSelectMode
	    })), isLogin && /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Add Mode')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      name: 'center',
	      title: _t('Add To Center'),
	      selected: addMode === 'center',
	      onClick: this.handleChangeAddMode
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      name: 'click',
	      title: _t('Click Scene To Add'),
	      selected: addMode === 'click',
	      onClick: this.handleChangeAddMode
	    })), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Language')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: 'English',
	      selected: lang === 'en-US',
	      onClick: this.handleChangeEnglish
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: '简体中文',
	      selected: lang === 'zh-CN',
	      onClick: this.handleChangeChinese
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: '繁體中文',
	      selected: lang === 'zh-TW',
	      onClick: this.handleChangeTraditionalChinese
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: '日本語',
	      selected: lang === 'ja-JP',
	      onClick: this.handleChangeJapanese
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: '한국어',
	      selected: lang === 'ko-KR',
	      onClick: this.handleChangeKorean
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: 'русский',
	      selected: lang === 'ru-RU',
	      onClick: this.handleChangeRussian
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: 'Le français',
	      selected: lang === 'fr-FR',
	      onClick: this.handleChangeFrench
	    })), isLogin && /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Debug Mode')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Enable'),
	      selected: app.debug,
	      onClick: this.handleEnableDebugMode
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Disable'),
	      selected: !app.debug,
	      onClick: this.handleDisableDebugMode
	    })));
	  } // ---------------------------------- 显示选项 ---------------------------------------


	  handleDisplayOptions() {
	    let win = app.createElement(OptionsWindow, {
	      activeTabIndex: 0
	    });
	    app.addElement(win);
	  } // ---------------------------------- 渲染器选项 -------------------------------------


	  handleRendererOptions() {
	    let win = app.createElement(OptionsWindow, {
	      activeTabIndex: 1
	    });
	    app.addElement(win);
	  } // ------------------------------- 帮助器选项 -----------------------------------------


	  handleHelperOptions() {
	    let win = app.createElement(OptionsWindow, {
	      activeTabIndex: 2
	    });
	    app.addElement(win);
	  } // ------------------------------ 滤镜选项 ---------------------------------------------


	  handleFilterOptions() {
	    let win = app.createElement(OptionsWindow, {
	      activeTabIndex: 3
	    });
	    app.addElement(win);
	  } // ------------------------------- 天气选项 ---------------------------------------------


	  handleWeatherOptions() {
	    let win = app.createElement(OptionsWindow, {
	      activeTabIndex: 4
	    });
	    app.addElement(win);
	  } // ------------------------------ 控制器模式 ---------------------------------------------


	  handleChangeControlMode(value) {
	    app.editor.controls.changeMode(value);
	    app.storage.controlMode = value;
	    this.forceUpdate();
	  } // ----------------------------- 添加模式 ------------------------------------------------


	  handleChangeAddMode(value) {
	    app.storage.addMode = value;
	    this.forceUpdate();
	  } // --------------------------- 选择模式 ----------------------------------------------


	  handleChangeSelectMode(value) {
	    app.storage.selectMode = value;
	    this.forceUpdate();
	  } // ---------------------------- 语言选项 -------------------------------------------------


	  handleChangeEnglish() {
	    // 英语
	    window.localStorage.setItem('lang', 'en-US');
	    window.location.reload();
	  }

	  handleChangeChinese() {
	    // 简体中文
	    window.localStorage.setItem('lang', 'zh-CN');
	    window.location.reload();
	  }

	  handleChangeTraditionalChinese() {
	    // 繁体中文
	    window.localStorage.setItem('lang', 'zh-TW');
	    window.location.reload();
	  }

	  handleChangeJapanese() {
	    // 日语
	    window.localStorage.setItem('lang', 'ja-JP');
	    window.location.reload();
	  }

	  handleChangeKorean() {
	    window.localStorage.setItem('lang', 'ko-KR');
	    window.location.reload();
	  }

	  handleChangeRussian() {
	    window.localStorage.setItem('lang', 'ru-RU');
	    window.location.reload();
	  }

	  handleChangeFrench() {
	    window.localStorage.setItem('lang', 'fr-FR');
	    window.location.reload();
	  } // ---------------------------------- 调试模式 -------------------------------


	  handleEnableDebugMode() {
	    app.storage.debug = true;
	    window.location.reload();
	  }

	  handleDisableDebugMode() {
	    app.storage.debug = false;
	    window.location.reload();
	  }

	}

	/**
	 * 组织机构编辑窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class EditDeptWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      id: props.id,
	      name: props.name,
	      pid: props.pid,
	      pname: props.pname
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleSave = this.handleSave.bind(this, props.callback);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      id,
	      name,
	      pid,
	      pname
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: _t('EditDeptWindow'),
	      title: pid ? _t('Add Child Department') : id ? _t('Edit Department') : _t('Add Department'),
	      style: {
	        width: '320px',
	        height: '200px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, {
	      hidden: pid === ''
	    }, /*#__PURE__*/React.createElement(Label, null, _t('PDept Name')), /*#__PURE__*/React.createElement(Label, {
	      className: 'text'
	    }, pname)), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Name')), /*#__PURE__*/React.createElement(Input, {
	      name: 'name',
	      value: name,
	      onChange: this.handleChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleSave(callback) {
	    const {
	      id,
	      name,
	      pid
	    } = this.state;

	    if (!name || name.trim() === '') {
	      app.toast(_t('Name is not allowed to be empty.'), 'warn');
	      return;
	    }

	    const url = !id ? `/api/Department/Add` : `/api/Department/Edit`;
	    fetch(`${app.options.server}${url}`, {
	      method: 'POST',
	      headers: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      body: `ID=${id}&ParentID=${pid}&Name=${name}&AdministratorID=`
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.handleClose();
	        callback && callback();
	      });
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	EditDeptWindow.propTypes = {
	  id: propTypes.string,
	  name: propTypes.string,
	  pid: propTypes.string,
	  pname: propTypes.string,
	  callback: propTypes.func
	};
	EditDeptWindow.defaultProps = {
	  id: '',
	  name: '',
	  pid: '',
	  pname: '',
	  callback: null
	};

	/**
	 * 选择用户窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class SelectUserWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      pageSize: 10,
	      pageNum: 1,
	      total: 0,
	      data: [],
	      selected: null,
	      keyword: '',
	      mask: false
	    };
	    this.handleSearch = this.handleSearch.bind(this);
	    this.renderStatus = this.renderStatus.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleChangePageSize = this.handleChangePageSize.bind(this);
	    this.handleFirstPage = this.handleFirstPage.bind(this);
	    this.handlePreviousPage = this.handlePreviousPage.bind(this);
	    this.handleNextPage = this.handleNextPage.bind(this);
	    this.handleLastPage = this.handleLastPage.bind(this);
	    this.handleRefresh = this.handleRefresh.bind(this);
	    this.handleOK = this.handleOK.bind(this);
	    this.handleCancel = this.handleCancel.bind(this);
	  }

	  render() {
	    const {
	      pageSize,
	      pageNum,
	      total,
	      data,
	      selected,
	      keyword,
	      mask
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'SelectUserWindow',
	      title: _t('Select User'),
	      style: {
	        width: '800px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleCancel
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Toolbar, null, /*#__PURE__*/React.createElement(SearchField, {
	      placeholder: _t('Search Content'),
	      value: keyword,
	      onInput: this.handleSearch
	    })), /*#__PURE__*/React.createElement(DataGrid, {
	      data: data,
	      pages: true,
	      pageSize: pageSize,
	      pageNum: pageNum,
	      total: total,
	      selected: selected,
	      mask: mask,
	      onSelect: this.handleSelect,
	      onChangePageSize: this.handleChangePageSize,
	      onFirstPage: this.handleFirstPage,
	      onPreviousPage: this.handlePreviousPage,
	      onNextPage: this.handleNextPage,
	      onLastPage: this.handleLastPage,
	      onRefresh: this.handleRefresh,
	      keyField: 'ID'
	    }, /*#__PURE__*/React.createElement(Column, {
	      type: 'number',
	      title: '#'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Username',
	      title: _t('Username'),
	      width: 120
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Name',
	      title: _t('NickName'),
	      align: 'center',
	      renderer: this.renderName
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'RoleName',
	      title: _t('Role'),
	      width: 120,
	      align: 'center',
	      renderer: this.renderRoleName
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'CreateTime',
	      title: _t('Create Date'),
	      width: 120,
	      align: 'center',
	      renderer: this.renderDate
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'UpdateTime',
	      title: _t('Update Date'),
	      width: 120,
	      align: 'center',
	      renderer: this.renderDate
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Status',
	      title: _t('Status'),
	      width: 80,
	      align: 'center',
	      renderer: this.renderStatus
	    }))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleOK
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleCancel
	    }, _t('Cancel'))));
	  }

	  componentDidMount() {
	    this.handleRefresh();
	  }

	  update(pageSize, pageNum, keyword = '') {
	    this.setState({
	      mask: true
	    });
	    fetch(`${app.options.server}/api/User/List?pageSize=${pageSize}&pageNum=${pageNum}&keyword=${keyword}`).then(response => {
	      response.json().then(obj => {
	        app.unmask();

	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          pageSize,
	          pageNum,
	          total: obj.Data.total,
	          data: obj.Data.rows,
	          keyword: keyword,
	          mask: false
	        });
	      });
	    });
	  }

	  handleSearch(value) {
	    const {
	      pageSize,
	      pageNum
	    } = this.state;
	    this.update(pageSize, pageNum, value);
	  }

	  renderName(value) {
	    if (value === 'Administrator') {
	      return _t(value);
	    }

	    return value;
	  }

	  renderRoleName(value) {
	    if (value === 'Administrator' || value === 'User' || value === 'Guest') {
	      return _t(value);
	    }

	    return value;
	  }

	  renderDate(value) {
	    return value.split(' ')[0];
	  }

	  renderStatus(value) {
	    return value === 0 ? _t('Enabled') : _t('Disabled');
	  }

	  handleSelect(selected) {
	    this.setState({
	      selected: selected.ID
	    });
	  }

	  handleChangePageSize(value) {
	    const {
	      pageNum,
	      keyword
	    } = this.state;
	    this.update(value, pageNum, keyword);
	  }

	  handleFirstPage() {
	    const {
	      pageSize,
	      keyword
	    } = this.state;
	    this.update(pageSize, 1, keyword);
	  }

	  handlePreviousPage() {
	    const {
	      pageSize,
	      pageNum,
	      keyword
	    } = this.state;
	    const newPageNum = pageNum > 1 ? pageNum - 1 : pageNum;
	    this.update(pageSize, newPageNum, keyword);
	  }

	  handleNextPage() {
	    const {
	      pageSize,
	      pageNum,
	      total,
	      keyword
	    } = this.state;
	    const totalPage = total % pageSize === 0 ? total / pageSize : parseInt(total / pageSize) + 1;
	    const newPageNum = pageNum < totalPage ? pageNum + 1 : pageNum;
	    this.update(pageSize, newPageNum, keyword);
	  }

	  handleLastPage() {
	    const {
	      pageSize,
	      total,
	      keyword
	    } = this.state;
	    const totalPage = total % pageSize === 0 ? total / pageSize : parseInt(total / pageSize) + 1;
	    const newPageNum = totalPage;
	    this.update(pageSize, newPageNum, keyword);
	  }

	  handleRefresh() {
	    const {
	      pageSize,
	      pageNum,
	      keyword
	    } = this.state;
	    this.update(pageSize, pageNum, keyword);
	  }

	  handleOK() {
	    const {
	      data,
	      selected
	    } = this.state;
	    const callback = this.props.callback;

	    if (!selected) {
	      app.toast(_t('Please select a department.'));
	      return;
	    }

	    const user = data.filter(n => n.ID === selected)[0];
	    this.handleCancel();
	    callback && callback(user.ID, user.Name, user);
	  }

	  handleCancel() {
	    app.removeElement(this);
	  }

	}

	SelectUserWindow.propTypes = {
	  callback: propTypes.func
	};
	SelectUserWindow.defaultProps = {
	  callback: null
	};

	/**
	 * 组织机构管理窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class DepartmentManagementWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.list = [];
	    this.expanded = {};
	    this.state = {
	      data: [],
	      selected: null,
	      deptName: '',
	      adminID: '',
	      adminName: ''
	    };
	    this.handleRefresh = this.handleRefresh.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleAddChild = this.handleAddChild.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handleSelectUser = this.handleSelectUser.bind(this);
	    this.commitSelectUser = this.commitSelectUser.bind(this);
	    this.handleSave = this.handleSave.bind(this);
	    this.handleReset = this.handleReset.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      data,
	      selected,
	      deptName,
	      adminName
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'DepartmentManagementWindow',
	      title: _t('Department Management'),
	      style: {
	        width: '520px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Toolbar, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleAdd
	    }, _t('Add')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleAddChild
	    }, _t('Add Child Department')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleDelete
	    }, _t('Delete')), /*#__PURE__*/React.createElement(ToolbarFiller, null)), /*#__PURE__*/React.createElement(HBoxLayout, {
	      className: 'box'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'left'
	    }, /*#__PURE__*/React.createElement(Tree, {
	      className: 'tree',
	      data: data,
	      selected: selected,
	      onSelect: this.handleSelect,
	      onExpand: this.handleExpand
	    })), /*#__PURE__*/React.createElement(Form, {
	      className: 'right'
	    }, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Name')), /*#__PURE__*/React.createElement(Input, {
	      name: 'deptName',
	      value: deptName,
	      disabled: selected === null,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Administrator')), /*#__PURE__*/React.createElement(Input, {
	      className: 'adminName',
	      name: 'adminName',
	      value: this.renderAdminName(adminName),
	      disabled: true
	    }), /*#__PURE__*/React.createElement(Button, {
	      className: 'select',
	      disabled: selected === null,
	      onClick: this.handleSelectUser
	    }, _t('Select'))), /*#__PURE__*/React.createElement(FormControl, {
	      className: 'buttons'
	    }, /*#__PURE__*/React.createElement(Label, null), /*#__PURE__*/React.createElement(Button, {
	      disabled: selected === null,
	      onClick: this.handleSave
	    }, _t('Save')), /*#__PURE__*/React.createElement(Button, {
	      disabled: selected === null,
	      onClick: this.handleReset
	    }, _t('Reset')))))));
	  }

	  componentDidMount() {
	    this.handleRefresh();
	  }

	  handleRefresh() {
	    fetch(`${app.options.server}/api/Department/List?pageSize=10000`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.list = obj.Data;
	        this.refreshTree();
	      });
	    });
	  }

	  refreshTree() {
	    var data = [];
	    this.createTree(data, '', this.list);
	    this.setState({
	      data
	    });
	  }

	  createTree(nodes, parentID, list) {
	    var list1 = list.filter(n => n.ParentID === parentID);
	    list1.forEach(obj1 => {
	      var node1 = {
	        value: obj1.ID,
	        text: obj1.Name,
	        children: [],
	        expanded: !!this.expanded[obj1.ID]
	      };
	      this.createTree(node1.children, obj1.ID, list);
	      nodes.push(node1);
	    });
	  }

	  handleAdd() {
	    const win = app.createElement(EditDeptWindow, {
	      callback: this.handleRefresh
	    });
	    app.addElement(win);
	  }

	  handleAddChild() {
	    const {
	      selected
	    } = this.state;

	    if (!selected) {
	      app.toast(_t('Pleast select a department.'));
	      return;
	    }

	    const record = this.list.filter(n => n.ID === selected)[0];
	    const win = app.createElement(EditDeptWindow, {
	      pid: record.ID,
	      pname: record.Name,
	      callback: this.handleRefresh
	    });
	    app.addElement(win);
	  }

	  handleDelete() {
	    const {
	      selected
	    } = this.state;

	    if (!selected) {
	      app.toast(_t('Pleast select a department.'));
	      return;
	    }

	    app.confirm({
	      title: _t('Query'),
	      content: _t('Delete this department?'),
	      onOK: () => {
	        this.commitDelete(selected);
	      }
	    });
	  }

	  commitDelete(id) {
	    fetch(`${app.options.server}/api/Department/Delete?ID=${id}`, {
	      method: 'POST'
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.handleRefresh();
	      });
	    });
	  }

	  handleSelect(selected) {
	    const data = this.list.filter(n => n.ID === selected)[0];
	    this.setState({
	      selected,
	      deptName: data.Name,
	      adminID: data.AdminID,
	      adminName: data.AdminName
	    });
	  }

	  handleExpand(value) {
	    let expanded = this.expanded;

	    if (expanded[value]) {
	      expanded[value] = false;
	    } else {
	      expanded[value] = true;
	    }

	    this.refreshTree();
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleSelectUser() {
	    const win = app.createElement(SelectUserWindow, {
	      callback: this.commitSelectUser
	    });
	    app.addElement(win);
	  }

	  commitSelectUser(adminID, adminName) {
	    this.setState({
	      adminID,
	      adminName
	    });
	  }

	  handleSave() {
	    const {
	      selected,
	      deptName,
	      adminID
	    } = this.state;

	    if (!deptName || deptName.trim() === '') {
	      app.toast(_t('Name is not allowed to be empty.'), 'warn');
	      return;
	    }

	    const item = this.list.filter(n => n.ID === selected)[0];
	    fetch(`${app.options.server}/api/Department/Edit`, {
	      method: 'POST',
	      headers: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      body: `ID=${selected}&ParentID=${item.ParentID}&Name=${deptName}&AdminID=${adminID}`
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        app.toast(_t(obj.Msg), 'success');
	        this.handleRefresh();
	      });
	    });
	  }

	  handleReset() {
	    const selected = this.state.selected;

	    if (!selected) {
	      this.setState({
	        deptName: '',
	        adminName: ''
	      });
	      return;
	    }

	    const data = this.list.filter(n => n.ID === selected)[0];
	    this.setState({
	      deptName: data.Name,
	      adminID: data.AdminID,
	      adminName: data.AdminName
	    });
	  }

	  renderAdminName(value) {
	    if (value === 'Administrator') {
	      return _t(value);
	    }

	    return value;
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 选择组织机构窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class SelectDeptWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.list = [];
	    this.expanded = {};
	    this.state = {
	      data: [],
	      selected: null
	    };
	    this.handleRefresh = this.handleRefresh.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleOK = this.handleOK.bind(this);
	    this.handleCancel = this.handleCancel.bind(this);
	  }

	  render() {
	    const {
	      data,
	      selected
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'SelectDeptWindow',
	      title: _t('Select Department Window'),
	      style: {
	        width: '280px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleCancel
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Toolbar, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleRefresh
	    }, _t('Refresh'))), /*#__PURE__*/React.createElement("div", {
	      className: 'box'
	    }, /*#__PURE__*/React.createElement(Tree, {
	      className: 'tree',
	      data: data,
	      selected: selected,
	      onSelect: this.handleSelect,
	      onExpand: this.handleExpand
	    }))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleOK
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleCancel
	    }, _t('Cancel'))));
	  }

	  componentDidMount() {
	    this.handleRefresh();
	  }

	  handleRefresh() {
	    fetch(`${app.options.server}/api/Department/List?pageSize=10000`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.list = obj.Data;
	        this.refreshTree();
	      });
	    });
	  }

	  refreshTree() {
	    var data = [];
	    this.createTree(data, '', this.list);
	    this.setState({
	      data
	    });
	  }

	  createTree(nodes, parentID, list) {
	    var list1 = list.filter(n => n.ParentID === parentID);
	    list1.forEach(obj1 => {
	      var node1 = {
	        value: obj1.ID,
	        text: obj1.Name,
	        children: [],
	        expanded: !!this.expanded[obj1.ID]
	      };
	      this.createTree(node1.children, obj1.ID, list);
	      nodes.push(node1);
	    });
	  }

	  handleSelect(selected) {
	    const data = this.list.filter(n => n.ID === selected)[0];
	    this.setState({
	      selected,
	      deptName: data.Name,
	      adminName: ''
	    });
	  }

	  handleExpand(value) {
	    let expanded = this.expanded;

	    if (expanded[value]) {
	      expanded[value] = false;
	    } else {
	      expanded[value] = true;
	    }

	    this.refreshTree();
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleOK() {
	    const selected = this.state.selected;
	    const callback = this.props.callback;

	    if (!selected) {
	      app.toast(_t('Please select a department.'));
	      return;
	    }

	    const dept = this.list.filter(n => n.ID === selected)[0];
	    this.handleCancel();
	    callback && callback(dept.ID, dept.Name, dept);
	  }

	  handleCancel() {
	    app.removeElement(this);
	  }

	}

	SelectDeptWindow.propTypes = {
	  callback: propTypes.func
	};
	SelectDeptWindow.defaultProps = {
	  callback: null
	};

	/**
	 * 用户编辑窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class EditUserWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      id: props.id,
	      username: props.username,
	      password: '',
	      confirmPassword: '',
	      name: props.name,
	      roles: {},
	      roleID: props.roleID,
	      deptID: props.deptID,
	      deptName: props.deptName
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleSelectDept = this.handleSelectDept.bind(this);
	    this.commitSelectDept = this.commitSelectDept.bind(this);
	    this.handleSave = this.handleSave.bind(this, props.callback);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      id,
	      username,
	      password,
	      confirmPassword,
	      name,
	      roles,
	      roleID,
	      deptName
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: _t('EditUserWindow'),
	      title: id ? _t('Edit User') : _t('Add User'),
	      style: {
	        width: '320px',
	        height: '280px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('User Name')), /*#__PURE__*/React.createElement(Input, {
	      name: 'username',
	      value: username,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement("input", {
	      type: 'text',
	      className: 'fake'
	    }), /*#__PURE__*/React.createElement("input", {
	      type: 'password',
	      className: 'fake'
	    })), /*#__PURE__*/React.createElement(FormControl, {
	      hidden: id !== ''
	    }, /*#__PURE__*/React.createElement(Label, null, _t('Password')), /*#__PURE__*/React.createElement(Input, {
	      name: 'password',
	      type: 'password',
	      value: password,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, {
	      hidden: id !== ''
	    }, /*#__PURE__*/React.createElement(Label, null, _t('Confirm Password')), /*#__PURE__*/React.createElement(Input, {
	      name: 'confirmPassword',
	      type: 'password',
	      value: confirmPassword,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('NickName')), /*#__PURE__*/React.createElement(Input, {
	      name: 'name',
	      value: name,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Role')), /*#__PURE__*/React.createElement(Select, {
	      name: 'roleID',
	      options: roles,
	      value: roleID,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Department')), /*#__PURE__*/React.createElement(Input, {
	      className: 'deptName',
	      name: 'deptName',
	      value: deptName,
	      disabled: true,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(Button, {
	      className: 'select',
	      onClick: this.handleSelectDept
	    }, _t('Select'))))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  componentDidMount() {
	    fetch(`${app.options.server}/api/Role/List?pageSize=10000`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        const roles = {
	          '': _t('Please Select')
	        };
	        obj.Data.rows.forEach(n => {
	          roles[n.ID] = this.renderRoleName(n.Name);
	        });
	        this.setState({
	          roles
	        });
	      });
	    });
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleSelectDept() {
	    const win = app.createElement(SelectDeptWindow, {
	      callback: this.commitSelectDept
	    });
	    app.addElement(win);
	  }

	  commitSelectDept(deptID, deptName) {
	    this.setState({
	      deptID,
	      deptName
	    });
	  }

	  handleSave(callback) {
	    const {
	      id,
	      username,
	      password,
	      confirmPassword,
	      name,
	      roleID,
	      deptID
	    } = this.state;

	    if (!username || username.trim() === '') {
	      app.toast(_t('Username is not allowed to be empty.'), 'warn');
	      return;
	    }

	    if (!id && (!password || password.trim() === '')) {
	      app.toast(_t('Password is not allowed to be empty.'), 'warn');
	      return;
	    }

	    if (!id && (!confirmPassword || confirmPassword.trim() === '')) {
	      app.toast(_t('Confirm password is not allowed to be empty.'), 'warn');
	      return;
	    }

	    if (!id && password !== confirmPassword) {
	      app.toast(_t('Password and confirm password is not the same.'), 'warn');
	      return;
	    }

	    if (!name || name.trim() === '') {
	      app.toast(_t('Nick name is not allowed to be empty.'), 'warn');
	      return;
	    }

	    const url = !id ? `/api/User/Add` : `/api/User/Edit`;
	    fetch(`${app.options.server}${url}`, {
	      method: 'POST',
	      headers: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      body: `ID=${id}&Username=${username}&Password=${password}&Name=${name}&RoleID=${roleID}&DeptID=${deptID}`
	    }).then(response => {
	      response.json().then(json => {
	        if (json.Code !== 200) {
	          app.toast(_t(json.Msg), 'warn');
	          return;
	        }

	        this.handleClose();
	        callback && callback();
	      });
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	  renderRoleName(value) {
	    if (value === 'Administrator' || value === 'User' || value === 'Guest') {
	      return _t(value);
	    }

	    return value;
	  }

	}

	EditUserWindow.propTypes = {
	  id: propTypes.string,
	  username: propTypes.string,
	  name: propTypes.string,
	  roleID: propTypes.string,
	  deptID: propTypes.string,
	  deptName: propTypes.string,
	  callback: propTypes.func
	};
	EditUserWindow.defaultProps = {
	  id: '',
	  username: '',
	  name: '',
	  roleID: '',
	  deptID: '',
	  deptName: '',
	  callback: null
	};

	/**
	 * 重置密码窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class ResetPasswordWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      id: props.id,
	      newPassword: '',
	      confirmPassword: ''
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleSave = this.handleSave.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      newPassword,
	      confirmPassword
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: _t('ResetPasswordWindows'),
	      title: _t('Reset Password'),
	      style: {
	        width: '320px',
	        height: '200px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('New Password')), /*#__PURE__*/React.createElement(Input, {
	      name: 'newPassword',
	      type: 'password',
	      value: newPassword,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Confirm Password')), /*#__PURE__*/React.createElement(Input, {
	      name: 'confirmPassword',
	      type: 'password',
	      value: confirmPassword,
	      onChange: this.handleChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleSave() {
	    const {
	      id,
	      newPassword,
	      confirmPassword
	    } = this.state;

	    if (!newPassword || newPassword.trim() === '') {
	      app.toast(_t('New password is not allowed to be empty.'), 'warn');
	      return;
	    }

	    if (!confirmPassword || confirmPassword.trim() === '') {
	      app.toast(_t('Confirm password is not allowed to be empty.'), 'warn');
	      return;
	    }

	    if (newPassword !== confirmPassword) {
	      app.toast(_t('New password and confirm password is not the same.'), 'warn');
	      return;
	    }

	    fetch(`${app.options.server}/api/User/ResetPassword`, {
	      method: 'POST',
	      headers: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      body: `UserID=${id}&NewPassword=${newPassword}&ConfirmPassword=${confirmPassword}`
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        app.toast(_t(obj.Msg), 'success');
	        this.handleClose();
	      });
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	ResetPasswordWindow.propTypes = {
	  id: propTypes.string
	};
	ResetPasswordWindow.defaultProps = {
	  id: ''
	};

	/**
	 * 用户管理窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class UserManageWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      pageSize: 10,
	      pageNum: 1,
	      total: 0,
	      selected: null,
	      keyword: '',
	      mask: false
	    };
	    this.update = this.update.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.commitDelete = this.commitDelete.bind(this);
	    this.handleResetPassword = this.handleResetPassword.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	    this.handleSearch = this.handleSearch.bind(this);
	    this.renderStatus = this.renderStatus.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleChangePageSize = this.handleChangePageSize.bind(this);
	    this.handleFirstPage = this.handleFirstPage.bind(this);
	    this.handlePreviousPage = this.handlePreviousPage.bind(this);
	    this.handleNextPage = this.handleNextPage.bind(this);
	    this.handleLastPage = this.handleLastPage.bind(this);
	    this.handleRefresh = this.handleRefresh.bind(this);
	  }

	  render() {
	    const {
	      data,
	      pageSize,
	      pageNum,
	      total,
	      selected,
	      mask
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'UserManageWindow',
	      title: _t('User Management'),
	      style: {
	        width: '900px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Toolbar, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleAdd
	    }, _t('Create')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleEdit
	    }, _t('Edit')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleDelete
	    }, _t('Delete')), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleResetPassword
	    }, _t('Reset Password')), /*#__PURE__*/React.createElement(ToolbarFiller, null), /*#__PURE__*/React.createElement(SearchField, {
	      placeholder: _t('Search Content'),
	      onInput: this.handleSearch
	    })), /*#__PURE__*/React.createElement(DataGrid, {
	      data: data,
	      pages: true,
	      pageSize: pageSize,
	      pageNum: pageNum,
	      total: total,
	      selected: selected,
	      mask: mask,
	      onSelect: this.handleSelect,
	      onChangePageSize: this.handleChangePageSize,
	      onFirstPage: this.handleFirstPage,
	      onPreviousPage: this.handlePreviousPage,
	      onNextPage: this.handleNextPage,
	      onLastPage: this.handleLastPage,
	      onRefresh: this.handleRefresh,
	      keyField: 'ID'
	    }, /*#__PURE__*/React.createElement(Column, {
	      type: 'number',
	      title: '#'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Username',
	      title: _t('Username'),
	      width: 120
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Name',
	      title: _t('NickName'),
	      align: 'center',
	      renderer: this.renderName
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'RoleName',
	      title: _t('Role'),
	      width: 120,
	      align: 'center',
	      renderer: this.renderRoleName
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'DeptName',
	      title: _t('Department'),
	      width: 180,
	      align: 'center',
	      renderer: this.renderRoleName
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'CreateTime',
	      title: _t('Create Date'),
	      width: 120,
	      align: 'center',
	      renderer: this.renderDate
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Status',
	      title: _t('Status'),
	      width: 80,
	      align: 'center',
	      renderer: this.renderStatus
	    }))));
	  }

	  componentDidMount() {
	    this.handleRefresh();
	  }

	  update(pageSize, pageNum, keyword = '') {
	    this.setState({
	      mask: true
	    });
	    fetch(`${app.options.server}/api/User/List?pageSize=${pageSize}&pageNum=${pageNum}&keyword=${keyword}`).then(response => {
	      response.json().then(obj => {
	        app.unmask();

	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          pageSize,
	          pageNum,
	          total: obj.Data.total,
	          data: obj.Data.rows,
	          keyword: keyword,
	          mask: false
	        });
	      });
	    });
	  }

	  handleAdd() {
	    const win = app.createElement(EditUserWindow, {
	      callback: this.handleRefresh
	    });
	    app.addElement(win);
	  }

	  handleEdit() {
	    const {
	      data,
	      selected
	    } = this.state;

	    if (!selected) {
	      app.toast(_t('Please select a record.'));
	      return;
	    }

	    const record = data.filter(n => n.ID === selected)[0];

	    if (record.Username === 'admin') {
	      app.toast(_t('Modifying system built-in users is not allowed.'), 'warn');
	      return;
	    }

	    const win = app.createElement(EditUserWindow, {
	      id: record.ID,
	      username: record.Username,
	      name: record.Name,
	      roleID: record.RoleID,
	      deptID: record.DeptID,
	      deptName: record.DeptName,
	      callback: this.handleRefresh
	    });
	    app.addElement(win);
	  }

	  handleDelete() {
	    const selected = this.state.selected;

	    if (!selected) {
	      app.toast(_t('Please select a record.'));
	      return;
	    }

	    const record = this.state.data.filter(n => n.ID === selected)[0];

	    if (record.Username === 'admin') {
	      app.toast(_t('It is not allowed to delete system built-in users.'), 'warn');
	      return;
	    }

	    app.confirm({
	      title: _t('Query'),
	      content: _t('Delete the selected record?'),
	      onOK: () => {
	        this.commitDelete(selected);
	      }
	    });
	  }

	  handleResetPassword() {
	    const {
	      selected
	    } = this.state;

	    if (!selected) {
	      app.toast(_t('Please select a record.'));
	      return;
	    }

	    const win = app.createElement(ResetPasswordWindow, {
	      id: selected
	    });
	    app.addElement(win);
	  }

	  commitDelete(id) {
	    fetch(`${app.options.server}/api/User/Delete?ID=${id}`, {
	      method: 'POST'
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.handleRefresh();
	        app.toast(_t(obj.Msg), 'success');
	      });
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	  handleSearch(value) {
	    const {
	      pageSize,
	      pageNum
	    } = this.state;
	    this.update(pageSize, pageNum, value);
	  }

	  renderName(value) {
	    if (value === 'Administrator') {
	      return `${_t(value)} (${value})`;
	    }

	    return value;
	  }

	  renderRoleName(value) {
	    if (value === 'Administrator' || value === 'User' || value === 'Guest') {
	      return _t(value);
	    }

	    return value;
	  }

	  renderDate(value) {
	    return value.split(' ')[0];
	  }

	  renderStatus(value) {
	    return value === 0 ? _t('Enabled') : _t('Disabled');
	  }

	  handleSelect(selected) {
	    this.setState({
	      selected: selected.ID
	    });
	  }

	  handleChangePageSize(value) {
	    const {
	      pageNum,
	      keyword
	    } = this.state;
	    this.update(value, pageNum, keyword);
	  }

	  handleFirstPage() {
	    const {
	      pageSize,
	      keyword
	    } = this.state;
	    this.update(pageSize, 1, keyword);
	  }

	  handlePreviousPage() {
	    const {
	      pageSize,
	      pageNum,
	      keyword
	    } = this.state;
	    const newPageNum = pageNum > 1 ? pageNum - 1 : pageNum;
	    this.update(pageSize, newPageNum, keyword);
	  }

	  handleNextPage() {
	    const {
	      pageSize,
	      pageNum,
	      total,
	      keyword
	    } = this.state;
	    const totalPage = total % pageSize === 0 ? total / pageSize : parseInt(total / pageSize) + 1;
	    const newPageNum = pageNum < totalPage ? pageNum + 1 : pageNum;
	    this.update(pageSize, newPageNum, keyword);
	  }

	  handleLastPage() {
	    const {
	      pageSize,
	      total,
	      keyword
	    } = this.state;
	    const totalPage = total % pageSize === 0 ? total / pageSize : parseInt(total / pageSize) + 1;
	    const newPageNum = totalPage;
	    this.update(pageSize, newPageNum, keyword);
	  }

	  handleRefresh() {
	    const {
	      pageSize,
	      pageNum,
	      keyword
	    } = this.state;
	    this.update(pageSize, pageNum, keyword);
	  }

	}

	/**
	 * 角色编辑窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class EditRoleWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      id: props.id,
	      name: props.name
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleSave = this.handleSave.bind(this, props.callback);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      name
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: _t('EditRoleWindow'),
	      title: _t('Edit Role'),
	      style: {
	        width: '320px',
	        height: '200px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Name')), /*#__PURE__*/React.createElement(Input, {
	      name: 'name',
	      value: name,
	      onChange: this.handleChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleSave(callback) {
	    const {
	      id,
	      name
	    } = this.state;

	    if (!name || name.trim() === '') {
	      app.toast(_t('Name is not allowed to be empty.'), 'warn');
	      return;
	    }

	    const url = !id ? `/api/Role/Add` : `/api/Role/Edit`;
	    fetch(`${app.options.server}${url}`, {
	      method: 'POST',
	      headers: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      body: `ID=${id}&Name=${name}`
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.handleClose();
	        callback && callback();
	      });
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	EditRoleWindow.propTypes = {
	  id: propTypes.string,
	  name: propTypes.string,
	  callback: propTypes.func
	};
	EditRoleWindow.defaultProps = {
	  id: '',
	  name: '',
	  callback: null
	};

	/**
	 * 角色管理窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class RoleManageWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      pageSize: 10,
	      pageNum: 1,
	      total: 0,
	      selected: null,
	      keyword: '',
	      mask: false
	    };
	    this.update = this.update.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.commitDelete = this.commitDelete.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	    this.handleSearch = this.handleSearch.bind(this);
	    this.renderStatus = this.renderStatus.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleChangePageSize = this.handleChangePageSize.bind(this);
	    this.handleFirstPage = this.handleFirstPage.bind(this);
	    this.handlePreviousPage = this.handlePreviousPage.bind(this);
	    this.handleNextPage = this.handleNextPage.bind(this);
	    this.handleLastPage = this.handleLastPage.bind(this);
	    this.handleRefresh = this.handleRefresh.bind(this);
	  }

	  render() {
	    const {
	      data,
	      pageSize,
	      pageNum,
	      total,
	      selected,
	      mask
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'RoleManageWindow',
	      title: _t('Role Management'),
	      style: {
	        width: '600px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Toolbar, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleAdd
	    }, _t('Create')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleEdit
	    }, _t('Edit')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleDelete
	    }, _t('Delete')), /*#__PURE__*/React.createElement(ToolbarFiller, null), /*#__PURE__*/React.createElement(SearchField, {
	      placeholder: _t('Search Content'),
	      onInput: this.handleSearch
	    })), /*#__PURE__*/React.createElement(DataGrid, {
	      data: data,
	      pages: true,
	      pageSize: pageSize,
	      pageNum: pageNum,
	      total: total,
	      selected: selected,
	      mask: mask,
	      onSelect: this.handleSelect,
	      onChangePageSize: this.handleChangePageSize,
	      onFirstPage: this.handleFirstPage,
	      onPreviousPage: this.handlePreviousPage,
	      onNextPage: this.handleNextPage,
	      onLastPage: this.handleLastPage,
	      onRefresh: this.handleRefresh,
	      keyField: 'ID'
	    }, /*#__PURE__*/React.createElement(Column, {
	      type: 'number',
	      title: '#'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Name',
	      title: _t('Name'),
	      renderer: this.renderName
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'UpdateTime',
	      title: _t('Update Date'),
	      width: 120,
	      align: 'center',
	      renderer: this.renderDate
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'CreateTime',
	      title: _t('Create Date'),
	      width: 120,
	      align: 'center',
	      renderer: this.renderDate
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Status',
	      title: _t('Status'),
	      width: 100,
	      align: 'center',
	      renderer: this.renderStatus
	    }))));
	  }

	  componentDidMount() {
	    this.handleRefresh();
	  }

	  update(pageSize, pageNum, keyword = '') {
	    this.setState({
	      mask: true
	    });
	    fetch(`${app.options.server}/api/Role/List?pageSize=${pageSize}&pageNum=${pageNum}&keyword=${keyword}`).then(response => {
	      response.json().then(obj => {
	        app.unmask();

	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          pageSize,
	          pageNum,
	          total: obj.Data.total,
	          data: obj.Data.rows,
	          keyword: keyword,
	          mask: false
	        });
	      });
	    });
	  }

	  handleAdd() {
	    const win = app.createElement(EditRoleWindow, {
	      callback: this.handleRefresh
	    });
	    app.addElement(win);
	  }

	  handleEdit() {
	    const {
	      data,
	      selected
	    } = this.state;

	    if (!selected) {
	      app.toast(_t('Please select a record.'));
	      return;
	    }

	    const record = data.filter(n => n.ID === selected)[0];

	    if (record.Name === 'Administrator' || record.Name === 'User' || record.Name === 'Guest') {
	      app.toast(_t('Modifying system built-in roles is not allowed.'), 'warn');
	      return;
	    }

	    const win = app.createElement(EditRoleWindow, {
	      id: record.ID,
	      name: record.Name,
	      callback: this.handleRefresh
	    });
	    app.addElement(win);
	  }

	  handleDelete() {
	    const selected = this.state.selected;

	    if (!selected) {
	      app.toast(_t('Please select a record.'));
	      return;
	    }

	    const record = this.state.data.filter(n => n.ID === selected)[0];

	    if (record.Name === 'Administrator' || record.Name === 'User' || record.Name === 'Guest') {
	      app.toast(_t('It is not allowed to delete system built-in roles.'), 'warn');
	      return;
	    }

	    app.confirm({
	      title: _t('Query'),
	      content: _t('Delete the selected record?'),
	      onOK: () => {
	        this.commitDelete(selected);
	      }
	    });
	  }

	  commitDelete(id) {
	    fetch(`${app.options.server}/api/Role/Delete?ID=${id}`, {
	      method: 'POST'
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.handleRefresh();
	        app.toast(_t(obj.Msg), 'success');
	      });
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	  handleSearch(value) {
	    const {
	      pageSize,
	      pageNum
	    } = this.state;
	    this.update(pageSize, pageNum, value);
	  }

	  renderName(value) {
	    if (value === 'Administrator' || value === 'User' || value === 'Guest') {
	      return `${_t(value)} (${value})`;
	    }

	    return value;
	  }

	  renderDate(value) {
	    return value.split(' ')[0];
	  }

	  renderStatus(value) {
	    return value === 0 ? _t('Enabled') : _t('Disabled');
	  }

	  handleSelect(selected) {
	    this.setState({
	      selected: selected.ID
	    });
	  }

	  handleChangePageSize(value) {
	    const {
	      pageNum,
	      keyword
	    } = this.state;
	    this.update(value, pageNum, keyword);
	  }

	  handleFirstPage() {
	    const {
	      pageSize,
	      keyword
	    } = this.state;
	    this.update(pageSize, 1, keyword);
	  }

	  handlePreviousPage() {
	    const {
	      pageSize,
	      pageNum,
	      keyword
	    } = this.state;
	    const newPageNum = pageNum > 1 ? pageNum - 1 : pageNum;
	    this.update(pageSize, newPageNum, keyword);
	  }

	  handleNextPage() {
	    const {
	      pageSize,
	      pageNum,
	      total,
	      keyword
	    } = this.state;
	    const totalPage = total % pageSize === 0 ? total / pageSize : parseInt(total / pageSize) + 1;
	    const newPageNum = pageNum < totalPage ? pageNum + 1 : pageNum;
	    this.update(pageSize, newPageNum, keyword);
	  }

	  handleLastPage() {
	    const {
	      pageSize,
	      total,
	      keyword
	    } = this.state;
	    const totalPage = total % pageSize === 0 ? total / pageSize : parseInt(total / pageSize) + 1;
	    const newPageNum = totalPage;
	    this.update(pageSize, newPageNum, keyword);
	  }

	  handleRefresh() {
	    const {
	      pageSize,
	      pageNum,
	      keyword
	    } = this.state;
	    this.update(pageSize, pageNum, keyword);
	  }

	}

	/**
	 * 权限管理窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class AuthorityManagementWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      roles: [],
	      authorities: [],
	      roleID: null,
	      mask: true
	    };
	    this.handleSelectRole = this.handleSelectRole.bind(this);
	    this.handleSelectAuthority = this.handleSelectAuthority.bind(this);
	    this.handleSelectAllAuthority = this.handleSelectAllAuthority.bind(this);
	    this.handleSave = this.handleSave.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      roles,
	      authorities,
	      roleID,
	      mask
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'AuthorityManagementWindow',
	      title: _t('Authority Management'),
	      style: {
	        width: '600px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Toolbar, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('Save')), /*#__PURE__*/React.createElement(ToolbarFiller, null)), /*#__PURE__*/React.createElement(HBoxLayout, {
	      className: 'hbox'
	    }, /*#__PURE__*/React.createElement(DataGrid, {
	      className: 'roles',
	      data: roles,
	      selected: roleID,
	      mask: mask,
	      onSelect: this.handleSelectRole,
	      keyField: 'ID'
	    }, /*#__PURE__*/React.createElement(Column, {
	      type: 'number'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Name',
	      title: _t('Role'),
	      renderer: this.renderRoleName
	    })), /*#__PURE__*/React.createElement(DataGrid, {
	      className: 'authorities',
	      data: authorities,
	      mask: mask,
	      onSelect: this.handleSelectAuthority,
	      onSelectAll: this.handleSelectAllAuthority,
	      keyField: 'ID'
	    }, /*#__PURE__*/React.createElement(Column, {
	      type: 'checkbox',
	      field: 'Enabled'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Name',
	      title: _t('Authority')
	    })))));
	  }

	  componentDidMount() {
	    fetch(`${app.options.server}/api/Role/List?pageSize=10000`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          roles: obj.Data.rows,
	          mask: false
	        });
	      });
	    });
	  }

	  handleSelectRole(selected) {
	    this.setState({
	      roleID: selected.ID,
	      mask: true
	    });
	    fetch(`${app.options.server}/api/OperatingAuthority/Get?roleID=${selected.ID}`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        obj.Data.rows.forEach(n => {
	          n.Name = _t(n.Name);
	        });
	        this.setState({
	          authorities: obj.Data.rows,
	          mask: false
	        });
	      });
	    });
	  }

	  handleSelectAuthority(selected) {
	    let authorities = this.state.authorities;
	    let authority = authorities.filter(n => n.ID === selected.ID)[0];

	    if (authority) {
	      authority.Enabled = !authority.Enabled;
	    }

	    this.setState({
	      authorities
	    });
	  }

	  handleSelectAllAuthority(value) {
	    let authorities = this.state.authorities;
	    authorities.forEach(n => {
	      n.Enabled = value;
	    });
	    this.setState({
	      authorities
	    });
	  }

	  handleSave() {
	    const {
	      roleID,
	      authorities
	    } = this.state;
	    let body = `RoleID=${roleID}`;
	    authorities.forEach(n => {
	      if (n.Enabled) {
	        body += `&Authorities[]=${n.ID}`;
	      }
	    });
	    fetch(`${app.options.server}/api/OperatingAuthority/Save`, {
	      method: 'POST',
	      headers: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      body
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        app.toast(_t(obj.Msg), 'success');
	        this.handleSelectRole({
	          ID: roleID
	        });
	      });
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	  renderRoleName(value) {
	    if (value === 'Administrator' || value === 'User' || value === 'Guest') {
	      return _t(value);
	    }

	    return value;
	  }

	}

	/**
	 * 系统设置窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class SystemSettingWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      roles: {},
	      registerRole: ''
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleSave = this.handleSave.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      roles,
	      registerRole
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'SystemSettingWindow',
	      title: _t('System Setting'),
	      style: {
	        width: '320px',
	        height: '200px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Register Default Role')), /*#__PURE__*/React.createElement(Select, {
	      name: 'registerRole',
	      options: roles,
	      value: registerRole,
	      onChange: this.handleChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  componentDidMount() {
	    fetch(`/api/Config/Get`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          registerRole: obj.Data.DefaultRegisterRole
	        });
	      });
	    });
	    fetch(`/api/Role/List?pageSize=10000`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        let roles = {};
	        obj.Data.rows.forEach(n => {
	          roles[n.ID] = this.renderRoleName(n.Name);
	        });
	        this.setState({
	          roles
	        });
	      });
	    });
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleSave() {
	    const {
	      registerRole
	    } = this.state;
	    fetch(`/api/Config/Save`, {
	      method: 'POST',
	      headers: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      body: `DefaultRegisterRole=${registerRole}`
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        app.toast(_t(obj.Msg), 'success');
	        this.handleClose();
	      });
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	  renderRoleName(value) {
	    if (value === 'Administrator' || value === 'User' || value === 'Guest') {
	      return _t(value);
	    }

	    return value;
	  }

	}

	/**
	 * 系统菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class SystemMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleDepartment = this.handleDepartment.bind(this);
	    this.handleUser = this.handleUser.bind(this);
	    this.handleRole = this.handleRole.bind(this);
	    this.handleAuthority = this.handleAuthority.bind(this);
	    this.handleSystemSetting = this.handleSystemSetting.bind(this);
	    this.handleResetSystem = this.handleResetSystem.bind(this);
	    this.commitResetSystem = this.commitResetSystem.bind(this);
	  }

	  render() {
	    const {
	      initialized
	    } = app.server;
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('System')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Department Management'),
	      show: initialized,
	      onClick: this.handleDepartment
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('User Management'),
	      show: initialized,
	      onClick: this.handleUser
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, {
	      show: initialized
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Role Management'),
	      show: initialized,
	      onClick: this.handleRole
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Authority Management'),
	      show: initialized,
	      onClick: this.handleAuthority
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, {
	      show: initialized
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('System Setting'),
	      show: initialized,
	      onClick: this.handleSystemSetting
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Reset System'),
	      show: initialized,
	      onClick: this.handleResetSystem
	    }));
	  }

	  handleDepartment() {
	    const win = app.createElement(DepartmentManagementWindow);
	    app.addElement(win);
	  }

	  handleUser() {
	    const win = app.createElement(UserManageWindow);
	    app.addElement(win);
	  }

	  handleRole() {
	    const win = app.createElement(RoleManageWindow);
	    app.addElement(win);
	  }

	  handleAuthority() {
	    const win = app.createElement(AuthorityManagementWindow);
	    app.addElement(win);
	  }

	  handleSystemSetting() {
	    const win = app.createElement(SystemSettingWindow);
	    app.addElement(win);
	  }

	  handleResetSystem() {
	    app.confirm({
	      title: _t('Query'),
	      content: _t('All roles and users will be deleted and the pre-initial state will be restored. Is it reset?'),
	      onOK: this.commitResetSystem
	    });
	  }

	  commitResetSystem() {
	    fetch(`${app.options.server}/api/Initialize/Reset`, {
	      method: 'POST'
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        app.confirm({
	          title: _t('Message'),
	          content: _t(obj.Msg) + ' ' + _t('Press OK To refresh.'),
	          onOK: () => {
	            window.location.reload();
	          }
	        });
	      });
	    });
	  }

	}

	/**
	 * 渲染器属性窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class RendererAttributesWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const attributes = app.editor.renderer.getContextAttributes();
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'RendererAttributesWindow',
	      title: _t('Renderer Attributes'),
	      style: {
	        width: '400px',
	        height: '320px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, Object.keys(attributes).map(key => {
	      const value = attributes[key];
	      return /*#__PURE__*/React.createElement(FormControl, {
	        key: key
	      }, /*#__PURE__*/React.createElement(Label, null, _t(key)), /*#__PURE__*/React.createElement(Input, {
	        name: key,
	        value: value.toString(),
	        disabled: true
	      }));
	    }))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * Three.js信息窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class ThreeJsInformationWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'ThreeJsInformationWindow',
	      title: _t('Three.js Information'),
	      style: {
	        width: '320px',
	        height: '160px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Version')), /*#__PURE__*/React.createElement(Input, {
	      value: THREE.REVISION,
	      disabled: true
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	const DESCRIPTIONS = {
	  'ANGLE_instanced_arrays': 'The ANGLE_instanced_arrays extension is part of the WebGL API and allows to draw the same object, or groups of similar objects multiple times, if they share the same vertex data, primitive count and type.',
	  'EXT_blend_minmax': 'The EXT_blend_minmax extension is part of the WebGL API and extends blending capabilities by adding two new blend equations: the minimum or maximum color components of the source and destination colors.',
	  'EXT_color_buffer_float': 'The EXT_color_buffer_float extension is part of WebGL and adds the ability to render a variety of floating point formats.',
	  'EXT_color_buffer_half_float': 'The EXT_color_buffer_half_float extension is part of the WebGL API and adds the ability to render to 16-bit floating-point color buffers.',
	  'EXT_disjoint_timer_query': 'The EXT_disjoint_timer_query extension is part of the WebGL API and provides a way to measure the duration of a set of GL commands, without stalling the rendering pipeline.',
	  'EXT_float_blend': "The WebGL API's EXT_float_blend extension allows blending and draw buffers with 32-bit floating-point components.",
	  'EXT_frag_depth': 'The EXT_frag_depth extension is part of the WebGL API and enables to set a depth value of a fragment from within the fragment shader.',
	  'EXT_sRGB': 'The EXT_sRGB extension is part of the WebGL API and adds sRGB support to textures and framebuffer objects.',
	  'EXT_shader_texture_lod': 'The EXT_shader_texture_lod extension is part of the WebGL API and adds additional texture functions to the OpenGL ES Shading Language which provide the shader writer with explicit control of LOD (Level of detail).',
	  'EXT_texture_compression_bptc': "The EXT_texture_compression_bptc extension is part of the WebGL API and exposes 4 BPTC compressed texture formats. These compression formats are called BC7 and BC6H in Microsoft's DirectX API.",
	  'EXT_texture_compression_rgtc': 'The EXT_texture_compression_rgtc extension is part of the WebGL API and exposes 4 RGTC compressed texture formats. RGTC is a block-based texture compression format suited for unsigned and signed red and red-green textures (Red-Green Texture Compression).',
	  'EXT_texture_filter_anisotropic': 'The EXT_texture_filter_anisotropic extension is part of the WebGL API and exposes two constants for anisotropic filtering (AF).',
	  'OES_element_index_uint': 'The OES_element_index_uint extension is part of the WebGL API and adds support for gl.UNSIGNED_INT types to WebGLRenderingContext.drawElements().',
	  'OES_fbo_render_mipmap': 'The OES_fbo_render_mipmap extension is part of the WebGL API and makes it possible to attach any level of a texture to a framebuffer object.',
	  'OES_standard_derivatives': 'The OES_standard_derivatives extension is part of the WebGL API and adds the GLSL derivative functions dFdx, dFdy, and fwidth.',
	  'OES_texture_float': 'The OES_texture_float extension is part of the WebGL API and exposes floating-point pixel types for textures.',
	  'OES_texture_float_linear': 'The OES_texture_float_linear extension is part of the WebGL API and allows linear filtering with floating-point pixel types for textures.',
	  'OES_texture_half_float': 'The OES_texture_half_float extension is part of the WebGL API and adds texture formats with 16- (aka half float) and 32-bit floating-point components.',
	  'OES_texture_half_float_linear': 'The OES_texture_half_float_linear extension is part of the WebGL API and allows linear filtering with half floating-point pixel types for textures.',
	  'OES_vertex_array_object': 'The OES_vertex_array_object extension is part of the WebGL API and provides vertex array objects (VAOs) which encapsulate vertex array states. These objects keep pointers to vertex data and provide names for different sets of vertex data.',
	  'OVR_multiview2': 'The OVR_multiview2 extension is part of the WebGL API and adds support for rendering into multiple views simultaneously. This especially useful for virtual reality (VR) and WebXR.',
	  'WEBGL_color_buffer_float': 'The WEBGL_color_buffer_float extension is part of the WebGL API and adds the ability to render to 32-bit floating-point color buffers.',
	  'WEBGL_compressed_texture_astc': 'The WEBGL_compressed_texture_astc extension is part of the WebGL API and exposes Adaptive Scalable Texture Compression (ASTC) compressed texture formats to WebGL.',
	  'WEBGL_compressed_texture_atc': 'The WEBGL_compressed_texture_atc extension is part of the WebGL API and exposes 3 ATC compressed texture formats. ATC is a proprietary compression algorithm for compressing textures on handheld devices.',
	  'WEBGL_compressed_texture_etc': 'The WEBGL_compressed_texture_etc extension is part of the WebGL API and exposes 10 ETC/EAC compressed texture formats.',
	  'WEBGL_compressed_texture_etc1': 'The WEBGL_compressed_texture_etc1 extension is part of the WebGL API and exposes the ETC1 compressed texture format.',
	  'WEBGL_compressed_texture_pvrtc': 'The WEBGL_compressed_texture_pvrtc extension is part of the WebGL API and exposes four PVRTC compressed texture formats.',
	  'WEBGL_compressed_texture_s3tc': 'The WEBGL_compressed_texture_s3tc extension is part of the WebGL API and exposes four S3TC compressed texture formats.',
	  'WEBGL_compressed_texture_s3tc_srgb': 'The WEBGL_compressed_texture_s3tc_srgb extension is part of the WebGL API and exposes four S3TC compressed texture formats for the sRGB colorspace.',
	  'WEBGL_debug_renderer_info': 'The WEBGL_debug_renderer_info extension is part of the WebGL API and exposes two constants with information about the graphics driver for debugging purposes.',
	  'WEBGL_debug_shaders': 'The WEBGL_debug_shaders extension is part of the WebGL API and exposes a method to debug shaders from privileged contexts.',
	  'WEBGL_depth_texture': 'The WEBGL_depth_texture extension is part of the WebGL API and defines 2D depth and depth-stencil textures.',
	  'WEBGL_draw_buffers': 'The WEBGL_draw_buffers extension is part of the WebGL API and enables a fragment shader to write to several textures, which is useful for deferred shading, for example.',
	  'WEBGL_lose_context': 'The WEBGL_lose_context extension is part of the WebGL API and exposes functions to simulate losing and restoring a WebGLRenderingContext.'
	};
	/**
	 * 扩展窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class ExtensionWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.renderDescription = this.renderDescription.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    let list = [];
	    const context = app.editor.renderer.getContext();
	    const extensions = context.getSupportedExtensions();
	    extensions.forEach(n => {
	      const key = n.startsWith('WEBKIT_') ? n.substring(7) : n;
	      list.push({
	        Name: n,
	        Description: DESCRIPTIONS[key]
	      });
	    });
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'ExtensionWindow',
	      title: _t('WebGL Extensions'),
	      style: {
	        width: '1000px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(DataGrid, {
	      data: list,
	      keyField: 'Name'
	    }, /*#__PURE__*/React.createElement(Column, {
	      type: 'number',
	      title: '#'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Name',
	      title: _t('Name'),
	      width: 200
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Description',
	      title: _t('Description'),
	      danger: true,
	      renderer: this.renderDescription
	    }))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  renderDescription(value, row) {
	    if (row.Description) {
	      let name = row.Name;

	      if (name.startsWith('WEBKIT_')) {
	        name = name.substring(7);
	      }

	      return `${value} [<a href="https://developer.mozilla.org/en-US/docs/Web/API/${name}" target="_blank">${_t('MDN')}</a>]`;
	    } else {
	      return value;
	    }
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 帮助菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class HelpMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleRendererAttributes = this.handleRendererAttributes.bind(this);
	    this.handleThreeJsInformation = this.handleThreeJsInformation.bind(this);
	    this.handleExtension = this.handleExtension.bind(this);
	    this.handleVisitSketchfab = this.handleVisitSketchfab.bind(this);
	    this.handleVisit3dpunk = this.handleVisit3dpunk.bind(this);
	    this.handleGitHubSource = this.handleGitHubSource.bind(this);
	    this.handleGiteeSource = this.handleGiteeSource.bind(this);
	    this.handleDocument = this.handleDocument.bind(this);
	    this.handleGitHubExamples = this.handleGitHubExamples.bind(this);
	    this.handleGiteeExamples = this.handleGiteeExamples.bind(this);
	    this.handleAbout = this.handleAbout.bind(this);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Help')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Renderer Attributes'),
	      onClick: this.handleRendererAttributes
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Three.js Information'),
	      onClick: this.handleThreeJsInformation
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('WebGL Extensions'),
	      onClick: this.handleExtension
	    }), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Download Mesh')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Sketchfab'),
	      onClick: this.handleVisitSketchfab
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('3dpunk'),
	      onClick: this.handleVisit3dpunk
	    })), /*#__PURE__*/React.createElement(MenuItemSeparator, null), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Source')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('GitHub'),
	      onClick: this.handleGitHubSource
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Gitee'),
	      onClick: this.handleGiteeSource
	    })), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Documents'),
	      onClick: this.handleDocument
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Examples')
	    }, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('GitHub'),
	      onClick: this.handleGitHubExamples
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Gitee'),
	      onClick: this.handleGiteeExamples
	    })), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('About'),
	      onClick: this.handleAbout
	    }));
	  }

	  handleRendererAttributes() {
	    const win = app.createElement(RendererAttributesWindow);
	    app.addElement(win);
	  }

	  handleThreeJsInformation() {
	    const win = app.createElement(ThreeJsInformationWindow);
	    app.addElement(win);
	  }

	  handleExtension() {
	    const win = app.createElement(ExtensionWindow);
	    app.addElement(win);
	  }

	  handleVisitSketchfab() {
	    window.open('https://sketchfab.com/3d-models?features=downloadable', '_blank');
	  }

	  handleVisit3dpunk() {
	    window.open('https://www.3dpunk.com/work/index.html?category=downloadable', '_blank');
	  }

	  handleGitHubSource() {
	    window.open('https://github.com/tengge1/ShadowEditor', '_blank');
	  }

	  handleGiteeSource() {
	    window.open('https://gitee.com/tengge1/ShadowEditor', '_blank');
	  }

	  handleDocument() {
	    window.open('https://gitee.com/tengge1/ShadowEditor/wikis/pages', '_blank');
	  }

	  handleGitHubExamples() {
	    window.open('https://tengge1.github.io/ShadowEditor-examples/', '_blank');
	  }

	  handleGiteeExamples() {
	    window.open('http://tengge1.gitee.io/shadoweditor-examples/', '_blank');
	  }

	  handleAbout() {
	    app.alert({
	      title: _t('About'),
	      className: 'About',
	      content: /*#__PURE__*/React.createElement(React.Fragment, null, _t('Name'), ": ShadowEditor", /*#__PURE__*/React.createElement("br", null), _t('Author'), ": tengge1", /*#__PURE__*/React.createElement("br", null), _t('Lisense'), ": MIT", /*#__PURE__*/React.createElement("br", null), _t('Source'), "1: ", /*#__PURE__*/React.createElement("a", {
	        href: "https://github.com/tengge1/ShadowEditor",
	        target: "_blank",
	        rel: "noopener noreferrer"
	      }, "https://github.com/tengge1/ShadowEditor"), /*#__PURE__*/React.createElement("br", null), _t('Source'), "2: ", /*#__PURE__*/React.createElement("a", {
	        href: "https://gitee.com/tengge1/ShadowEditor",
	        target: "_blank",
	        rel: "noopener noreferrer"
	      }, "https://gitee.com/tengge1/ShadowEditor"), /*#__PURE__*/React.createElement("br", null))
	    });
	  }

	}

	/**
	 * 登录窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class LoginWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      username: '',
	      password: ''
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleLogin = this.handleLogin.bind(this, props.callback);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      username,
	      password
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'Login',
	      title: _t('Login'),
	      style: {
	        width: '320px',
	        height: '200px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Username')), /*#__PURE__*/React.createElement(Input, {
	      name: 'username',
	      value: username,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement("input", {
	      type: 'password',
	      className: 'fake'
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Password')), /*#__PURE__*/React.createElement(Input, {
	      name: 'password',
	      type: 'password',
	      value: password,
	      onChange: this.handleChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleLogin
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleLogin() {
	    const {
	      username,
	      password
	    } = this.state;
	    app.server.login(username, password).then(succes => {
	      if (!succes) {
	        return;
	      }

	      this.handleClose();
	      window.location.reload();
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 注册窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class RegisterWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      username: '',
	      password: '',
	      confirmPassword: '',
	      name: ''
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleLogin = this.handleLogin.bind(this, props.callback);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      username,
	      password,
	      confirmPassword,
	      name
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'RegisterWindow',
	      title: _t('Register'),
	      style: {
	        width: '400px',
	        height: '240px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Username')), /*#__PURE__*/React.createElement(Input, {
	      name: 'username',
	      value: username,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement("input", {
	      type: 'text',
	      className: 'fake',
	      value: username
	    }), /*#__PURE__*/React.createElement("input", {
	      type: 'password',
	      className: 'fake'
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Password')), /*#__PURE__*/React.createElement(Input, {
	      name: 'password',
	      type: 'password',
	      value: password,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Confirm Password')), /*#__PURE__*/React.createElement(Input, {
	      name: 'confirmPassword',
	      type: 'password',
	      value: confirmPassword,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('NickName')), /*#__PURE__*/React.createElement(Input, {
	      name: 'name',
	      value: name,
	      onChange: this.handleChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleLogin
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleLogin() {
	    const {
	      username,
	      password,
	      confirmPassword,
	      name
	    } = this.state;
	    fetch(`/api/Register/Register`, {
	      method: 'POST',
	      headers: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      body: `Username=${username}&Password=${password}&ConfirmPassword=${confirmPassword}&name=${name}`
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        app.toast(_t(obj.Msg), 'success');
	        this.handleClose();
	      });
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 修改密码窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class ChangePasswordWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      oldPassword: '',
	      newPassword: '',
	      confirmPassword: ''
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleOK = this.handleOK.bind(this, props.callback);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      oldPassword,
	      newPassword,
	      confirmPassword
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'ChangePasswordWindow',
	      title: _t('Change Password'),
	      style: {
	        width: '400px',
	        height: '240px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Old Password')), /*#__PURE__*/React.createElement(Input, {
	      name: 'oldPassword',
	      type: 'password',
	      value: oldPassword,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('New Password')), /*#__PURE__*/React.createElement(Input, {
	      name: 'newPassword',
	      type: 'password',
	      value: newPassword,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Confirm Password')), /*#__PURE__*/React.createElement(Input, {
	      name: 'confirmPassword',
	      type: 'password',
	      value: confirmPassword,
	      onChange: this.handleChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleOK
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleOK() {
	    const {
	      oldPassword,
	      newPassword,
	      confirmPassword
	    } = this.state;
	    fetch(`/api/User/ChangePassword`, {
	      method: 'POST',
	      headers: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      body: `OldPassword=${oldPassword}&NewPassword=${newPassword}&ConfirmPassword=${confirmPassword}`
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        app.toast(_t(obj.Msg), 'success');
	        this.handleClose();
	      });
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 登录菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class LoginMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleInitialize = this.handleInitialize.bind(this);
	    this.commitInitialize = this.commitInitialize.bind(this);
	    this.handleClickRegister = this.handleClickRegister.bind();
	    this.handleClickLogin = this.handleClickLogin.bind(this);
	    this.handleChangePassword = this.handleChangePassword.bind(this);
	    this.handleClickLogout = this.handleClickLogout.bind(this);
	    this.commitLogout = this.commitLogout.bind(this);
	  }

	  render() {
	    if (!app.server.initialized) {
	      // 系统未初始化
	      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MenuItemSeparator, {
	        className: 'LoginSeparator',
	        direction: 'horizontal'
	      }), /*#__PURE__*/React.createElement("li", {
	        className: bind('MenuItem', 'LoginMenuItem')
	      }, /*#__PURE__*/React.createElement(LinkButton, {
	        className: 'button',
	        onClick: this.handleInitialize
	      }, _t(`Initialize`))));
	    } else if (app.server.isLogin) {
	      // 已经登录
	      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MenuItemSeparator, {
	        className: 'LoginSeparator',
	        direction: 'horizontal'
	      }), /*#__PURE__*/React.createElement("li", {
	        className: bind('MenuItem', 'LoginMenuItem')
	      }, /*#__PURE__*/React.createElement("span", {
	        className: 'welcome'
	      }, _t(`Welcome, {{Name}}`, {
	        Name: app.server.name === 'Administrator' ? _t(app.server.name) : app.server.name
	      }))), /*#__PURE__*/React.createElement(MenuItemSeparator, {
	        className: 'LoginSeparator',
	        direction: 'horizontal'
	      }), /*#__PURE__*/React.createElement("li", {
	        className: bind('MenuItem', 'LoginMenuItem')
	      }, /*#__PURE__*/React.createElement(LinkButton, {
	        className: 'button',
	        onClick: this.handleChangePassword
	      }, _t(`Change Password`))), /*#__PURE__*/React.createElement(MenuItemSeparator, {
	        className: 'LoginSeparator',
	        direction: 'horizontal'
	      }), /*#__PURE__*/React.createElement("li", {
	        className: bind('MenuItem', 'LoginMenuItem')
	      }, /*#__PURE__*/React.createElement(LinkButton, {
	        className: 'button',
	        onClick: this.handleClickLogout
	      }, _t(`Logout`))));
	    } else {
	      // 尚未登录
	      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MenuItemSeparator, {
	        className: 'LoginSeparator',
	        direction: 'horizontal'
	      }), /*#__PURE__*/React.createElement("li", {
	        className: bind('MenuItem', 'LoginMenuItem')
	      }, /*#__PURE__*/React.createElement(LinkButton, {
	        className: 'button',
	        onClick: this.handleClickRegister
	      }, _t(`Register`))), /*#__PURE__*/React.createElement(MenuItemSeparator, {
	        className: 'LoginSeparator',
	        direction: 'horizontal'
	      }), /*#__PURE__*/React.createElement("li", {
	        className: bind('MenuItem', 'LoginMenuItem')
	      }, /*#__PURE__*/React.createElement(LinkButton, {
	        className: 'button',
	        onClick: this.handleClickLogin
	      }, _t(`Login`))));
	    }
	  }

	  handleInitialize() {
	    app.confirm({
	      title: _t('Query'),
	      content: _t('Are you sure to initialize the roles and users?'),
	      onOK: this.commitInitialize
	    });
	  }

	  commitInitialize() {
	    fetch(`${app.options.server}/api/Initialize/Initialize`, {
	      method: 'POST'
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        app.confirm({
	          title: _t('Message'),
	          content: _t(obj.Msg) + ' ' + _t('Press OK To refresh.'),
	          onOK: () => {
	            window.location.reload();
	          }
	        });
	      });
	    });
	  }

	  handleClickRegister() {
	    const win = app.createElement(RegisterWindow);
	    app.addElement(win);
	  }

	  handleClickLogin() {
	    const win = app.createElement(LoginWindow);
	    app.addElement(win);
	  }

	  handleChangePassword() {
	    const win = app.createElement(ChangePasswordWindow);
	    app.addElement(win);
	  }

	  handleClickLogout() {
	    app.confirm({
	      title: _t('Query'),
	      content: _t('Are you sure to log out?'),
	      onOK: this.commitLogout
	    });
	  }

	  commitLogout() {
	    // 服务端需要设置SameSite=Lax，否则无法清除客户端Cookie。
	    app.server.logout().then(success => {
	      if (!success) {
	        return;
	      } // CookieUtils.clearAll();


	      window.location.reload();
	      app.toast(_t(obj.Msg));
	    });
	  }

	}

	/**
	 * 编辑器菜单栏
	 * @author tengge / https://github.com/tengge1
	 */

	class EditorMenuBar extends React.Component {
	  render() {
	    const {
	      className
	    } = this.props;
	    const {
	      enableAuthority,
	      isLogin,
	      isAdmin
	    } = app.server;
	    return /*#__PURE__*/React.createElement(MenuBar, {
	      className: bind('EditorMenuBar', className)
	    }, !enableAuthority || isLogin ? /*#__PURE__*/React.createElement(SceneMenu, null) : null, !enableAuthority || isLogin ? /*#__PURE__*/React.createElement(EditMenu, null) : null, !enableAuthority || isLogin ? /*#__PURE__*/React.createElement(TwoDMenu, null) : null, !enableAuthority || isLogin ? /*#__PURE__*/React.createElement(ObjectMenu, null) : null, !enableAuthority || isLogin ? /*#__PURE__*/React.createElement(LightMenu, null) : null, !enableAuthority || isLogin ? /*#__PURE__*/React.createElement(AssetsMenu, null) : null, !enableAuthority || isLogin ? /*#__PURE__*/React.createElement(ComponentMenu, null) : null, enableAuthority && isAdmin ? /*#__PURE__*/React.createElement(SystemMenu, null) : null, /*#__PURE__*/React.createElement(PlayMenu, null), !enableAuthority || isAdmin ? /*#__PURE__*/React.createElement(ExampleMenu, null) : null, !enableAuthority || isAdmin ? /*#__PURE__*/React.createElement(ToolMenu, null) : null, /*#__PURE__*/React.createElement(ViewMenu, null), /*#__PURE__*/React.createElement(OptionsMenu, null), /*#__PURE__*/React.createElement(HelpMenu, null), /*#__PURE__*/React.createElement(MenuItemSeparator, {
	      direction: 'horizontal'
	    }), /*#__PURE__*/React.createElement(MenuBarFiller, null), enableAuthority && /*#__PURE__*/React.createElement(LoginMenu, null));
	  }

	}

	/**
	 * 状态栏
	 * @author tengge / https://github.com/tengge1
	 */

	class EditorStatusBar extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      x: 0,
	      y: 0,
	      objects: 0,
	      vertices: 0,
	      triangles: 0
	    };
	    this.handleUpdateMousePosition = this.handleUpdateMousePosition.bind(this);
	    this.handleUpdateSceneInfo = this.handleUpdateSceneInfo.bind(this);
	    this.handleAutoSaveChange = this.handleAutoSaveChange.bind(this);
	  }

	  render() {
	    const {
	      x,
	      y,
	      objects,
	      vertices,
	      triangles
	    } = this.state;
	    const autoSave = app.storage.autoSave;
	    return /*#__PURE__*/React.createElement(Toolbar, {
	      className: 'EditorStatusBar'
	    }, /*#__PURE__*/React.createElement(Label, null, `r${THREE.REVISION}`), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(Label, null, _t('X')), /*#__PURE__*/React.createElement("div", {
	      className: 'mouse-position'
	    }, /*#__PURE__*/React.createElement(Label, null, x)), /*#__PURE__*/React.createElement(Label, null, _t('Y')), /*#__PURE__*/React.createElement("div", {
	      className: 'mouse-position'
	    }, /*#__PURE__*/React.createElement(Label, null, y)), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(Label, null, _t('Object')), /*#__PURE__*/React.createElement(Label, {
	      className: 'value'
	    }, objects), /*#__PURE__*/React.createElement(Label, null, _t('Vertex')), /*#__PURE__*/React.createElement(Label, {
	      className: 'value'
	    }, vertices), /*#__PURE__*/React.createElement(Label, null, _t('Triangle')), /*#__PURE__*/React.createElement(Label, {
	      className: 'value'
	    }, triangles), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(Label, null, _t('Auto Save')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'autoSave',
	      checked: autoSave,
	      onChange: this.handleAutoSaveChange
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null));
	  }

	  componentDidMount() {
	    app.on(`mousemove.EditorStatusBar`, this.handleUpdateMousePosition);
	    app.on(`objectAdded.EditorStatusBar`, this.handleUpdateSceneInfo);
	    app.on(`objectRemoved.EditorStatusBar`, this.handleUpdateSceneInfo);
	    app.on(`geometryChanged.EditorStatusBar`, this.handleUpdateSceneInfo);
	  }

	  handleUpdateMousePosition(event) {
	    if (event.target !== app.editor.renderer.domElement) {
	      this.setState({
	        x: 0,
	        y: 0
	      });
	      return;
	    }

	    this.setState({
	      x: event.offsetX,
	      y: event.offsetY
	    });
	  }

	  handleUpdateSceneInfo() {
	    var editor = app.editor;
	    var scene = editor.scene;
	    var objects = 0,
	        vertices = 0,
	        triangles = 0;

	    for (var i = 0, l = scene.children.length; i < l; i++) {
	      var object = scene.children[i];
	      object.traverseVisible(function (object) {
	        objects++;

	        if (object instanceof THREE.Mesh) {
	          var geometry = object.geometry;

	          if (geometry instanceof THREE.Geometry) {
	            vertices += geometry.vertices.length;
	            triangles += geometry.faces.length;
	          } else if (geometry instanceof THREE.BufferGeometry) {
	            if (geometry.index !== null) {
	              vertices += geometry.index.count * 3;
	              triangles += geometry.index.count;
	            } else if (geometry.attributes.position) {
	              vertices += geometry.attributes.position.count;
	              triangles += geometry.attributes.position.count / 3;
	            }
	          }
	        }
	      });
	    }

	    this.setState({
	      objects: objects.format(),
	      vertices: vertices.format(),
	      triangles: triangles.format()
	    });
	  }

	  handleAutoSaveChange(value, name) {
	    app.storage.autoSave = value;
	    this.forceUpdate();
	    app.call('storageChanged', this, name, value);
	  }

	}

	/**
	 * canvas转DataURL
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {HTMLCanvasElement} canvas 画布
	 * @param {String} type 图片类型 image/png或image/jpeg
	 * @param {Number} quality jpeg图片质量
	 * @returns {String} DataURL数据
	 */
	function canvasToDataURL(canvas, type = 'image/png', quality = 0.8) {
	  if (type.toLowerCase() === 'image/png') {
	    return canvas.toDataURL(type);
	  } else {
	    return canvas.toDataURL(type, quality);
	  }
	}
	/**
	 * Blob转DataURL
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {Blob} blob Blob对象
	 * @returns {Promise} DataURL数据
	 */


	function blobToDataURL(blob) {
	  var reader = new FileReader();
	  return new Promise(resolve => {
	    reader.onload = e => {
	      resolve(e.target.result);
	    };

	    reader.readAsDataURL(blob);
	  });
	}
	/**
	 * 文件转DataURL
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {File} file 文件
	 * @returns {Promise} DataURL数据
	 */


	function fileToDataURL(file) {
	  return blobToDataURL(file);
	}
	/**
	 * DataURL转Blob
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {String} dataURL DataURL数据
	 * @returns {Blob} Blob对象
	 */


	function dataURLToBlob(dataURL) {
	  var array = dataURL.split(',');
	  var mimeType = array[0].match(/:(.*?);/)[1];
	  var binaryString = atob(array[1]);
	  var length = binaryString.length;
	  var uint8Array = new Uint8Array(length);

	  while (length--) {
	    uint8Array[length] = binaryString.charCodeAt(length);
	  }

	  return new Blob([uint8Array], {
	    type: mimeType
	  });
	}
	/**
	 * DataURL转File
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {String} dataURL DataURL数据
	 * @param {String} filename 文件名
	 * @returns {File} 文件
	 */


	function dataURLtoFile(dataURL, filename) {
	  var array = dataURL.split(',');
	  var mimeType = array[0].match(/:(.*?);/)[1];
	  var binaryString = atob(array[1]);
	  var length = binaryString.length;
	  var uint8Array = new Uint8Array(length);

	  while (length--) {
	    uint8Array[length] = binaryString.charCodeAt(length);
	  }

	  if (mimeType === 'image/jpeg') {
	    filename = filename + '.jpg';
	  } else if (mimeType === 'image/png') {
	    filename = filename + '.png';
	  } else {
	    console.warn(`Converter: not supported mime-type: ${mimeType}.`);
	  }

	  return new File([uint8Array], filename, {
	    type: mimeType
	  });
	}
	/**
	 * DataURL转图片
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {String} dataURL DataURL数据
	 * @returns {Image} 图片
	 */


	function dataURLToImage(dataURL) {
	  var image = new Image();
	  return new Promise(resolve => {
	    image.onload = () => {
	      image.onload = null;
	      image.onerror = null;
	      resolve(image);
	    };

	    image.onerror = () => {
	      image.onload = null;
	      image.onerror = null;
	      resolve(null);
	    };

	    image.src = dataURL;
	  });
	}
	/**
	 * Blob转图片
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {Blob} blob Blob对象
	 * @returns {Promise} 图片
	 */


	function BlobToImage(blob) {
	  return new Promise(resolve => {
	    blobToDataURL(blob).then(dataURL => {
	      dataURLToImage(dataURL).then(image => {
	        resolve(image);
	      });
	    });
	  });
	}
	/**
	 * 文件转图片
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {File} file 文件
	 * @returns {Image} 图片
	 */


	function FileToImage(file) {
	  return BlobToImage(file);
	}
	/**
	 * 图片转画布
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {Image} image 图片
	 * @returns {HTMLCanvasElement} 画布
	 */


	function ImageToCanvas(image) {
	  var canvas = document.createElement('canvas');
	  canvas.width = image.width;
	  canvas.height = image.height;
	  var context = canvas.getContext('2d');
	  context.drawImage(image, 0, 0);
	  return canvas;
	}
	/**
	 * 画布转图片
	 * @param {HTMLCanvasElement} canvas 画布
	 * @param {String} type 类型
	 * @param {Number} quality jpeg图片质量
	 * @returns {Image} 图片
	 */


	function CanvasToImage(canvas, type = 'image/png', quality = 0.8) {
	  var image = new Image();

	  if (type === 'image/jpeg') {
	    image.src = canvas.toDataURL('image/jpeg', quality);
	  } else {
	    image.src = canvas.toDataURL('image/png');
	  }

	  return image;
	}
	/**
	 * 类型转换工具
	 * @author tengge / https://github.com/tengge1
	 */


	const Converter$1 = {
	  canvasToDataURL: canvasToDataURL,
	  blobToDataURL: blobToDataURL,
	  fileToDataURL: fileToDataURL,
	  dataURLToBlob: dataURLToBlob,
	  dataURLtoFile: dataURLtoFile,
	  dataURLToImage: dataURLToImage,
	  BlobToImage: BlobToImage,
	  FileToImage: FileToImage,
	  imageToCanvas: ImageToCanvas,
	  canvasToImage: CanvasToImage
	};

	/**
	 * 视频录制器
	 * @author tengge / https://github.com/tengge1
	 */

	class VideoRecorder {
	  constructor() {
	    this.chunks = [];
	    this.recorder = null;
	    this.running = false;
	    this.onDataAvailable = this.onDataAvailable.bind(this);
	  }

	  start() {
	    if (!navigator.mediaDevices) {
	      app.toast(`Record is not supported!`, 'error');
	      return new Promise(resolve => {
	        resolve(false);
	      });
	    }

	    return new Promise(resolve => {
	      navigator.mediaDevices.getDisplayMedia().then(stream => {
	        this.recorder = new MediaRecorder(stream);
	        this.recorder.ondataavailable = this.onDataAvailable;
	        this.recorder.start();
	        this.running = true;
	        resolve(true);
	      }).catch(() => {
	        this.running = false;
	        resolve(false);
	      });
	    });
	  }

	  stop() {
	    return new Promise(resolve => {
	      this.recorder.onstop = () => {
	        this.recorder.ondataavailable = null;
	        this.recorder.onstop = null;
	        this.running = false;
	        const file = new File(this.chunks, TimeUtils.getDateTime() + '.webm');
	        let form = new FormData();
	        form.append('file', file);
	        fetch(`/api/Video/Add`, {
	          method: 'POST',
	          body: form
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code !== 200) {
	              app.toast(_t(obj.Msg), 'warn');
	              return;
	            }

	            app.toast(_t(obj.Msg), 'success');
	            this.chunks.length = 0;
	            resolve(true);
	          });
	        });
	      };

	      this.recorder.stop();
	    }).catch(() => {
	      this.running = false;
	      resolve(false);
	    });
	  }

	  onDataAvailable(e) {
	    this.chunks.push(e.data);
	  }

	}

	let recorder = null;
	/**
	 * 通用工具
	 * @author tengge / https://github.com/tengge1
	 */

	class GeneralTools extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      mode: 'translate',
	      view: 'perspective',
	      isGridMode: false,
	      isRecording: recorder ? recorder.running : false,
	      isFirstPerspective: false
	    };
	    this.handleEnterSelectMode = this.handleEnterSelectMode.bind(this);
	    this.handleEnterTranslateMode = this.handleEnterTranslateMode.bind(this);
	    this.handleEnterRotateMode = this.handleEnterRotateMode.bind(this);
	    this.handleEnterScaleMode = this.handleEnterScaleMode.bind(this);
	    this.handlePerspective = this.handlePerspective.bind(this);
	    this.handleFrontView = this.handleFrontView.bind(this);
	    this.handleSideView = this.handleSideView.bind(this);
	    this.handleTopView = this.handleTopView.bind(this);
	    this.handleGridMode = this.handleGridMode.bind(this);
	    this.handleScreenshot = this.handleScreenshot.bind(this);
	    this.commitScreenshot = this.commitScreenshot.bind(this);
	    this.handleRecord = this.handleRecord.bind(this);
	    this.handleFirstPerspective = this.handleFirstPerspective.bind(this);
	  }

	  render() {
	    const {
	      mode,
	      view,
	      isGridMode,
	      isRecording,
	      isFirstPerspective
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'select',
	      title: _t('Select'),
	      selected: mode === 'select',
	      onClick: this.handleEnterSelectMode
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'translate',
	      title: _t('Translate'),
	      selected: mode === 'translate',
	      onClick: this.handleEnterTranslateMode
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'rotate',
	      title: _t('Rotate'),
	      selected: mode === 'rotate',
	      onClick: this.handleEnterRotateMode
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'scale',
	      title: _t('Scale'),
	      selected: mode === 'scale',
	      onClick: this.handleEnterScaleMode
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(ImageButton, {
	      src: 'assets/image/perspective-view.png',
	      title: _t('Perspective View'),
	      selected: view === 'perspective',
	      onClick: this.handlePerspective
	    }), /*#__PURE__*/React.createElement(ImageButton, {
	      src: 'assets/image/front-view.png',
	      title: _t('Front View'),
	      selected: view === 'front',
	      onClick: this.handleFrontView
	    }), /*#__PURE__*/React.createElement(ImageButton, {
	      src: 'assets/image/side-view.png',
	      title: _t('Side View'),
	      selected: view === 'side',
	      onClick: this.handleSideView
	    }), /*#__PURE__*/React.createElement(ImageButton, {
	      src: 'assets/image/top-view.png',
	      title: _t('Top View'),
	      selected: view === 'top',
	      onClick: this.handleTopView
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'grid',
	      title: _t('Grid Mode'),
	      selected: isGridMode,
	      onClick: this.handleGridMode
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'camera',
	      title: _t('Screenshot'),
	      show: !enableAuthority || authorities.includes('ADD_SCREENSHOT'),
	      onClick: this.handleScreenshot
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: isRecording ? 'stop-record' : 'recorder',
	      title: isRecording ? _t('Stop') : _t('Record'),
	      show: !enableAuthority || authorities.includes('ADD_VIDEO'),
	      onClick: this.handleRecord
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'first-perspective',
	      title: _t('First Perspective'),
	      selected: isFirstPerspective,
	      onClick: this.handleFirstPerspective
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null));
	  } // --------------------------------- 选择模式 -------------------------------------


	  handleEnterSelectMode() {
	    this.setState({
	      mode: 'select'
	    });
	    app.call('changeMode', this, 'select');
	  }

	  handleEnterTranslateMode() {
	    this.setState({
	      mode: 'translate'
	    });
	    app.call('changeMode', this, 'translate');
	  }

	  handleEnterRotateMode() {
	    this.setState({
	      mode: 'rotate'
	    });
	    app.call('changeMode', this, 'rotate');
	  }

	  handleEnterScaleMode() {
	    this.setState({
	      mode: 'scale'
	    });
	    app.call('changeMode', this, 'scale');
	  } // ------------------------------ 视角工具 ------------------------------------------


	  handlePerspective() {
	    app.call(`changeView`, this, 'perspective');
	    this.setState({
	      view: 'perspective'
	    });
	  }

	  handleFrontView() {
	    app.call(`changeView`, this, 'front');
	    this.setState({
	      view: 'front'
	    });
	  }

	  handleSideView() {
	    app.call(`changeView`, this, 'side');
	    this.setState({
	      view: 'side'
	    });
	  }

	  handleTopView() {
	    app.call(`changeView`, this, 'top');
	    this.setState({
	      view: 'top'
	    });
	  } // ----------------------------- 网格模式 ------------------------------------------


	  handleGridMode() {
	    const isGridMode = !this.state.isGridMode;

	    if (isGridMode) {
	      app.editor.scene.overrideMaterial = new THREE.MeshBasicMaterial({
	        wireframe: true
	      });
	    } else {
	      app.editor.scene.overrideMaterial = null;
	    }

	    this.setState({
	      isGridMode
	    });
	  } // ---------------------------- 截图 ----------------------------------------------


	  handleScreenshot() {
	    app.on(`afterRender.Screenshot`, this.commitScreenshot);
	  }

	  commitScreenshot() {
	    app.on(`afterRender.Screenshot`, null);
	    const canvas = app.editor.renderer.domElement;
	    const dataUrl = Converter$1.canvasToDataURL(canvas);
	    const file = Converter$1.dataURLtoFile(dataUrl, TimeUtils.getDateTime());
	    let form = new FormData();
	    form.append('file', file);
	    fetch(`/api/Screenshot/Add`, {
	      method: 'POST',
	      body: form
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        app.toast(_t(obj.Msg), 'success');
	      });
	    });
	  } // ------------------------------ 视频录制 --------------------------------------


	  handleRecord() {
	    if (this.state.isRecording) {
	      this.stopRecord();
	    } else {
	      this.startRecord();
	    }
	  }

	  startRecord() {
	    if (recorder === null) {
	      recorder = new VideoRecorder();
	    }

	    recorder.start().then(success => {
	      if (success) {
	        this.setState({
	          isRecording: true
	        });
	      }
	    });
	  }

	  stopRecord() {
	    if (!recorder) {
	      return;
	    }

	    recorder.stop().then(() => {
	      this.setState({
	        isRecording: false
	      });
	    });
	  } // --------------------------- 第一视角 ------------------------------


	  handleFirstPerspective() {
	    let controls = app.editor.controls;
	    controls.on(`change.FirstPerspective`, (enabled, controlName) => {
	      if (controlName !== 'FirstPersonControls') {
	        return;
	      }

	      this.setState({
	        isFirstPerspective: enabled
	      });
	    });
	    controls.changeMode('FirstPersonControls');
	  }

	}

	/**
	 * 编辑工具
	 * @author tengge / https://github.com/tengge1
	 */

	class EditTools extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleUndo = this.handleUndo.bind(this);
	    this.handleRedo = this.handleRedo.bind(this);
	    this.handleClearHistory = this.handleClearHistory.bind(this);
	    this.onHistoryChanged = this.onHistoryChanged.bind(this);
	    this.onObjectSelected = this.onObjectSelected.bind(this);
	  }

	  render() {
	    const editor = app.editor;
	    const history = editor.history;
	    const enableUndo = history.undos.length > 0;
	    const enableRedo = history.redos.length > 0;
	    const enableClearHistory = history.undos.length > 0 || history.redos.length > 0;
	    const enableClone = editor.selected && editor.selected.parent !== null;
	    const enableDelete = editor.selected && editor.selected.parent !== null;
	    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'undo',
	      title: `${_t('Undo')}(Ctrl+Z)`,
	      disabled: !enableUndo,
	      onClick: this.handleUndo
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'redo',
	      title: `${_t('Redo')}(Ctrl+Y)`,
	      disabled: !enableRedo,
	      onClick: this.handleRedo
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'history',
	      title: _t('Clear History'),
	      disabled: !enableClearHistory,
	      onClick: this.handleClearHistory
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'duplicate',
	      title: `${_t('Clone')}(Ctrl+C)`,
	      disabled: !enableClone,
	      onClick: this.handleCopy
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'delete',
	      title: `${_t('Delete')}(Delete)`,
	      disabled: !enableDelete,
	      onClick: this.handleDelete
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null));
	  }

	  componentDidMount() {
	    app.on(`historyChanged.EditMenu`, this.onHistoryChanged);
	    app.on(`objectSelected.EditMenu`, this.onObjectSelected);
	  }

	  handleUndo() {
	    app.call(`undo`, this);
	  }

	  handleRedo() {
	    app.call(`redo`, this);
	  }

	  handleClearHistory() {
	    app.call(`clearHistory`, this);
	  }

	  handleCopy() {
	    app.call(`clone`, this);
	  }

	  handleDelete() {
	    app.call(`delete`, this);
	  }

	  onHistoryChanged() {
	    this.forceUpdate();
	  }

	  onObjectSelected() {
	    this.forceUpdate();
	  }

	}

	/**
	 * 挖坑工具
	 * @param {*} app 应用程序
	 */

	function DigTool(app) {
	  BaseTool.call(this, app);
	  this.points = [];
	}

	DigTool.prototype = Object.create(BaseTool.prototype);
	DigTool.prototype.constructor = DigTool;

	DigTool.prototype.start = function () {
	  app.on(`intersect.${this.id}`, this.onRaycast.bind(this));
	  app.on(`dblclick.${this.id}`, this.onDblClick.bind(this));
	  app.on(`beforeRender.${this.id}`, this.onBeforeRender.bind(this));
	  app.on(`afterRender.${this.id}`, this.onAfterRender.bind(this));
	};

	DigTool.prototype.stop = function () {
	  app.on(`intersect.${this.id}`, null);
	  app.on(`dblclick.${this.id}`, null);
	  app.on(`beforeRender.${this.id}`, null);
	  app.on(`afterRender.${this.id}`, null);
	};

	DigTool.prototype.onRaycast = function (obj) {
	  this.points.push(obj.point);
	};

	DigTool.prototype.onDblClick = function () {
	  this.call('end');

	  if (this.scene === undefined) {
	    this.scene = new THREE.Scene();
	  } // var xys = this.points.map(n => {
	  //     return {
	  //         x: n.x,
	  //         y: n.z
	  //     };
	  // });
	  // if (!THREE.ShapeUtils.isClockWise(xys)) {
	  //     this.points.reverse();
	  // }


	  var geometry = new THREE.BufferGeometry();
	  var vertices = [];
	  this.points.forEach(n => {
	    vertices.push(n.x, n.y, n.z);
	  });
	  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
	  var material = new THREE.MeshBasicMaterial();
	  material.polygonOffset = true;
	  material.polygonOffsetFactor = -1;
	  var mesh = new THREE.Mesh(geometry, material);
	  this.scene.add(mesh);
	  this.points.length = 0;
	};

	DigTool.prototype.onBeforeRender = function () {
	  if (!this.scene || this.scene.children.length === 0) {
	    return;
	  }

	  var renderer = app.editor.renderer;
	  var context = renderer.getContext();
	  var state = renderer.state;
	  state.buffers.color.setMask(false);
	  state.buffers.depth.setMask(false);
	  state.buffers.stencil.setMask(0xff);
	  state.buffers.stencil.setTest(true);
	  state.buffers.stencil.setFunc(context.ALWAYS, 1, 0xff);
	  state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.REPLACE);
	  renderer.render(this.scene, app.editor.camera);
	  state.buffers.color.setMask(0xff);
	  state.buffers.depth.setMask(0xff);
	  state.buffers.stencil.setMask(0x0);
	  state.buffers.stencil.setFunc(context.NOTEQUAL, 1, 0xff);
	};

	DigTool.prototype.onAfterRender = function () {
	  if (!this.scene || this.scene.children.length === 0) {
	    return;
	  }

	  var renderer = app.editor.renderer; // var context = renderer.getContext();

	  var state = renderer.state;
	  state.buffers.stencil.setMask(0xff);
	  state.buffers.stencil.setTest(false);
	  renderer.clearStencil();
	};

	/**
	 * 绘制工具
	 * @author tengge / https://github.com/tengge1
	 */

	class DrawTools extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      isAddingPoint: false,
	      isAddingLine: false,
	      isAddingPolygon: false,
	      isSpraying: false,
	      isDigging: false
	    };
	    this.handleAddPoint = this.handleAddPoint.bind(this);
	    this.onAddPointIntersect = this.onAddPointIntersect.bind(this);
	    this.handleAddLine = this.handleAddLine.bind(this);
	    this.onAddLineIntersect = this.onAddLineIntersect.bind(this);
	    this.onAddLineDblClick = this.onAddLineDblClick.bind(this);
	    this.handleAddPolygon = this.handleAddPolygon.bind(this);
	    this.onAddPolygonIntersect = this.onAddPolygonIntersect.bind(this);
	    this.onAddPolygonDblClick = this.onAddPolygonDblClick.bind(this);
	    this.handleSpray = this.handleSpray.bind(this);
	    this.onSprayIntersect = this.onSprayIntersect.bind(this);
	    this.handleDig = this.handleDig.bind(this);
	  }

	  render() {
	    const {
	      isAddingPoint,
	      isAddingLine,
	      isAddingPolygon,
	      isSpraying,
	      isDigging
	    } = this.state;
	    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'point',
	      title: _t('Draw Point'),
	      selected: isAddingPoint,
	      onClick: this.handleAddPoint
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'line',
	      title: _t('Draw Line'),
	      selected: isAddingLine,
	      onClick: this.handleAddLine
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'polygon',
	      title: _t('Draw Pologon'),
	      selected: isAddingPolygon,
	      onClick: this.handleAddPolygon
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'spray',
	      title: _t('Spray'),
	      selected: isSpraying,
	      onClick: this.handleSpray
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'texture',
	      title: _t('Dig'),
	      show: false,
	      selected: isDigging,
	      onClick: this.handleDig
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null));
	  } // --------------------------------- 画点 ------------------------------------------


	  handleAddPoint() {
	    const isAddingPoint = !this.state.isAddingPoint;
	    this.setState({
	      isAddingPoint
	    });

	    if (isAddingPoint) {
	      app.editor.gpuPickNum++;
	      app.on(`intersect.EditorToolbarAddPoint`, this.onAddPointIntersect);
	    } else {
	      app.on(`intersect.EditorToolbarAddPoint`, null);
	    }
	  }

	  onAddPointIntersect(obj, event) {
	    if (event.button !== 0) {
	      return;
	    }

	    this.handleAddPoint();
	    var geometry = new THREE.CircleBufferGeometry(0.4, 32, 0, Math.PI * 2);
	    var material = new THREE.PointsMaterial({
	      color: 0xffffff * Math.random(),
	      polygonOffset: true,
	      polygonOffsetFactor: -40
	    });
	    var mesh = new THREE.Mesh(geometry, material);
	    mesh.position.copy(obj.point);
	    var normal = obj.face.normal.clone();
	    normal.transformDirection(obj.object.matrixWorld);
	    mesh.lookAt(new THREE.Vector3().addVectors(obj.point, normal));
	    mesh.name = _t('Point');
	    app.editor.execute(new AddObjectCommand(mesh));
	    app.editor.gpuPickNum--;
	  } // ---------------------------------- 画线 -----------------------------------------


	  handleAddLine() {
	    if (this.hasLoadLineScript === undefined) {
	      this.hasLoadLineScript = true;

	      app.require('line').then(() => {
	        this.onAddLine();
	      });
	    } else {
	      this.onAddLine();
	    }
	  }

	  onAddLine() {
	    const isAddingLine = !this.state.isAddingLine;
	    this.setState({
	      isAddingLine
	    });

	    if (isAddingLine) {
	      app.editor.gpuPickNum++;
	      app.on(`intersect.EditorToolbarAddLine`, this.onAddLineIntersect);
	      app.on(`dblclick.EditorToolbarAddLine`, this.onAddLineDblClick);
	      this.linePositions = [];
	      this.lineColors = [];
	      var geometry = new THREE.LineGeometry();
	      var material = new THREE.LineMaterial({
	        color: 0xffffff,
	        linewidth: 8,
	        // in pixels
	        vertexColors: THREE.VertexColors,
	        dashed: false,
	        polygonOffset: true,
	        polygonOffsetFactor: -40
	      });
	      var renderer = app.editor.renderer;
	      material.resolution.set(renderer.domElement.clientWidth, renderer.domElement.clientHeight);
	      this.line = new THREE.Line2(geometry, material);
	      this.line.name = _t('Line');
	      app.editor.execute(new AddObjectCommand(this.line));
	    } else {
	      app.on(`intersect.EditorToolbarAddLine`, null);
	      app.on(`dblclick.EditorToolbarAddLine`, null);
	      this.linePositions = null;
	      this.lineColors = null;
	      this.line = null;
	    }
	  }

	  onAddLineIntersect(obj, event) {
	    if (event.button !== 0) {
	      return;
	    }

	    this.linePositions.push(obj.point.x, obj.point.y, obj.point.z);
	    var color = new THREE.Color(0xffffff * Math.random());
	    this.lineColors.push(color.r, color.g, color.b);

	    if (this.linePositions.length < 6) {
	      return;
	    }

	    var geometry = this.line.geometry;
	    geometry.setPositions(this.linePositions);
	    geometry.setColors(this.lineColors);
	    geometry.maxInstancedCount = this.linePositions.length / 3 - 1;
	    this.line.computeLineDistances();
	  }

	  onAddLineDblClick() {
	    this.onAddLine();
	  } // ---------------------------------- 画面 ------------------------------------------


	  handleAddPolygon() {
	    const isAddingPolygon = !this.state.isAddingPolygon;
	    this.setState({
	      isAddingPolygon
	    });

	    if (isAddingPolygon) {
	      app.on(`intersect.EditorToolbarAddPolygon`, this.onAddPolygonIntersect);
	      app.on(`dblclick.EditorToolbarAddPolygon`, this.onAddPolygonDblClick);
	      var geometry = new THREE.BufferGeometry();
	      geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(300), 3));
	      geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(300), 3));
	      geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(200), 2));
	      geometry.attributes.position.count = 0;
	      geometry.attributes.normal.count = 0;
	      geometry.attributes.uv.count = 0;
	      var material = new THREE.MeshBasicMaterial({
	        color: 0xffffff * Math.random(),
	        polygonOffset: true,
	        polygonOffsetFactor: -40,
	        side: THREE.DoubleSide
	      });
	      this.polygon = new THREE.Mesh(geometry, material);
	      this.polygon.name = _t('Polygon');
	      this.polygon.drawMode = THREE.TriangleStripDrawMode;
	      app.editor.execute(new AddObjectCommand(this.polygon));
	      this.polygonPoints = [];
	    } else {
	      app.on(`intersect.EditorToolbarAddPolygon`, null);
	      app.on(`dblclick.EditorToolbarAddPolygon`, null);
	      this.polygon = null;
	      this.polygonPoints = null;
	    }
	  }

	  onAddPolygonIntersect(obj) {
	    if (event.button !== 0) {
	      return;
	    }

	    this.polygonPoints.push(obj.point);
	    var position = this.polygon.geometry.attributes.position;
	    var normal = this.polygon.geometry.attributes.normal;
	    var uv = this.polygon.geometry.attributes.uv;
	    var index = position.count;
	    position.setXYZ(index, obj.point.x, obj.point.y, obj.point.z);
	    normal.setXYZ(index, obj.face.normal.x, obj.face.normal.y, obj.face.normal.z);
	    uv.setXY(index, obj.uv.x, obj.uv.y);
	    position.count++;
	    normal.count++;
	    uv.count++;
	    position.needsUpdate = true;
	    normal.needsUpdate = true;
	    uv.needsUpdate = true;
	  }

	  onAddPolygonDblClick() {
	    this.handleAddPolygon();
	  } // -------------------------------- 贴花工具 ---------------------------------------


	  handleSpray() {
	    const isSpraying = !this.state.isSpraying;
	    this.setState({
	      isSpraying
	    });

	    if (isSpraying) {
	      app.on(`intersect.EditorToolbarSpray`, this.onSprayIntersect);
	    } else {
	      app.on(`intersect.EditorToolbarSpray`, null);
	    }
	  }

	  onSprayIntersect(obj, event) {
	    if (event.button !== 0) {
	      return;
	    }

	    this.handleSpray();
	    var mesh = obj.object;
	    var position = obj.point;

	    if (mesh instanceof THREE.Points) {
	      return;
	    }

	    var normal = obj.face.normal.clone();
	    normal.transformDirection(obj.object.matrixWorld);
	    var mat = new THREE.Matrix4();
	    mat.lookAt(position, new THREE.Vector3().addVectors(position, normal), mesh.up);
	    var orientation = new THREE.Euler();
	    orientation.setFromRotationMatrix(mat);
	    var size = new THREE.Vector3(1, 1, 1).multiplyScalar(10 + Math.random() * 10);

	    if (this.decalMaterial === undefined) {
	      var textureLoader = new THREE.TextureLoader();
	      var decalDiffuse = textureLoader.load('assets/textures/decal/decal-diffuse.png');
	      var decalNormal = textureLoader.load('assets/textures/decal/decal-normal.jpg');
	      this.decalMaterial = new THREE.MeshPhongMaterial({
	        specular: 0x444444,
	        map: decalDiffuse,
	        normalMap: decalNormal,
	        normalScale: new THREE.Vector2(1, 1),
	        shininess: 30,
	        transparent: true,
	        depthTest: true,
	        depthWrite: false,
	        polygonOffset: true,
	        polygonOffsetFactor: -4,
	        wireframe: false
	      });
	    }

	    var material = this.decalMaterial.clone();
	    material.color.setHex(Math.random() * 0xffffff);
	    var decal = new THREE.Mesh(new THREE.DecalGeometry(mesh, position, orientation, size), material);
	    decal.name = _t('Decal');
	    app.editor.execute(new AddObjectCommand(decal));
	  } // ------------------------------- 挖坑工具 -------------------------------------


	  handleDig() {
	    this.setState({
	      isDigging: true
	    });

	    if (this.digTool === undefined) {
	      this.digTool = new DigTool(app);
	      this.digTool.on(`end.EditorToolbar`, () => {
	        this.setState({
	          isDigging: false
	        });
	      });
	    }

	    this.digTool.start();
	  }

	}

	/**
	 * 标注工具
	 * @author tengge / https://github.com/tengge1
	 */

	class MarkTools extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      isAddPointMark: false,
	      isAddLineMark: false,
	      isAddPolygonMark: false
	    };
	    this.handleStartPointMarkTool = this.handleStartPointMarkTool.bind(this);
	    this.handleStartLineMarkTool = this.handleStartLineMarkTool.bind(this);
	    this.handleStartPolygonMarkTool = this.handleStartPolygonMarkTool.bind(this);
	  }

	  render() {
	    const {
	      isAddPointMark,
	      isAddLineMark,
	      isAddPolygonMark
	    } = this.state;
	    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'point-mark',
	      title: _t('Point Mark'),
	      selected: isAddPointMark,
	      onClick: this.handleStartPointMarkTool
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'line-mark',
	      title: _t('Line Mark'),
	      selected: isAddLineMark,
	      onClick: this.handleStartLineMarkTool
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'polygon-mark',
	      title: _t('Polygon Mark'),
	      selected: isAddPolygonMark,
	      onClick: this.handleStartPolygonMarkTool
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null));
	  }

	  handleStartPointMarkTool() {
	    if (this.pointMarkTool === undefined) {
	      this.pointMarkTool = new PointMarkTool();
	      this.pointMarkTool.on(`end`, () => {
	        app.editor.gpuPickNum--;
	        this.setState({
	          isAddPointMark: false
	        });
	      });
	    }

	    this.pointMarkTool.start();
	    app.editor.gpuPickNum++;
	    this.setState({
	      isAddPointMark: true
	    });
	  }

	  handleStartLineMarkTool() {}

	  handleStartPolygonMarkTool() {}

	}

	/**
	 * 距离测量工具
	 */

	class DistanceTool extends BaseTool {
	  constructor() {
	    super();
	    this.onMouseDown = this.onMouseDown.bind(this);
	    this.onGpuPick = this.onGpuPick.bind(this);
	    this.onDblClick = this.onDblClick.bind(this);
	  }

	  start() {
	    if (!this.init) {
	      this.init = true;
	      this.positions = [];
	      this.lines = [];
	      this.world = new THREE.Vector3();

	      app.require('line').then(() => {
	        app.on(`mousedown.${this.id}`, this.onMouseDown);
	        app.on(`gpuPick.${this.id}`, this.onGpuPick);
	        app.on(`dblclick.${this.id}`, this.onDblClick);
	      });
	    } else {
	      this.positions.length = 0;
	      app.on(`mousedown.${this.id}`, this.onMouseDown);
	      app.on(`gpuPick.${this.id}`, this.onGpuPick);
	      app.on(`dblclick.${this.id}`, this.onDblClick);
	    }

	    app.editor.gpuPickNum++;
	  }

	  stop() {
	    app.editor.gpuPickNum--;
	    app.on(`mousedown.${this.id}`, null);
	    app.on(`gpuPick.${this.id}`, null);
	    app.on(`dblclick.${this.id}`, null);
	    this.positions.length = 0;
	    delete this.line;
	  }

	  clear() {
	    while (this.lines.length) {
	      let line = this.lines[0];
	      app.editor.sceneHelpers.remove(line);
	    }

	    this.lines.length = 0;
	  }

	  onMouseDown() {
	    if (!this.line) {
	      let {
	        width,
	        height
	      } = app.editor.renderer.domElement;
	      let geometry1 = new THREE.LineGeometry();
	      let material = new THREE.LineMaterial({
	        color: 0xffff00,
	        linewidth: 4,
	        resolution: new THREE.Vector2(width, height)
	      });
	      this.line = new THREE.Line2(geometry1, material);
	      this.line.texts = [];
	      this.lines.push(this.line);
	      app.editor.sceneHelpers.add(this.line);
	    }

	    if (this.positions.length === 0) {
	      this.positions.push(this.world.x, this.world.y, this.world.z);
	      this.positions.push(this.world.x, this.world.y, this.world.z);
	    } else {
	      this.positions.push(this.world.x, this.world.y, this.world.z);
	    }

	    this.update();
	  }

	  onGpuPick(obj) {
	    if (!obj.point) {
	      return;
	    }

	    this.world.copy(obj.point);

	    if (this.positions.length === 0) {
	      return;
	    }

	    this.positions.splice(this.positions.length - 3, 3);
	    this.positions.push(this.world.x, this.world.y, this.world.z);
	    this.update();
	  }

	  update() {
	    let geometry = this.line.geometry;
	    geometry.setPositions(this.positions);
	    geometry.maxInstancedCount = this.positions.length / 3 - 1;
	    let dist = 0;

	    for (let i = 3; i < this.positions.length; i += 3) {
	      dist += Math.sqrt((this.positions[i] - this.positions[i - 3]) ** 2 + (this.positions[i + 1] - this.positions[i - 2]) ** 2 + (this.positions[i + 2] - this.positions[i - 1]) ** 2);
	    }

	    dist = dist.toFixed(2);
	    let domElement = app.editor.renderer.domElement;

	    if (this.positions.length === 6 && this.line.texts.length === 0) {
	      // 前两个点
	      let text1 = new UnscaledText(_t('Start Point'), {
	        domWidth: domElement.width,
	        domHeight: domElement.height
	      });
	      this.offsetText(text1);
	      text1.position.fromArray(this.positions);
	      let text2 = new UnscaledText(_t('{{dist}}m', {
	        dist: 0
	      }), {
	        domWidth: domElement.width,
	        domHeight: domElement.height
	      });
	      this.offsetText(text2);
	      text2.position.fromArray(this.positions, 3);
	      this.line.texts.push(text1, text2);
	      app.editor.sceneHelpers.add(text1);
	      app.editor.sceneHelpers.add(text2);
	    } else if (this.line.texts.length < this.positions.length / 3) {
	      // 增加点了
	      let text1 = new UnscaledText(_t('{{dist}}m', {
	        dist
	      }), {
	        domWidth: domElement.width,
	        domHeight: domElement.height
	      });
	      this.offsetText(text1);
	      text1.position.fromArray(this.positions, this.positions.length - 3);
	      this.line.texts.push(text1);
	      app.editor.sceneHelpers.add(text1);
	    } else {
	      // 更新最后一个点坐标
	      let text1 = this.line.texts[this.line.texts.length - 1];
	      this.offsetText(text1);
	      text1.position.fromArray(this.positions, this.positions.length - 3);
	      text1.setText(_t('{{dist}}m', {
	        dist
	      }));
	    }
	  }

	  offsetText(text) {
	    // 避免文字被遮挡
	    text.material.depthTest = false; // text.material.polygonOffset = true;
	    // text.material.polygonOffsetFactor = -10;
	    // text.material.polygonOffsetUnits = -10;
	  }

	  onDblClick() {
	    this.stop();
	    this.call(`end`, this);
	  }

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * Port from https://github.com/mapbox/earcut (v2.1.2)
	 */
	var Earcut = {
	  triangulate: function (data, holeIndices, dim) {
	    dim = dim || 2;
	    var hasHoles = holeIndices && holeIndices.length,
	        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
	        outerNode = linkedList(data, 0, outerLen, dim, true),
	        triangles = [];
	    if (!outerNode) return triangles;
	    var minX, minY, maxX, maxY, x, y, invSize;
	    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

	    if (data.length > 80 * dim) {
	      minX = maxX = data[0];
	      minY = maxY = data[1];

	      for (var i = dim; i < outerLen; i += dim) {
	        x = data[i];
	        y = data[i + 1];
	        if (x < minX) minX = x;
	        if (y < minY) minY = y;
	        if (x > maxX) maxX = x;
	        if (y > maxY) maxY = y;
	      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


	      invSize = Math.max(maxX - minX, maxY - minY);
	      invSize = invSize !== 0 ? 1 / invSize : 0;
	    }

	    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
	    return triangles;
	  }
	}; // create a circular doubly linked list from polygon points in the specified winding order

	function linkedList(data, start, end, dim, clockwise) {
	  var i, last;

	  if (clockwise === signedArea(data, start, end, dim) > 0) {
	    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
	  } else {
	    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
	  }

	  if (last && equals(last, last.next)) {
	    removeNode(last);
	    last = last.next;
	  }

	  return last;
	} // eliminate colinear or duplicate points


	function filterPoints(start, end) {
	  if (!start) return start;
	  if (!end) end = start;
	  var p = start,
	      again;

	  do {
	    again = false;

	    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
	      removeNode(p);
	      p = end = p.prev;
	      if (p === p.next) break;
	      again = true;
	    } else {
	      p = p.next;
	    }
	  } while (again || p !== end);

	  return end;
	} // main ear slicing loop which triangulates a polygon (given as a linked list)


	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
	  if (!ear) return; // interlink polygon nodes in z-order

	  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
	  var stop = ear,
	      prev,
	      next; // iterate through ears, slicing them one by one

	  while (ear.prev !== ear.next) {
	    prev = ear.prev;
	    next = ear.next;

	    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
	      // cut off the triangle
	      triangles.push(prev.i / dim);
	      triangles.push(ear.i / dim);
	      triangles.push(next.i / dim);
	      removeNode(ear); // skipping the next vertice leads to less sliver triangles

	      ear = next.next;
	      stop = next.next;
	      continue;
	    }

	    ear = next; // if we looped through the whole remaining polygon and can't find any more ears

	    if (ear === stop) {
	      // try filtering points and slicing again
	      if (!pass) {
	        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
	      } else if (pass === 1) {
	        ear = cureLocalIntersections(ear, triangles, dim);
	        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
	      } else if (pass === 2) {
	        splitEarcut(ear, triangles, dim, minX, minY, invSize);
	      }

	      break;
	    }
	  }
	} // check whether a polygon node forms a valid ear with adjacent nodes


	function isEar(ear) {
	  var a = ear.prev,
	      b = ear,
	      c = ear.next;
	  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
	  // now make sure we don't have other points inside the potential ear

	  var p = ear.next.next;

	  while (p !== ear.prev) {
	    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
	      return false;
	    }

	    p = p.next;
	  }

	  return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
	  var a = ear.prev,
	      b = ear,
	      c = ear.next;
	  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
	  // triangle bbox; min & max are calculated like this for speed

	  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
	      minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
	      maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
	      maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

	  var minZ = zOrder(minTX, minTY, minX, minY, invSize),
	      maxZ = zOrder(maxTX, maxTY, minX, minY, invSize); // first look for points inside the triangle in increasing z-order

	  var p = ear.nextZ;

	  while (p && p.z <= maxZ) {
	    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	    p = p.nextZ;
	  } // then look for points in decreasing z-order


	  p = ear.prevZ;

	  while (p && p.z >= minZ) {
	    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	    p = p.prevZ;
	  }

	  return true;
	} // go through all polygon nodes and cure small local self-intersections


	function cureLocalIntersections(start, triangles, dim) {
	  var p = start;

	  do {
	    var a = p.prev,
	        b = p.next.next;

	    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
	      triangles.push(a.i / dim);
	      triangles.push(p.i / dim);
	      triangles.push(b.i / dim); // remove two nodes involved

	      removeNode(p);
	      removeNode(p.next);
	      p = start = b;
	    }

	    p = p.next;
	  } while (p !== start);

	  return p;
	} // try splitting polygon into two and triangulate them independently


	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
	  // look for a valid diagonal that divides the polygon into two
	  var a = start;

	  do {
	    var b = a.next.next;

	    while (b !== a.prev) {
	      if (a.i !== b.i && isValidDiagonal(a, b)) {
	        // split the polygon in two by the diagonal
	        var c = splitPolygon(a, b); // filter colinear points around the cuts

	        a = filterPoints(a, a.next);
	        c = filterPoints(c, c.next); // run earcut on each half

	        earcutLinked(a, triangles, dim, minX, minY, invSize);
	        earcutLinked(c, triangles, dim, minX, minY, invSize);
	        return;
	      }

	      b = b.next;
	    }

	    a = a.next;
	  } while (a !== start);
	} // link every hole into the outer loop, producing a single-ring polygon without holes


	function eliminateHoles(data, holeIndices, outerNode, dim) {
	  var queue = [],
	      i,
	      len,
	      start,
	      end,
	      list;

	  for (i = 0, len = holeIndices.length; i < len; i++) {
	    start = holeIndices[i] * dim;
	    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	    list = linkedList(data, start, end, dim, false);
	    if (list === list.next) list.steiner = true;
	    queue.push(getLeftmost(list));
	  }

	  queue.sort(compareX); // process holes from left to right

	  for (i = 0; i < queue.length; i++) {
	    eliminateHole(queue[i], outerNode);
	    outerNode = filterPoints(outerNode, outerNode.next);
	  }

	  return outerNode;
	}

	function compareX(a, b) {
	  return a.x - b.x;
	} // find a bridge between vertices that connects hole with an outer ring and and link it


	function eliminateHole(hole, outerNode) {
	  outerNode = findHoleBridge(hole, outerNode);

	  if (outerNode) {
	    var b = splitPolygon(outerNode, hole);
	    filterPoints(b, b.next);
	  }
	} // David Eberly's algorithm for finding a bridge between hole and outer polygon


	function findHoleBridge(hole, outerNode) {
	  var p = outerNode,
	      hx = hole.x,
	      hy = hole.y,
	      qx = -Infinity,
	      m; // find a segment intersected by a ray from the hole's leftmost point to the left;
	  // segment's endpoint with lesser x will be potential connection point

	  do {
	    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
	      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

	      if (x <= hx && x > qx) {
	        qx = x;

	        if (x === hx) {
	          if (hy === p.y) return p;
	          if (hy === p.next.y) return p.next;
	        }

	        m = p.x < p.next.x ? p : p.next;
	      }
	    }

	    p = p.next;
	  } while (p !== outerNode);

	  if (!m) return null;
	  if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint
	  // look for points inside the triangle of hole point, segment intersection and endpoint;
	  // if there are no points found, we have a valid connection;
	  // otherwise choose the point of the minimum angle with the ray as connection point

	  var stop = m,
	      mx = m.x,
	      my = m.y,
	      tanMin = Infinity,
	      tan;
	  p = m.next;

	  while (p !== stop) {
	    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
	      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

	      if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
	        m = p;
	        tanMin = tan;
	      }
	    }

	    p = p.next;
	  }

	  return m;
	} // interlink polygon nodes in z-order


	function indexCurve(start, minX, minY, invSize) {
	  var p = start;

	  do {
	    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
	    p.prevZ = p.prev;
	    p.nextZ = p.next;
	    p = p.next;
	  } while (p !== start);

	  p.prevZ.nextZ = null;
	  p.prevZ = null;
	  sortLinked(p);
	} // Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


	function sortLinked(list) {
	  var i,
	      p,
	      q,
	      e,
	      tail,
	      numMerges,
	      pSize,
	      qSize,
	      inSize = 1;

	  do {
	    p = list;
	    list = null;
	    tail = null;
	    numMerges = 0;

	    while (p) {
	      numMerges++;
	      q = p;
	      pSize = 0;

	      for (i = 0; i < inSize; i++) {
	        pSize++;
	        q = q.nextZ;
	        if (!q) break;
	      }

	      qSize = inSize;

	      while (pSize > 0 || qSize > 0 && q) {
	        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
	          e = p;
	          p = p.nextZ;
	          pSize--;
	        } else {
	          e = q;
	          q = q.nextZ;
	          qSize--;
	        }

	        if (tail) tail.nextZ = e;else list = e;
	        e.prevZ = tail;
	        tail = e;
	      }

	      p = q;
	    }

	    tail.nextZ = null;
	    inSize *= 2;
	  } while (numMerges > 1);

	  return list;
	} // z-order of a point given coords and inverse of the longer side of data bbox


	function zOrder(x, y, minX, minY, invSize) {
	  // coords are transformed into non-negative 15-bit integer range
	  x = 32767 * (x - minX) * invSize;
	  y = 32767 * (y - minY) * invSize;
	  x = (x | x << 8) & 0x00FF00FF;
	  x = (x | x << 4) & 0x0F0F0F0F;
	  x = (x | x << 2) & 0x33333333;
	  x = (x | x << 1) & 0x55555555;
	  y = (y | y << 8) & 0x00FF00FF;
	  y = (y | y << 4) & 0x0F0F0F0F;
	  y = (y | y << 2) & 0x33333333;
	  y = (y | y << 1) & 0x55555555;
	  return x | y << 1;
	} // find the leftmost node of a polygon ring


	function getLeftmost(start) {
	  var p = start,
	      leftmost = start;

	  do {
	    if (p.x < leftmost.x) leftmost = p;
	    p = p.next;
	  } while (p !== start);

	  return leftmost;
	} // check if a point lies within a convex triangle


	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


	function isValidDiagonal(a, b) {
	  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
	} // signed area of a triangle


	function area(p, q, r) {
	  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	} // check if two points are equal


	function equals(p1, p2) {
	  return p1.x === p2.x && p1.y === p2.y;
	} // check if two segments intersect


	function intersects(p1, q1, p2, q2) {
	  if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;
	  return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
	} // check if a polygon diagonal intersects any polygon segments


	function intersectsPolygon(a, b) {
	  var p = a;

	  do {
	    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
	      return true;
	    }

	    p = p.next;
	  } while (p !== a);

	  return false;
	} // check if a polygon diagonal is locally inside the polygon


	function locallyInside(a, b) {
	  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	} // check if the middle point of a polygon diagonal is inside the polygon


	function middleInside(a, b) {
	  var p = a,
	      inside = false,
	      px = (a.x + b.x) / 2,
	      py = (a.y + b.y) / 2;

	  do {
	    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
	      inside = !inside;
	    }

	    p = p.next;
	  } while (p !== a);

	  return inside;
	} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring


	function splitPolygon(a, b) {
	  var a2 = new Node(a.i, a.x, a.y),
	      b2 = new Node(b.i, b.x, b.y),
	      an = a.next,
	      bp = b.prev;
	  a.next = b;
	  b.prev = a;
	  a2.next = an;
	  an.prev = a2;
	  b2.next = a2;
	  a2.prev = b2;
	  bp.next = b2;
	  b2.prev = bp;
	  return b2;
	} // create a node and optionally link it with previous one (in a circular doubly linked list)


	function insertNode(i, x, y, last) {
	  var p = new Node(i, x, y);

	  if (!last) {
	    p.prev = p;
	    p.next = p;
	  } else {
	    p.next = last.next;
	    p.prev = last;
	    last.next.prev = p;
	    last.next = p;
	  }

	  return p;
	}

	function removeNode(p) {
	  p.next.prev = p.prev;
	  p.prev.next = p.next;
	  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {
	  // vertice index in coordinates array
	  this.i = i; // vertex coordinates

	  this.x = x;
	  this.y = y; // previous and next vertice nodes in a polygon ring

	  this.prev = null;
	  this.next = null; // z-order curve value

	  this.z = null; // previous and next nodes in z-order

	  this.prevZ = null;
	  this.nextZ = null; // indicates whether this is a steiner point

	  this.steiner = false;
	}

	function signedArea(data, start, end, dim) {
	  var sum = 0;

	  for (var i = start, j = end - dim; i < end; i += dim) {
	    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
	    j = i;
	  }

	  return sum;
	}

	/**
	 * 面积测量工具
	 */

	class AreaTool extends BaseTool {
	  constructor() {
	    super();
	    this.onMouseDown = this.onMouseDown.bind(this);
	    this.onGpuPick = this.onGpuPick.bind(this);
	    this.onDblClick = this.onDblClick.bind(this);
	  }

	  start() {
	    if (!this.init) {
	      this.init = true;
	      this.positions = [];
	      this.polygons = [];
	      this.world = new THREE.Vector3();
	    }

	    app.editor.gpuPickNum++;
	    this.positions.length = 0;
	    app.on(`mousedown.${this.id}`, this.onMouseDown);
	    app.on(`gpuPick.${this.id}`, this.onGpuPick);
	    app.on(`dblclick.${this.id}`, this.onDblClick);
	  }

	  stop() {
	    app.on(`mousedown.${this.id}`, null);
	    app.on(`gpuPick.${this.id}`, null);
	    app.on(`dblclick.${this.id}`, null);
	    app.editor.gpuPickNum--;
	    this.positions.length = 0;
	    delete this.polygon;
	  }

	  clear() {
	    while (this.polygons.length) {
	      let polygon = this.polygons[0];
	      app.editor.sceneHelpers.remove(polygon);
	    }

	    this.polygons.length = 0;
	  }

	  onMouseDown() {
	    if (!this.polygon) {
	      let geometry = new THREE.BufferGeometry();
	      let material = new THREE.MeshBasicMaterial({
	        color: 0xffff00
	      });
	      this.polygon = new THREE.Mesh(geometry, material);
	      this.polygon.texts = [];
	      this.polygons.push(this.polygon);
	      app.editor.sceneHelpers.add(this.polygon);
	    }

	    if (this.positions.length === 0) {
	      this.positions.push(this.world.x, this.world.y, this.world.z);
	      this.positions.push(this.world.x, this.world.y, this.world.z);
	    } else {
	      this.positions.push(this.world.x, this.world.y, this.world.z);
	    }

	    this.update();
	  }

	  onGpuPick(obj) {
	    if (!obj.point) {
	      return;
	    }

	    this.world.copy(obj.point);

	    if (this.positions.length === 0) {
	      return;
	    }

	    this.positions.splice(this.positions.length - 3, 3);
	    this.positions.push(this.world.x, this.world.y, this.world.z);
	    this.update();
	  }

	  update() {
	    let vertices = Earcut.triangulate(this.positions, null, 3);
	    this.polygon.geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
	    let dist = 0;

	    for (let i = 3; i < this.positions.length; i += 3) {
	      dist += Math.sqrt((this.positions[i] - this.positions[i - 3]) ** 2 + (this.positions[i + 1] - this.positions[i - 2]) ** 2 + (this.positions[i + 2] - this.positions[i - 1]) ** 2);
	    }

	    dist = dist.toFixed(2);
	    let domElement = app.editor.renderer.domElement;

	    if (this.positions.length === 6 && this.polygon.texts.length === 0) {
	      // 前两个点
	      let text1 = new UnscaledText(_t('Start Point'), {
	        domWidth: domElement.width,
	        domHeight: domElement.height
	      });
	      text1.position.fromArray(this.positions);
	      let text2 = new UnscaledText(_t('{{dist}}m', {
	        dist: 0
	      }), {
	        domWidth: domElement.width,
	        domHeight: domElement.height
	      });
	      text2.position.fromArray(this.positions, 3);
	      this.polygon.texts.push(text1, text2);
	      app.editor.sceneHelpers.add(text1);
	      app.editor.sceneHelpers.add(text2);
	    } else if (this.polygon.texts.length < this.positions.length / 3) {
	      // 增加点了
	      let text1 = new UnscaledText(_t('{{dist}}m', {
	        dist
	      }), {
	        domWidth: domElement.width,
	        domHeight: domElement.height
	      });
	      text1.position.fromArray(this.positions, this.positions.length - 3);
	      this.polygon.texts.push(text1);
	      app.editor.sceneHelpers.add(text1);
	    } else {
	      // 更新最后一个点坐标
	      let text1 = this.polygon.texts[this.polygon.texts.length - 1];
	      text1.position.fromArray(this.positions, this.positions.length - 3);
	      text1.setText(_t('{{dist}}m', {
	        dist
	      }));
	    }
	  }

	  onDblClick() {
	    this.stop();
	    this.call(`end`, this);
	  }

	}

	/**
	 * 测量工具
	 * @author tengge / https://github.com/tengge1
	 */

	class MeasureTools extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      distanceToolEnabled: false,
	      areaToolEnabled: false,
	      angleToolEnabled: false
	    };
	    this.handleMeasureDistance = this.handleMeasureDistance.bind(this);
	    this.handleEndMeasureDistance = this.handleEndMeasureDistance.bind(this);
	    this.handleMeasureArea = this.handleMeasureArea.bind(this);
	    this.handleEndMeasureArea = this.handleEndMeasureArea.bind(this);
	    this.handleMeasureAngle = this.handleMeasureAngle.bind(this);
	    this.handleClearTools = this.handleClearTools.bind(this);
	  }

	  render() {
	    const {
	      distanceToolEnabled,
	      areaToolEnabled,
	      angleToolEnabled
	    } = this.state;
	    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'distance',
	      title: _t('Measure Distance'),
	      selected: distanceToolEnabled,
	      onClick: this.handleMeasureDistance
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'area',
	      title: _t('Measure Area'),
	      selected: areaToolEnabled,
	      onClick: this.handleMeasureArea
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'angle',
	      title: _t('Measure Angle'),
	      selected: angleToolEnabled,
	      onClick: this.handleMeasureAngle
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'delete',
	      title: _t('Clear Tools'),
	      onClick: this.handleClearTools
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null));
	  } // ----------------------------- 距离测量 ------------------------------------


	  handleMeasureDistance() {
	    if (this.distanceTool === undefined) {
	      this.distanceTool = new DistanceTool();
	      this.distanceTool.on(`end.${this.id}`, this.handleEndMeasureDistance);
	    }

	    this.distanceTool.start();
	    this.setState({
	      distanceToolEnabled: true
	    });
	    app.toast(_t('Start distance measurement.'));
	  }

	  handleEndMeasureDistance() {
	    this.setState({
	      distanceToolEnabled: false
	    });
	  } // --------------------------- 面积测量 -------------------------------------


	  handleMeasureArea() {
	    if (this.areaTool === undefined) {
	      this.areaTool = new AreaTool();
	      this.areaTool.on(`end.${this.id}`, this.handleEndMeasureArea);
	    }

	    this.areaTool.start();
	    this.setState({
	      areaToolEnabled: true
	    });
	    app.toast(_t('Start area measurement.'));
	  }

	  handleEndMeasureArea() {
	    this.setState({
	      areaToolEnabled: false
	    });
	  } // --------------------------- 角度测量 ---------------------------------------


	  handleMeasureAngle() {} // --------------------------- 清空工具 ---------------------------------------


	  handleClearTools() {}

	}

	/**
	 * 编辑器工具栏
	 * @author tengge / https://github.com/tengge1
	 */

	class EditorToolbar extends React.Component {
	  constructor(props) {
	    super(props);
	    this.toolbars = {
	      general: _t('General Tools'),
	      draw: _t('Draw Tools'),
	      edit: _t('Edit Tools'),
	      // terrain: _t('Terrain Tools'),
	      mark: _t('Mark Tools'),
	      measure: _t('Measure Tools')
	    };
	    this.state = {
	      toolbar: 'general'
	    };
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      toolbar
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Toolbar, {
	      className: 'EditorToolbar',
	      direction: 'horizontal'
	    }, /*#__PURE__*/React.createElement(Select, {
	      options: this.toolbars,
	      name: 'toolbar',
	      value: toolbar,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null), toolbar === 'general' && /*#__PURE__*/React.createElement(GeneralTools, null), toolbar === 'edit' && /*#__PURE__*/React.createElement(EditTools, null), toolbar === 'draw' && /*#__PURE__*/React.createElement(DrawTools, null), toolbar === 'mark' && /*#__PURE__*/React.createElement(MarkTools, null), toolbar === 'measure' && /*#__PURE__*/React.createElement(MeasureTools, null));
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	}

	/**
	 * 脚本编辑器
	 * @author mrdoob / http://mrdoob.com/
	 * @author tengge / https://github.com/tengge1
	 * @param {*} container 容器
	 */
	function ScriptEditor(container = document.body) {
	  this.delay = null; // 代码校验延迟函数

	  this.delayTime = 1000; // 代码校验间隔时间（毫秒）

	  this.mode = 'javascript'; // 模式：json, vertexShader, fragmentShader, javascript

	  this.source = ''; // 代码

	  this.errorLines = []; // 代码错误行数

	  this.widgets = []; // Code Mirror

	  var codemirror = CodeMirror(container, {
	    value: '',
	    lineNumbers: true,
	    matchBrackets: true,
	    indentWithTabs: true,
	    tabSize: 4,
	    indentUnit: 4,
	    hintOptions: {
	      completeSingle: false
	    }
	  });
	  codemirror.setOption('theme', 'monokai');
	  codemirror.on('change', this.onCodeMirrorChange.bind(this)); // 防止回退键删除物体

	  var wrapper = codemirror.getWrapperElement();
	  wrapper.addEventListener('keydown', event => {
	    event.stopPropagation();
	  }); // tern js 自动完成

	  var server = new CodeMirror.TernServer({
	    caseInsensitive: true,
	    plugins: {
	      threejs: null
	    }
	  }); // 快捷键

	  codemirror.setOption('extraKeys', {
	    'Ctrl-Space': cm => {
	      server.complete(cm);
	    },
	    'Ctrl-I': cm => {
	      server.showType(cm);
	    },
	    'Ctrl-O': cm => {
	      server.showDocs(cm);
	    },
	    'Alt-.': cm => {
	      server.jumpToDef(cm);
	    },
	    'Alt-,': cm => {
	      server.jumpBack(cm);
	    },
	    'Ctrl-Q': cm => {
	      server.rename(cm);
	    },
	    'Ctrl-.': cm => {
	      server.selectName(cm);
	    }
	  });
	  codemirror.on('cursorActivity', cm => {
	    if (this.mode !== 'javascript') {
	      return;
	    }

	    try {
	      server.updateArgHints(cm);
	    } catch (e) {
	      console.log(e);
	    }
	  });
	  codemirror.on('keypress', (cm, kb) => {
	    if (this.mode !== 'javascript') {
	      return;
	    }

	    var typed = String.fromCharCode(kb.which || kb.keyCode);

	    if (/[\w\.]/.exec(typed)) {
	      // eslint-disable-line
	      server.complete(cm);
	    }
	  });
	  this.codemirror = codemirror;
	}
	/**
	 * 设置编辑器脚本代码
	 * @param {*} source 源码
	 * @param {*} mode 模式 javascript, vertexShader, fragmentShader, json
	 * @param {*} cursorPosition 光标位置
	 * @param {*} scrollInfo 滚动信息
	 */


	ScriptEditor.prototype.setValue = function (source = '', mode = 'javascript', cursorPosition = {
	  line: 0,
	  ch: 0
	}, scrollInfo = {
	  left: 0,
	  top: 0
	}) {
	  this.source = source;
	  this.mode = mode;
	  var codemirror = this.codemirror;
	  var history = codemirror.getHistory();
	  codemirror.setValue(source);

	  if (mode === 'json') {
	    codemirror.setOption('mode', {
	      name: 'javascript',
	      json: true
	    });
	  } else if (mode === 'vertexShader' || mode === 'fragmentShader') {
	    codemirror.setOption('mode', 'glsl');
	  } else {
	    codemirror.setOption('mode', mode);
	  }

	  codemirror.focus();
	  codemirror.setCursor(cursorPosition);
	  codemirror.scrollTo(scrollInfo.left, scrollInfo.top);
	  codemirror.setHistory(history);
	};
	/**
	 * 获取编辑器脚本代码
	 * @returns {String} 脚本
	 */


	ScriptEditor.prototype.getValue = function () {
	  return this.codemirror.getValue();
	};
	/**
	 * 清空编辑器
	 */


	ScriptEditor.prototype.clear = function () {
	  this.setValue();
	}; // ---------------------- 内部函数 -----------------------------------------

	/**
	 * 代码修改事件
	 */


	ScriptEditor.prototype.onCodeMirrorChange = function () {
	  var codemirror = this.codemirror;

	  if (codemirror.state.focused === false) {
	    return;
	  }

	  if (this.delay) {
	    clearTimeout(this.delay);
	  }

	  this.delay = setTimeout(() => {
	    var code = codemirror.getValue();
	    this.validate(code);
	  }, this.delayTime);
	};
	/**
	 * 校验编辑器中代码正确性
	 * @param {*} string 脚本
	 * @returns {Boolean} 是否正确
	 */


	ScriptEditor.prototype.validate = function (string) {
	  var codemirror = this.codemirror;
	  var mode = this.mode;
	  var errorLines = this.errorLines;
	  var widgets = this.widgets;
	  var errors = [];
	  return codemirror.operation(() => {
	    while (errorLines.length > 0) {
	      codemirror.removeLineClass(errorLines.shift(), 'background', 'errorLine');
	    }

	    while (widgets.length > 0) {
	      codemirror.removeLineWidget(widgets.shift());
	    }

	    var i, error;

	    switch (mode) {
	      case 'javascript':
	        try {
	          var syntax = esprima.parse(string, {
	            tolerant: true
	          });
	          errors = syntax.errors;
	        } catch (error) {
	          errors.push({
	            lineNumber: error.lineNumber - 1,
	            message: error.message
	          });
	        }

	        for (i = 0; i < errors.length; i++) {
	          error = errors[i];
	          error.message = error.message.replace(/Line [0-9]+: /, '');
	        }

	        break;

	      case 'json':
	        jsonlint.parseError = (message, info) => {
	          message = message.split('\n')[3];
	          errors.push({
	            lineNumber: info.loc.first_line - 1,
	            message: message
	          });
	        };

	        try {
	          jsonlint.parse(string);
	        } catch (error) {// ignore failed error recovery
	        }

	        break;

	      case 'vertexShader':
	      case 'fragmentShader':
	        try {
	          var shaderType = mode === 'vertexShader' ? glslprep.Shader.VERTEX : glslprep.Shader.FRAGMENT;
	          glslprep.parseGlsl(string, shaderType);
	        } catch (error) {
	          if (error instanceof glslprep.SyntaxError) {
	            errors.push({
	              lineNumber: error.line,
	              message: "Syntax Error: " + error.message
	            });
	          } else {
	            console.error(error.stack || error);
	          }
	        }

	    }

	    for (i = 0; i < errors.length; i++) {
	      error = errors[i];
	      var message = document.createElement('div');
	      message.className = 'esprima-error';
	      message.textContent = error.message;
	      var lineNumber = Math.max(error.lineNumber, 0);
	      errorLines.push(lineNumber);
	      codemirror.addLineClass(lineNumber, 'background', 'errorLine');
	      var widget = codemirror.addLineWidget(lineNumber, message);
	      widgets.push(widget);
	    }

	    return errors.length === 0;
	  });
	};

	/**
	 * 脚本面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ScriptEditorPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      show: false,
	      uuid: null,
	      name: '',
	      type: 'javascript',
	      source: ''
	    };
	    this.callback = null;
	    this.ref = React.createRef();
	    this.handleEditScript = this.handleEditScript.bind(this);
	    this.handleSave = this.handleSave.bind(this);
	  }

	  render() {
	    const {
	      show,
	      name,
	      type
	    } = this.state;
	    let title = name;

	    switch (type) {
	      case 'javascript':
	        title = name + '.js';
	        break;

	      case 'vertexShader':
	      case 'fragmentShader':
	        title = name + '.glsl';
	        break;

	      case 'json':
	        title = name + '.json';
	        break;
	    }

	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('ScriptEditorPanel', !show && 'hidden')
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'header'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'title'
	    }, title), /*#__PURE__*/React.createElement(Icon, {
	      icon: 'close',
	      onClick: this.handleSave
	    })), /*#__PURE__*/React.createElement("div", {
	      className: 'content',
	      ref: this.ref
	    }));
	  }

	  componentDidMount() {
	    app.require(['codemirror', 'codemirror-addon', 'esprima', 'jsonlint', 'glslprep', 'acorn', 'ternjs']).then(() => {
	      app.scriptEditor = new ScriptEditor(this.ref.current);
	    });

	    app.on(`editScript.ScriptPanel`, this.handleEditScript);
	  }

	  handleEditScript(uuid, name, type, source, callback) {
	    this.callback = callback;
	    this.setState({
	      show: true,
	      uuid,
	      name,
	      type,
	      source
	    }, () => {
	      app.scriptEditor.setValue(source, type);
	    });
	  }

	  handleSave() {
	    const {
	      uuid,
	      name,
	      type
	    } = this.state;
	    const source = app.scriptEditor.getValue();
	    this.callback && this.callback(uuid, name, type, source);
	    this.callback = null;
	    this.setState({
	      show: false,
	      uuid: null,
	      name: '',
	      type: 'javascript',
	      source: ''
	    });
	  }

	}

	/**
	 * 将SVG组件包裹起来
	 */

	class Wrapper extends React.Component {
	  render() {
	    const {
	      children,
	      ...others
	    } = this.props; // eslint-disable-next-line

	    return /*#__PURE__*/React.createElement(React.Fragment, others, children);
	  }

	}

	Wrapper.propTypes = {
	  children: propTypes.node
	};
	Wrapper.defaultProps = {
	  children: null
	};

	/**
	 * VisualDOM
	 * @author tengge / https://github.com/tengge1
	 */

	class VisualDOM extends React.Component {
	  constructor(props) {
	    super(props);
	    this.defMap = {};
	    this.componentMap = {};
	    this.state = {
	      defs: [],
	      components: []
	    };
	  }

	  render() {
	    const {
	      defs,
	      components
	    } = this.state;
	    return /*#__PURE__*/React.createElement("svg", {
	      className: 'VisualDOM'
	    }, /*#__PURE__*/React.createElement("defs", null, defs), components.map((n, i) => {
	      return /*#__PURE__*/React.createElement(Wrapper, {
	        key: i
	      }, n);
	    }));
	  }

	  getDef(id) {
	    return this.defMap[id] || null;
	  }

	  get(id) {
	    return this.componentMap[id] || null;
	  }

	  addDef(def, id = null) {
	    if (id === null) {
	      id = THREE.Math.generateUUID();
	    }

	    if (this.defMap[id]) {
	      console.warn(`VisualDOM: def ${id} is already added.`);
	      return;
	    }

	    this.defMap[id] = def;
	    let defs = this.state.defs;
	    defs.push(def);
	    this.setState({
	      defs
	    });
	    return id;
	  }

	  removeDef(obj) {
	    let defMap = this.defMap;
	    let defs = this.state.defs;

	    if (obj instanceof React.Component) {
	      for (let i in defMap) {
	        if (defMap[i] === obj) {
	          delete defMap[i];
	          break;
	        }
	      }
	    } else {
	      delete defMap[obj];
	    }

	    let index = defs.indexOf(obj);

	    if (index === -1) {
	      return false;
	    }

	    defs.splice(index, 1);
	    this.setState({
	      defs
	    });
	    return true;
	  }

	  add(component, id = null) {
	    if (id === null) {
	      id = THREE.Math.generateUUID();
	    }

	    if (this.componentMap[id]) {
	      console.warn(`VisualDOM: component ${id} is already added.`);
	      return;
	    }

	    this.componentMap[id] = component;
	    let components = this.state.components;
	    components.push(component);
	    this.setState({
	      components
	    });
	    return id;
	  }

	  remove(obj) {
	    let componentMap = this.componentMap;
	    let components = this.state.components;

	    if (obj instanceof React.Component) {
	      for (let i in componentMap) {
	        if (componentMap[i] === obj) {
	          delete componentMap[i];
	          break;
	        }
	      }
	    } else {
	      delete componentMap[obj];
	    }

	    let index = components.indexOf(obj);

	    if (index === -1) {
	      return false;
	    }

	    components.splice(index, 1);
	    this.setState({
	      components
	    });
	    return true;
	  }

	}

	/**
	 * 视口
	 * @author tengge / https://github.com/tengge1
	 */

	class Viewport extends React.Component {
	  constructor(props) {
	    super(props);
	    this.viewportRef = React.createRef();
	    this.editorRef = React.createRef();
	    this.svgRef = React.createRef();
	    this.playerRef = React.createRef();
	  }

	  render() {
	    return /*#__PURE__*/React.createElement("div", {
	      className: 'Viewport',
	      ref: this.viewportRef
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'editor',
	      ref: this.editorRef,
	      tabIndex: 0
	    }), /*#__PURE__*/React.createElement(VisualDOM, {
	      className: 'svg',
	      ref: this.svgRef
	    }), /*#__PURE__*/React.createElement(ScriptEditorPanel, null), /*#__PURE__*/React.createElement("div", {
	      className: 'player',
	      ref: this.playerRef
	    }));
	  }

	  componentDidMount() {
	    app.viewportRef = this.viewportRef.current;
	    app.editorRef = this.editorRef.current;
	    app.svgRef = this.svgRef.current;
	    app.visual = this.svgRef.current;
	    app.playerRef = this.playerRef.current; // 性能控件

	    app.stats = new Stats();
	    let showStats = app.storage.showStats;

	    if (showStats === undefined) {
	      showStats = true;
	      app.storage.showStats = true;
	    }

	    Object.assign(app.stats.dom.style, {
	      position: 'absolute',
	      left: '8px',
	      top: '8px',
	      zIndex: 'initial',
	      display: showStats ? 'block' : 'none'
	    });
	    app.viewportRef.appendChild(app.stats.dom);
	    app.viewport = this.editorRef.current;
	    app.player = new Player(this.playerRef.current, {
	      server: app.options.server,
	      enableThrowBall: false,
	      showStats: false
	    });
	  }

	}

	/**
	 * 时间轴面板
	 * @author tengge / https://github.com/tengge1
	 */

	class TimelinePanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      animations: [],
	      selectedLayer: null,
	      selected: null
	    };
	    this.handleAddLayer = this.handleAddLayer.bind(this);
	    this.commitAddLayer = this.commitAddLayer.bind(this);
	    this.handleEditLayer = this.handleEditLayer.bind(this);
	    this.commitEditLayer = this.commitEditLayer.bind(this);
	    this.handleDeleteLayer = this.handleDeleteLayer.bind(this);
	    this.commitDeleteLayer = this.commitDeleteLayer.bind(this);
	    this.handleSelectedLayerChange = this.handleSelectedLayerChange.bind(this);
	    this.handleAddAnimation = this.handleAddAnimation.bind(this);
	    this.handleDropAnimation = this.handleDropAnimation.bind(this);
	    this.handleClickAnimation = this.handleClickAnimation.bind(this);
	    this.updateUI = this.updateUI.bind(this);
	  }

	  render() {
	    const {
	      animations,
	      selectedLayer,
	      selected
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Timeline, {
	      className: 'TimelinePanel',
	      animations: animations,
	      selectedLayer: selectedLayer,
	      selected: selected,
	      onAddLayer: this.handleAddLayer,
	      onEditLayer: this.handleEditLayer,
	      onDeleteLayer: this.handleDeleteLayer,
	      onSelectedLayerChange: this.handleSelectedLayerChange,
	      onAddAnimation: this.handleAddAnimation,
	      onDropAnimation: this.handleDropAnimation,
	      onClickAnimation: this.handleClickAnimation
	    });
	  }

	  componentDidMount() {
	    app.on(`appStarted.TimelinePanel`, this.updateUI);
	    app.on(`animationChanged.TimelinePanel`, this.updateUI);
	  }

	  updateUI() {
	    this.setState({
	      animations: app.editor.animations
	    });
	  } // ----------------------- 动画层管理 ------------------------------


	  handleAddLayer() {
	    app.prompt({
	      title: _t('Input Layer Name'),
	      content: _t('Layer Name'),
	      value: _t('New Layer'),
	      onOK: this.commitAddLayer
	    });
	  }

	  commitAddLayer(layerName) {
	    let animations = app.editor.animations;
	    const layer = Math.max.apply(Math, animations.map(n => n.layer)) + 1;
	    animations.push({
	      id: null,
	      layer,
	      layerName: layerName,
	      uuid: THREE.Math.generateUUID(),
	      animations: []
	    });
	    app.call(`animationChanged`, this);
	  }

	  handleEditLayer(id) {
	    if (!id) {
	      app.toast(_t('Please select an animation layer.'));
	      return;
	    }

	    const animations = app.editor.animations;
	    const layer = animations.filter(n => n.uuid === id)[0];
	    app.prompt({
	      title: _t('Edit Layer Name'),
	      content: _t('Layer Name'),
	      value: layer.layerName,
	      onOK: this.commitEditLayer
	    });
	  }

	  commitEditLayer(layerName) {
	    let animations = app.editor.animations;
	    const index = animations.findIndex(n => n.uuid === this.state.selectedLayer);

	    if (index > -1) {
	      animations[index].layerName = layerName;
	      app.call(`animationChanged`, this);
	    }
	  }

	  handleDeleteLayer(id) {
	    if (!id) {
	      app.toast(_t('Please select an animation layer.'));
	      return;
	    }

	    const animations = app.editor.animations;
	    const layer = animations.filter(n => n.uuid === id)[0];
	    app.confirm({
	      title: _t('Delete'),
	      content: _t(`Delete animation layer {{layerName}}?`, {
	        layerName: layer.layerName
	      }),
	      onOK: this.commitDeleteLayer
	    });
	  }

	  commitDeleteLayer() {
	    let animations = app.editor.animations;
	    const index = animations.findIndex(n => n.uuid === this.state.selectedLayer);

	    if (index > -1) {
	      animations.splice(index, 1);
	      app.call(`animationChanged`, this);
	    }
	  }

	  handleSelectedLayerChange(value) {
	    this.setState({
	      selectedLayer: value
	    });
	  } // ---------------------------- 动画管理 ---------------------------------


	  handleAddAnimation(layerID, beginTime, endTime) {
	    let layer = app.editor.animations.filter(n => n.uuid === layerID)[0];

	    if (!layer) {
	      console.warn(`TimelinePanel: layer ${layerID} is not defined.`);
	      return;
	    }

	    layer.animations.push({
	      id: null,
	      uuid: THREE.Math.generateUUID(),
	      name: _t('Animation'),
	      target: null,
	      type: 'Tween',
	      beginTime,
	      endTime,
	      data: {
	        beginStatus: 'Current',
	        // 开始状态：Current-当前位置、Custom-自定义位置
	        beginPositionX: 0,
	        beginPositionY: 0,
	        beginPositionZ: 0,
	        beginRotationX: 0,
	        beginRotationY: 0,
	        beginRotationZ: 0,
	        beginScaleLock: true,
	        beginScaleX: 1.0,
	        beginScaleY: 1.0,
	        beginScaleZ: 1.0,
	        ease: 'linear',
	        // linear, quadIn, quadOut, quadInOut, cubicIn, cubicOut, cubicInOut, quartIn, quartOut, quartInOut, quintIn, quintOut, quintInOut, sineIn, sineOut, sineInOut, backIn, backOut, backInOut, circIn, circOut, circInOut, bounceIn, bounceOut, bounceInOut, elasticIn, elasticOut, elasticInOut
	        endStatus: 'Current',
	        endPositionX: 0,
	        endPositionY: 0,
	        endPositionZ: 0,
	        endRotationX: 0,
	        endRotationY: 0,
	        endRotationZ: 0,
	        endScaleLock: true,
	        endScaleX: 1.0,
	        endScaleY: 1.0,
	        endScaleZ: 1.0
	      }
	    });
	    app.call(`animationChanged`, this);
	  }

	  handleDropAnimation(id, oldLayerID, newLayerID, beginTime) {
	    let oldLayer = app.editor.animations.filter(n => n.uuid === oldLayerID)[0];

	    if (!oldLayer) {
	      console.warn(`TimelinePanel: layer ${oldLayerID} is not defined.`);
	      return;
	    }

	    let newLayer = app.editor.animations.filter(n => n.uuid === newLayerID)[0];

	    if (!newLayer) {
	      console.warn(`TimelinePanel: layer ${newLayerID} is not defined.`);
	      return;
	    }

	    let index = oldLayer.animations.findIndex(n => n.uuid === id);

	    if (index === -1) {
	      console.warn(`TimelinePanel: animation ${id} is not defined.`);
	      return;
	    }

	    let animation = oldLayer.animations[index];
	    let duration = animation.endTime - animation.beginTime;
	    animation.beginTime = beginTime;
	    animation.endTime = beginTime + duration;
	    oldLayer.animations.splice(index, 1);
	    newLayer.animations.push(animation);
	    app.call(`animationChanged`, this);
	  }

	  handleClickAnimation(id, pid) {
	    const layer = app.editor.animations.filter(n => n.uuid === pid)[0];

	    if (!layer) {
	      console.warn(`TimelinePanel: layer ${pid} is not defined.`);
	      return;
	    }

	    const animation = layer.animations.filter(n => n.uuid === id)[0];

	    if (!animation) {
	      console.warn(`TimelinePanel: animation ${id} is not defined.`);
	      return;
	    }

	    app.call('animationSelected', this, animation);
	    this.setState({
	      selected: animation.uuid
	    });
	  }

	}

	/**
	 * 移动物体命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 当前物体
	 * @param {THREE.Object3D} newParent 新的父要素
	 * @param {THREE.Object3D} newBefore 旧的父要素
	 * @constructor
	 */

	function MoveObjectCommand(object, newParent, newBefore) {
	  Command.call(this);
	  this.type = 'MoveObjectCommand';
	  this.name = _t('Move Object');
	  this.object = object;
	  this.oldParent = object !== undefined ? object.parent : undefined;
	  this.oldIndex = this.oldParent !== undefined ? this.oldParent.children.indexOf(this.object) : undefined;
	  this.newParent = newParent;

	  if (newBefore !== undefined) {
	    this.newIndex = newParent !== undefined ? newParent.children.indexOf(newBefore) : undefined;
	  } else {
	    this.newIndex = newParent !== undefined ? newParent.children.length : undefined;
	  }

	  if (this.oldParent === this.newParent && this.newIndex > this.oldIndex) {
	    this.newIndex--;
	  }

	  this.newBefore = newBefore;
	}

	MoveObjectCommand.prototype = Object.create(Command.prototype);
	Object.assign(MoveObjectCommand.prototype, {
	  constructor: MoveObjectCommand,
	  execute: function () {
	    this.oldParent.remove(this.object);
	    var children = this.newParent.children;
	    children.splice(this.newIndex, 0, this.object);
	    this.object.parent = this.newParent;
	  },
	  undo: function () {
	    this.newParent.remove(this.object);
	    var children = this.oldParent.children;
	    children.splice(this.oldIndex, 0, this.object);
	    this.object.parent = this.oldParent;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.newParentUuid = this.newParent.uuid;
	    output.oldParentUuid = this.oldParent.uuid;
	    output.newIndex = this.newIndex;
	    output.oldIndex = this.oldIndex;
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldParent = this.editor.objectByUuid(json.oldParentUuid);

	    if (this.oldParent === undefined) {
	      this.oldParent = this.editor.scene;
	    }

	    this.newParent = this.editor.objectByUuid(json.newParentUuid);

	    if (this.newParent === undefined) {
	      this.newParent = this.editor.scene;
	    }

	    this.newIndex = json.newIndex;
	    this.oldIndex = json.oldIndex;
	  }
	});

	/**
	 * 场景树状图
	 * @author tengge / https://github.com/tengge1
	 */

	class HierarchyPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.expanded = {};
	    this.checked = {};
	    this.treeRef = React.createRef();
	    this.state = {
	      data: [],
	      selected: null
	    };
	    this.updateUI = this.updateUI.bind(this);
	    this.handleObjectSelected = this.handleObjectSelected.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleCheck = this.handleCheck.bind(this);
	    this.handleDoubleClick = this.handleDoubleClick.bind(this);
	    this.handleClickVisible = this.handleClickVisible.bind(this);
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleDrop = this.handleDrop.bind(this);
	  }

	  render() {
	    const {
	      data,
	      selected,
	      checked
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Tree, {
	      data: data,
	      selected: selected,
	      checked: checked,
	      ref: this.treeRef,
	      onSelect: this.handleSelect,
	      onCheck: this.handleCheck,
	      onDoubleClick: this.handleDoubleClick,
	      onClickIcon: this.handleClickVisible,
	      onExpand: this.handleExpand,
	      onDrop: this.handleDrop
	    });
	  }

	  componentDidMount() {
	    app.on(`sceneGraphChanged.HierarchyPanel`, this.updateUI); // bug: https://gitee.com/tengge1/ShadowEditor/issues/ITCA9

	    app.on(`objectChanged.HierarchyPanel`, this.updateUI);
	    app.on(`objectRemoved.HierarchyPanel`, this.updateUI);
	    app.on(`objectSelected.HierarchyPanel`, this.handleObjectSelected);
	  }
	  /**
	   * 单击树节点
	   * @param {*} value uuid值
	   */


	  handleSelect(value) {
	    this.setState({
	      selected: value
	    });
	    app.editor.selectByUuid(value);
	  }

	  handleCheck(value, name) {
	    let checked = this.checked;

	    if (value && !checked[name]) {
	      checked[name] = true;
	    } else if (!value && checked[name]) {
	      delete checked[name];
	    } else {
	      console.warn(`HierarchyPanel: handleCheck error.`);
	    }

	    this.updateUI();
	  }

	  handleDoubleClick(value) {
	    this.setState({
	      selected: value
	    });
	    app.editor.focusByUUID(value);
	  }

	  handleClickVisible(value) {
	    let obj = app.editor.objectByUuid(value);

	    if (obj) {
	      obj.visible = !obj.visible;
	      app.call(`objectChanged`, this, obj.visible);
	    }
	  }
	  /**
	   * 选中物体改变
	   * @param {*} object 当前选中物体
	   */


	  handleObjectSelected(object) {
	    // 展开选中节点的所有父节点，并设置选中
	    if (!object) {
	      this.setState({
	        selected: null
	      });
	      return;
	    }

	    let selected = object.uuid;
	    this.setState({
	      selected
	    }, () => {
	      this.updateUI(true);
	    });
	  }
	  /**
	   * 根据场景变化，更新场景树状图
	   * @param {Boolean} shouldExpandData 是否展开选中物体父节点
	   */


	  updateUI(shouldExpandData = false) {
	    const scene = app.editor.scene;
	    const camera = app.editor.camera;
	    let data = [{
	      value: camera.uuid,
	      text: camera.name,
	      cls: 'Camera',
	      expanded: false,
	      checked: this.checked[camera.uuid] || false,
	      draggable: false,
	      children: []
	    }];

	    this._parseData(scene, data);

	    const selected = this.state.selected;
	    shouldExpandData && this.expandData(selected, data);
	    this.setState({
	      data,
	      selected
	    }, () => {
	      shouldExpandData && this.treeRef.current.scrollToView(selected);
	    });
	  }

	  expandData(uuid, list) {
	    for (let item of list) {
	      if (uuid === item.value) {
	        return true;
	      }

	      if (this.expandData(uuid, item.children)) {
	        // 找到了，父节点也要展开
	        this.expanded[item.uuid] = true;
	        item.expanded = true;
	        return true;
	      }
	    }

	    return false;
	  }

	  _parseData(obj, list) {
	    const scene = app.editor.scene;
	    const camera = app.editor.camera;
	    let cls = null;

	    if (obj === scene) {
	      cls = 'Scene';
	    } else if (obj instanceof THREE.Line) {
	      cls = 'Line';
	    } else if (obj instanceof THREE.Light) {
	      cls = 'Light';
	    } else if (obj instanceof THREE.Points) {
	      cls = 'Points';
	    } else {
	      cls = 'Default';
	    }

	    let expanded = this.expanded;

	    if (obj === scene && expanded[obj.uuid] === undefined) {
	      expanded[obj.uuid] = true;
	    }

	    var data = {
	      value: obj.uuid,
	      text: obj.name,
	      expanded: expanded[obj.uuid],
	      checked: this.checked[obj.uuid] || false,
	      draggable: obj !== scene && obj !== camera,
	      cls: cls,
	      children: [],
	      icons: [{
	        name: 'visible',
	        icon: obj.visible ? 'visible' : 'invisible',
	        title: obj.visible ? _t('Hide') : _t('Show')
	      }]
	    };
	    list.push(data);

	    if (Array.isArray(obj.children)) {
	      obj.children.forEach(n => {
	        this._parseData(n, data.children);
	      });
	    }
	  }
	  /**
	   * 展开关闭节点
	   * @param {*} value uuid值
	   */


	  handleExpand(value) {
	    let expanded = this.expanded;

	    if (expanded[value]) {
	      expanded[value] = false;
	    } else {
	      expanded[value] = true;
	    }

	    this.updateUI();
	  }
	  /**
	   * 拖动节点
	   * @param {*} value uuid值
	   * @param {*} newParentValue 新的父节点值
	   * @param {*} newBeforeValue 旧的父节点值
	   */


	  handleDrop(value, newParentValue, newBeforeValue) {
	    var editor = app.editor;
	    let object = editor.objectByUuid(value);
	    let newParent = editor.objectByUuid(newParentValue);
	    let newBefore = null;

	    if (newBeforeValue) {
	      newBefore = editor.objectByUuid(newBeforeValue);
	    }

	    app.editor.execute(new MoveObjectCommand(object, newParent, newBefore));
	    this.expanded[newParentValue] = true;
	    this.updateUI();
	  }

	}

	/**
	 * 历史面板
	 * @author tengge / https://github.com/tengge1
	 */

	class HistoryPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      undos: [],
	      redos: []
	    };
	    this.ref = React.createRef();
	    this.update = this.update.bind(this);
	    this.handleClick = this.handleClick.bind(this);
	    this.handleClear = this.handleClear.bind(this);
	  }

	  render() {
	    const {
	      undos,
	      redos
	    } = this.state;
	    return /*#__PURE__*/React.createElement("div", {
	      className: 'HistoryPanel'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'toolbar'
	    }, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClear
	    }, _t('Clear'))), /*#__PURE__*/React.createElement("div", {
	      className: 'content',
	      ref: this.ref,
	      onClick: this.handleClick
	    }, undos.map(n => {
	      return /*#__PURE__*/React.createElement("div", {
	        className: 'undo',
	        value: n.id,
	        key: n.id,
	        onClick: this.handleClick
	      }, n.name);
	    }), redos.map(n => {
	      return /*#__PURE__*/React.createElement("div", {
	        className: 'redo',
	        value: n.id,
	        key: n.id,
	        onClick: this.handleClick
	      }, n.name);
	    })));
	  }

	  componentDidMount() {
	    app.on(`editorCleared.HistoryPanel`, this.update);
	    app.on(`historyChanged.HistoryPanel`, this.update);
	  }

	  componentDidUpdate() {
	    let dom = this.ref.current;
	    dom.scrollTop = dom.scrollHeight;
	  }

	  update() {
	    var history = app.editor.history;
	    let undos = [],
	        redos = [];
	    history.undos.forEach(n => {
	      undos.push({
	        id: n.id,
	        name: n.name
	      });
	    });
	    history.redos.forEach(n => {
	      redos.push({
	        id: n.id,
	        name: n.name
	      });
	    });
	    undos.sort((a, b) => {
	      return a.id - b.id;
	    });
	    redos.sort((a, b) => {
	      return a.id - b.id;
	    });
	    this.setState({
	      undos,
	      redos
	    });
	  }

	  handleClick(event) {
	    const id = event.target.getAttribute('value');

	    if (!id) {
	      return;
	    }

	    app.editor.history.goToState(parseInt(id));
	    this.update();
	  }

	  handleClear() {
	    var editor = app.editor;
	    app.confirm({
	      title: _t('Confirm'),
	      content: _t('Undo/Redo history will be cleared. Are you sure?'),
	      onOK: () => {
	        editor.history.clear();
	      }
	    });
	  }

	}

	/**
	 * 设置值命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 物体
	 * @param {String} attributeName 属性名称
	 * @param {String} newValue number, string, boolean or object
	 * @constructor
	 */

	function SetValueCommand(object, attributeName, newValue) {
	  Command.call(this);
	  this.type = 'SetValueCommand';
	  this.name = _t('Set') + ' ' + attributeName;
	  this.updatable = true;
	  this.object = object;
	  this.attributeName = attributeName;
	  this.oldValue = object !== undefined ? object[attributeName] : undefined;
	  this.newValue = newValue;
	}

	SetValueCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetValueCommand.prototype, {
	  constructor: SetValueCommand,
	  execute: function () {
	    this.object[this.attributeName] = this.newValue;
	    app.call('objectChanged', this, this.object);
	  },
	  undo: function () {
	    this.object[this.attributeName] = this.oldValue;
	    app.call('objectChanged', this, this.object);
	  },
	  update: function (cmd) {
	    this.newValue = cmd.newValue;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.attributeName = this.attributeName;
	    output.oldValue = this.oldValue;
	    output.newValue = this.newValue;
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.attributeName = json.attributeName;
	    this.oldValue = json.oldValue;
	    this.newValue = json.newValue;
	    this.object = this.editor.objectByUuid(json.objectUuid);
	  }
	});

	/**
	 * 基本信息组件
	 * @author tengge / https://github.com/tengge1
	 */

	class BasicComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      show: false,
	      expanded: true,
	      name: '',
	      type: '',
	      visible: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangeName = this.handleChangeName.bind(this);
	    this.handleChangeVisible = this.handleChangeVisible.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      name,
	      type,
	      visible
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Basic Info'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(TextProperty, {
	      label: _t('Name'),
	      name: 'name',
	      value: name,
	      onChange: this.handleChangeName
	    }), /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('Type'),
	      name: 'type',
	      value: type
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Visible'),
	      name: 'visible',
	      value: visible,
	      onChange: this.handleChangeVisible
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.BasicComponent`, this.handleUpdate);
	    app.on(`objectChanged.BasicComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      name: this.selected.name,
	      type: this.selected.constructor.name,
	      visible: this.selected.visible
	    });
	  }

	  handleChangeName(value) {
	    this.setState({
	      name: value
	    });
	    app.editor.execute(new SetValueCommand(this.selected, 'name', value)); // bug: https://gitee.com/tengge1/ShadowEditor/issues/IV1V3

	    if (this.selected instanceof UnscaledText || this.selected instanceof PointMarker) {
	      this.selected.setText(value);
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeVisible(value) {
	    this.setState({
	      visible: value
	    });
	    this.selected.visible = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 相机组件
	 * @author tengge / https://github.com/tengge1
	 */

	class CameraComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      show: false,
	      expanded: true,
	      fov: 70,
	      near: 0.1,
	      far: 1000
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangeFov = this.handleChangeFov.bind(this);
	    this.handleChangeNear = this.handleChangeNear.bind(this);
	    this.handleChangeFar = this.handleChangeFar.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      fov,
	      near,
	      far
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Camera Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Fov'),
	      name: 'fov',
	      value: fov,
	      onChange: this.handleChangeFov
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Near'),
	      name: 'near',
	      value: near,
	      onChange: this.handleChangeNear
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Far'),
	      name: 'far',
	      value: far,
	      onChange: this.handleChangeFar
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.CameraComponent`, this.handleUpdate);
	    app.on(`objectChanged.CameraComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor; // TODO: 应判断是否等于默认相机

	    if (!editor.selected || !(editor.selected instanceof THREE.PerspectiveCamera)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      fov: this.selected.fov,
	      near: this.selected.near,
	      far: this.selected.far
	    });
	  }

	  handleChangeFov(value) {
	    if (value === null) {
	      this.setState({
	        fov: value
	      });
	      return;
	    }

	    app.editor.execute(new SetValueCommand(this.selected, 'fov', value));
	  }

	  handleChangeNear(value) {
	    if (value === null) {
	      this.setState({
	        near: value
	      });
	      return;
	    }

	    app.editor.execute(new SetValueCommand(this.selected, 'near', value));
	  }

	  handleChangeFar(value) {
	    if (value === null) {
	      this.setState({
	        far: value
	      });
	      return;
	    }

	    app.editor.execute(new SetValueCommand(this.selected, 'far', value));
	  }

	}

	/**
	 * 火焰组件
	 * @author tengge / https://github.com/tengge1
	 */

	class FireComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      width: 2,
	      height: 4,
	      depth: 2,
	      sliceSpacing: 2,
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      width,
	      height,
	      depth,
	      sliceSpacing,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Fire Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Width'),
	      name: 'width',
	      value: width,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Height'),
	      name: 'height',
	      value: height,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Depth'),
	      name: 'depth',
	      value: depth,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('SliceSpacing'),
	      name: 'sliceSpacing',
	      value: sliceSpacing,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.FireComponent`, this.handleUpdate);
	    app.on(`objectChanged.FireComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'Fire')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      width: this.selected.userData.width,
	      height: this.selected.userData.height,
	      depth: this.selected.userData.depth,
	      sliceSpacing: this.selected.userData.sliceSpacing,
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    let {
	      width,
	      height,
	      depth,
	      sliceSpacing
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    VolumetricFire.texturePath = 'assets/textures/VolumetricFire/';
	    const editor = app.editor;
	    let fire = new VolumetricFire(width, height, depth, sliceSpacing, editor.camera);
	    fire.mesh.name = this.selected.name;
	    fire.mesh.position.copy(this.selected.position);
	    fire.mesh.rotation.copy(this.selected.rotation);
	    fire.mesh.scale.copy(this.selected.scale);
	    Object.assign(fire.mesh.userData, {
	      type: 'Fire',
	      fire,
	      width,
	      height,
	      depth,
	      sliceSpacing
	    });
	    const index = editor.scene.children.indexOf(this.selected);

	    if (index > -1) {
	      editor.select(null);
	      editor.scene.children[index] = fire.mesh;
	      fire.mesh.parent = this.selected.parent;
	      this.selected.parent = null;
	      app.call(`objectRemoved`, this, this.selected);
	      app.call(`objectAdded`, this, fire.mesh);
	      editor.select(fire.mesh);
	      fire.update(0);
	    }
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    app.on(`animate.FireComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    app.on(`animate.FireComponent`, null);
	  }

	  onAnimate(clock) {
	    const elapsed = clock.elapsedTime;
	    const fire = this.selected.userData.fire;
	    fire.update(elapsed);
	  }

	}

	/**
	 * 光源组件
	 * @author tengge / https://github.com/tengge1
	 */

	class LightComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      showColor: false,
	      color: '#ffffff',
	      showIntensity: false,
	      intensity: 1,
	      showDistance: false,
	      distance: 0,
	      showAngle: false,
	      angle: Math.PI * 0.1,
	      showPenumbra: false,
	      penumbra: 0,
	      showDecay: false,
	      decay: 1,
	      showSkyColor: false,
	      skyColor: '#00aaff',
	      showGroundColor: false,
	      groundColor: '#ffaa00',
	      showWidth: false,
	      width: 20,
	      showHeight: false,
	      height: 10
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangeColor = this.handleChangeColor.bind(this);
	    this.handleChangeIntensity = this.handleChangeIntensity.bind(this);
	    this.handleChangeDistance = this.handleChangeDistance.bind(this);
	    this.handleChangeAngle = this.handleChangeAngle.bind(this);
	    this.handleChangePenumbra = this.handleChangePenumbra.bind(this);
	    this.handleChangeDecay = this.handleChangeDecay.bind(this);
	    this.handleChangeSkyColor = this.handleChangeSkyColor.bind(this);
	    this.handleChangeGroundColor = this.handleChangeGroundColor.bind(this);
	    this.handleChangeWidth = this.handleChangeWidth.bind(this);
	    this.handleChangeHeight = this.handleChangeHeight.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      showColor,
	      color,
	      showIntensity,
	      intensity,
	      showDistance,
	      distance,
	      showAngle,
	      angle,
	      showPenumbra,
	      penumbra,
	      showDecay,
	      decay,
	      showSkyColor,
	      skyColor,
	      showGroundColor,
	      groundColor,
	      showWidth,
	      width,
	      showHeight,
	      height
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Light Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(ColorProperty, {
	      label: _t('Color'),
	      name: 'color',
	      value: color,
	      show: showColor,
	      onChange: this.handleChangeColor
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Intensity'),
	      name: 'intensity',
	      value: intensity,
	      show: showIntensity,
	      onChange: this.handleChangeIntensity
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Distance'),
	      name: 'distance',
	      value: distance,
	      show: showDistance,
	      onChange: this.handleChangeDistance
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Angle'),
	      name: 'angle',
	      value: angle,
	      show: showAngle,
	      onChange: this.handleChangeAngle
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Penumbra'),
	      name: 'penumbra',
	      value: penumbra,
	      show: showPenumbra,
	      onChange: this.handleChangePenumbra
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Decay'),
	      name: 'decay',
	      value: decay,
	      show: showDecay,
	      onChange: this.handleChangeDecay
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: _t('SkyColor'),
	      name: 'skyColor',
	      value: skyColor,
	      show: showSkyColor,
	      onChange: this.handleChangeSkyColor
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: _t('GroundColor'),
	      name: 'groundColor',
	      value: groundColor,
	      show: showGroundColor,
	      onChange: this.handleChangeGroundColor
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Width'),
	      name: 'width',
	      value: width,
	      show: showWidth,
	      onChange: this.handleChangeWidth
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Height'),
	      name: 'height',
	      value: height,
	      show: showHeight,
	      onChange: this.handleChangeHeight
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.LightComponent`, this.handleUpdate);
	    app.on(`objectChanged.LightComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Light)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let state = {
	      show: true
	    };

	    if (this.selected instanceof THREE.HemisphereLight) {
	      state.showColor = false;
	    } else {
	      state.showColor = true;
	      state.color = `#${this.selected.color.getHexString()}`;
	    }

	    state.showIntensity = true;
	    state.intensity = this.selected.intensity;

	    if (this.selected instanceof THREE.PointLight || this.selected instanceof THREE.SpotLight) {
	      state.showDistance = true;
	      state.showDecay = true;
	      state.distance = this.selected.distance;
	      state.decay = this.selected.decay;
	    } else {
	      state.showDistance = false;
	      state.showDecay = false;
	    }

	    if (this.selected instanceof THREE.SpotLight) {
	      state.showAngle = true;
	      state.showPenumbra = true;
	      state.angle = this.selected.angle;
	      state.penumbra = this.selected.penumbra;
	    } else {
	      state.showAngle = false;
	      state.showPenumbra = false;
	    }

	    if (this.selected instanceof THREE.HemisphereLight) {
	      state.showSkyColor = true;
	      state.showGroundColor = true;
	      state.skyColor = `#${this.selected.color.getHexString()}`;
	      state.groundColor = `#${this.selected.groundColor.getHexString()}`;
	    } else {
	      state.showSkyColor = false;
	      state.showGroundColor = false;
	    }

	    if (this.selected instanceof THREE.RectAreaLight) {
	      state.showWidth = true;
	      state.showHeight = true;
	      state.width = this.selected.width;
	      state.height = this.selected.height;
	    } else {
	      state.showWidth = false;
	      state.showHeight = false;
	    }

	    this.setState(state);
	  }

	  handleChangeColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.color = new THREE.Color(value);
	    let helper = this.selected.children.filter(n => n.userData.type === 'helper')[0];

	    if (helper) {
	      helper.material.color = this.selected.color;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeIntensity(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.intensity = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeDistance(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.distance = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeAngle(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.angle = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangePenumbra(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.penumbra = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeDecay(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.decay = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeSkyColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.color = new THREE.Color(value);
	    let sky = this.selected.children.filter(n => n.userData.type === 'sky')[0];

	    if (sky) {
	      sky.material.uniforms.topColor.value = this.selected.color;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeGroundColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.groundColor = new THREE.Color(value);
	    let ground = this.selected.children.filter(n => n.userData.type === 'sky')[0];

	    if (ground) {
	      ground.material.uniforms.bottomColor.value = this.selected.groundColor;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeWidth(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.width = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeHeight(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.height = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * LMesh组件
	 * @author tengge / https://github.com/tengge1
	 */

	class LMeshComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      options: [],
	      animation: '',
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      options,
	      animation,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('LMesh Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Animation'),
	      name: 'animation',
	      options: options,
	      value: animation,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.LMeshComponent`, this.handleUpdate);
	    app.on(`objectChanged.LMeshComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'lol')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const model = this.selected.userData.model;
	    const animNames = model.getAnimations();
	    let options = {};
	    animNames.forEach(n => {
	      options[n] = n;
	    });
	    this.setState({
	      show: true,
	      options,
	      animation: animNames[0],
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    });
	  }

	  handleChange(value) {
	    const model = this.selected.userData.model;
	    model.setAnimation(value);
	    this.setState({
	      animation: value
	    });
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    const animation = this.state.animation;

	    if (!animation) {
	      app.toast(`Please select animation.`);
	      return;
	    }

	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    const model = this.selected.userData.model;
	    model.setAnimation(animation);
	    app.on(`animate.LMeshComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    app.on(`animate.LMeshComponent`, null);
	  }

	  onAnimate(clock) {
	    var model = this.selected.userData.model;
	    model.update(clock.elapsedTime * 1000);
	  }

	}

	/**
	 * 多材质组件
	 * @author tengge / https://github.com/tengge1
	 */

	class MultiMaterialComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      count: 0,
	      materials: [],
	      index: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      count,
	      materials,
	      index
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    let _materials = {};
	    materials.forEach((n, i) => {
	      _materials[i] = n.name || (i + 1).toString();
	    });
	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('MultiMaterial Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('Count'),
	      value: count.toString()
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Material'),
	      options: _materials,
	      name: 'index',
	      value: index === -1 ? undefined : index,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.MultiMaterialComponent`, this.handleUpdate);
	    app.on(`objectChanged.MultiMaterialComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !Array.isArray(editor.selected.material)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const materials = this.selected.material;
	    const index = 0;
	    const current = materials[index];
	    app.call(`currentMaterialChange`, this, current, index, materials, this.selected);
	    let state = {
	      show: true,
	      count: materials.length,
	      materials,
	      index
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    const materials = this.state.materials;
	    const index = parseInt(value);
	    const current = materials[index];
	    app.call(`currentMaterialChange`, this, current, index, materials, this.selected);
	    this.setState({
	      [name]: value
	    });
	  }

	}

	/**
	 * 设置材质命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 物体
	 * @param {THREE.Material} newMaterial 新材质
	 * @constructor
	 */

	function SetMaterialCommand(object, newMaterial) {
	  Command.call(this);
	  this.type = 'SetMaterialCommand';
	  this.name = _t('New Material');
	  this.object = object;
	  this.oldMaterial = object !== undefined ? object.material : undefined;
	  this.newMaterial = newMaterial;
	}

	SetMaterialCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetMaterialCommand.prototype, {
	  constructor: SetMaterialCommand,
	  execute: function () {
	    this.object.material = this.newMaterial;
	  },
	  undo: function () {
	    this.object.material = this.oldMaterial;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.oldMaterial = this.oldMaterial.toJSON();
	    output.newMaterial = this.newMaterial.toJSON();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldMaterial = parseMaterial(json.oldMaterial);
	    this.newMaterial = parseMaterial(json.newMaterial);

	    function parseMaterial(json) {
	      var loader = new THREE.ObjectLoader();
	      var images = loader.parseImages(json.images);
	      var textures = loader.parseTextures(json.textures, images);
	      var materials = loader.parseMaterials([json], textures);
	      return materials[json.uuid];
	    }
	  }
	});

	let color = new THREE.Color();
	/**
	 * 设置材质颜色命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 物体
	 * @param {String} attributeName 属性名称
	 * @param {String} newValue integer representing a hex color value or a hex string startsWith `#`
	 * @constructor
	 */

	function SetMaterialColorCommand(object, attributeName, newValue) {
	  Command.call(this);
	  this.type = 'SetMaterialColorCommand';
	  this.name = _t('Set Material') + '.' + attributeName;
	  this.updatable = true;
	  this.object = object;
	  this.attributeName = attributeName;
	  this.oldValue = object !== undefined ? this.object.material[this.attributeName].getHex() : undefined;

	  if (Number.isInteger(newValue)) {
	    this.newValue = newValue;
	  } else {
	    // #ffffff
	    color.set(newValue);
	    this.newValue = color.getHex();
	  }
	}

	SetMaterialColorCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetMaterialColorCommand.prototype, {
	  constructor: SetMaterialColorCommand,
	  execute: function () {
	    this.object.material[this.attributeName].setHex(this.newValue);
	  },
	  undo: function () {
	    this.object.material[this.attributeName].setHex(this.oldValue);
	  },
	  update: function (cmd) {
	    this.newValue = cmd.newValue;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.attributeName = this.attributeName;
	    output.oldValue = this.oldValue;
	    output.newValue = this.newValue;
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.attributeName = json.attributeName;
	    this.oldValue = json.oldValue;
	    this.newValue = json.newValue;
	  }
	});

	/**
	 * 设置材质值命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 物体
	 * @param {String} attributeName 属性名称
	 * @param {String} newValue number, string, boolean or object
	 * @constructor
	 */

	function SetMaterialValueCommand(object, attributeName, newValue) {
	  Command.call(this);
	  this.type = 'SetMaterialValueCommand';
	  this.name = _t('Set Material') + '.' + attributeName;
	  this.updatable = true;
	  this.object = object;
	  this.oldValue = object !== undefined ? object.material[attributeName] : undefined;
	  this.newValue = newValue;
	  this.attributeName = attributeName;
	}

	SetMaterialValueCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetMaterialValueCommand.prototype, {
	  constructor: SetMaterialValueCommand,
	  execute: function () {
	    this.object.material[this.attributeName] = this.newValue;
	    this.object.material.needsUpdate = true;
	    app.call('objectChanged', this, this.object);
	  },
	  undo: function () {
	    this.object.material[this.attributeName] = this.oldValue;
	    this.object.material.needsUpdate = true;
	    app.call('objectChanged', this, this.object);
	  },
	  update: function (cmd) {
	    this.newValue = cmd.newValue;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.attributeName = this.attributeName;
	    output.oldValue = this.oldValue;
	    output.newValue = this.newValue;
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.attributeName = json.attributeName;
	    this.oldValue = json.oldValue;
	    this.newValue = json.newValue;
	    this.object = this.editor.objectByUuid(json.objectUuid);
	  }
	});

	/**
	 * 设置材质纹理命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 物体
	 * @param {String} mapName 属性名称
	 * @param {THREE.Texture} newMap 新纹理
	 * @constructor
	 */

	function SetMaterialMapCommand(object, mapName, newMap) {
	  Command.call(this);
	  this.type = 'SetMaterialMapCommand';
	  this.name = _t('Set Material') + '.' + mapName;
	  this.object = object;
	  this.mapName = mapName;
	  this.oldMap = object !== undefined ? object.material[mapName] : undefined;
	  this.newMap = newMap;
	}

	SetMaterialMapCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetMaterialMapCommand.prototype, {
	  constructor: SetMaterialMapCommand,
	  execute: function () {
	    this.object.material[this.mapName] = this.newMap;
	    this.object.material.needsUpdate = true;
	  },
	  undo: function () {
	    this.object.material[this.mapName] = this.oldMap;
	    this.object.material.needsUpdate = true;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.mapName = this.mapName;
	    output.newMap = serializeMap(this.newMap);
	    output.oldMap = serializeMap(this.oldMap);
	    return output; // serializes a map (THREE.Texture)

	    function serializeMap(map) {
	      if (map === null || map === undefined) return null;
	      var meta = {
	        geometries: {},
	        materials: {},
	        textures: {},
	        images: {}
	      };
	      var json = map.toJSON(meta);
	      var images = extractFromCache(meta.images);
	      if (images.length > 0) json.images = images;
	      json.sourceFile = map.sourceFile;
	      return json;
	    } // Note: The function 'extractFromCache' is copied from Object3D.toJSON()
	    // extract data from the cache hash
	    // remove metadata on each item
	    // and return as array


	    function extractFromCache(cache) {
	      var values = [];

	      for (var key in cache) {
	        var data = cache[key];
	        delete data.metadata;
	        values.push(data);
	      }

	      return values;
	    }
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.mapName = json.mapName;
	    this.oldMap = parseTexture(json.oldMap);
	    this.newMap = parseTexture(json.newMap);

	    function parseTexture(json) {
	      var map = null;

	      if (json !== null) {
	        var loader = new THREE.ObjectLoader();
	        var images = loader.parseImages(json.images);
	        var textures = loader.parseTextures([json], images);
	        map = textures[json.uuid];
	        map.sourceFile = json.sourceFile;
	      }

	      return map;
	    }
	  }
	});

	var ShaderMaterialVertex = "void main()\t{\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}";

	var ShaderMaterialFragment = "void main()\t{\r\n\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n}";

	var RawShaderMaterialVertex = "precision mediump float;\r\n\r\nuniform mat4 modelViewMatrix;\r\nuniform mat4 projectionMatrix;\r\n\r\nattribute vec3 position;\r\n\r\nvoid main()\t{\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}";

	var RawShaderMaterialFragment = "precision mediump float;\r\n\r\nvoid main()\t{\r\n\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n}";

	/**
	 * 纹理设置窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class TextureSettingWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.wrapS = {
	      [THREE.ClampToEdgeWrapping]: _t('Clamp To Edge'),
	      [THREE.RepeatWrapping]: _t('Repeat'),
	      [THREE.MirroredRepeatWrapping]: _t('Mirrored Repeat')
	    };
	    this.wrapT = {
	      [THREE.ClampToEdgeWrapping]: _t('Clamp To Edge'),
	      [THREE.RepeatWrapping]: _t('Repeat'),
	      [THREE.MirroredRepeatWrapping]: _t('Mirrored Repeat')
	    };
	    this.magFilter = {
	      [THREE.LinearFilter]: 'LinearFilter',
	      [THREE.NearestFilter]: 'NearestFilter'
	    };
	    this.minFilter = {
	      [THREE.LinearMipMapLinearFilter]: 'LinearMipMapLinearFilter',
	      [THREE.NearestFilter]: 'NearestFilter',
	      [THREE.NearestMipMapNearestFilter]: 'NearestMipMapNearestFilter',
	      [THREE.NearestMipMapLinearFilter]: 'NearestMipMapLinearFilter',
	      [THREE.LinearFilter]: 'LinearFilter',
	      [THREE.LinearMipMapNearestFilter]: 'LinearMipMapNearestFilter'
	    };
	    this.type = {
	      [THREE.UnsignedByteType]: 'UnsignedByteType',
	      [THREE.ByteType]: 'ByteType',
	      [THREE.ShortType]: 'ShortType',
	      [THREE.UnsignedShortType]: 'UnsignedShortType',
	      [THREE.IntType]: 'IntType',
	      [THREE.UnsignedIntType]: 'UnsignedIntType',
	      [THREE.FloatType]: 'FloatType',
	      [THREE.HalfFloatType]: 'HalfFloatType',
	      [THREE.UnsignedShort4444Type]: 'UnsignedShort4444Type',
	      [THREE.UnsignedShort5551Type]: 'UnsignedShort5551Type',
	      [THREE.UnsignedShort565Type]: 'UnsignedShort565Type',
	      [THREE.UnsignedInt248Type]: 'UnsignedInt248Type'
	    };
	    this.encoding = {
	      [THREE.LinearEncoding]: 'LinearEncoding',
	      [THREE.sRGBEncoding]: 'sRGBEncoding',
	      [THREE.GammaEncoding]: 'GammaEncoding',
	      [THREE.RGBEEncoding]: 'RGBEEncoding',
	      [THREE.LogLuvEncoding]: 'LogLuvEncoding',
	      [THREE.RGBM7Encoding]: 'RGBM7Encoding',
	      [THREE.RGBM16Encoding]: 'RGBM16Encoding',
	      [THREE.RGBDEncoding]: 'RGBDEncoding',
	      [THREE.BasicDepthPacking]: 'BasicDepthPacking',
	      [THREE.RGBADepthPacking]: 'RGBADepthPacking'
	    };
	    this.format = {
	      [THREE.RGBAFormat]: 'RGBAFormat',
	      [THREE.AlphaFormat]: 'AlphaFormat',
	      [THREE.RGBFormat]: 'RGBFormat',
	      [THREE.LuminanceFormat]: 'LuminanceFormat',
	      [THREE.LuminanceAlphaFormat]: 'LuminanceAlphaFormat',
	      [THREE.RGBEFormat]: 'RGBEFormat',
	      [THREE.DepthFormat]: 'DepthFormat',
	      [THREE.DepthStencilFormat]: 'DepthStencilFormat'
	    };
	    this.mapping = {
	      [THREE.UVMapping]: 'UVMapping',
	      [THREE.CubeReflectionMapping]: 'CubeReflectionMapping',
	      [THREE.CubeRefractionMapping]: 'CubeRefractionMapping',
	      [THREE.EquirectangularReflectionMapping]: 'EquirectangularReflectionMapping',
	      [THREE.EquirectangularRefractionMapping]: 'EquirectangularRefractionMapping',
	      [THREE.SphericalReflectionMapping]: 'SphericalReflectionMapping',
	      [THREE.CubeUVReflectionMapping]: 'CubeUVReflectionMapping',
	      [THREE.CubeUVRefractionMapping]: 'CubeUVRefractionMapping'
	    };
	    this.unpackAlignment = {
	      [4]: '4',
	      [1]: '1',
	      [2]: '2',
	      [8]: '8'
	    };
	    const {
	      anisotropy,
	      center,
	      offset,
	      repeat,
	      rotation,
	      type,
	      encoding,
	      flipY,
	      format,
	      generateMipmaps,
	      magFilter,
	      minFilter,
	      mapping,
	      premultiplyAlpha,
	      unpackAlignment,
	      wrapS,
	      wrapT
	    } = this.props.map;
	    const centerX = center.x,
	          centerY = center.y,
	          offsetX = offset.x,
	          offsetY = offset.y,
	          repeatX = repeat.x,
	          repeatY = repeat.y;
	    this.state = {
	      anisotropy,
	      center,
	      offset,
	      repeat,
	      rotation,
	      type,
	      encoding,
	      flipY,
	      format,
	      generateMipmaps,
	      magFilter,
	      minFilter,
	      mapping,
	      premultiplyAlpha,
	      unpackAlignment,
	      wrapS,
	      wrapT,
	      centerX,
	      centerY,
	      offsetX,
	      offsetY,
	      repeatX,
	      repeatY
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      anisotropy,
	      rotation,
	      type,
	      encoding,
	      flipY,
	      format,
	      generateMipmaps,
	      magFilter,
	      minFilter,
	      mapping,
	      premultiplyAlpha,
	      unpackAlignment,
	      wrapS,
	      wrapT,
	      centerX,
	      centerY,
	      offsetX,
	      offsetY,
	      repeatX,
	      repeatY
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'TextureSettingWindow',
	      title: _t('Texture Settings'),
	      style: {
	        width: '360px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Center X')), /*#__PURE__*/React.createElement(Input, {
	      name: 'centerX',
	      value: centerX,
	      type: 'number',
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Center Y')), /*#__PURE__*/React.createElement(Input, {
	      name: 'centerY',
	      value: centerY,
	      type: 'number',
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Offset X')), /*#__PURE__*/React.createElement(Input, {
	      name: 'offsetX',
	      value: offsetX,
	      type: 'number',
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Offset Y')), /*#__PURE__*/React.createElement(Input, {
	      name: 'offsetY',
	      value: offsetY,
	      type: 'number',
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Repeat X')), /*#__PURE__*/React.createElement(Input, {
	      name: 'repeatX',
	      value: repeatX,
	      type: 'number',
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Repeat Y')), /*#__PURE__*/React.createElement(Input, {
	      name: 'repeatY',
	      value: repeatY,
	      type: 'number',
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Rotation')), /*#__PURE__*/React.createElement(Input, {
	      name: 'rotation',
	      value: rotation,
	      type: 'number',
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('WrapS')), /*#__PURE__*/React.createElement(Select, {
	      options: this.wrapS,
	      name: 'wrapS',
	      value: wrapS,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('WrapT')), /*#__PURE__*/React.createElement(Select, {
	      options: this.wrapT,
	      name: 'wrapT',
	      value: wrapT,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('FlipY')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'flipY',
	      checked: flipY,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Mag Filter')), /*#__PURE__*/React.createElement(Select, {
	      options: this.magFilter,
	      name: 'magFilter',
	      value: magFilter,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Min Filter')), /*#__PURE__*/React.createElement(Select, {
	      options: this.minFilter,
	      name: 'minFilter',
	      value: minFilter,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Type')), /*#__PURE__*/React.createElement(Select, {
	      options: this.type,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Encoding')), /*#__PURE__*/React.createElement(Select, {
	      options: this.encoding,
	      name: 'encoding',
	      value: encoding,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Format')), /*#__PURE__*/React.createElement(Select, {
	      options: this.format,
	      name: 'format',
	      value: format,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Generate Mipmaps')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'generateMipmaps',
	      checked: generateMipmaps,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Mapping')), /*#__PURE__*/React.createElement(Select, {
	      options: this.mapping,
	      name: 'mapping',
	      value: mapping,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Premultiply Alpha')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'premultiplyAlpha',
	      checked: premultiplyAlpha,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Unpack Alignment')), /*#__PURE__*/React.createElement(Select, {
	      options: this.unpackAlignment,
	      name: 'unpackAlignment',
	      value: unpackAlignment,
	      onChange: this.handleChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Anisotropy')), /*#__PURE__*/React.createElement(Input, {
	      name: 'anisotropy',
	      value: anisotropy,
	      type: 'number',
	      precision: 0,
	      onChange: this.handleChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });

	    if (value === null) {
	      return;
	    }

	    const {
	      anisotropy,
	      rotation,
	      type,
	      encoding,
	      flipY,
	      format,
	      generateMipmaps,
	      magFilter,
	      minFilter,
	      mapping,
	      premultiplyAlpha,
	      unpackAlignment,
	      wrapS,
	      wrapT,
	      centerX,
	      centerY,
	      offsetX,
	      offsetY,
	      repeatX,
	      repeatY
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let map = this.props.map;
	    Object.assign(map, {
	      anisotropy,
	      rotation,
	      type: parseInt(type),
	      encoding: parseInt(encoding),
	      flipY,
	      format: parseInt(format),
	      generateMipmaps,
	      magFilter: parseInt(magFilter),
	      minFilter: parseInt(minFilter),
	      mapping: parseInt(mapping),
	      premultiplyAlpha,
	      unpackAlignment: parseInt(unpackAlignment),
	      wrapS: parseInt(wrapS),
	      wrapT: parseInt(wrapT)
	    });
	    map.center.set(centerX, centerY);
	    map.offset.set(offsetX, offsetY);
	    map.repeat.set(repeatX, repeatY);
	    map.needsUpdate = true;
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	TextureSettingWindow.propTypes = {
	  map: (props, propName, componentName) => {
	    const map = props[propName];

	    if (!(map instanceof THREE.Texture)) {
	      return new TypeError(`Invalid prop \`${propName}\` of type supplied to \`${componentName}\`, expected \`THREE.Texture\`.`);
	    }
	  }
	};
	TextureSettingWindow.defaultProps = {
	  map: null
	};

	/**
	 * 创建材质球图片
	 * @param {THREE.Material} material 材质
	 * @param {Number} width 宽度
	 * @param {Number} height 高度
	 * @returns {THREE.WebGLRenderTarget} 贴图
	 */
	function createMaterialImage(material, width = 160, height = 160) {
	  var scene = new THREE.Scene();
	  var camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 0, 1000);
	  camera.position.z = 80;
	  var renderer = new THREE.WebGLRenderer({
	    antialias: true,alpha:true 
	  });
	  renderer.setSize(width, height);
	  var light1 = new THREE.AmbientLight(0xffffff, 0.3);
	  scene.add(light1);
	  var light2 = new THREE.DirectionalLight(0xffffff, 0.8);
	  scene.add(light2);
	  light2.position.set(0, 10, 10);
	  light2.lookAt(new THREE.Vector3());
	  var geometry = new THREE.SphereBufferGeometry(72, 32, 32);
	  var mesh = new THREE.Mesh(geometry, material);
	  scene.add(mesh);
	  renderer.setClearColor(0xeeeeee);
	  renderer.clear();
	  renderer.render(scene, camera);
	  geometry.dispose();
	  renderer.dispose();
	  return renderer.domElement;
	}
	/**
	 * 材质工具类
	 */


	const MaterialUtils = {
	  createMaterialImage: createMaterialImage
	};

	/**
	 * 材质组件
	 * @author tengge / https://github.com/tengge1
	 */

	class MaterialComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.materialIndex = 0;
	    this.material = null;
	    this.materials = {
	      'LineBasicMaterial': _t('LineBasicMaterial'),
	      'LineDashedMaterial': _t('LineDashedMaterial'),
	      'MeshBasicMaterial': _t('MeshBasicMaterial'),
	      'MeshDepthMaterial': _t('MeshDepthMaterial'),
	      'MeshNormalMaterial': _t('MeshNormalMaterial'),
	      'MeshLambertMaterial': _t('MeshLambertMaterial'),
	      'MeshPhongMaterial': _t('MeshPhongMaterial'),
	      'PointsMaterial': _t('PointCloudMaterial'),
	      'MeshStandardMaterial': _t('MeshStandardMaterial'),
	      'MeshPhysicalMaterial': _t('MeshPhysicalMaterial'),
	      'SpriteMaterial': _t('SpriteMaterial'),
	      'ShaderMaterial': _t('ShaderMaterial'),
	      'RawShaderMaterial': _t('RawShaderMaterial')
	    };
	    this.vertexColors = {
	      0: _t('No Colors'),
	      1: _t('Face Colors'),
	      2: _t('Vertex Colors')
	    };
	    this.side = {
	      0: _t('Front Side'),
	      1: _t('Back Side'),
	      2: _t('Double Side')
	    };
	    this.blending = {
	      0: _t('No Blending'),
	      1: _t('Normal Blending'),
	      2: _t('Additive Blending'),
	      3: _t('Substractive Blending'),
	      4: _t('Multiply Blending'),
	      5: _t('Custom Blending')
	    };
	    this.mapNames = [// 用于判断属性是否是纹理
	    'map', 'alphaMap', 'bumpMap', 'normalMap', 'displacementMap', 'roughnessMap', 'metalnessMap', 'specularMap', 'envMap', 'lightMap', 'aoMap', 'emissiveMap'];
	    this.state = {
	      show: false,
	      expanded: false,
	      type: null,
	      showProgram: false,
	      showColor: false,
	      color: null,
	      showRoughness: false,
	      roughness: null,
	      showMetalness: false,
	      metalness: null,
	      showEmissive: false,
	      emissive: null,
	      showSpecular: false,
	      specular: null,
	      showShininess: false,
	      shininess: null,
	      showClearCoat: false,
	      clearCoat: null,
	      showClearCoatRoughness: false,
	      clearCoatRoughness: null,
	      showVertexColors: false,
	      vertexColors: null,
	      showSkinning: false,
	      skinning: null,
	      showMap: false,
	      map: null,
	      showAlphaMap: false,
	      alphaMap: null,
	      showBumpMap: false,
	      bumpMap: null,
	      bumpScale: null,
	      showNormalMap: false,
	      normalMap: null,
	      showDisplacementMap: false,
	      displacementMap: null,
	      displacementScale: null,
	      showRoughnessMap: false,
	      roughnessMap: null,
	      showMetalnessMap: false,
	      metalnessMap: null,
	      showSpecularMap: false,
	      specularMap: null,
	      showEnvMap: false,
	      envMap: null,
	      envMapIntensity: null,
	      showLightMap: false,
	      lightMap: null,
	      showAoMap: false,
	      aoMap: null,
	      aoScale: null,
	      showEmissiveMap: false,
	      emissiveMap: null,
	      showSide: false,
	      side: null,
	      showFlatShading: false,
	      flatShading: null,
	      showBlending: false,
	      blending: null,
	      showOpacity: false,
	      opacity: 1,
	      showTransparent: false,
	      transparent: false,
	      showAlphaTest: false,
	      alphaTest: 1,
	      showWireframe: false,
	      wireframe: false,
	      wireframeLinewidth: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleCurrentMaterialChange = this.handleCurrentMaterialChange.bind(this);
	    this.handleMaterial = this.handleMaterial.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handleTextureSetting = this.handleTextureSetting.bind(this);
	    this.editProgramInfo = this.editProgramInfo.bind(this);
	    this.saveProgramInfo = this.saveProgramInfo.bind(this);
	    this.editVertexShader = this.editVertexShader.bind(this);
	    this.saveVertexShader = this.saveVertexShader.bind(this);
	    this.editFragmentShader = this.editFragmentShader.bind(this);
	    this.saveFragmentShader = this.saveFragmentShader.bind(this);
	    this.onSave = this.onSave.bind(this);
	    this.onLoad = this.onLoad.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      type,
	      showProgram,
	      showColor,
	      color,
	      showRoughness,
	      roughness,
	      showMetalness,
	      metalness,
	      showEmissive,
	      emissive,
	      showSpecular,
	      specular,
	      showShininess,
	      shininess,
	      showClearCoat,
	      clearCoat,
	      showClearCoatRoughness,
	      clearCoatRoughness,
	      showVertexColors,
	      vertexColors,
	      showSkinning,
	      skinning,
	      showMap,
	      map,
	      showAlphaMap,
	      alphaMap,
	      showBumpMap,
	      bumpMap,
	      bumpScale,
	      showNormalMap,
	      normalMap,
	      showDisplacementMap,
	      displacementMap,
	      displacementScale,
	      showRoughnessMap,
	      roughnessMap,
	      showMetalnessMap,
	      metalnessMap,
	      showSpecularMap,
	      specularMap,
	      showEnvMap,
	      envMap,
	      envMapIntensity,
	      showLightMap,
	      lightMap,
	      showAoMap,
	      aoMap,
	      aoScale,
	      showEmissiveMap,
	      emissiveMap,
	      side,
	      flatShading,
	      blending,
	      opacity,
	      transparent,
	      alphaTest,
	      wireframe,
	      wireframeLinewidth
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Material Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(ButtonsProperty, {
	      label: ''
	    }, /*#__PURE__*/React.createElement(Button, {
	      show: !enableAuthority || authorities.includes('SAVE_MATERIAL'),
	      onClick: this.onSave
	    }, _t('Save')), /*#__PURE__*/React.createElement(Button, {
	      show: !enableAuthority || authorities.includes('LIST_MATERIAL'),
	      onClick: this.onLoad
	    }, _t('Select'))), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Type'),
	      options: this.materials,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(ButtonProperty, {
	      label: _t('ShaderInfo'),
	      text: _t('Edit'),
	      show: showProgram,
	      onChange: this.editProgramInfo
	    }), /*#__PURE__*/React.createElement(ButtonProperty, {
	      label: _t('Vertex Shader'),
	      text: _t('Edit'),
	      show: showProgram,
	      onChange: this.editVertexShader
	    }), /*#__PURE__*/React.createElement(ButtonProperty, {
	      label: _t('Frag Shader'),
	      text: _t('Edit'),
	      show: showProgram,
	      onChange: this.editFragmentShader
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: _t('Color'),
	      name: 'color',
	      value: color,
	      show: showColor,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Roughness'),
	      name: 'roughness',
	      value: roughness,
	      show: showRoughness,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MetalNess'),
	      name: 'metalness',
	      value: metalness,
	      show: showMetalness,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: _t('Emissive'),
	      name: 'emissive',
	      value: emissive,
	      show: showEmissive,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: _t('Specular'),
	      name: 'specular',
	      value: specular,
	      show: showSpecular,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Shininess'),
	      name: 'shininess',
	      value: shininess,
	      show: showShininess,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('ClearCoat'),
	      name: 'clearCoat',
	      value: clearCoat,
	      show: showClearCoat,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('ClearCoatRoughness'),
	      name: 'clearCoatRoughness',
	      value: clearCoatRoughness,
	      show: showClearCoatRoughness,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Vertex Color'),
	      options: this.vertexColors,
	      name: 'vertexColors',
	      value: vertexColors,
	      show: showVertexColors,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Skin'),
	      name: 'skinning',
	      value: skinning,
	      show: showSkinning,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('Map'),
	      name: 'map',
	      value: map,
	      show: showMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(ButtonProperty, {
	      text: _t('Texture Settings'),
	      onChange: this.handleTextureSetting
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('AlphaMap'),
	      name: 'alphaMap',
	      value: alphaMap,
	      show: showAlphaMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('BumpMap'),
	      name: 'bumpMap',
	      value: bumpMap,
	      show: showBumpMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Bump Scale'),
	      name: 'bumpScale',
	      value: bumpScale,
	      show: showBumpMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('NormalMap'),
	      name: 'normalMap',
	      value: normalMap,
	      show: showNormalMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('DisplacementMap'),
	      name: 'displacementMap',
	      value: displacementMap,
	      show: showDisplacementMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Displace Scale'),
	      name: 'displacementScale',
	      value: displacementScale,
	      show: showDisplacementMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('RoughnessMap'),
	      name: 'roughnessMap',
	      value: roughnessMap,
	      show: showRoughnessMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('MetalnessMap'),
	      name: 'metalnessMap',
	      value: metalnessMap,
	      show: showMetalnessMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('SpecularMap'),
	      name: 'specularMap',
	      value: specularMap,
	      show: showSpecularMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('EnvMap'),
	      name: 'envMap',
	      value: envMap,
	      show: showEnvMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('EnvMapIntensity'),
	      name: 'envMapIntensity',
	      value: envMapIntensity,
	      show: showEnvMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('LightMap'),
	      name: 'lightMap',
	      value: lightMap,
	      show: showLightMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('AoMap'),
	      name: 'aoMap',
	      value: aoMap,
	      show: showAoMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Ao Scale'),
	      name: 'aoScale',
	      value: aoScale,
	      show: showAoMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('EmissiveMap'),
	      name: 'emissiveMap',
	      value: emissiveMap,
	      show: showEmissiveMap,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Side'),
	      options: this.side,
	      name: 'side',
	      value: side,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Flat Shading'),
	      name: 'flatShading',
	      value: flatShading,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Blending'),
	      options: this.blending,
	      name: 'blending',
	      value: blending,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Opacity'),
	      name: 'opacity',
	      value: opacity,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Transparent'),
	      name: 'transparent',
	      value: transparent,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('AlphaTest'),
	      name: 'alphaTest',
	      value: alphaTest,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Wireframe'),
	      name: 'wireframe',
	      value: wireframe,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('WireWidth'),
	      name: 'wireframeLinewidth',
	      value: wireframeLinewidth,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.MaterialComponent`, this.handleUpdate);
	    app.on(`objectChanged.MaterialComponent`, this.handleUpdate);
	    app.on(`currentMaterialChange.MaterialComponent`, this.handleCurrentMaterialChange); // 多材质组件
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !editor.selected.material) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    if (Array.isArray(editor.selected.material)) {
	      // 多材质模型，由多材质组件选择。
	      return;
	    }

	    this.selected = editor.selected;
	    this.materialIndex = 0;
	    this.material = this.selected.material;
	    this.handleMaterial(this.material);
	  }

	  handleCurrentMaterialChange(material, index, materials, selected) {
	    // 多材质组件材质改变
	    this.selected = selected;
	    this.materialIndex = index;
	    this.handleMaterial(material);
	  }

	  handleMaterial(material) {
	    let state = {
	      show: true,
	      type: material.type,
	      showProgram: material instanceof THREE.ShaderMaterial || material instanceof THREE.RawShaderMaterial
	    };

	    if (material.color) {
	      state.showColor = true;
	      state.color = `#${material.color.getHexString()}`;
	    } else {
	      state.showColor = false;
	    }

	    if (material.roughness !== undefined) {
	      state.showRoughness = true;
	      state.roughness = material.roughness;
	    } else {
	      state.showRoughness = false;
	    }

	    if (material.metalness !== undefined) {
	      state.showMetalness = true;
	      state.metalness = material.metalness;
	    } else {
	      state.showMetalness = false;
	    }

	    if (material.emissive !== undefined) {
	      state.showEmissive = true;
	      state.emissive = `#${material.emissive.getHexString()}`;
	    } else {
	      state.showEmissive = false;
	    }

	    if (material.specular !== undefined) {
	      state.showSpecular = true;
	      state.specular = `#${material.specular.getHexString()}`;
	    } else {
	      state.showSpecular = false;
	    }

	    if (material.shininess !== undefined) {
	      state.showShininess = true;
	      state.shininess = material.shininess;
	    } else {
	      state.showShininess = false;
	    }

	    if (material.clearCoat !== undefined) {
	      state.showClearCoat = true;
	      state.clearCoat = material.clearCoat;
	    } else {
	      state.showClearCoat = false;
	    }

	    if (material.clearCoatRoughness !== undefined) {
	      state.showClearCoatRoughness = true;
	      state.clearCoatRoughness = material.clearCoatRoughness;
	    } else {
	      state.showClearCoatRoughness = false;
	    }

	    if (material.vertexColors !== undefined) {
	      state.showVertexColors = true;
	      state.vertexColors = material.vertexColors;
	    } else {
	      state.showVertexColors = false;
	    }

	    if (material.skinning !== undefined) {
	      state.showSkinning = true;
	      state.skinning = material.skinning;
	    } else {
	      state.showSkinning = false;
	    }

	    if (material.map !== undefined) {
	      state.showMap = true;
	      state.map = material.map;
	    } else {
	      state.showMap = false;
	    }

	    if (material.alphaMap !== undefined) {
	      state.showAlphaMap = true;
	      state.alphaMap = material.alphaMap;
	    } else {
	      state.showAlphaMap = false;
	    }

	    if (material.bumpMap !== undefined) {
	      state.showBumpMap = true;
	      state.bumpMap = material.bumpMap;
	      state.bumpScale = material.bumpScale;
	    } else {
	      state.showBumpMap = false;
	    }

	    if (material.normalMap !== undefined) {
	      state.showNormalMap = true;
	      state.normalMap = material.normalMap;
	    } else {
	      state.showNormalMap = false;
	    }

	    if (material.displacementMap !== undefined) {
	      state.showDisplacementMap = true;
	      state.displacementMap = material.displacementMap;
	      state.displacementScale = material.displacementScale;
	    } else {
	      state.showDisplacementMap = false;
	    }

	    if (material.roughnessMap !== undefined) {
	      state.showRoughnessMap = true;
	      state.roughnessMap = material.roughnessMap;
	    } else {
	      state.showRoughnessMap = false;
	    }

	    if (material.metalnessMap !== undefined) {
	      state.showMetalnessMap = true;
	      state.metalnessMap = material.metalnessMap;
	    } else {
	      state.showMetalnessMap = false;
	    }

	    if (material.specularMap !== undefined) {
	      state.showSpecularMap = true;
	      state.specularMap = material.specularMap;
	    } else {
	      state.showSpecularMap = false;
	    }

	    if (material.envMap !== undefined) {
	      state.showEnvMap = true;
	      state.envMap = material.envMap;

	      if (material.envMapIntensity !== undefined) {
	        state.envMapIntensity = material.envMapIntensity;
	      }
	    } else {
	      state.showEnvMap = false;
	    }

	    if (material.lightMap !== undefined) {
	      state.showLightMap = true;
	      state.lightMap = material.lightMap;
	    } else {
	      state.showLightMap = false;
	    }

	    if (material.aoMap !== undefined) {
	      state.showAoMap = true;
	      state.aoMap = material.aoMap;
	      state.aoScale = material.aoMapIntensity;
	    } else {
	      state.showAoMap = false;
	    }

	    if (material.emissiveMap !== undefined) {
	      state.showEmissiveMap = true;
	      state.emissiveMap = material.emissiveMap;
	    } else {
	      state.showEmissiveMap = false;
	    }

	    if (material.side !== undefined) {
	      state.side = material.side;
	    }

	    if (material.flatShading !== undefined) {
	      state.flatShading = material.flatShading;
	    }

	    if (material.blending !== undefined) {
	      state.blending = material.blending;
	    }

	    if (material.opacity !== undefined) {
	      state.opacity = material.opacity;
	    }

	    if (material.transparent !== undefined) {
	      state.transparent = material.transparent;
	    }

	    if (material.alphaTest !== undefined) {
	      state.alphaTest = material.alphaTest;
	    }

	    if (material.wireframe !== undefined) {
	      state.wireframe = material.wireframe;
	    }

	    if (material.wireframeLinewidth !== undefined) {
	      state.wireframeLinewidth = material.wireframeLinewidth;
	    }

	    this.setState(state);
	  }

	  handleChange(value, name) {
	    // 当name是纹理时，value为null表示不显示纹理，不应该跳过。
	    if (value === null && this.mapNames.indexOf(name) === -1) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const editor = app.editor;
	    let object = this.selected;
	    let material = this.material;
	    const {
	      type,
	      color,
	      roughness,
	      metalness,
	      emissive,
	      specular,
	      shininess,
	      clearCoat,
	      clearCoatRoughness,
	      vertexColors,
	      skinning,
	      map,
	      alphaMap,
	      bumpMap,
	      bumpScale,
	      normalMap,
	      displacementMap,
	      displacementScale,
	      roughnessMap,
	      metalnessMap,
	      specularMap,
	      envMap,
	      envMapIntensity,
	      lightMap,
	      aoMap,
	      aoScale,
	      emissiveMap,
	      side,
	      flatShading,
	      blending,
	      opacity,
	      transparent,
	      alphaTest,
	      wireframe,
	      wireframeLinewidth
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (material instanceof THREE[type] === false) {
	      material = new THREE[type]();

	      if (material instanceof THREE.ShaderMaterial) {
	        material.uniforms = {
	          time: {
	            value: 1.0
	          }
	        };
	        material.vertexShader = ShaderMaterialVertex;
	        material.fragmentShader = ShaderMaterialFragment;
	      }

	      if (material instanceof THREE.RawShaderMaterial) {
	        material.uniforms = {
	          time: {
	            value: 1.0
	          }
	        };
	        material.vertexShader = RawShaderMaterialVertex;
	        material.fragmentShader = RawShaderMaterialFragment;
	      }

	      editor.execute(new SetMaterialCommand(object, material), _t('New Material') + ':' + type);
	    }

	    if (material.color !== undefined && `#${material.color.getHexString()}` !== color) {
	      editor.execute(new SetMaterialColorCommand(object, 'color', color));
	    }

	    if (material.roughness !== undefined && Math.abs(material.roughness - roughness) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'roughness', roughness));
	    }

	    if (material.metalness !== undefined && Math.abs(material.metalness - metalness) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'metalness', metalness));
	    }

	    if (material.emissive !== undefined && `#${material.emissive.getHexString()}` !== emissive) {
	      editor.execute(new SetMaterialColorCommand(object, 'emissive', emissive));
	    } // bug: 切换材质时，由于新材质有specular属性，旧材质没有specular属性，可能会导致报错。


	    if (material.specular !== undefined && `#${material.specular.getHexString()}` !== specular && specular !== null) {
	      editor.execute(new SetMaterialValueCommand(object, 'specular', specular));
	    }

	    if (material.shininess !== undefined && Math.abs(material.shininess - shininess) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'shininess', shininess));
	    }

	    if (material.clearCoat !== undefined && Math.abs(material.clearCoat - clearCoat) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'clearCoat', clearCoat));
	    }

	    if (material.clearCoatRoughness !== undefined && Math.abs(material.clearCoatRoughness - clearCoatRoughness) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'clearCoatRoughness', clearCoatRoughness));
	    }

	    if (material.vertexColors !== undefined && material.vertexColors !== vertexColors) {
	      editor.execute(new SetMaterialValueCommand(object, 'vertexColors', vertexColors));
	    }

	    if (material.skinning !== undefined && material.skinning !== skinning) {
	      editor.execute(new SetMaterialValueCommand(object, 'skinning', skinning));
	    }

	    if (name === 'map' && material.map !== undefined) {
	      if (material.map !== map) {
	        editor.execute(new SetMaterialMapCommand(object, 'map', map));
	      }
	    }

	    if (name === 'alphaMap' && material.alphaMap !== undefined) {
	      if (material.alphaMap !== alphaMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'alphaMap', alphaMap));
	      }
	    }

	    if (name === 'bumpMap' && material.bumpMap !== undefined) {
	      if (material.bumpMap !== bumpMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'bumpMap', bumpMap));
	      }
	    }

	    if (name === 'bumpScale' && material.bumpScale !== undefined) {
	      editor.execute(new SetMaterialValueCommand(object, 'bumpScale', bumpScale));
	    }

	    if (name === 'normalMap' && material.normalMap !== undefined) {
	      if (material.normalMap !== normalMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'normalMap', normalMap));
	      }
	    }

	    if (name === 'displacementMap' && material.displacementMap !== undefined) {
	      if (material.displacementMap !== displacementMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'displacementMap', displacementMap));
	      }
	    }

	    if (name === 'displacementScale' && material.displacementScale !== undefined) {
	      editor.execute(new SetMaterialValueCommand(object, 'displacementScale', displacementScale));
	    }

	    if (name === 'roughnessMap' && material.roughnessMap !== undefined) {
	      if (material.roughnessMap !== roughnessMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'roughnessMap', roughnessMap));
	      }
	    }

	    if (name === 'metalnessMap' && material.metalnessMap !== undefined) {
	      if (material.metalnessMap !== metalnessMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'metalnessMap', metalnessMap));
	      }
	    }

	    if (name === 'specularMap' && material.specularMap !== undefined) {
	      if (material.specularMap !== specularMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'specularMap', specularMap));
	      }
	    }

	    if (name === 'envMap' && material.envMap !== undefined) {
	      if (material.envMap !== envMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'envMap', envMap));
	      }
	    }

	    if (name === 'envMapIntensity' && material.envMapIntensity !== undefined) {
	      editor.execute(new SetMaterialValueCommand(object, 'envMapIntensity', envMapIntensity));
	    }

	    if (name === 'lightMap' && material.lightMap !== undefined) {
	      if (material.lightMap !== lightMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'lightMap', lightMap));
	      }
	    }

	    if (name === 'aoMap' && material.aoMap !== undefined) {
	      if (material.aoMap !== aoMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'aoMap', aoMap));
	      }
	    }

	    if (name === 'aoScale' && material.aoMapIntensity !== undefined) {
	      editor.execute(new SetMaterialValueCommand(object, 'aoMapIntensity', aoScale));
	    }

	    if (name === 'emissiveMap' && material.emissiveMap !== undefined) {
	      if (material.emissiveMap !== emissiveMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'emissiveMap', emissiveMap));
	      }
	    }

	    if (material.side !== undefined && material.side !== side) {
	      editor.execute(new SetMaterialValueCommand(object, 'side', side));
	    }

	    if (material.flatShading !== undefined && material.flatShading !== flatShading) {
	      editor.execute(new SetMaterialValueCommand(object, 'flatShading', flatShading));
	    }

	    if (material.blending !== undefined && material.blending !== blending) {
	      editor.execute(new SetMaterialValueCommand(object, 'blending', blending));
	    }

	    if (material.opacity !== undefined && Math.abs(material.opacity - opacity) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'opacity', opacity));
	    }

	    if (material.transparent !== undefined && material.transparent !== transparent) {
	      editor.execute(new SetMaterialValueCommand(object, 'transparent', transparent));
	    }

	    if (material.alphaTest !== undefined && Math.abs(material.alphaTest - alphaTest) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'alphaTest', alphaTest));
	    }

	    if (material.wireframe !== undefined && material.wireframe !== wireframe) {
	      editor.execute(new SetMaterialValueCommand(object, 'wireframe', wireframe));
	    }

	    if (material.wireframeLinewidth !== undefined && Math.abs(material.wireframeLinewidth - wireframeLinewidth) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'wireframeLinewidth', wireframeLinewidth));
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleTextureSetting() {
	    if (!this.material.map) {
	      app.toast(_t('Please select texture first.'), 'warn');
	      return;
	    }

	    let win = app.createElement(TextureSettingWindow, {
	      map: this.material.map
	    });
	    app.addElement(win);
	  }

	  editProgramInfo() {
	    let material = this.material;
	    let obj = {
	      defines: material.defines,
	      uniforms: material.uniforms,
	      attributes: material.attributes
	    };
	    app.call(`editScript`, this, material.uuid, this.selected.name + '-ProgramInfo', 'json', JSON.stringify(obj), this.saveProgramInfo);
	  }

	  saveProgramInfo(uuid, name, type, source) {
	    let material = this.material;

	    try {
	      let obj = JSON.parse(source);
	      material.defines = obj.defines;
	      material.uniforms = obj.uniforms;
	      material.attributes = obj.attributes;
	      material.needsUpdate = true;
	    } catch (e) {
	      app.error(this.selected.name + `-${_t('Shader cannot be parsed.')}`);
	    }
	  }

	  editVertexShader() {
	    let material = this.material;
	    app.call(`editScript`, this, material.uuid, this.selected.name + '-VertexShader', 'vertexShader', material.vertexShader, this.saveVertexShader);
	  }

	  saveVertexShader(uuid, name, type, source) {
	    let material = this.material;
	    material.vertexShader = source;
	    material.needsUpdate = true;
	  }

	  editFragmentShader() {
	    let material = this.material;
	    app.call(`editScript`, this, material.uuid, this.selected.name + '-FragmentShader', 'fragmentShader', material.fragmentShader, this.saveFragmentShader);
	  }

	  saveFragmentShader(uuid, name, type, source) {
	    let material = this.material;
	    material.fragmentShader = source;
	    material.needsUpdate = true;
	  } // --------------------------------------- 材质保存载入 --------------------------------------------------


	  onSave() {
	    app.prompt({
	      title: _t('Please enter material name'),
	      content: _t('Name'),
	      value: _t('New Material'),
	      onOK: value => {
	        this.commitSave(value);
	      }
	    });
	  }

	  commitSave(name) {
	    const material = this.material;
	    const data = new MaterialsSerializer().toJSON(material); // 材质球图片

	    const dataURL = MaterialUtils.createMaterialImage(material).toDataURL('image/png');
	    const file = Converter$1.dataURLtoFile(dataURL, name); // 上传图片

	    Ajax.post(`${app.options.server}/api/Upload/Upload`, {
	      file: file
	    }, result => {
	      let obj = JSON.parse(result);

	      if (obj.Code === 300) {
	        app.toast(_t(obj.Msg));
	        return;
	      }

	      Ajax.post(`${app.options.server}/api/Material/Save`, {
	        Name: name,
	        Data: JSON.stringify(data),
	        Thumbnail: obj.Data.url
	      }, result => {
	        obj = JSON.parse(result);

	        if (obj.Code === 200) {
	          // TODO: 保存材质时，没有刷新材质面板。
	          app.call(`showBottomPanel`, this, 'material');
	        }

	        app.toast(_t(obj.Msg));
	      });
	    });
	  }

	  onLoad() {
	    app.call(`selectBottomPanel`, this, 'material');
	    app.toast(_t('Please click material on material panel.'));
	    app.on(`selectMaterial.MaterialComponent`, this.onWaitingForMaterial.bind(this));
	  }

	  onWaitingForMaterial(material) {
	    app.on(`selectMaterial.MaterialComponent`, null);

	    if (this.material) {
	      this.material.dispose();
	    }

	    if (Array.isArray(this.selected.material)) {
	      this.selected.material[this.materialIndex] = material;
	    } else {
	      this.selected.material = material;
	    }

	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * MMD模型组件
	 * @author tengge / https://github.com/tengge1
	 */

	class MMDComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      animation: null,
	      cameraAnimation: null,
	      audio: null
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleSelectAnimation = this.handleSelectAnimation.bind(this);
	    this.onSelectAnimation = this.onSelectAnimation.bind(this);
	    this.handleSelectCameraAnimation = this.handleSelectCameraAnimation.bind(this);
	    this.onSelectCameraAnimation = this.onSelectCameraAnimation.bind(this);
	    this.handleSelectAudio = this.handleSelectAudio.bind(this);
	    this.onSelectAudio = this.onSelectAudio.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      animation,
	      cameraAnimation,
	      audio
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('MMD Model'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('Model Animation'),
	      name: 'animation',
	      value: animation,
	      btnShow: true,
	      btnText: _t('Select'),
	      onClick: this.handleSelectAnimation
	    }), /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('Camera Animation'),
	      name: 'cameraAnimation',
	      value: cameraAnimation,
	      btnShow: true,
	      btnText: _t('Select'),
	      onClick: this.handleSelectCameraAnimation
	    }), /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('Audio'),
	      name: 'audio',
	      value: audio,
	      btnShow: true,
	      btnText: _t('Select'),
	      onClick: this.handleSelectAudio
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.MMDComponent`, this.handleUpdate);
	    app.on(`objectChanged.MMDComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.Type === 'pmd' || editor.selected.userData.Type === 'pmx')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let state = {
	      show: true,
	      animation: this.selected.userData.Animation ? this.selected.userData.Animation.Name : null,
	      cameraAnimation: this.selected.userData.CameraAnimation ? this.selected.userData.CameraAnimation.Name : null,
	      audio: this.selected.userData.Audio ? this.selected.userData.Audio.Name : null
	    };
	    this.setState(state);
	  } // ----------------------------- 模型动画 ------------------------------------------


	  handleSelectAnimation() {
	    app.call(`selectBottomPanel`, this, 'animation');
	    app.toast(_t('Please click the animation in the animation panel.'));
	    app.on(`selectAnimation.MMDComponent`, this.onSelectAnimation);
	  }

	  onSelectAnimation(data) {
	    if (data.Type !== 'mmd') {
	      app.toast(_t('Please select MMD animation only.'), 'warn');
	      return;
	    }

	    app.on(`selectAnimation.MMDComponent`, null);
	    this.selected.userData.Animation = {};
	    Object.assign(this.selected.userData.Animation, data);
	    app.call(`objectChanged`, this, this.selected);
	  } // ---------------------------- 相机动画 -------------------------------------------


	  handleSelectCameraAnimation() {
	    app.call(`selectBottomPanel`, this, 'animation');
	    app.toast(_t('Please select camera animation.'));
	    app.on(`selectAnimation.MMDComponent`, this.onSelectCameraAnimation);
	  }

	  onSelectCameraAnimation(data) {
	    if (data.Type !== 'mmd') {
	      app.toast(_t('Please select camera animation only.'), 'warn');
	      return;
	    }

	    app.on(`selectAnimation.MMDComponent`, null);
	    this.selected.userData.CameraAnimation = {};
	    Object.assign(this.selected.userData.CameraAnimation, data);
	    app.call(`objectChanged`, this, this.selected);
	  } // ------------------------------ MMD音乐 --------------------------------------------


	  handleSelectAudio() {
	    app.call(`selectBottomPanel`, this, 'audio');
	    app.toast(_t('Please select MMD audio.'));
	    app.on(`selectAudio.MMDComponent`, this.onSelectAudio.bind(this));
	  }

	  onSelectAudio(data) {
	    app.on(`selectAudio.MMDComponent`, null);
	    this.selected.userData.Audio = {};
	    Object.assign(this.selected.userData.Audio, data);
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 粒子发射器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class ParticleEmitterComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      positionX: 0,
	      positionY: 0,
	      positionZ: 0,
	      positionSpreadX: 0,
	      positionSpreadY: 0,
	      positionSpreadZ: 0,
	      velocityX: 0,
	      velocityY: 0,
	      velocityZ: 0,
	      velocitySpreadX: 0,
	      velocitySpreadY: 0,
	      velocitySpreadZ: 0,
	      accelerationX: 0,
	      accelerationY: 0,
	      accelerationZ: 0,
	      accelerationSpreadX: 0,
	      accelerationSpreadY: 0,
	      accelerationSpreadZ: 0,
	      color1: null,
	      color2: null,
	      color3: null,
	      color4: null,
	      size: 1,
	      sizeSpread: 0,
	      texture: null,
	      particleCount: 1000,
	      maxAge: 5,
	      maxAgeSpread: 2,
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangePosition = this.handleChangePosition.bind(this);
	    this.handleChangeVelocity = this.handleChangeVelocity.bind(this);
	    this.handleChangeAcceleration = this.handleChangeAcceleration.bind(this);
	    this.handleChangeColor = this.handleChangeColor.bind(this);
	    this.handleChangeSize = this.handleChangeSize.bind(this);
	    this.handleChangeTexture = this.handleChangeTexture.bind(this);
	    this.handleChangeParticleCount = this.handleChangeParticleCount.bind(this);
	    this.handleChangeMaxAge = this.handleChangeMaxAge.bind(this);
	    this.handleChangeMaxAgeSpread = this.handleChangeMaxAgeSpread.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.startPreview = this.startPreview.bind(this);
	    this.stopPreview = this.stopPreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      positionX,
	      positionY,
	      positionZ,
	      positionSpreadX,
	      positionSpreadY,
	      positionSpreadZ,
	      velocityX,
	      velocityY,
	      velocityZ,
	      velocitySpreadX,
	      velocitySpreadY,
	      velocitySpreadZ,
	      accelerationX,
	      accelerationY,
	      accelerationZ,
	      accelerationSpreadX,
	      accelerationSpreadY,
	      accelerationSpreadZ,
	      color1,
	      color2,
	      color3,
	      color4,
	      size,
	      sizeSpread,
	      texture,
	      particleCount,
	      maxAge,
	      maxAgeSpread,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('ParticleEmitter'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Position')}X`,
	      name: 'positionX',
	      value: positionX,
	      onChange: this.handleChangePosition
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Position')}Y`,
	      name: 'positionY',
	      value: positionY,
	      onChange: this.handleChangePosition
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Position')}Z`,
	      name: 'positionZ',
	      value: positionZ,
	      onChange: this.handleChangePosition
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('PositionSpread')}X`,
	      name: 'positionSpreadX',
	      value: positionSpreadX,
	      onChange: this.handleChangePosition
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('PositionSpread')}Y`,
	      name: 'positionSpreadY',
	      value: positionSpreadY,
	      onChange: this.handleChangePosition
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('PositionSpread')}Z`,
	      name: 'positionSpreadZ',
	      value: positionSpreadZ,
	      onChange: this.handleChangePosition
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Velocity')}X`,
	      name: 'velocityX',
	      value: velocityX,
	      onChange: this.handleChangeVelocity
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Velocity')}Y`,
	      name: 'velocityY',
	      value: velocityY,
	      onChange: this.handleChangeVelocity
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Velocity')}Z`,
	      name: 'velocityZ',
	      value: velocityZ,
	      onChange: this.handleChangeVelocity
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('VelocitySpread')}X`,
	      name: 'velocitySpreadX',
	      value: velocitySpreadX,
	      onChange: this.handleChangeVelocity
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('VelocitySpread')}Y`,
	      name: 'velocitySpreadY',
	      value: velocitySpreadY,
	      onChange: this.handleChangeVelocity
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('VelocitySpread')}Z`,
	      name: 'velocitySpreadZ',
	      value: velocitySpreadZ,
	      onChange: this.handleChangeVelocity
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Acceleration')}X`,
	      name: 'accelerationX',
	      value: accelerationX,
	      onChange: this.handleChangeAcceleration
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Acceleration')}Y`,
	      name: 'accelerationY',
	      value: accelerationY,
	      onChange: this.handleChangeAcceleration
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Acceleration')}Z`,
	      name: 'accelerationZ',
	      value: accelerationZ,
	      onChange: this.handleChangeAcceleration
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('AccelerationSpread')}X`,
	      name: 'accelerationSpreadX',
	      value: accelerationSpreadX,
	      onChange: this.handleChangeAcceleration
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('AccelerationSpread')}Y`,
	      name: 'accelerationSpreadY',
	      value: accelerationSpreadY,
	      onChange: this.handleChangeAcceleration
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('AccelerationSpread')}Z`,
	      name: 'accelerationSpreadZ',
	      value: accelerationSpreadZ,
	      onChange: this.handleChangeAcceleration
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: `${_t('Color')}1`,
	      name: 'color1',
	      value: color1,
	      onChange: this.handleChangeColor
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: `${_t('Color')}2`,
	      name: 'color2',
	      value: color2,
	      onChange: this.handleChangeColor
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: `${_t('Color')}3`,
	      name: 'color3',
	      value: color3,
	      onChange: this.handleChangeColor
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: `${_t('Color')}4`,
	      name: 'color4',
	      value: color4,
	      onChange: this.handleChangeColor
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Size')}`,
	      name: 'size',
	      value: size,
	      onChange: this.handleChangeSize
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('SizeSpread')}`,
	      name: 'sizeSpread',
	      value: sizeSpread,
	      onChange: this.handleChangeSize
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: `${_t('Texture')}`,
	      name: 'texture',
	      value: texture,
	      onChange: this.handleChangeTexture
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      label: `${_t('ParticleCount')}`,
	      name: 'particleCount',
	      value: particleCount,
	      onChange: this.handleChangeParticleCount
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('MaxAge')}`,
	      name: 'maxAge',
	      value: maxAge,
	      onChange: this.handleChangeMaxAge
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('maxAgeSpread')}`,
	      name: 'maxAgeSpread',
	      value: maxAgeSpread,
	      onChange: this.maxAgeSpread
	    }), /*#__PURE__*/React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.ParticleEmitterComponent`, this.handleUpdate);
	    app.on(`objectChanged.ParticleEmitterComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'ParticleEmitter')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    let state = {
	      show: true,
	      positionX: emitter.position.value.x,
	      positionY: emitter.position.value.y,
	      positionZ: emitter.position.value.z,
	      positionSpreadX: emitter.position.spread.x,
	      positionSpreadY: emitter.position.spread.y,
	      positionSpreadZ: emitter.position.spread.z,
	      velocityX: emitter.velocity.value.x,
	      velocityY: emitter.velocity.value.y,
	      velocityZ: emitter.velocity.value.z,
	      velocitySpreadX: emitter.velocity.spread.x,
	      velocitySpreadY: emitter.velocity.spread.y,
	      velocitySpreadZ: emitter.velocity.spread.z,
	      accelerationX: emitter.acceleration.value.x,
	      accelerationY: emitter.acceleration.value.y,
	      accelerationZ: emitter.acceleration.value.z,
	      accelerationSpreadX: emitter.acceleration.spread.x,
	      accelerationSpreadY: emitter.acceleration.spread.y,
	      accelerationSpreadZ: emitter.acceleration.spread.z,
	      color1: `#${emitter.color.value[0].getHexString()}`,
	      color2: `#${emitter.color.value[1].getHexString()}`,
	      color3: `#${emitter.color.value[2].getHexString()}`,
	      color4: `#${emitter.color.value[3].getHexString()}`,
	      size: emitter.size.value[0],
	      sizeSpread: emitter.size.spread[0],
	      texture: group.texture,
	      particleCount: emitter.particleCount,
	      maxAge: emitter.maxAge.value,
	      maxAgeSpread: emitter.maxAge.spread,
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    };
	    this.setState(state);
	  }

	  handleChangePosition(value, name) {
	    this.setState({
	      [name]: value
	    });

	    if (value === null) {
	      return;
	    }

	    const {
	      positionX,
	      positionY,
	      positionZ,
	      positionSpreadX,
	      positionSpreadY,
	      positionSpreadZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.position.value.x = positionX;
	    emitter.position.value.y = positionY;
	    emitter.position.value.z = positionZ;
	    emitter.position.spread.x = positionSpreadX;
	    emitter.position.spread.y = positionSpreadY;
	    emitter.position.spread.z = positionSpreadZ;
	    emitter.updateFlags.position = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeVelocity(value, name) {
	    this.setState({
	      [name]: value
	    });

	    if (value === null) {
	      return;
	    }

	    const {
	      velocityX,
	      velocityY,
	      velocityZ,
	      velocitySpreadX,
	      velocitySpreadY,
	      velocitySpreadZ
	    } = Object.assign({}, this.selected, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.velocity.value.x = velocityX;
	    emitter.velocity.value.y = velocityY;
	    emitter.velocity.value.z = velocityZ;
	    emitter.velocity.spread.x = velocitySpreadX;
	    emitter.velocity.spread.y = velocitySpreadY;
	    emitter.velocity.spread.z = velocitySpreadZ;
	    emitter.updateFlags.velocity = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeAcceleration(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      accelerationX,
	      accelerationY,
	      accelerationZ,
	      accelerationSpreadX,
	      accelerationSpreadY,
	      accelerationSpreadZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.acceleration.value.x = accelerationX;
	    emitter.acceleration.value.y = accelerationY;
	    emitter.acceleration.value.z = accelerationZ;
	    emitter.acceleration.spread.x = accelerationSpreadX;
	    emitter.acceleration.spread.y = accelerationSpreadY;
	    emitter.acceleration.spread.z = accelerationSpreadZ;
	    emitter.updateFlags.acceleration = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      color1,
	      color2,
	      color3,
	      color4
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.color.value[0] = new THREE.Color(color1);
	    emitter.color.value[1] = new THREE.Color(color2);
	    emitter.color.value[2] = new THREE.Color(color3);
	    emitter.color.value[3] = new THREE.Color(color4);
	    emitter.updateFlags.color = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeSize(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      size,
	      sizeSpread
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];

	    for (var i = 0; i < emitter.size.value.length; i++) {
	      emitter.size.value[i] = size;
	      emitter.size.spread[i] = sizeSpread;
	    }

	    emitter.updateFlags.size = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeTexture(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      texture
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    texture.needsUpdate = true;
	    group.texture = texture;
	    group.material.uniforms.texture.value = texture;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeParticleCount(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      particleCount
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.particleCount = particleCount;
	    emitter.updateFlags.params = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeMaxAge(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      maxAge
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.maxAge.value = maxAge;
	    emitter.updateFlags.params = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeMaxAgeSpread(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      maxAgeSpread
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.maxAge.spread = maxAgeSpread;
	    emitter.updateFlags.params = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    app.on(`animate.ParticleEmitterComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    let group = this.selected.userData.group;
	    let emitter = this.selected.userData.emitter;
	    group.removeEmitter(emitter);
	    group.addEmitter(emitter);
	    group.tick(0);
	    app.on(`animate.ParticleEmitterComponent`, null);
	  }

	  onAnimate(clock, deltaTime) {
	    let group = this.selected.userData.group;
	    group.tick(deltaTime);
	  }

	}

	/**
	 * 反光组件
	 * @author tengge / https://github.com/tengge1
	 */

	class ReflectorComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.sizes = {
	      '512': '512*512',
	      '1024': '1024*1024',
	      '2048': '2048*2048'
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      reflect: false,
	      showColor: false,
	      color: '#ffffff',
	      showSize: false,
	      size: '1024',
	      showClipBias: false,
	      clipBias: 0,
	      showRecursion: false,
	      recursion: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      reflect,
	      showColor,
	      color,
	      showSize,
	      size,
	      showClipBias,
	      clipBias,
	      showRecursion,
	      recursion
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Reflector Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Reflect'),
	      name: 'reflect',
	      value: reflect,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: _t('Color'),
	      name: 'color',
	      value: color,
	      show: showColor,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('TextureSize'),
	      name: 'size',
	      options: this.sizes,
	      value: size,
	      show: showSize,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('ClipBias'),
	      name: 'clipBias',
	      value: clipBias,
	      show: showClipBias,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Recursion'),
	      name: 'recursion',
	      value: recursion,
	      show: showRecursion,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.ReflectorComponent`, this.handleUpdate);
	    app.on(`objectChanged.ReflectorComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let state = {
	      show: true
	    };

	    if (this.selected instanceof THREE.Reflector) {
	      Object.assign(state, {
	        reflect: true,
	        showColor: true,
	        color: this.selected.userData.color,
	        showSize: true,
	        size: this.selected.userData.size,
	        showClipBias: true,
	        clipBias: this.selected.userData.clipBias,
	        showRecursion: true,
	        recursion: this.selected.userData.recursion
	      });
	    } else {
	      Object.assign(state, {
	        reflect: false,
	        showColor: false,
	        showSize: false,
	        showClipBias: false,
	        showRecursion: false
	      });
	    }

	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      reflect,
	      color,
	      size,
	      clipBias,
	      recursion
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let editor = app.editor;

	    if (reflect) {
	      let reflector = new THREE.Reflector(this.selected.geometry, {
	        color: color,
	        textureWidth: parseInt(size),
	        textureHeight: parseInt(size),
	        clipBias: clipBias,
	        recursion: recursion ? 1 : 0
	      });
	      reflector.name = this.selected.name;
	      reflector.position.copy(this.selected.position);
	      reflector.rotation.copy(this.selected.rotation);
	      reflector.scale.copy(this.selected.scale);
	      reflector.castShadow = this.selected.castShadow;
	      reflector.receiveShadow = this.selected.receiveShadow;

	      if (this.selected instanceof THREE.Reflector) {
	        Object.assign(reflector.userData, this.selected.userData);
	      } else {
	        Object.assign(reflector.userData, this.selected.userData, {
	          mesh: this.selected
	        });
	      }

	      reflector.userData.color = color;
	      reflector.userData.size = size;
	      reflector.userData.clipBias = clipBias;
	      reflector.userData.recursion = recursion;
	      var index = editor.scene.children.indexOf(this.selected);

	      if (index > -1) {
	        editor.scene.children[index] = reflector;
	        reflector.parent = this.selected.parent;
	        editor.select(null);
	        this.selected.parent = null;
	        app.call(`objectRemoved`, this, this.selected);
	        app.call(`objectAdded`, this, reflector);
	        editor.select(reflector);
	      }
	    } else {
	      if (this.selected instanceof THREE.Reflector) {
	        let mesh = this.selected.userData.mesh;
	        this.selected.userData.mesh = null;
	        mesh.name = this.selected.name;
	        mesh.position.copy(this.selected.position);
	        mesh.rotation.copy(this.selected.rotation);
	        mesh.scale.copy(this.selected.scale);
	        mesh.castShadow = this.selected.castShadow;
	        mesh.receiveShadow = this.selected.receiveShadow;

	        if (!Array.isArray(mesh.material) && mesh.material.color) {
	          mesh.material.color = new THREE.Color(color);
	        }

	        Object.assign(mesh.userData, this.selected.userData);
	        let index = editor.scene.children.indexOf(this.selected);

	        if (index > -1) {
	          editor.scene.children[index] = mesh;
	          mesh.parent = this.selected.parent;
	          this.selected.parent = null;
	          app.call(`objectRemoved`, this, this.selected);
	          app.call(`objectAdded`, this, mesh);
	          editor.select(mesh);
	        }
	      }
	    }
	  }

	}

	/**
	 * 场景组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SceneComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.backgroundType = {
	      'Color': _t('Solid Color'),
	      'Image': _t('Background Image'),
	      'SkyBox': _t('Cube Texture')
	    };
	    this.fogType = {
	      'None': _t('None'),
	      'Fog': _t('Linear'),
	      'FogExp2': _t('Exponential')
	    };
	    this.state = {
	      show: false,
	      expanded: true,
	      backgroundType: 'Color',
	      backgroundColor: '#aaaaaa',
	      backgroundColorShow: false,
	      backgroundImage: null,
	      backgroundImageShow: false,
	      backgroundPosX: null,
	      backgroundNegX: null,
	      backgroundPosY: null,
	      backgroundNegY: null,
	      backgroundPosZ: null,
	      backgroundNegZ: null,
	      backgroundCubeTextureShow: false,
	      fogType: 'None',
	      fogColor: '#aaaaaa',
	      fogColorShow: false,
	      fogNear: 0.1,
	      fogNearShow: false,
	      fogFar: 50,
	      fogFarShow: false,
	      fogDensity: 0.05,
	      fogDensityShow: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangeBackgroundType = this.handleChangeBackgroundType.bind(this);
	    this.handleChangeBackgroundColor = this.handleChangeBackgroundColor.bind(this);
	    this.handleChangeBackgroundImage = this.handleChangeBackgroundImage.bind(this);
	    this.handleChangeBackgroundCubeTexture = this.handleChangeBackgroundCubeTexture.bind(this);
	    this.handleLoadCubeTexture = this.handleLoadCubeTexture.bind(this);
	    this.handleSelectCubeMap = this.handleSelectCubeMap.bind(this);
	    this.handleSaveCubeTexture = this.handleSaveCubeTexture.bind(this);
	    this.handleChangeFogType = this.handleChangeFogType.bind(this);
	    this.handleChangeFogColor = this.handleChangeFogColor.bind(this);
	    this.handleChangeFogNear = this.handleChangeFogNear.bind(this);
	    this.handleChangeFogFar = this.handleChangeFogFar.bind(this);
	    this.handleChangeFogDensity = this.handleChangeFogDensity.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      backgroundType,
	      backgroundColor,
	      backgroundColorShow,
	      backgroundImage,
	      backgroundImageShow,
	      backgroundPosX,
	      backgroundNegX,
	      backgroundPosY,
	      backgroundNegY,
	      backgroundPosZ,
	      backgroundNegZ,
	      backgroundCubeTextureShow,
	      fogType,
	      fogColor,
	      fogColorShow,
	      fogNear,
	      fogNearShow,
	      fogFar,
	      fogFarShow,
	      fogDensity,
	      fogDensityShow
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('SceneComponent'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Background'),
	      name: 'backgroundType',
	      options: this.backgroundType,
	      value: backgroundType,
	      onChange: this.handleChangeBackgroundType
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: _t('BackgroundColor'),
	      name: 'backgroundColor',
	      value: backgroundColor,
	      show: backgroundColorShow,
	      onChange: this.handleChangeBackgroundColor
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('Background Image'),
	      name: 'backgroundImage',
	      value: backgroundImage,
	      show: backgroundImageShow,
	      onChange: this.handleChangeBackgroundImage
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('PosX'),
	      name: 'backgroundPosX',
	      value: backgroundPosX,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('NegX'),
	      name: 'backgroundNegX',
	      value: backgroundNegX,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('PosY'),
	      name: 'backgroundPosY',
	      value: backgroundPosY,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('NegY'),
	      name: 'backgroundNegY',
	      value: backgroundNegY,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('PosZ'),
	      name: 'backgroundPosZ',
	      value: backgroundPosZ,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), /*#__PURE__*/React.createElement(TextureProperty, {
	      label: _t('NegZ'),
	      name: 'backgroundNegZ',
	      value: backgroundNegZ,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), /*#__PURE__*/React.createElement(ButtonsProperty, {
	      show: backgroundCubeTextureShow
	    }, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleLoadCubeTexture
	    }, _t('Select')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSaveCubeTexture
	    }, _t('Upload'))), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Fog'),
	      name: 'fogType',
	      options: this.fogType,
	      value: fogType,
	      onChange: this.handleChangeFogType
	    }), /*#__PURE__*/React.createElement(ColorProperty, {
	      label: _t('FogColor'),
	      name: 'fogColor',
	      value: fogColor,
	      show: fogColorShow,
	      onChange: this.handleChangeFogColor
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('FogNear'),
	      name: 'fogNear',
	      value: fogNear,
	      show: fogNearShow,
	      onChange: this.handleChangeFogNear
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('FogFar'),
	      name: 'fogFar',
	      value: fogFar,
	      show: fogFarShow,
	      onChange: this.handleChangeFogFar
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('FogDensity'),
	      name: 'fogDensity',
	      value: fogDensity,
	      show: fogDensityShow,
	      onChange: this.handleChangeFogDensity
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SceneComponent`, this.handleUpdate);
	    app.on(`objectChanged.SceneComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== app.editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const background = this.selected.background;
	    const fog = this.selected.fog;
	    const {
	      backgroundColor,
	      fogColor,
	      fogNear,
	      fogFar,
	      fogDensity
	    } = this.state;
	    let state = {
	      show: true,
	      // 背景
	      backgroundType: background instanceof THREE.CubeTexture ? 'SkyBox' : background instanceof THREE.Texture ? 'Image' : 'Color',
	      backgroundColor: background instanceof THREE.Color ? `#${background.getHexString()}` : backgroundColor,
	      backgroundColorShow: background instanceof THREE.Color,
	      backgroundImage: background instanceof THREE.Texture && !(background instanceof THREE.CubeTexture) ? background : null,
	      backgroundImageShow: background instanceof THREE.Texture && !(background instanceof THREE.CubeTexture),
	      backgroundPosX: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[0]) : null,
	      backgroundNegX: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[1]) : null,
	      backgroundPosY: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[2]) : null,
	      backgroundNegY: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[3]) : null,
	      backgroundPosZ: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[4]) : null,
	      backgroundNegZ: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[5]) : null,
	      backgroundCubeTextureShow: background instanceof THREE.CubeTexture,
	      // 雾效
	      fogType: fog === null ? 'None' : fog instanceof THREE.FogExp2 ? 'FogExp2' : 'Fog',
	      fogColor: fog === null ? fogColor : `#${fog.color.getHexString()}`,
	      fogColorShow: fog !== null,
	      fogNear: fog instanceof THREE.Fog ? fog.near : fogNear,
	      fogNearShow: fog !== null && fog instanceof THREE.Fog,
	      fogFar: fog instanceof THREE.Fog ? fog.far : fogFar,
	      fogFarShow: fog instanceof THREE.Fog,
	      fogDensity: fog instanceof THREE.FogExp2 ? fog.density : fogDensity,
	      fogDensityShow: fog instanceof THREE.FogExp2
	    };
	    this.setState(state);
	  }

	  handleChangeBackgroundType(value, name) {
	    const {
	      backgroundType,
	      backgroundColor,
	      backgroundImage,
	      backgroundPosX,
	      backgroundNegX,
	      backgroundPosY,
	      backgroundNegY,
	      backgroundPosZ,
	      backgroundNegZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;

	    switch (backgroundType) {
	      case 'Color':
	        scene.background = new THREE.Color(backgroundColor);
	        break;

	      case 'Image':
	        if (backgroundImage) {
	          scene.background = backgroundImage;
	        } else {
	          scene.background = new THREE.Color(backgroundColor);
	          this.setState({
	            [name]: value,
	            backgroundColorShow: false,
	            backgroundImageShow: true,
	            backgroundCubeTextureShow: false
	          });
	          return;
	        }

	        break;

	      case 'SkyBox':
	        if (backgroundPosX && backgroundNegX && backgroundPosY && backgroundNegY && backgroundPosZ && backgroundNegZ) {
	          scene.background = new THREE.CubeTexture([backgroundPosX.image, backgroundNegX.image, backgroundPosY.image, backgroundNegY.image, backgroundPosZ.image, backgroundNegZ.image]);
	          scene.background.needsUpdate = true;
	        } else {
	          scene.background = new THREE.Color(backgroundColor);
	          this.setState({
	            [name]: value,
	            backgroundColorShow: false,
	            backgroundImageShow: false,
	            backgroundCubeTextureShow: true
	          });
	          return;
	        }

	        break;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeBackgroundColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.background = new THREE.Color(value);
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeBackgroundImage(value, name) {
	    if (value === null) {
	      this.selected.background = new THREE.Color(this.state.backgroundColor);
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.background = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeBackgroundCubeTexture(value, name) {
	    if (value === null) {
	      this.selected.background = new THREE.Color(this.state.backgroundColor);
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      backgroundPosX,
	      backgroundNegX,
	      backgroundPosY,
	      backgroundNegY,
	      backgroundPosZ,
	      backgroundNegZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (backgroundPosX && backgroundNegX && backgroundPosY && backgroundNegY && backgroundPosZ && backgroundNegZ) {
	      let scene = this.selected;
	      scene.background = new THREE.CubeTexture([backgroundPosX.image, backgroundNegX.image, backgroundPosY.image, backgroundNegY.image, backgroundPosZ.image, backgroundNegZ.image]);
	      scene.background.needsUpdate = true;
	      app.call(`objectChanged`, this, this.selected);
	    } else {
	      this.setState({
	        [name]: value
	      });
	    }
	  }

	  handleLoadCubeTexture() {
	    app.call(`selectBottomPanel`, this, 'map');
	    app.toast(_t('Please click the map in the Map Panel.'));
	    app.on(`selectMap.SceneComponent`, this.handleSelectCubeMap);
	  }

	  handleSelectCubeMap(model) {
	    if (model.Type !== 'cube') {
	      app.toast(_t('You should select Cube Texture.'));
	      return;
	    }

	    app.on(`selectMap.SceneComponent`, null);
	    var urls = model.Url.split(';');
	    var loader = new THREE.TextureLoader();
	    var promises = urls.map(url => {
	      return new Promise(resolve => {
	        loader.load(`${app.options.server}${url}`, texture => {
	          resolve(texture);
	        }, undefined, error => {
	          console.error(error);
	          app.toast(_t('Cube Texture fetch failed.'), 'warn');
	        });
	      });
	    });
	    let scene = this.selected;
	    Promise.all(promises).then(textures => {
	      scene.background = new THREE.CubeTexture([textures[0].image, textures[1].image, textures[2].image, textures[3].image, textures[4].image, textures[5].image]);
	      scene.background.needsUpdate = true;
	      app.call(`objectChanged`, this, this.selected);
	    });
	  }

	  handleSaveCubeTexture() {
	    const {
	      backgroundPosX,
	      backgroundNegX,
	      backgroundPosY,
	      backgroundNegY,
	      backgroundPosZ,
	      backgroundNegZ
	    } = this.state;

	    if (!backgroundPosX || !backgroundNegX || !backgroundPosY || !backgroundNegY || !backgroundPosZ || !backgroundNegZ) {
	      app.toast(_t('Please upload all the textures before save.'), 'warn');
	      return;
	    }

	    const posXSrc = backgroundPosX.image.src;
	    const negXSrc = backgroundNegX.image.src;
	    const posYSrc = backgroundPosY.image.src;
	    const negYSrc = backgroundNegY.image.src;
	    const posZSrc = backgroundPosZ.image.src;
	    const negZSrc = backgroundNegZ.image.src;

	    if (posXSrc.startsWith('http') || negXSrc.startsWith('http') || posYSrc.startsWith('http') || negYSrc.startsWith('http') || posZSrc.startsWith('http') || negZSrc.startsWith('http')) {
	      app.toast(_t('Cube texture has already been uploaded.'), 'warn');
	      return;
	    }

	    const promises = [Converter$1.dataURLtoFile(posXSrc, 'posX'), Converter$1.dataURLtoFile(negXSrc, 'negX'), Converter$1.dataURLtoFile(posYSrc, 'posY'), Converter$1.dataURLtoFile(negYSrc, 'negY'), Converter$1.dataURLtoFile(posZSrc, 'posZ'), Converter$1.dataURLtoFile(negZSrc, 'negZ')];
	    Promise.all(promises).then(files => {
	      Ajax.post(`${app.options.server}/api/Map/Add`, {
	        posX: files[0],
	        negX: files[1],
	        posY: files[2],
	        negY: files[3],
	        posZ: files[4],
	        negZ: files[5]
	      }, result => {
	        let obj = JSON.parse(result);
	        app.toast(_t(obj.Msg));
	      });
	    });
	  }

	  handleChangeFogType(value, name) {
	    const {
	      fogType,
	      fogColor,
	      fogNear,
	      fogFar,
	      fogDensity
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;

	    switch (fogType) {
	      case 'None':
	        scene.fog = null;
	        break;

	      case 'Fog':
	        scene.fog = new THREE.Fog(fogColor, fogNear, fogFar);
	        break;

	      case 'FogExp2':
	        scene.fog = new THREE.FogExp2(fogColor, fogDensity);
	        break;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeFogColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.fog.color.set(value);
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeFogNear(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.fog.near = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeFogFar(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.fog.far = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeFogDensity(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.fog.density = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 阴影组件
	 * @author tengge / https://github.com/tengge1
	 */

	class ShadowComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.mapSize = {
	      '512': '512*512',
	      '1024': '1024*1024',
	      '2048': '2048*2048',
	      '4096': '4096*4096'
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      castShadow: false,
	      castShadowShow: false,
	      receiveShadow: false,
	      receiveShadowShow: false,
	      shadowRadius: 1,
	      shadowRadiusShow: false,
	      mapSize: 512,
	      mapSizeShow: false,
	      bias: 0,
	      biasShow: false,
	      cameraLeft: -5,
	      cameraRight: 5,
	      cameraTop: 5,
	      cameraBottom: -5,
	      cameraNear: 0.5,
	      cameraFar: 1000,
	      cameraShow: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangeCastShadow = this.handleChangeCastShadow.bind(this);
	    this.handleChangeReceiveShadow = this.handleChangeReceiveShadow.bind(this);
	    this.handleChangeShadowRadius = this.handleChangeShadowRadius.bind(this);
	    this.handleChangeMapSize = this.handleChangeMapSize.bind(this);
	    this.handleChangeBias = this.handleChangeBias.bind(this);
	    this.handleChangeCameraLeft = this.handleChangeCameraLeft.bind(this);
	    this.handleChangeCameraRight = this.handleChangeCameraRight.bind(this);
	    this.handleChangeCameraTop = this.handleChangeCameraTop.bind(this);
	    this.handleChangeCameraBottom = this.handleChangeCameraBottom.bind(this);
	    this.handleChangeCameraNear = this.handleChangeCameraNear.bind(this);
	    this.handleChangeCameraFar = this.handleChangeCameraFar.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      castShadow,
	      castShadowShow,
	      receiveShadow,
	      receiveShadowShow,
	      shadowRadius,
	      shadowRadiusShow,
	      mapSize,
	      mapSizeShow,
	      bias,
	      biasShow,
	      cameraLeft,
	      cameraRight,
	      cameraTop,
	      cameraBottom,
	      cameraNear,
	      cameraFar,
	      cameraShow
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Shadow Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Cast'),
	      name: 'castShadow',
	      value: castShadow,
	      show: castShadowShow,
	      onChange: this.handleChangeCastShadow
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Receive'),
	      name: 'receiveShadow',
	      value: receiveShadow,
	      show: receiveShadowShow,
	      onChange: this.handleChangeReceiveShadow
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Radius'),
	      name: 'shadowRadius',
	      value: shadowRadius,
	      show: shadowRadiusShow,
	      onChange: this.handleChangeShadowRadius
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('MapSize'),
	      options: this.mapSize,
	      name: 'mapSize',
	      value: mapSize.toString(),
	      show: mapSizeShow,
	      onChange: this.handleChangeMapSize
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Bias'),
	      name: 'bias',
	      value: bias,
	      show: biasShow,
	      onChange: this.handleChangeBias
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('CameraLeft'),
	      name: 'cameraLeft',
	      value: cameraLeft,
	      show: cameraShow,
	      onChange: this.handleChangeCameraLeft
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('CameraRight'),
	      name: 'cameraRight',
	      value: cameraRight,
	      show: cameraShow,
	      onChange: this.handleChangeCameraRight
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('CameraTop'),
	      name: 'cameraTop',
	      value: cameraTop,
	      show: cameraShow,
	      onChange: this.handleChangeCameraTop
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('CameraBottom'),
	      name: 'cameraBottom',
	      value: cameraBottom,
	      show: cameraShow,
	      onChange: this.handleChangeCameraBottom
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('CameraNear'),
	      name: 'cameraNear',
	      value: cameraNear,
	      show: cameraShow,
	      onChange: this.handleChangeCameraNear
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('CameraFar'),
	      name: 'cameraFar',
	      value: cameraFar,
	      show: cameraShow,
	      onChange: this.handleChangeCameraFar
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.ShadowComponent`, this.handleUpdate);
	    app.on(`objectChanged.ShadowComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh || editor.selected instanceof THREE.DirectionalLight || editor.selected instanceof THREE.PointLight || editor.selected instanceof THREE.SpotLight)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let state = {
	      show: true,
	      castShadow: this.selected.castShadow,
	      castShadowShow: true
	    };

	    if (this.selected instanceof THREE.Light) {
	      Object.assign(state, {
	        receiveShadowShow: false,
	        shadowRadius: this.selected.shadow.radius,
	        shadowRadiusShow: true,
	        mapSize: this.selected.shadow.mapSize.x,
	        mapSizeShow: true,
	        bias: this.selected.shadow.bias,
	        biasShow: true,
	        cameraLeft: this.selected.shadow.camera.left,
	        cameraRight: this.selected.shadow.camera.right,
	        cameraTop: this.selected.shadow.camera.top,
	        cameraBottom: this.selected.shadow.camera.bottom,
	        cameraNear: this.selected.shadow.camera.near,
	        cameraFar: this.selected.shadow.camera.far,
	        cameraShow: true
	      });
	    } else {
	      Object.assign(state, {
	        receiveShadow: this.selected.receiveShadow,
	        receiveShadowShow: true,
	        shadowRadiusShow: false,
	        mapSizeShow: false,
	        biasShow: false,
	        cameraShow: false
	      });
	    }

	    this.setState(state);
	  }

	  handleChangeCastShadow(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.castShadow = value;

	    if (this.selected instanceof THREE.Mesh) {
	      this.updateMaterial(this.selected.material);
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeReceiveShadow(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.receiveShadow = value;

	    if (this.selected instanceof THREE.Mesh) {
	      this.updateMaterial(this.selected.material);
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeShadowRadius(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.radius = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  updateMaterial(material) {
	    if (Array.isArray(material)) {
	      material.forEach(n => {
	        n.needsUpdate = true;
	      });
	    } else {
	      material.needsUpdate = true;
	    }
	  }

	  handleChangeMapSize(value) {
	    this.selected.shadow.mapSize.x = this.selected.shadow.mapSize.y = parseInt(value);
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeBias(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.bias = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraLeft(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.left = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraRight(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.right = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraTop(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.top = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraBottom(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.bottom = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraNear(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.near = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraFar(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.far = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 烟组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SmokeComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      size: 2,
	      lifetime: 10,
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      size,
	      lifetime,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('SmokeComponent'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Size'),
	      name: 'size',
	      value: size,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('TimeSpan'),
	      name: 'lifetime',
	      value: lifetime,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SmokeComponent`, this.handleUpdate);
	    app.on(`objectChanged.SmokeComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'Smoke')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      size: this.selected.userData.size,
	      lifetime: this.selected.userData.lifetime,
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      size,
	      lifetime
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.size = size;
	    this.selected.userData.lifetime = lifetime;
	    this.selected.material.uniforms.size.value = size;
	    this.selected.material.uniforms.lifetime.value = lifetime;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    app.on(`animate.SmokeComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    app.on(`animate.SmokeComponent`, null);
	  }

	  onAnimate(clock) {
	    const elapsed = clock.elapsedTime;
	    this.selected.update(elapsed);
	  }

	}

	/**
	 * 位移组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TransformComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      positionX: 0.0,
	      positionY: 0.0,
	      positionZ: 0.0,
	      rotationX: 0.0,
	      rotationY: 0.0,
	      rotationZ: 0.0,
	      scaleX: 1.0,
	      scaleY: 1.0,
	      scaleZ: 1.0,
	      scaleLocked: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangePosition = this.handleChangePosition.bind(this);
	    this.handleChangeRotation = this.handleChangeRotation.bind(this);
	    this.handleChangeScale = this.handleChangeScale.bind(this);
	    this.handleChangeScaleLock = this.handleChangeScaleLock.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      positionX,
	      positionY,
	      positionZ,
	      rotationX,
	      rotationY,
	      rotationZ,
	      scaleX,
	      scaleY,
	      scaleZ,
	      scaleLocked
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Transform Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'positionX',
	      label: `${_t('Translate')}X`,
	      value: positionX,
	      onChange: this.handleChangePosition
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'positionY',
	      label: `${_t('Translate')}Y`,
	      value: positionY,
	      onChange: this.handleChangePosition
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'positionZ',
	      label: `${_t('Translate')}Z`,
	      value: positionZ,
	      onChange: this.handleChangePosition
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'rotationX',
	      label: `${_t('Rotate')}X`,
	      value: rotationX,
	      onChange: this.handleChangeRotation
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'rotationY',
	      label: `${_t('Rotate')}Y`,
	      value: rotationY,
	      onChange: this.handleChangeRotation
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'rotationZ',
	      label: `${_t('Rotate')}Z`,
	      value: rotationZ,
	      onChange: this.handleChangeRotation
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'scaleX',
	      label: `${_t('Scale')}X`,
	      value: scaleX,
	      onChange: this.handleChangeScale
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'scaleY',
	      label: `${_t('Scale')}Y`,
	      value: scaleY,
	      onChange: this.handleChangeScale
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'scaleZ',
	      label: `${_t('Scale')}Z`,
	      value: scaleZ,
	      onChange: this.handleChangeScale
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      name: 'scaleLocked',
	      label: _t('Scale Locked'),
	      value: scaleLocked,
	      onChange: this.handleChangeScaleLock
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TransformComponent`, this.handleUpdate);
	    app.on(`objectChanged.TransformComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected === app.editor.scene || editor.selected.isGlobe) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      positionX: this.selected.position.x,
	      positionY: this.selected.position.y,
	      positionZ: this.selected.position.z,
	      rotationX: this.selected.rotation.x * 180 / Math.PI,
	      rotationY: this.selected.rotation.y * 180 / Math.PI,
	      rotationZ: this.selected.rotation.z * 180 / Math.PI,
	      scaleX: this.selected.scale.x,
	      scaleY: this.selected.scale.y,
	      scaleZ: this.selected.scale.z
	    });
	  }

	  handleChangePosition(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      positionX,
	      positionY,
	      positionZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetPositionCommand(this.selected, new THREE.Vector3(positionX, positionY, positionZ)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeRotation(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      rotationX,
	      rotationY,
	      rotationZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetRotationCommand(this.selected, new THREE.Euler(rotationX * Math.PI / 180, rotationY * Math.PI / 180, rotationZ * Math.PI / 180)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeScale(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      scaleX,
	      scaleY,
	      scaleZ,
	      scaleLocked
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (scaleLocked) {
	      app.editor.execute(new SetScaleCommand(this.selected, new THREE.Vector3(value, value, value)));
	    } else {
	      app.editor.execute(new SetScaleCommand(this.selected, new THREE.Vector3(scaleX, scaleY, scaleZ)));
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeScaleLock(value) {
	    this.setState({
	      scaleLocked: value
	    });
	  }

	}

	/**
	 * 音频监听器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class AudioListenerComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      masterVolume: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      masterVolume
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('AudioListener'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Max Volume'),
	      name: 'masterVolume',
	      value: masterVolume,
	      min: 0,
	      max: 1,
	      step: 0.1,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.AudioListenerComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.AudioListenerComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.children.indexOf(editor.audioListener) === -1) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let audioListener = editor.audioListener;
	    this.setState({
	      show: true,
	      masterVolume: audioListener.getMasterVolume()
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      masterVolume
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let audioListener = app.editor.audioListener;
	    audioListener.setMasterVolume(masterVolume);
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 音频监听器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class BackgroundMusicComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      name: '',
	      autoplay: false,
	      loop: true,
	      volume: 1,
	      showPlayButton: false,
	      isPlaying: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.onSelectAudio = this.onSelectAudio.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handlePlay = this.handlePlay.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      name,
	      autoplay,
	      loop,
	      volume,
	      showPlayButton,
	      isPlaying
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Background Music'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('Audio'),
	      name: 'name',
	      value: name === '' ? `(${_t('None')})` : name,
	      btnShow: true,
	      btnText: _t('Select'),
	      onClick: this.handleSelect
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Auto Play'),
	      name: 'autoplay',
	      value: autoplay,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Loop'),
	      name: 'loop',
	      value: loop,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Volume'),
	      name: 'volume',
	      value: volume,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(ButtonProperty, {
	      text: isPlaying ? _t('Stop') : _t('Play'),
	      show: showPlayButton,
	      onChange: this.handlePlay
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.BackgroundMusicComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.BackgroundMusicComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Audio)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let state = {
	      show: true,
	      name: this.selected.userData.Name || '',
	      autoplay: this.selected.userData.autoplay || false,
	      loop: this.selected.getLoop(),
	      volumn: this.selected.getVolume(),
	      showPlayButton: this.selected.buffer !== null,
	      isPlaying: this.selected.isPlaying || false
	    };
	    this.setState(state);
	  }

	  handleSelect() {
	    app.call(`selectBottomPanel`, this, 'audio');
	    app.toast(_t('Please click the audio in the Audio Panel.'));
	    app.on(`selectAudio.BackgroundMusicComponent`, this.onSelectAudio);
	  }

	  onSelectAudio(obj) {
	    app.on(`selectAudio.BackgroundMusicComponent`, null);
	    Object.assign(this.selected.userData, obj);
	    let loader = new THREE.AudioLoader();
	    loader.load(obj.Url, buffer => {
	      this.selected.setBuffer(buffer);
	      this.setState({
	        name: obj.Name,
	        showPlayButton: true
	      });
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      autoplay,
	      loop,
	      volumn
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.autoplay = autoplay; // 这里不能给this.selected赋值，否则音频会自动播放

	    this.selected.setLoop(loop);
	    this.selected.setVolume(volumn);
	    app.call('objectChanged', this, this.selected);
	  }

	  handlePlay() {
	    if (!this.selected.buffer) {
	      this.setState({
	        showPlayButton: false,
	        isPlaying: false
	      });
	      return;
	    }

	    if (this.selected.isPlaying) {
	      this.selected.stop();
	    } else {
	      this.selected.play();
	    }

	    this.setState({
	      showPlayButton: true,
	      isPlaying: this.selected.isPlaying
	    });
	  }

	}

	/**
	 * 场景控制器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class ControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.type = {
	      '': _t('None'),
	      'FirstPersonControls': _t('First Person Controls'),
	      'FlyControls': _t('Fly Controls'),
	      'OrbitControls': _t('Orbit Controls'),
	      'PointerLockControls': _t('Pointer Lock Controls'),
	      'TrackballControls': _t('Traceball Controls')
	    };
	    this.state = {
	      show: false,
	      expanded: true,
	      type: ''
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      type
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Scene Controller'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Type'),
	      options: this.type,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.ControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.ControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      type: this.selected.userData.control || ''
	    });
	  }

	  handleChange(value, name) {
	    const {
	      type
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.control = type;
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 第一视角控制器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class FirstPersonControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      movementSpeed: 10.0,
	      lookSpeed: 0.05,
	      lookVertical: true,
	      autoForward: false,
	      activeLook: true,
	      heightSpeed: false,
	      heightCoef: 1.0,
	      heightMin: 0.0,
	      heightMax: 1.0,
	      constrainVertical: false,
	      verticalMin: 0,
	      verticalMax: 3.14
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      movementSpeed,
	      lookSpeed,
	      lookVertical,
	      autoForward,
	      activeLook,
	      heightSpeed,
	      heightCoef,
	      heightMin,
	      heightMax,
	      constrainVertical,
	      verticalMin,
	      verticalMax
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('First Person Controls'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MovementSpeed'),
	      name: 'movementSpeed',
	      value: movementSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('LookSpeed'),
	      name: 'lookSpeed',
	      value: lookSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('LookVertical'),
	      name: 'lookVertical',
	      value: lookVertical,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('AutoForward'),
	      name: 'autoForward',
	      value: autoForward,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('ActiveLock'),
	      name: 'activeLook',
	      value: activeLook,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('HeightSpeed'),
	      name: 'heightSpeed',
	      value: heightSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('HeightCoef'),
	      name: 'heightCoef',
	      value: heightCoef,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('HeightMin'),
	      name: 'heightMin',
	      value: heightMin,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('HeightMax'),
	      name: 'heightMax',
	      value: heightMax,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('ConstrainVertical'),
	      name: 'constrainVertical',
	      value: constrainVertical,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('VerticalMin'),
	      name: 'verticalMin',
	      value: verticalMin,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('VerticalMax'),
	      name: 'verticalMax',
	      value: verticalMax,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.FirstPersonControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.FirstPersonControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.userData.control !== 'FirstPersonControls') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (this.selected.userData.firstPersonOptions === undefined) {
	      this.selected.userData.firstPersonOptions = {
	        movementSpeed: 10.0,
	        lookSpeed: 0.05,
	        lookVertical: true,
	        autoForward: false,
	        activeLook: true,
	        heightSpeed: false,
	        heightCoef: 1.0,
	        heightMin: 0.0,
	        heightMax: 1.0,
	        constrainVertical: false,
	        verticalMin: 0,
	        verticalMax: 3.14
	      };
	    }

	    this.setState({
	      show: true,
	      ...this.selected.userData.firstPersonOptions
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      movementSpeed,
	      lookSpeed,
	      lookVertical,
	      autoForward,
	      activeLook,
	      heightSpeed,
	      heightCoef,
	      heightMin,
	      heightMax,
	      constrainVertical,
	      verticalMin,
	      verticalMax
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData.firstPersonOptions, {
	      movementSpeed,
	      lookSpeed,
	      lookVertical,
	      autoForward,
	      activeLook,
	      heightSpeed,
	      heightCoef,
	      heightMin,
	      heightMax,
	      constrainVertical,
	      verticalMin,
	      verticalMax
	    });
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 音频监听器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class FlyControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      movementSpeed: 10.0,
	      rollSpeed: 0.05,
	      dragToLook: false,
	      autoForward: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      movementSpeed,
	      rollSpeed,
	      dragToLook,
	      autoForward
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Fly Controls'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MovementSpeed'),
	      name: 'movementSpeed',
	      value: movementSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('RotateSpeed'),
	      name: 'rollSpeed',
	      value: rollSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('DragToLook'),
	      name: 'dragToLook',
	      value: dragToLook,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('AutoForward'),
	      name: 'autoForward',
	      value: autoForward,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.FlyControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.FlyControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.userData.control !== 'FlyControls') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (this.selected.userData.flyOptions === undefined) {
	      this.selected.userData.flyOptions = {
	        movementSpeed: 20.0,
	        rollSpeed: 0.2,
	        dragToLook: false,
	        autoForward: false
	      };
	    }

	    this.setState({
	      show: true,
	      ...this.selected.userData.flyOptions
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      movementSpeed,
	      rollSpeed,
	      dragToLook,
	      autoForward
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData.flyOptions, {
	      movementSpeed,
	      rollSpeed,
	      dragToLook,
	      autoForward
	    });
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 轨道控制器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class OrbitControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      minDistance: 0.0,
	      maxDistance: 100000,
	      minPolarAngle: 0,
	      maxPolarAngle: 3.14,
	      minAzimuthAngle: -100,
	      maxAzimuthAngle: 100,
	      enableDamping: false,
	      dampingFactor: 0.25,
	      enableZoom: true,
	      zoomSpeed: 1.0,
	      enableRotate: true,
	      rotateSpeed: 1.0,
	      enablePan: true,
	      panSpeed: 1.0,
	      screenSpacePanning: false,
	      keyPanSpeed: 7.0,
	      autoRotate: false,
	      autoRotateSpeed: 2.0,
	      enableKeys: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      minDistance,
	      maxDistance,
	      minPolarAngle,
	      maxPolarAngle,
	      minAzimuthAngle,
	      maxAzimuthAngle,
	      enableDamping,
	      dampingFactor,
	      enableZoom,
	      zoomSpeed,
	      enableRotate,
	      rotateSpeed,
	      enablePan,
	      panSpeed,
	      screenSpacePanning,
	      keyPanSpeed,
	      autoRotate,
	      autoRotateSpeed,
	      enableKeys
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Orbit Controls'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MinDistance'),
	      name: 'minDistance',
	      value: minDistance,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MaxDistance'),
	      name: 'maxDistance',
	      value: maxDistance,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MinPolarAngle'),
	      name: 'minPolarAngle',
	      value: minPolarAngle,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MaxPolarAngle'),
	      name: 'maxPolarAngle',
	      value: maxPolarAngle,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MinAzimuthAngle'),
	      name: 'minAzimuthAngle',
	      value: minAzimuthAngle,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MaxAzimuthAngle'),
	      name: 'maxAzimuthAngle',
	      value: maxAzimuthAngle,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableDamping'),
	      name: 'enableDamping',
	      value: enableDamping,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('DampingFactor'),
	      name: 'dampingFactor',
	      value: dampingFactor,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableZoom'),
	      name: 'enableZoom',
	      value: enableZoom,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('ZoomSpeed'),
	      name: 'zoomSpeed',
	      value: zoomSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableRotate'),
	      name: 'enableRotate',
	      value: enableRotate,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('RotateSpeed'),
	      name: 'rotateSpeed',
	      value: rotateSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('PanSpeed'),
	      name: 'enablePan',
	      value: enablePan,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('PanSpeed'),
	      name: 'panSpeed',
	      value: panSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('ScreenSpacePanning'),
	      name: 'screenSpacePanning',
	      value: screenSpacePanning,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('KeyPanSpeed'),
	      name: 'keyPanSpeed',
	      value: keyPanSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('AutoRotate'),
	      name: 'autoRotate',
	      value: autoRotate,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('AutoRotateSpeed'),
	      name: 'autoRotateSpeed',
	      value: autoRotateSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableKeys'),
	      name: 'enableKeys',
	      value: enableKeys,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.OrbitControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.OrbitControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.userData.control !== 'OrbitControls') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (this.selected.userData.orbitOptions === undefined) {
	      this.selected.userData.orbitOptions = {
	        minDistance: 0,
	        maxDistance: 99999,
	        minPolarAngle: 0,
	        maxPolarAngle: Math.PI,
	        minAzimuthAngle: -9999,
	        maxAzimuthAngle: 9999,
	        enableDamping: false,
	        dampingFactor: 0.25,
	        enableZoom: true,
	        zoomSpeed: 1.0,
	        enableRotate: true,
	        rotateSpeed: 1.0,
	        enablePan: true,
	        panSpeed: 1.0,
	        screenSpacePanning: false,
	        keyPanSpeed: 7.0,
	        autoRotate: false,
	        autoRotateSpeed: 2.0,
	        enableKeys: true
	      };
	    }

	    this.setState({
	      show: true,
	      ...this.selected.userData.orbitOptions
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      minDistance,
	      maxDistance,
	      minPolarAngle,
	      maxPolarAngle,
	      minAzimuthAngle,
	      maxAzimuthAngle,
	      enableDamping,
	      dampingFactor,
	      enableZoom,
	      zoomSpeed,
	      enableRotate,
	      rotateSpeed,
	      enablePan,
	      panSpeed,
	      screenSpacePanning,
	      keyPanSpeed,
	      autoRotate,
	      autoRotateSpeed,
	      enableKeys
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData.orbitOptions, {
	      minDistance,
	      maxDistance,
	      minPolarAngle,
	      maxPolarAngle,
	      minAzimuthAngle,
	      maxAzimuthAngle,
	      enableDamping,
	      dampingFactor,
	      enableZoom,
	      zoomSpeed,
	      enableRotate,
	      rotateSpeed,
	      enablePan,
	      panSpeed,
	      screenSpacePanning,
	      keyPanSpeed,
	      autoRotate,
	      autoRotateSpeed,
	      enableKeys
	    });
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 指针锁定控制器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PointerLockControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      isLocked: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      isLocked
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Pointer Lock Controls'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('IsLocked'),
	      name: 'isLocked',
	      value: isLocked,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PointerLockControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.PointerLockControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.userData.control !== 'PointerLockControls') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (this.selected.userData.pointerLockOptions === undefined) {
	      this.selected.userData.pointerLockOptions = {
	        isLocked: true
	      };
	    }

	    this.setState({
	      show: true,
	      ...this.selected.userData.pointerLockOptions
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      isLocked
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData.pointerLockOptions, {
	      isLocked
	    });
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 轨迹球控制器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TrackballControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      rotateSpeed: 1.0,
	      zoomSpeed: 1.2,
	      panSpeed: 0.3,
	      noRotate: false,
	      noZoom: false,
	      noPan: false,
	      staticMoving: false,
	      dynamicDampingFactor: 0.2,
	      minDistance: 0,
	      maxDistance: 99999
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      rotateSpeed,
	      zoomSpeed,
	      panSpeed,
	      noRotate,
	      noZoom,
	      noPan,
	      staticMoving,
	      dynamicDampingFactor,
	      minDistance,
	      maxDistance
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Traceball Controls'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('RotateSpeed'),
	      name: 'rotateSpeed',
	      value: rotateSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('ZoomSpeed'),
	      name: 'zoomSpeed',
	      value: zoomSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('PanSpeed'),
	      name: 'panSpeed',
	      value: panSpeed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('NoRotate'),
	      name: 'noRotate',
	      value: noRotate,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('NoZoom'),
	      name: 'noZoom',
	      value: noZoom,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('NoPan'),
	      name: 'noPan',
	      value: noPan,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('StaticMoving'),
	      name: 'staticMoving',
	      value: staticMoving,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('DampingFactor'),
	      name: 'dynamicDampingFactor',
	      value: dynamicDampingFactor,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MinDistance'),
	      name: 'minDistance',
	      value: minDistance,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MaxDistance'),
	      name: 'maxDistance',
	      value: maxDistance,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TrackballControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.TrackballControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.userData.control !== 'TrackballControls') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (this.selected.userData.trackballOptions === undefined) {
	      this.selected.userData.trackballOptions = {
	        rotateSpeed: 1.0,
	        zoomSpeed: 1.2,
	        panSpeed: 0.3,
	        noRotate: false,
	        noZoom: false,
	        noPan: false,
	        staticMoving: false,
	        dynamicDampingFactor: 0.2,
	        minDistance: 0,
	        maxDistance: 99999
	      };
	    }

	    this.setState({
	      show: true,
	      ...this.selected.userData.trackballOptions
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      rotateSpeed,
	      zoomSpeed,
	      panSpeed,
	      noRotate,
	      noZoom,
	      noPan,
	      staticMoving,
	      dynamicDampingFactor,
	      minDistance,
	      maxDistance
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData.trackballOptions, {
	      rotateSpeed,
	      zoomSpeed,
	      panSpeed,
	      noRotate,
	      noZoom,
	      noPan,
	      staticMoving,
	      dynamicDampingFactor,
	      minDistance,
	      maxDistance
	    });
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * BufferGeometry组件
	 * @author tengge / https://github.com/tengge1
	 */

	class BufferGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      positionCount: 0,
	      normalCount: 0,
	      uvCount: 0,
	      indexCound: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleComputeVertexNormals = this.handleComputeVertexNormals.bind(this); // this.handleComputeFaceNormals = this.handleComputeFaceNormals.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      positionCount,
	      normalCount,
	      uvCount,
	      indexCound
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('BufferGeometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('Position Count'),
	      value: positionCount.toString()
	    }), /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('Normal Count'),
	      value: normalCount.toString()
	    }), /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('UV Count'),
	      value: uvCount.toString()
	    }), /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('Index Count'),
	      value: indexCound.toString()
	    }), /*#__PURE__*/React.createElement(ButtonProperty, {
	      text: _t('Compute Vertex Normals'),
	      onChange: this.handleComputeVertexNormals
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.BufferGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.BufferGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.BufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const geometry = this.selected.geometry;
	    this.setState({
	      show: true,
	      positionCount: geometry.attributes.position ? geometry.attributes.position.count : 0,
	      normalCount: geometry.attributes.normal ? geometry.attributes.normal.count : 0,
	      uvCount: geometry.attributes.uv ? geometry.attributes.uv.count : 0,
	      indexCound: geometry.index ? geometry.index.count : 0
	    });
	  }

	  handleComputeVertexNormals() {
	    const geometry = this.selected.geometry;

	    if (!geometry) {
	      return;
	    }

	    geometry.computeVertexNormals();
	  } // computeFaceNormals被three.js移除了。
	  // handleComputeFaceNormals() {
	  //     const geometry = this.selected.geometry;
	  //     if (!geometry) {
	  //         return;
	  //     }
	  //     geometry.computeFaceNormals();
	  // }


	}

	/**
	 * 设置几何体命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {THREE.Object3D} object 物体
	 * @param {THREE.Geometry} newGeometry 几何体
	 * @constructor
	 */

	function SetGeometryCommand(object, newGeometry) {
	  Command.call(this);
	  this.type = 'SetGeometryCommand';
	  this.name = _t('Set Geometry');
	  this.updatable = true;
	  this.object = object;
	  this.oldGeometry = object !== undefined ? object.geometry : undefined;
	  this.newGeometry = newGeometry;
	}

	SetGeometryCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetGeometryCommand.prototype, {
	  constructor: SetGeometryCommand,
	  execute: function () {
	    this.object.geometry.dispose();
	    this.object.geometry = this.newGeometry;
	    this.object.geometry.computeBoundingSphere();
	    app.call('geometryChanged', this, this.object);
	  },
	  undo: function () {
	    this.object.geometry.dispose();
	    this.object.geometry = this.oldGeometry;
	    this.object.geometry.computeBoundingSphere();
	    app.call('geometryChanged', this, this.object);
	  },
	  update: function (cmd) {
	    this.newGeometry = cmd.newGeometry;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.oldGeometry = this.object.geometry.toJSON();
	    output.newGeometry = this.newGeometry.toJSON();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldGeometry = parseGeometry(json.oldGeometry);
	    this.newGeometry = parseGeometry(json.newGeometry);

	    function parseGeometry(data) {
	      var loader = new THREE.ObjectLoader();
	      return loader.parseGeometries([data])[data.uuid];
	    }
	  }
	});

	/**
	 * 正方体组件
	 * @author tengge / https://github.com/tengge1
	 */

	class BoxGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      type: '',
	      width: 1,
	      height: 1,
	      depth: 1,
	      widthSegments: 1,
	      heightSegments: 1,
	      depthSegments: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      type,
	      width,
	      height,
	      depth,
	      widthSegments,
	      heightSegments,
	      depthSegments
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('Type'),
	      value: type
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'width',
	      label: _t('Width'),
	      value: width,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'height',
	      label: _t('Height'),
	      value: height,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'depth',
	      label: _t('Depth'),
	      value: depth,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'widthSegments',
	      label: _t('WidthSegments'),
	      value: widthSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'heightSegments',
	      label: _t('HeightSegments'),
	      value: heightSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'depthSegments',
	      label: _t('DepthSegments'),
	      value: depthSegments,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.BoxGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.BoxGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.BoxBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      width,
	      height,
	      depth,
	      widthSegments,
	      heightSegments,
	      depthSegments
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      width: width === undefined ? 1 : width,
	      height: height === undefined ? 1 : height,
	      depth: depth === undefined ? 1 : depth,
	      widthSegments: widthSegments === undefined ? 1 : widthSegments,
	      heightSegments: heightSegments === undefined ? 1 : heightSegments,
	      depthSegments: depthSegments === undefined ? 1 : depthSegments
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      width,
	      height,
	      depth,
	      widthSegments,
	      heightSegments,
	      depthSegments
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 圆形组件
	 * @author tengge / https://github.com/tengge1
	 */

	class CircleGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radius: 1.0,
	      segments: 16,
	      thetaStart: 0.0,
	      thetaLength: Math.PI * 2
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radius,
	      segments,
	      thetaStart,
	      thetaLength
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'radius',
	      label: _t('Radius'),
	      value: radius,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'segments',
	      label: _t('Segments'),
	      value: segments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'thetaStart',
	      label: _t('ThetaStart'),
	      value: thetaStart,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'thetaLength',
	      label: _t('ThetaLength'),
	      value: thetaLength,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.CircleGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.CircleGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.CircleBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radius,
	      segments,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radius: radius === undefined ? 1 : radius,
	      segments: segments === undefined ? 8 : segments,
	      thetaStart: thetaStart === undefined ? 0 : thetaStart,
	      thetaLength: thetaLength === undefined ? Math.PI * 2 : thetaLength
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radius,
	      segments,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.CircleBufferGeometry(radius, segments, thetaStart, thetaLength)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 圆柱组件
	 * @author tengge / https://github.com/tengge1
	 */

	class CylinderGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radiusTop: 1.0,
	      radiusBottom: 1.0,
	      height: 1.0,
	      radialSegments: 16,
	      heightSegments: 1,
	      openEnded: false,
	      thetaStart: 0,
	      thetaLength: Math.PI * 2
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radiusTop,
	      radiusBottom,
	      height,
	      radialSegments,
	      heightSegments,
	      openEnded,
	      thetaStart,
	      thetaLength
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'radiusTop',
	      label: _t('RadiusTop'),
	      value: radiusTop,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'radiusBottom',
	      label: _t('RadiusBottom'),
	      value: radiusBottom,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'height',
	      label: _t('Height'),
	      value: height,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'radialSegments',
	      label: _t('RadialSegments'),
	      value: radialSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'heightSegments',
	      label: _t('HeightSegments'),
	      value: heightSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      name: 'openEnded',
	      label: _t('OpenEnded'),
	      value: openEnded,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'thetaStart',
	      label: _t('ThetaStart'),
	      value: thetaStart,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'thetaLength',
	      label: _t('ThetaLength'),
	      value: thetaLength,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.CylinderGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.CylinderGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.CylinderBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radiusTop,
	      radiusBottom,
	      height,
	      radialSegments,
	      heightSegments,
	      openEnded,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radiusTop: radiusTop === undefined ? 1 : radiusTop,
	      radiusBottom: radiusBottom === undefined ? 1 : radiusBottom,
	      height: height === undefined ? 1 : height,
	      radialSegments: radialSegments === undefined ? 8 : radialSegments,
	      heightSegments: heightSegments === undefined ? 1 : heightSegments,
	      openEnded: openEnded === undefined ? false : openEnded,
	      thetaStart: thetaStart === undefined ? 0 : thetaStart,
	      thetaLength: thetaLength === undefined ? Math.PI * 2 : thetaLength
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radiusTop,
	      radiusBottom,
	      height,
	      radialSegments,
	      heightSegments,
	      openEnded,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 二十面体组件
	 * @author tengge / https://github.com/tengge1
	 */

	class IcosahedronGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radius: 1.0,
	      detail: 1.0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radius,
	      detail
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'radius',
	      label: _t('Radius'),
	      value: radius,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'detail',
	      label: _t('Detail'),
	      value: detail,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.IcosahedronGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.IcosahedronGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.IcosahedronBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radius,
	      detail
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radius: radius === undefined ? 1 : radius,
	      detail: detail === undefined ? 0 : detail
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radius,
	      detail
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.setState(state);
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.IcosahedronBufferGeometry(radius, detail)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 车床组件
	 * @author tengge / https://github.com/tengge1
	 */

	class LatheGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      segments: 16,
	      phiStart: 0.0,
	      phiLength: Math.PI * 2
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      segments,
	      phiStart,
	      phiLength
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'segments',
	      label: _t('RadialSegments'),
	      value: segments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'phiStart',
	      label: _t('PhiStart'),
	      value: phiStart,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'phiLength',
	      label: _t('PhiLength'),
	      value: phiLength,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.LatheGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.LatheGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.LatheBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      segments,
	      phiStart,
	      phiLength
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      segments: segments === undefined ? 12 : segments,
	      phiStart: phiStart === undefined ? 0 : phiStart,
	      phiLength: phiLength === undefined ? Math.PI * 2 : phiLength
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      segments,
	      phiStart,
	      phiLength
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    const points = this.selected.geometry.parameters.points;
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.LatheBufferGeometry(points, segments, phiStart, phiLength)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 平板组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PlaneGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      width: 1,
	      height: 1,
	      widthSegments: 1,
	      heightSegments: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      width,
	      height,
	      widthSegments,
	      heightSegments
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'width',
	      label: _t('Width'),
	      value: width,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'height',
	      label: _t('Height'),
	      value: height,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'widthSegments',
	      label: _t('WidthSegments'),
	      value: widthSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'heightSegments',
	      label: _t('HeightSegments'),
	      value: heightSegments,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PlaneGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.PlaneGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.PlaneBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      width,
	      height,
	      widthSegments,
	      heightSegments
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      width: width === undefined ? 1 : width,
	      height: height === undefined ? 1 : height,
	      widthSegments: widthSegments === undefined ? 1 : widthSegments,
	      heightSegments: heightSegments === undefined ? 1 : heightSegments
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      width,
	      height,
	      widthSegments,
	      heightSegments
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 球体组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SphereGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radius: 1,
	      widthSegments: 16,
	      heightSegments: 16,
	      phiStart: 0,
	      phiLength: Math.PI * 2,
	      thetaStart: 0,
	      thetaLength: Math.PI / 2
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radius,
	      widthSegments,
	      heightSegments,
	      phiStart,
	      phiLength,
	      thetaStart,
	      thetaLength
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'radius',
	      label: _t('Radius'),
	      value: radius,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'widthSegments',
	      label: _t('WidthSegments'),
	      value: widthSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'heightSegments',
	      label: _t('HeightSegments'),
	      value: heightSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'phiStart',
	      label: _t('PhiStart'),
	      value: phiStart,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'phiLength',
	      label: _t('PhiLength'),
	      value: phiLength,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'thetaStart',
	      label: _t('ThetaStart'),
	      value: thetaStart,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'thetaLength',
	      label: _t('ThetaLength'),
	      value: thetaLength,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SphereGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.SphereGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.SphereBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radius,
	      widthSegments,
	      heightSegments,
	      phiStart,
	      phiLength,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radius: radius === undefined ? 1 : radius,
	      widthSegments: widthSegments === undefined ? 8 : widthSegments,
	      heightSegments: heightSegments === undefined ? 6 : heightSegments,
	      phiStart: phiStart === undefined ? 0 : phiStart,
	      phiLength: phiLength === undefined ? Math.PI * 2 : phiLength,
	      thetaStart: thetaStart === undefined ? 0 : thetaStart,
	      thetaLength: thetaLength === undefined ? Math.PI : thetaLength
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radius,
	      widthSegments,
	      heightSegments,
	      phiStart,
	      phiLength,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 茶壶组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TeapotGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      size: 3,
	      segments: 10,
	      bottom: true,
	      lid: true,
	      body: true,
	      fitLid: true,
	      blinn: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      size,
	      segments,
	      bottom,
	      lid,
	      body,
	      fitLid,
	      blinn
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'size',
	      label: _t('Size'),
	      value: size,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'segments',
	      label: _t('Segments'),
	      value: segments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      name: 'bottom',
	      label: _t('Bottom'),
	      value: bottom,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      name: 'lid',
	      label: _t('Lid'),
	      value: lid,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      name: 'body',
	      label: _t('Body'),
	      value: body,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      name: 'fitLid',
	      label: _t('FitLid'),
	      value: fitLid,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      name: 'blinn',
	      label: _t('Blinn'),
	      value: blinn,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TeapotGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.TeapotGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.TeapotBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      size,
	      segments,
	      bottom,
	      lid,
	      body,
	      fitLid,
	      blinn
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      size: size === undefined ? 50 : size,
	      segments: segments === undefined ? 10 : segments,
	      bottom: bottom === undefined ? true : bottom,
	      lid: lid === undefined ? true : lid,
	      body: body === undefined ? true : body,
	      fitLid: fitLid === undefined ? true : fitLid,
	      blinn: blinn === undefined ? true : blinn
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      size,
	      segments,
	      bottom,
	      lid,
	      body,
	      fitLid,
	      blinn
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let geometry = new THREE.TeapotBufferGeometry(size, segments, bottom, lid, body, fitLid, blinn);
	    geometry.type = 'TeapotBufferGeometry';
	    geometry.parameters = {
	      size,
	      segments,
	      bottom,
	      lid,
	      body,
	      fitLid,
	      blinn
	    };
	    app.editor.execute(new SetGeometryCommand(this.selected, geometry));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 花托组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TorusGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radius: 1,
	      tube: 1,
	      radialSegments: 16,
	      tubularSegments: 16,
	      arc: Math.PI * 2
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radius,
	      tube,
	      radialSegments,
	      tubularSegments,
	      arc
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'radius',
	      label: _t('Radius'),
	      value: radius,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'tube',
	      label: _t('Tube'),
	      value: tube,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'radialSegments',
	      label: _t('RadialSegments'),
	      value: radialSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'tubularSegments',
	      label: _t('TubelarSegments'),
	      value: tubularSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'arc',
	      label: _t('Arc'),
	      value: arc,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TorusGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.TorusGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.TorusBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radius,
	      tube,
	      radialSegments,
	      tubularSegments,
	      arc
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radius: radius === undefined ? 1 : radius,
	      tube: tube === undefined ? 0.4 : tube,
	      radialSegments: radialSegments === undefined ? 8 : radialSegments,
	      tubularSegments: tubularSegments === undefined ? 16 : tubularSegments,
	      arc: arc === undefined ? Math.PI * 2 : arc
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radius,
	      tube,
	      radialSegments,
	      tubularSegments,
	      arc
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.setState(state);
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 环面纽结组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TorusKnotGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radius: 1,
	      tube: 1,
	      tubularSegments: 16,
	      radialSegments: 16,
	      p: 20,
	      q: 20
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radius,
	      tube,
	      tubularSegments,
	      radialSegments,
	      p,
	      q
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'radius',
	      label: _t('Radius'),
	      value: radius,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'tube',
	      label: _t('Tube'),
	      value: tube,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'tubularSegments',
	      label: _t('TubelarSegments'),
	      value: tubularSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      name: 'radialSegments',
	      label: _t('RadialSegments'),
	      value: radialSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'p',
	      label: _t('TubeArc'),
	      value: p,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      name: 'q',
	      label: _t('DistortedArc'),
	      value: q,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TorusKnotGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.TorusKnotGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.TorusKnotBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radius,
	      tube,
	      tubularSegments,
	      radialSegments,
	      p,
	      q
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radius: radius === undefined ? 1 : radius,
	      tube: tube === undefined ? 0.4 : tube,
	      tubularSegments: tubularSegments === undefined ? 64 : tubularSegments,
	      radialSegments: radialSegments === undefined ? 8 : radialSegments,
	      p: p === undefined ? 2 : p,
	      q: q === undefined ? 3 : q
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radius,
	      tube,
	      tubularSegments,
	      radialSegments,
	      p,
	      q
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.setState(state);
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * GIS基本组件
	 * @author tengge / https://github.com/tengge1
	 */

	class GisBasicComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.bakcground = {
	      google: _t('Google Map'),
	      bing: _t('Bing Map'),
	      tianditu: _t('Tianditu Map')
	    };
	    this.state = {
	      show: false,
	      expanded: true,
	      bakcground: 'google'
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      bakcground
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('GIS Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Map'),
	      options: this.bakcground,
	      name: 'bakcground',
	      value: bakcground,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.GisBasicComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.GisBasicComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'Globe') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      bakcground: this.selected.getBackground()
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      bakcground
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.setBackground(bakcground);
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * CatmullRom曲线组件
	 * @author tengge / https://github.com/tengge1
	 */

	class CatmullRomCurveComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.curveType = {
	      centripetal: _t('Centripetal Force'),
	      chordal: _t('Chord'),
	      catmullrom: _t('Catmullrom')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      closed: true,
	      curveType: 'catmullrom',
	      tension: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleAddPoint = this.handleAddPoint.bind(this);
	    this.handleRemovePoint = this.handleRemovePoint.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      closed,
	      curveType,
	      tension
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('CatmullRom Curve'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(ButtonsProperty, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleAddPoint
	    }, _t('Add Point')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleRemovePoint
	    }, _t('Remove Point'))), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Closed'),
	      name: 'closed',
	      value: closed,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Curve Type'),
	      options: this.curveType,
	      name: 'curveType',
	      value: curveType,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Tension'),
	      name: 'tension',
	      value: tension,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.CatmullRomCurveComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.CatmullRomCurveComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'CatmullRomCurve') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      closed: this.selected.userData.closed,
	      curveType: this.selected.userData.curveType,
	      tension: this.selected.userData.tension
	    });
	  }

	  handleAddPoint() {
	    let points = this.selected.userData.points; // let closed = this.selected.userData.closed;
	    // let curveType = this.selected.userData.curveType;
	    // let tension = this.selected.userData.tension;
	    // let curve = new THREE.CatmullRomCurve3(points, closed, curveType, tension);

	    let point = new THREE.Vector3(parseInt((Math.random() - 0.5) * 40), parseInt(Math.random() * 20), parseInt((Math.random() - 0.5) * 40));
	    points.splice(points.length, 0, point);
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	  handleRemovePoint() {
	    let points = this.selected.userData.points;

	    if (points.length === 3) {
	      app.toast(_t('CatmullRom curve should have at least 3 points.'), 'warn');
	      return;
	    }

	    points.splice(points.length - 1, 1);
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      closed,
	      curveType,
	      tension
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData, {
	      closed,
	      curveType,
	      tension
	    });
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 三次贝塞尔曲线组件
	 * @author tengge / https://github.com/tengge1
	 */

	class CubicBezierCurveComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      v0x: 0,
	      v0y: 0,
	      v0z: 0,
	      v1x: 0,
	      v1y: 0,
	      v1z: 0,
	      v2x: 0,
	      v2y: 0,
	      v2z: 0,
	      v3x: 0,
	      v3y: 0,
	      v3z: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      v0x,
	      v0y,
	      v0z,
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z,
	      v3x,
	      v3y,
	      v3z
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('CubicBezier Curve'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point1 X',
	      name: 'v0x',
	      value: v0x,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point1 Y',
	      name: 'v0y',
	      value: v0y,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point1 Z',
	      name: 'v0z',
	      value: v0z,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point2 X',
	      name: 'v1x',
	      value: v1x,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point2 Y',
	      name: 'v1y',
	      value: v1y,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point2 Z',
	      name: 'v1z',
	      value: v1z,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point3 X',
	      name: 'v2x',
	      value: v2x,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point3 Y',
	      name: 'v2y',
	      value: v2y,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point3 Z',
	      name: 'v2z',
	      value: v2z,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point4 X',
	      name: 'v3x',
	      value: v3x,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point4 Y',
	      name: 'v3y',
	      value: v3y,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point4 Z',
	      name: 'v3z',
	      value: v3z,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.CubicBezierCurveComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.CubicBezierCurveComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'CubicBezierCurve') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let points = this.selected.userData.points;
	    this.setState({
	      show: true,
	      v0x: points[0].x,
	      v0y: points[0].y,
	      v0z: points[0].z,
	      v1x: points[1].x,
	      v1y: points[1].y,
	      v1z: points[1].z,
	      v2x: points[2].x,
	      v2y: points[2].y,
	      v2z: points[2].z,
	      v3x: points[3].x,
	      v3y: points[3].y,
	      v3z: points[3].z
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      v0x,
	      v0y,
	      v0z,
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z,
	      v3x,
	      v3y,
	      v3z
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.points = [new THREE.Vector3(v0x, v0y, v0z), new THREE.Vector3(v1x, v1y, v1z), new THREE.Vector3(v2x, v2y, v2z), new THREE.Vector3(v3x, v3y, v3z)];
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 椭圆曲线组件
	 * @author tengge / https://github.com/tengge1
	 */

	class EllipseCurveComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      aX: 0,
	      aY: 0,
	      xRadius: 0,
	      yRadius: 0,
	      aStartAngle: 0,
	      aEndAngle: 0,
	      aClockwise: false,
	      aRotation: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      aX,
	      aY,
	      xRadius,
	      yRadius,
	      aStartAngle,
	      aEndAngle,
	      aClockwise,
	      aRotation
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Ellipse Curve'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Center X',
	      name: 'aX',
	      value: aX,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Center Y',
	      name: 'aY',
	      value: aY,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Radius X',
	      name: 'xRadius',
	      value: xRadius,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Radius Y',
	      name: 'yRadius',
	      value: yRadius,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Start Angle',
	      name: 'aStartAngle',
	      value: aStartAngle,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'End Angle',
	      name: 'aEndAngle',
	      value: aEndAngle,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: 'Clockwise',
	      name: 'aClockwise',
	      value: aClockwise,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Rotation',
	      name: 'aRotation',
	      value: aRotation,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.EllipseCurveComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.EllipseCurveComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'EllipseCurve') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      aX: this.selected.userData.aX,
	      aY: this.selected.userData.aY,
	      xRadius: this.selected.userData.xRadius,
	      yRadius: this.selected.userData.yRadius,
	      aStartAngle: this.selected.userData.aStartAngle,
	      aEndAngle: this.selected.userData.aEndAngle,
	      aClockwise: this.selected.userData.aClockwise,
	      aRotation: this.selected.userData.aRotation
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      aX,
	      aY,
	      xRadius,
	      yRadius,
	      aStartAngle,
	      aEndAngle,
	      aClockwise,
	      aRotation
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData, {
	      aX,
	      aY,
	      xRadius,
	      yRadius,
	      aStartAngle,
	      aEndAngle,
	      aClockwise,
	      aRotation
	    });
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 椭圆曲线组件
	 * @author tengge / https://github.com/tengge1
	 */

	class LineCurveComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      v1x: 0,
	      v1y: 0,
	      v1z: 0,
	      v2x: 0,
	      v2y: 0,
	      v2z: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Line Curve'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point1 X',
	      name: 'v1x',
	      value: v1x,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point1 Y',
	      name: 'v1y',
	      value: v1y,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point1 Z',
	      name: 'v1z',
	      value: v1z,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point2 X',
	      name: 'v2x',
	      value: v2x,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point2 Y',
	      name: 'v2y',
	      value: v2y,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point2 Z',
	      name: 'v2z',
	      value: v2z,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.LineCurveComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.LineCurveComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'LineCurve') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let points = this.selected.userData.points;
	    this.setState({
	      show: true,
	      v1x: points[0].x,
	      v1y: points[0].y,
	      v1z: points[0].z,
	      v2x: points[1].x,
	      v2y: points[1].y,
	      v2z: points[1].z
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.points = [new THREE.Vector3(v1x, v1y, v1z), new THREE.Vector3(v2x, v2y, v2z)];
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 二次贝塞尔曲线组件
	 * @author tengge / https://github.com/tengge1
	 */

	class QuadraticBezierCurveComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      v0x: 0,
	      v0y: 0,
	      v0z: 0,
	      v1x: 0,
	      v1y: 0,
	      v1z: 0,
	      v2x: 0,
	      v2y: 0,
	      v2z: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      v0x,
	      v0y,
	      v0z,
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('QuadraticBezier Curve'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point1 X',
	      name: 'v0x',
	      value: v0x,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point1 Y',
	      name: 'v0y',
	      value: v0y,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point1 Z',
	      name: 'v0z',
	      value: v0z,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point2 X',
	      name: 'v1x',
	      value: v1x,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point2 Y',
	      name: 'v1y',
	      value: v1y,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point2 Z',
	      name: 'v1z',
	      value: v1z,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point3 X',
	      name: 'v2x',
	      value: v2x,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point3 Y',
	      name: 'v2y',
	      value: v2y,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Point3 Z',
	      name: 'v2z',
	      value: v2z,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.QuadraticBezierCurveComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.QuadraticBezierCurveComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'QuadraticBezierCurve') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let points = this.selected.userData.points;
	    this.setState({
	      show: true,
	      v0x: points[0].x,
	      v0y: points[0].y,
	      v0z: points[0].z,
	      v1x: points[1].x,
	      v1y: points[1].y,
	      v1z: points[1].z,
	      v2x: points[2].x,
	      v2y: points[2].y,
	      v2z: points[2].z
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      v0x,
	      v0y,
	      v0z,
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.points = [new THREE.Vector3(v0x, v0y, v0z), new THREE.Vector3(v1x, v1y, v1z), new THREE.Vector3(v2x, v2y, v2z)];
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 布组件
	 * @author tengge / https://github.com/tengge1
	 */

	class ClothComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('ClothComponent'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.ClothComponent`, this.handleUpdate);
	    app.on(`objectChanged.ClothComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'Cloth')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    });
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    app.on(`animate.ClothComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    app.on(`animate.ClothComponent`, null);
	  }

	  onAnimate() {
	    this.selected.update();
	  }

	}

	/**
	 * 柏林地形组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PerlinTerrainComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      width: 1000,
	      depth: 1000,
	      widthSegments: 256,
	      depthSegments: 256,
	      quality: 80
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      width,
	      depth,
	      widthSegments,
	      depthSegments,
	      quality
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Perlin Terrain'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Width'),
	      name: 'width',
	      value: width,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Depth'),
	      name: 'depth',
	      value: depth,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      label: _t('WidthSegments'),
	      name: 'widthSegments',
	      value: widthSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      label: _t('DepthSegments'),
	      name: 'depthSegments',
	      value: depthSegments,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Quality'),
	      name: 'quality',
	      value: quality,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PerlinTerrainComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.PerlinTerrainComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof PerlinTerrain)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      width: this.selected.userData.width,
	      depth: this.selected.userData.depth,
	      widthSegments: this.selected.userData.widthSegments,
	      depthSegments: this.selected.userData.depthSegments,
	      quality: this.selected.userData.quality
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      width,
	      depth,
	      widthSegments,
	      depthSegments,
	      quality
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let terrain = new PerlinTerrain(width, depth, widthSegments, depthSegments, quality);
	    const editor = app.editor;
	    const index = editor.scene.children.indexOf(this.selected);

	    if (index > -1) {
	      editor.select(null);
	      editor.scene.children[index] = terrain;
	      terrain.parent = this.selected.parent;
	      this.selected.parent = null;
	      app.call(`objectRemoved`, this, this.selected);
	      app.call(`objectAdded`, this, terrain);
	      editor.select(terrain);
	    }
	  }

	}

	/**
	 * 天空组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SkyComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      turbidity: 10,
	      rayleigh: 2,
	      luminance: 1,
	      mieCoefficient: 0.005,
	      mieDirectionalG: 0.005
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      turbidity,
	      rayleigh,
	      luminance,
	      mieCoefficient,
	      mieDirectionalG
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Sky'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Turbidity'),
	      name: 'turbidity',
	      value: turbidity,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Rayleigh'),
	      name: 'rayleigh',
	      value: rayleigh,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Luminance'),
	      name: 'luminance',
	      value: luminance,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MieCofficient'),
	      name: 'mieCoefficient',
	      value: mieCoefficient,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MieDirectionalG'),
	      name: 'mieDirectionalG',
	      value: mieDirectionalG,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SkyComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.SkyComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof Sky)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      turbidity: this.selected.userData.turbidity,
	      rayleigh: this.selected.userData.rayleigh,
	      luminance: this.selected.userData.luminance,
	      mieCoefficient: this.selected.userData.mieCoefficient * 100,
	      mieDirectionalG: this.selected.userData.mieDirectionalG
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      turbidity,
	      rayleigh,
	      luminance,
	      mieCoefficient,
	      mieDirectionalG
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData, {
	      turbidity,
	      rayleigh,
	      luminance,
	      mieCoefficient: mieCoefficient / 100,
	      mieDirectionalG
	    });
	    const sky = this.selected.children.filter(n => n instanceof THREE.Sky)[0];

	    if (sky) {
	      let uniforms = sky.material.uniforms;
	      uniforms.turbidity.value = turbidity;
	      uniforms.rayleigh.value = rayleigh;
	      uniforms.luminance.value = luminance;
	      uniforms.mieCoefficient.value = mieCoefficient / 100;
	      uniforms.mieDirectionalG.value = mieDirectionalG;
	      sky.material.needsUpdate = true;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 水组件
	 * @author tengge / https://github.com/tengge1
	 */

	class WaterComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Water Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.WaterComponent`, this.handleUpdate);
	    app.on(`objectChanged.WaterComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'Water')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    });
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    app.on(`animate.WaterComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    app.on(`animate.WaterComponent`, null);
	  }

	  onAnimate() {
	    this.selected.update();
	  }

	}

	/**
	 * 物理类型组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PhysicsTypeComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.type = {
	      rigidBody: _t('RigidBody'),
	      softVolume: _t('SoftVolume')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      physicsEnabled: false,
	      type: 'rigidBody'
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      physicsEnabled,
	      type
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('PhysicsType'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Enabled'),
	      name: 'physicsEnabled',
	      value: physicsEnabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Type'),
	      options: this.type,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PhysicsTypeComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.PhysicsTypeComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !editor.selected.userData.physics || editor.selected === editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let physics = this.selected.userData.physics || {};
	    this.setState({
	      show: true,
	      physicsEnabled: physics.enabled || false,
	      type: physics.type || 'rigidBody'
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      physicsEnabled,
	      type
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (!this.selected.userData.physics) {
	      this.selected.userData.physics = {};
	    }

	    let physics = this.selected.userData.physics;
	    physics.enabled = physicsEnabled;
	    physics.type = type;
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 物理环境组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PhysicsWorldComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.type = {
	      'btDefaultCollisionConfiguration': _t('DefaultCollisionConfig'),
	      // 无法使用布料
	      'btSoftBodyRigidBodyCollisionConfiguration': _t('SoftBodyRigidBodyCollisionConfig')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      type: 'btSoftBodyRigidBodyCollisionConfiguration',
	      gravityX: 0,
	      gravityY: -9.8,
	      gravityZ: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      type,
	      gravityX,
	      gravityY,
	      gravityZ
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('PhysicsEnvironment'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Type'),
	      options: this.type,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'GravityX',
	      name: 'gravityX',
	      value: gravityX,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'GravityY',
	      name: 'gravityY',
	      value: gravityY,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'GravityZ',
	      name: 'gravityZ',
	      value: gravityZ,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PhysicsWorldComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.PhysicsWorldComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (!this.selected.userData.physics) {
	      this.selected.userData.physics = {
	        type: 'btSoftBodyRigidBodyCollisionConfiguration',
	        gravityX: 0.0,
	        gravityY: -9.8,
	        gravityZ: 0.0
	      };
	    }

	    let {
	      type,
	      gravityX,
	      gravityY,
	      gravityZ
	    } = this.selected.userData.physics;
	    this.setState({
	      show: true,
	      type,
	      gravityX,
	      gravityY,
	      gravityZ
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      type,
	      gravityX,
	      gravityY,
	      gravityZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.physics = {
	      type,
	      gravityX,
	      gravityY,
	      gravityZ
	    };
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 立方体帮助器
	 * @param {*} object 物体
	 */
	function BoxShapeHelper(object) {
	  this.object = object;
	  var geometry = this.object.geometry;
	  geometry.computeBoundingBox();
	  var box = geometry.boundingBox;
	  var x = box.max.x - box.min.x;
	  var y = box.max.y - box.min.y;
	  var z = box.max.z - box.min.z;
	  var center = new THREE.Vector3();
	  box.getCenter(center);
	  geometry = new THREE.BoxBufferGeometry(x, y, z);
	  geometry.translate(center.x, center.y, center.z);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xffff00
	  });
	  material.wireframe = true;
	  material.depthTest = false;
	  THREE.Mesh.call(this, geometry, material);
	  this.update();
	}

	BoxShapeHelper.prototype = Object.create(THREE.Mesh.prototype);
	BoxShapeHelper.prototype.constructor = BoxShapeHelper;

	BoxShapeHelper.prototype.update = function () {
	  this.object.geometry.computeBoundingBox();
	  this.position.copy(this.object.position);
	  this.rotation.copy(this.object.rotation);
	  this.scale.copy(this.object.scale);
	};

	/**
	 * 立方体帮助器
	 * @param {*} object 物体
	 */
	function SphereShapeHelper(object) {
	  this.object = object;
	  var geometry = this.object.geometry;
	  geometry.computeBoundingSphere();
	  var sphere = geometry.boundingSphere;
	  geometry = new THREE.SphereBufferGeometry(sphere.radius);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xffff00
	  });
	  material.wireframe = true;
	  material.depthTest = false;
	  THREE.Mesh.call(this, geometry, material);
	  this.update();
	}

	SphereShapeHelper.prototype = Object.create(THREE.Mesh.prototype);
	SphereShapeHelper.prototype.constructor = SphereShapeHelper;

	SphereShapeHelper.prototype.update = function () {
	  this.object.geometry.computeBoundingSphere();
	  this.position.copy(this.object.position);
	  this.rotation.copy(this.object.rotation);
	  this.scale.copy(this.object.scale);
	};

	let physicsShapeHelper = {
	  btBoxShape: BoxShapeHelper,
	  btSphereShape: SphereShapeHelper
	};
	/**
	 * 刚体组件
	 * @author tengge / https://github.com/tengge1
	 */

	class RigidBodyComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.shape = {
	      btBoxShape: _t('BoxShape'),
	      // btBvhTriangleMeshShape: 'bvh三角形网格',
	      // btCapsuleShape: '胶囊',
	      // btCapsuleShapeX: 'x轴胶囊',
	      // btCapsuleShapeZ: 'z轴胶囊',
	      // btCollisionShape: '碰撞体',
	      // btCompoundShape: '复合形状',
	      // btConcaveShape: '凹面体',
	      // btConeShape: '圆锥体',
	      // btConeShapeX: 'x轴圆椎体',
	      // btConeShapeZ: 'z轴圆椎体',
	      // btConvexHullShape: '凸包',
	      // btConvexShape: '凸面体',
	      // btConvexTriangleMeshShape: '凸三角形网格',
	      // btCylinderShape: '圆柱体',
	      // btCylinderShapeX: 'x轴圆柱体',
	      // btCylinderShapeZ: 'z轴圆柱体',
	      // btHeightfieldTerrainShape: '灰阶高程地形',
	      btSphereShape: _t('SphereShape') // btStaticPlaneShape: '静态平板',
	      // btTriangleMeshShape: '三角网格'

	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      shape: 'btBoxShape',
	      mass: 1,
	      inertiaX: 0,
	      inertiaY: 0,
	      inertiaZ: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handleRemoved = this.handleRemoved.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      shape,
	      mass,
	      inertiaX,
	      inertiaY,
	      inertiaZ
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('RigidBody'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Shape'),
	      options: this.shape,
	      name: 'shape',
	      value: shape,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Mass',
	      name: 'mass',
	      value: mass,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'InertiaX',
	      name: 'inertiaX',
	      value: inertiaX,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'InertiaY',
	      name: 'inertiaY',
	      value: inertiaY,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'InertiaZ',
	      name: 'inertiaZ',
	      value: inertiaZ,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.RigidBodyComponent`, this.handleUpdate);
	    app.on(`objectChanged.RigidBodyComponent`, this.handleUpdate);
	    app.on(`objectRemoved.RigidBodyComponent`, this.handleRemoved);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !editor.selected.userData.physics || !editor.selected.userData.physics.enabled || editor.selected.userData.physics.type !== 'rigidBody') {
	      if (this.helper !== undefined) {
	        app.editor.removePhysicsHelper(this.helper);
	      }

	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let {
	      shape,
	      mass,
	      inertia
	    } = this.selected.userData.physics || {};
	    this.setState({
	      show: true,
	      shape: shape || 'btBoxShape',
	      mass: mass || 0,
	      inertiaX: inertia.x || 0,
	      inertiaY: inertia.y || 0,
	      inertiaZ: inertia.z || 0
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      shape,
	      mass,
	      inertiaX,
	      inertiaY,
	      inertiaZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let physics = this.selected.userData.physics;
	    physics.shape = shape;
	    physics.mass = mass;
	    physics.inertia.x = inertiaX;
	    physics.inertia.y = inertiaY;
	    physics.inertia.z = inertiaZ;
	    app.call('objectChanged', this, this.selected);
	  }

	  handleRemoved(object) {
	    if (this.helper && this.helper.object === object) {
	      app.editor.removePhysicsHelper(this.helper);
	    }
	  } // -------------------------- 物理形状帮助器 -------------------------------------


	  showPhysicsShapeHelper() {
	    if (this.selected === null) {
	      return;
	    }

	    if (this.helper !== undefined) {
	      app.editor.removePhysicsHelper(this.helper);
	    }

	    let physics = this.selected.userData.physics;

	    if (!physics || !physics.enabled) {
	      return;
	    }

	    let helper = physicsShapeHelper[physics.shape];

	    if (!helper) {
	      console.warn(`RigidBodyComponent: ${physics.shape} ${_t('has no physics helper.')}`);
	      return;
	    }

	    this.helper = new helper(this.selected);
	    app.editor.addPhysicsHelper(this.helper);
	  }

	}

	/**
	 * 柔软体组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SoftVolumeComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      mass: 1,
	      pressure: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      mass,
	      pressure
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('SoftVolume'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(NumberProperty, {
	      label: 'Mass',
	      name: 'mass',
	      value: mass,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Pressure'),
	      name: 'pressure',
	      value: pressure,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SoftVolumeComponent`, this.handleUpdate);
	    app.on(`objectChanged.SoftVolumeComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !editor.selected.userData.physics || !editor.selected.userData.physics.enabled || editor.selected.userData.physics.type !== 'softVolume') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let {
	      mass,
	      pressure
	    } = this.selected.userData.physics || {};
	    this.setState({
	      show: true,
	      mass: mass || 0,
	      pressure: pressure || 0
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      mass,
	      pressure
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let physics = this.selected.userData.physics;
	    physics.mass = mass;
	    physics.pressure = pressure;
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 残影特效组件
	 * @author tengge / https://github.com/tengge1
	 */

	class AfterimageComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      damp: 0.92
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      damp
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('AfterimageEffect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Damp'),
	      name: 'damp',
	      value: damp,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.AfterimageComponent`, this.handleUpdate);
	    app.on(`objectChanged.AfterimageComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.afterimage ? postProcessing.afterimage.enabled : false,
	      damp: postProcessing.afterimage ? postProcessing.afterimage.damp : this.state.damp
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      damp
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      afterimage: {
	        enabled,
	        damp
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 背景虚化特效组件
	 * @author tengge / https://github.com/tengge1
	 */

	class BokehComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      focus: 50,
	      // 距离相机距离，哪里最清晰
	      aperture: 2.8,
	      // *1e-4，光圈越小越清楚
	      maxBlur: 1 // 最大模糊程度，越大越模糊

	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      focus,
	      aperture,
	      maxBlur
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Bokeh Effect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Focus'),
	      name: 'focus',
	      value: focus,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Aperture'),
	      name: 'aperture',
	      value: aperture,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MaxBlur'),
	      name: 'maxBlur',
	      value: maxBlur,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.BokehComponent`, this.handleUpdate);
	    app.on(`objectChanged.BokehComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.bokeh ? postProcessing.bokeh.enabled : false,
	      focus: postProcessing.bokeh ? postProcessing.bokeh.focus : this.state.focus,
	      aperture: postProcessing.bokeh ? postProcessing.bokeh.aperture : this.state.aperture,
	      maxBlur: postProcessing.bokeh ? postProcessing.bokeh.maxBlur : this.state.maxBlur
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      focus,
	      aperture,
	      maxBlur
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      bokeh: {
	        enabled,
	        focus,
	        aperture,
	        maxBlur
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 点阵化组件
	 * @author tengge / https://github.com/tengge1
	 */

	class DotScreenComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      scale: 4.0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      scale
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('DotScreenEffect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Scale'),
	      name: 'scale',
	      value: scale,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.DotScreenComponent`, this.handleUpdate);
	    app.on(`objectChanged.DotScreenComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.dotScreen ? postProcessing.dotScreen.enabled : false,
	      scale: postProcessing.dotScreen ? postProcessing.dotScreen.scale : this.state.scale
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      scale
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      dotScreen: {
	        enabled,
	        scale
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 快速近似抗锯齿(FXAA)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class FxaaComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('FXAA Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.FxaaComponent`, this.handleUpdate);
	    app.on(`objectChanged.FxaaComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.fxaa ? postProcessing.fxaa.enabled : false
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      fxaa: {
	        enabled
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 毛刺组件
	 * @author tengge / https://github.com/tengge1
	 */

	class GlitchComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      wild: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      wild
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Glitch Effect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('WildMode'),
	      name: 'wild',
	      value: wild,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.GlitchComponent`, this.handleUpdate);
	    app.on(`objectChanged.GlitchComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.glitch ? postProcessing.glitch.enabled : false,
	      wild: postProcessing.glitch ? postProcessing.glitch.wild : false
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      wild
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      glitch: {
	        enabled,
	        wild
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 半色调特效组件
	 * @author tengge / https://github.com/tengge1
	 */

	class HalftoneComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.shape = {
	      1: _t('Point'),
	      2: _t('Ellipse'),
	      3: _t('Line'),
	      4: _t('Square')
	    };
	    this.blendingMode = {
	      1: _t('Linear'),
	      2: _t('Multiply'),
	      3: _t('Add together'),
	      4: _t('Lighter'),
	      5: _t('Darker')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      shape: 1,
	      radius: 4,
	      rotateR: 15,
	      rotateG: 45,
	      rotateB: 30,
	      scatter: 0,
	      blending: 1,
	      blendingMode: 1,
	      greyscale: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      shape,
	      radius,
	      rotateR,
	      rotateG,
	      rotateB,
	      scatter,
	      blending,
	      blendingMode,
	      greyscale
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Halftone Effect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Shape'),
	      options: this.shape,
	      name: 'shape',
	      value: shape,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(IntegerProperty, {
	      label: _t('Radius'),
	      name: 'radius',
	      value: radius,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('RotateRed'),
	      name: 'rotateR',
	      value: rotateR,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('RotateGreen'),
	      name: 'rotateG',
	      value: rotateG,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('RotateBlue'),
	      name: 'rotateB',
	      value: rotateB,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Scatter'),
	      name: 'scatter',
	      value: scatter,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Blending'),
	      name: 'blending',
	      value: blending,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('BlendingMode'),
	      options: this.blendingMode,
	      name: 'blendingMode',
	      value: blendingMode,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('GreyScale'),
	      name: 'greyscale',
	      value: greyscale,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.HalftoneComponent`, this.handleUpdate);
	    app.on(`objectChanged.HalftoneComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.halftone ? postProcessing.halftone.enabled : false,
	      shape: postProcessing.halftone ? postProcessing.halftone.shape : this.state.shape,
	      radius: postProcessing.halftone ? postProcessing.halftone.radius : this.state.radius,
	      rotateR: postProcessing.halftone ? postProcessing.halftone.rotateR : this.state.rotateR,
	      rotateB: postProcessing.halftone ? postProcessing.halftone.rotateB : this.state.rotateG,
	      rotateG: postProcessing.halftone ? postProcessing.halftone.rotateG : this.state.rotateB,
	      scatter: postProcessing.halftone ? postProcessing.halftone.scatter : this.state.scatter,
	      blending: postProcessing.halftone ? postProcessing.halftone.blending : this.state.blending,
	      blendingMode: postProcessing.halftone ? postProcessing.halftone.blendingMode : this.state.blendingMode,
	      greyscale: postProcessing.halftone ? postProcessing.halftone.greyscale : this.state.greyscale
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      shape,
	      radius,
	      rotateR,
	      rotateG,
	      rotateB,
	      scatter,
	      blending,
	      blendingMode,
	      greyscale
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      halftone: {
	        enabled,
	        shape,
	        radius,
	        rotateR,
	        rotateG,
	        rotateB,
	        scatter,
	        blending,
	        blendingMode,
	        greyscale
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 像素特效组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PixelComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      pixelSize: 8
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      pixelSize
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('PixelEffect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('PixelSize'),
	      name: 'pixelSize',
	      value: pixelSize,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PixelComponent`, this.handleUpdate);
	    app.on(`objectChanged.PixelComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.pixel ? postProcessing.pixel.enabled : false,
	      pixelSize: postProcessing.pixel ? postProcessing.pixel.pixelSize : this.state.pixelSize
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      pixelSize
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      pixel: {
	        enabled,
	        pixelSize
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 颜色偏移组件
	 * @author tengge / https://github.com/tengge1
	 */

	class RgbShiftComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      amount: 0.1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      amount
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('RGB Shift Effect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Amount'),
	      name: 'amount',
	      value: amount,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.RgbShiftComponent`, this.handleUpdate);
	    app.on(`objectChanged.RgbShiftComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.rgbShift ? postProcessing.rgbShift.enabled : false,
	      amount: postProcessing.rgbShift ? postProcessing.rgbShift.amount : this.state.amount
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      amount
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      rgbShift: {
	        enabled,
	        amount
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 可扩展环境光遮挡(SAO)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SaoComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.output = {
	      1: _t('Beauty'),
	      // THREE.SAOPass.OUTPUT.Beauty
	      0: _t('Beauty&Occlusion'),
	      // THREE.SAOPass.OUTPUT.Default
	      2: _t('Occlusion'),
	      // THREE.SAOPass.OUTPUT.SAO
	      3: _t('Depth'),
	      // THREE.SAOPass.OUTPUT.Depth
	      4: _t('Normal') // THREE.SAOPass.OUTPUT.Normal

	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      output: 0,
	      saoBias: 0.5,
	      saoIntensity: 0.02,
	      saoScale: 100,
	      saoKernelRadius: 50,
	      saoMinResolution: 0,
	      saoBlur: true,
	      saoBlurRadius: 16,
	      saoBlurStdDev: 32.6,
	      saoBlurDepthCutoff: 0.046
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      output,
	      saoBias,
	      saoIntensity,
	      saoScale,
	      saoKernelRadius,
	      saoMinResolution,
	      saoBlur,
	      saoBlurRadius,
	      saoBlurStdDev,
	      saoBlurDepthCutoff
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('SAO'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Output'),
	      options: this.output,
	      name: 'output',
	      value: output,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Bias'),
	      name: 'saoBias',
	      value: saoBias,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Intensity'),
	      name: 'saoIntensity',
	      value: saoIntensity,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('Scale'),
	      name: 'saoScale',
	      value: saoScale,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('KernalRadius'),
	      name: 'saoKernelRadius',
	      value: saoKernelRadius,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MinResolution'),
	      name: 'saoMinResolution',
	      value: saoMinResolution,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Blur'),
	      name: 'saoBlur',
	      value: saoBlur,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('BlurRadius'),
	      name: 'saoBlurRadius',
	      value: saoBlurRadius,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('BlurStdDev'),
	      name: 'saoBlurStdDev',
	      value: saoBlurStdDev,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('BlurDepthCutoff'),
	      name: 'saoBlurDepthCutoff',
	      value: saoBlurDepthCutoff,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SaoComponent`, this.handleUpdate);
	    app.on(`objectChanged.SaoComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.sao ? postProcessing.sao.enabled : false,
	      output: postProcessing.sao ? postProcessing.sao.output : this.state.output,
	      saoBias: postProcessing.sao ? postProcessing.sao.saoBias : this.state.saoBias,
	      saoIntensity: postProcessing.sao ? postProcessing.sao.saoIntensity : this.state.saoIntensity,
	      saoScale: postProcessing.sao ? postProcessing.sao.saoScale : this.state.saoScale,
	      saoKernelRadius: postProcessing.sao ? postProcessing.sao.saoKernelRadius : this.state.saoKernelRadius,
	      saoMinResolution: postProcessing.sao ? postProcessing.sao.saoMinResolution : this.state.saoMinResolution,
	      saoBlur: postProcessing.sao ? postProcessing.sao.saoBlur : this.state.saoBlur,
	      saoBlurRadius: postProcessing.sao ? postProcessing.sao.saoBlurRadius : this.state.saoBlurRadius,
	      saoBlurStdDev: postProcessing.sao ? postProcessing.sao.saoBlurStdDev : this.setState.saoBlurStdDev,
	      saoBlurDepthCutoff: postProcessing.sao ? postProcessing.sao.saoBlurDepthCutoff : this.state.saoBlurDepthCutoff
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      output,
	      saoBias,
	      saoIntensity,
	      saoScale,
	      saoKernelRadius,
	      saoMinResolution,
	      saoBlur,
	      saoBlurRadius,
	      saoBlurStdDev,
	      saoBlurDepthCutoff
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      sao: {
	        enabled,
	        output,
	        saoBias,
	        saoIntensity,
	        saoScale,
	        saoKernelRadius,
	        saoMinResolution,
	        saoBlur,
	        saoBlurRadius,
	        saoBlurStdDev,
	        saoBlurDepthCutoff
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 多重采样抗锯齿(SMAA)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SmaaComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('SMAA'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SmaaComponent`, this.handleUpdate);
	    app.on(`objectChanged.SmaaComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.smaa ? postProcessing.smaa.enabled : false
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      smaa: {
	        enabled
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 全屏抗锯齿(SSAA)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SsaaComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.sampleLevel = {
	      0: _t('1 Sample'),
	      1: _t('2 Samples'),
	      2: _t('4 Samples'),
	      3: _t('8 Samples'),
	      4: _t('16 Samples'),
	      5: _t('32 Samples')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      sampleLevel: 3,
	      unbiased: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      sampleLevel,
	      unbiased
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('SSAA'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Level'),
	      options: this.sampleLevel,
	      name: 'sampleLevel',
	      value: sampleLevel,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Unbiased'),
	      name: 'unbiased',
	      value: unbiased,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SsaaComponent`, this.handleUpdate);
	    app.on(`objectChanged.SsaaComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.ssaa ? postProcessing.ssaa.enabled : false,
	      sampleLevel: postProcessing.ssaa ? postProcessing.ssaa.sampleLevel : this.state.sampleLevel,
	      unbiased: postProcessing.ssaa ? postProcessing.ssaa.unbiased : this.state.unbiased
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      sampleLevel,
	      unbiased
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      ssaa: {
	        enabled,
	        sampleLevel,
	        unbiased
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 屏幕空间环境光遮蔽(SSAO)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SsaoComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.output = {
	      0: _t('Default'),
	      // THREE.SSAOPass.OUTPUT.Default
	      1: _t('Occlusion'),
	      // THREE.SSAOPass.OUTPUT.SSAO
	      2: _t('Occlusion&Blur'),
	      // THREE.SSAOPass.OUTPUT.Blur
	      3: _t('Beauty'),
	      // THREE.SSAOPass.OUTPUT.Beauty
	      4: _t('Depth'),
	      // THREE.SSAOPass.OUTPUT.Depth
	      5: _t('Normal') // THREE.SSAOPass.OUTPUT.Normal

	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      output: 0,
	      kernelRadius: 10,
	      minDistance: 0.001,
	      maxDistance: 0.1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      output,
	      kernelRadius,
	      minDistance,
	      maxDistance
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('SSAO'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Output'),
	      options: this.output,
	      name: 'output',
	      value: output,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('KernalRadius'),
	      name: 'kernelRadius',
	      value: kernelRadius,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MinDistance'),
	      name: 'minDistance',
	      value: minDistance,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('MaxDistance'),
	      name: 'maxDistance',
	      value: maxDistance,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SsaoComponent`, this.handleUpdate);
	    app.on(`objectChanged.SsaoComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.ssao ? postProcessing.ssao.enabled : false,
	      output: postProcessing.ssao ? postProcessing.ssao.output : this.state.output,
	      kernelRadius: postProcessing.ssao ? postProcessing.ssao.kernelRadius : this.state.kernelRadius,
	      minDistance: postProcessing.ssao ? postProcessing.ssao.minDistance : this.state.minDistance,
	      maxDistance: postProcessing.ssao ? postProcessing.ssao.maxDistance : this.state.maxDistance
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      output,
	      kernelRadius,
	      minDistance,
	      maxDistance
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      ssao: {
	        enabled,
	        output,
	        kernelRadius,
	        minDistance,
	        maxDistance
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 时间抗锯齿(TAA)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TaaComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.sampleLevel = {
	      0: _t('1 Sample'),
	      1: _t('2 Samples'),
	      2: _t('4 Samples'),
	      3: _t('8 Samples'),
	      4: _t('16 Samples'),
	      5: _t('32 Samples')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      sampleLevel: 3,
	      unbiased: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      sampleLevel,
	      unbiased
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('TAA'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Level'),
	      options: this.sampleLevel,
	      name: 'sampleLevel',
	      value: sampleLevel,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Unbiased'),
	      name: 'unbiased',
	      value: unbiased,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TaaComponent`, this.handleUpdate);
	    app.on(`objectChanged.TaaComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.taa ? postProcessing.taa.enabled : false,
	      sampleLevel: postProcessing.taa ? postProcessing.taa.sampleLevel : this.state.sampleLevel,
	      unbiased: postProcessing.taa ? postProcessing.taa.unbiased : this.state.unbiased
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      sampleLevel,
	      unbiased
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      taa: {
	        enabled,
	        sampleLevel,
	        unbiased
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 属性面板
	 * @author tengge / https://github.com/tengge1
	 */

	class PropertyPanel extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(PropertyGrid, null, /*#__PURE__*/React.createElement(BasicComponent, null), /*#__PURE__*/React.createElement(TransformComponent, null), /*#__PURE__*/React.createElement(SceneComponent, null), /*#__PURE__*/React.createElement(LightComponent, null), /*#__PURE__*/React.createElement(ShadowComponent, null), /*#__PURE__*/React.createElement(CameraComponent, null), /*#__PURE__*/React.createElement(AudioListenerComponent, null), /*#__PURE__*/React.createElement(BackgroundMusicComponent, null), /*#__PURE__*/React.createElement(ReflectorComponent, null), /*#__PURE__*/React.createElement(FireComponent, null), /*#__PURE__*/React.createElement(WaterComponent, null), /*#__PURE__*/React.createElement(SmokeComponent, null), /*#__PURE__*/React.createElement(LMeshComponent, null), /*#__PURE__*/React.createElement(ClothComponent, null), /*#__PURE__*/React.createElement(PerlinTerrainComponent, null), /*#__PURE__*/React.createElement(SkyComponent, null), /*#__PURE__*/React.createElement(ParticleEmitterComponent, null), /*#__PURE__*/React.createElement(MMDComponent, null), /*#__PURE__*/React.createElement(GisBasicComponent, null), /*#__PURE__*/React.createElement(CatmullRomCurveComponent, null), /*#__PURE__*/React.createElement(CubicBezierCurveComponent, null), /*#__PURE__*/React.createElement(EllipseCurveComponent, null), /*#__PURE__*/React.createElement(LineCurveComponent, null), /*#__PURE__*/React.createElement(QuadraticBezierCurveComponent, null), /*#__PURE__*/React.createElement(ControlComponent, null), /*#__PURE__*/React.createElement(FirstPersonControlComponent, null), /*#__PURE__*/React.createElement(FlyControlComponent, null), /*#__PURE__*/React.createElement(OrbitControlComponent, null), /*#__PURE__*/React.createElement(PointerLockControlComponent, null), /*#__PURE__*/React.createElement(TrackballControlComponent, null), /*#__PURE__*/React.createElement(PhysicsTypeComponent, null), /*#__PURE__*/React.createElement(PhysicsWorldComponent, null), /*#__PURE__*/React.createElement(RigidBodyComponent, null), /*#__PURE__*/React.createElement(SoftVolumeComponent, null), /*#__PURE__*/React.createElement(BufferGeometryComponent, null), /*#__PURE__*/React.createElement(BoxGeometryComponent, null), /*#__PURE__*/React.createElement(CircleGeometryComponent, null), /*#__PURE__*/React.createElement(CylinderGeometryComponent, null), /*#__PURE__*/React.createElement(IcosahedronGeometryComponent, null), /*#__PURE__*/React.createElement(LatheGeometryComponent, null), /*#__PURE__*/React.createElement(PlaneGeometryComponent, null), /*#__PURE__*/React.createElement(SphereGeometryComponent, null), /*#__PURE__*/React.createElement(TeapotGeometryComponent, null), /*#__PURE__*/React.createElement(TorusGeometryComponent, null), /*#__PURE__*/React.createElement(TorusKnotGeometryComponent, null), /*#__PURE__*/React.createElement(MultiMaterialComponent, null), /*#__PURE__*/React.createElement(MaterialComponent, null), /*#__PURE__*/React.createElement(AfterimageComponent, null), /*#__PURE__*/React.createElement(BokehComponent, null), /*#__PURE__*/React.createElement(DotScreenComponent, null), /*#__PURE__*/React.createElement(FxaaComponent, null), /*#__PURE__*/React.createElement(GlitchComponent, null), /*#__PURE__*/React.createElement(HalftoneComponent, null), /*#__PURE__*/React.createElement(PixelComponent, null), /*#__PURE__*/React.createElement(RgbShiftComponent, null), /*#__PURE__*/React.createElement(SaoComponent, null), /*#__PURE__*/React.createElement(SmaaComponent, null), /*#__PURE__*/React.createElement(SsaaComponent, null), /*#__PURE__*/React.createElement(SsaoComponent, null), /*#__PURE__*/React.createElement(TaaComponent, null));
	  }

	}

	/**
	 * 片源着色器起始代码
	 * @returns {String} 代码
	 */
	function FragmentShaderStarter() {
	  return `
precision mediump float;

void main()	{
	gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
`;
	}

	/**
	 * JavaScript起始代码
	 * @returns {String} 代码
	 */
	function JavaScriptStarter() {
	  return `
// ${_t('Execute before scene render')}
function init() {

}

// ${_t('Execute after scene render')}
function start() {

}

// ${_t('Execute each frame during running')}
function update(clock, deltaTime) {

}

// ${_t('Execute after program stopped')}
function stop() {

}

// ${_t('Listen to click event')}
function onClick(event) {

}

// ${_t('Listen to dblclick event')}
function onDblClick(event) {

}

// ${_t('Listen to keydown event')}
function onKeyDown(event) {

}

// ${_t('Listen to keyup event')}
function onKeyUp(event) {

}

// ${_t('Listen to mousedown event')}
function onMouseDown(event) {

}

// ${_t('Listen to mousemove event')}
function onMouseMove(event) {

}

// ${_t('Listen to mouseup event')}
function onMouseUp(event) {

}

// ${_t('Listen to mousewheel event')}
function onMouseWheel(event) {

}

// ${_t('Listen to resize event')}
function onResize(event) {

}
`;
	}

	/**
	 * Json起始代码
	 * @returns {String} 代码
	 */
	function JsonStarter() {
	  return `
{
    "defines": {

    },
    "uniforms": {

    },
    "attributes": {

    }
}
`;
	}

	/**
	 * 顶点着色器起始代码
	 * @returns {String} 代码
	 */
	function VertexShaderStarter() {
	  return `
precision mediump float;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

attribute vec3 position;

void main()	{
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
	}

	/**
	 * 脚本窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class ScriptWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.scriptTypes = {
	      'javascript': 'JavaScript',
	      'vertexShader': _t('Vertex Shader'),
	      'fragmentShader': _t('Frag Shader'),
	      'json': _t('Shader Program Info')
	    };
	    this.state = {
	      name: _t('New Script'),
	      type: 'javascript'
	    };
	    this.handleNameChange = this.handleNameChange.bind(this);
	    this.handleTypeChange = this.handleTypeChange.bind(this);
	    this.handleOK = this.handleOK.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	    this.handleSaveScript = this.handleSaveScript.bind(this);
	  }

	  render() {
	    const {
	      name,
	      type
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'ScriptWindow',
	      title: _t('Create Script'),
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Name')), /*#__PURE__*/React.createElement(Input, {
	      value: name,
	      onChange: this.handleNameChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Type')), /*#__PURE__*/React.createElement(Select, {
	      options: this.scriptTypes,
	      value: type,
	      disabled: true,
	      onChange: this.handleTypeChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleOK
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  handleNameChange(value) {
	    this.setState({
	      name: value
	    });
	  }

	  handleTypeChange(value) {
	    this.setState({
	      type: value
	    });
	  }

	  handleOK() {
	    const {
	      name,
	      type
	    } = this.state;
	    const uuid = THREE.Math.generateUUID();
	    let source = '';

	    switch (type) {
	      case 'javascript':
	        source = JavaScriptStarter();
	        break;

	      case 'vertexShader':
	        source = VertexShaderStarter();
	        break;

	      case 'fragmentShader':
	        source = FragmentShaderStarter();
	        break;

	      case 'json':
	        source = JsonStarter();
	        break;

	      default:
	        source = JavaScriptStarter();
	    }

	    const index = app.editor.scripts.findIndex(n => n.uuid === uuid);

	    if (index > -1) {
	      app.editor.scripts[index] = {
	        id: null,
	        name,
	        type,
	        source,
	        uuid
	      };
	    } else {
	      app.editor.scripts.push({
	        id: null,
	        name,
	        type,
	        source,
	        uuid
	      });
	    }

	    app.call(`scriptChanged`, this);
	    this.handleClose();
	    this.setState({
	      show: false,
	      uuid: null,
	      name: '',
	      type: 'javascript',
	      source: ''
	    });
	    app.call(`editScript`, this, uuid, name, type, source, this.handleSaveScript);
	  }

	  handleSaveScript(uuid, name, type, source) {
	    const index = app.editor.scripts.findIndex(n => n.uuid === uuid);

	    if (index > -1) {
	      app.editor.scripts[index] = {
	        id: null,
	        uuid,
	        name,
	        type,
	        source
	      };
	    } else {
	      app.editor.scripts.push({
	        id: null,
	        uuid,
	        name,
	        type,
	        source
	      });
	    }

	    app.call(`scriptChanged`, this);
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 历史面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ScriptPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      scripts: [],
	      selected: null,
	      expanded: {},
	      mask: false
	    };
	    this.handleAddScript = this.handleAddScript.bind(this);
	    this.handleAddFolder = this.handleAddFolder.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleRefresh = this.handleRefresh.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.handleEditScript = this.handleEditScript.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleDrop = this.handleDrop.bind(this);
	    this.update = this.update.bind(this);
	    this.save = this.save.bind(this);
	  }

	  render() {
	    const {
	      scripts,
	      selected,
	      expanded,
	      mask
	    } = this.state;
	    const tree = [];
	    this.createScriptTree(0, tree, scripts, expanded);
	    let script = null;

	    if (selected !== null) {
	      script = scripts.filter(n => n.uuid === selected)[0];
	    }

	    return /*#__PURE__*/React.createElement("div", {
	      className: 'ScriptPanel'
	    }, /*#__PURE__*/React.createElement("div", {
	      className: 'toolbar'
	    }, /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'add script',
	      title: _t('Create Script'),
	      onClick: this.handleAddScript
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'add-folder',
	      title: _t('Create Folder'),
	      onClick: this.handleAddFolder
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'edit',
	      title: _t('Edit'),
	      disabled: script === null,
	      onClick: this.handleEdit
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'refresh',
	      title: _t('Refresh'),
	      onClick: this.handleRefresh
	    }), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'delete',
	      title: _t('Delete'),
	      disabled: script === null,
	      onClick: this.handleDelete
	    }), /*#__PURE__*/React.createElement(ToolbarSeparator, null), /*#__PURE__*/React.createElement(IconButton, {
	      icon: 'edit',
	      title: _t('Edit Script'),
	      disabled: script === null || script.type === 'folder',
	      onClick: this.handleEditScript
	    })), /*#__PURE__*/React.createElement("div", {
	      className: 'content'
	    }, /*#__PURE__*/React.createElement(Tree, {
	      data: tree,
	      selected: selected,
	      mask: mask,
	      onSelect: this.handleSelect,
	      onExpand: this.handleExpand,
	      onDrop: this.handleDrop
	    })));
	  }

	  createScriptTree(pid, tree, scripts, expanded) {
	    let list = null;

	    if (pid === 0) {
	      list = scripts.filter(n => n.pid === undefined || n.pid === null);
	    } else {
	      list = scripts.filter(n => n.pid === pid);
	    }

	    if (!list || list.length === 0) {
	      return;
	    }

	    list.sort((a, b) => {
	      if (!a.sort) {
	        a.sort = 0;
	      }

	      if (!b.sort) {
	        b.sort = 0;
	      }

	      return a.sort - b.sort;
	    });
	    list.forEach(n => {
	      if (n.type === 'folder') {
	        let node = {
	          value: n.uuid,
	          text: `${n.name}`,
	          children: [],
	          leaf: false,
	          expanded: expanded[n.uuid] !== false
	        };
	        tree.push(node);
	        this.createScriptTree(n.uuid, node.children, scripts, expanded);
	      } else {
	        tree.push({
	          value: n.uuid,
	          text: `${n.name}.${this.getExtension(n.type)}`,
	          leaf: true
	        });
	      }
	    });
	  }

	  getExtension(type) {
	    let extension = '';

	    switch (type) {
	      case 'javascript':
	        extension = 'js';
	        break;

	      case 'vertexShader':
	        extension = 'glsl';
	        break;

	      case 'fragmentShader':
	        extension = 'glsl';
	        break;

	      case 'json':
	        extension = 'json';
	        break;
	    }

	    return extension;
	  }

	  componentDidMount() {
	    app.on(`scriptChanged.ScriptPanel`, this.update);
	  }

	  update() {
	    this.setState({
	      scripts: app.editor.scripts
	    });
	  }

	  handleAddScript() {
	    const window = app.createElement(ScriptWindow);
	    app.addElement(window);
	  }

	  handleAddFolder() {
	    app.prompt({
	      title: _t('Input Folder Name'),
	      content: _t('Folder Name'),
	      value: _t('New folder'),
	      onOK: value => {
	        app.editor.scripts.push({
	          id: null,
	          pid: null,
	          name: value,
	          type: 'folder',
	          uuid: THREE.Math.generateUUID(),
	          sort: 0
	        });
	        app.call(`scriptChanged`, this);
	      }
	    });
	  }

	  handleEdit() {
	    const selected = this.state.selected;

	    if (selected === null) {
	      return;
	    }

	    var script = app.editor.scripts.filter(n => n.uuid === selected)[0];
	    app.prompt({
	      title: _t('Input New Name'),
	      content: _t('Name'),
	      value: script.name,
	      onOK: value => {
	        script.name = value;
	        app.call('scriptChanged', this);
	      }
	    });
	  }

	  handleRefresh() {
	    // TODO: 为了显示LoadMask，刷新一次其实刷新了两次。
	    this.setState({
	      mask: true
	    }, () => {
	      setTimeout(() => {
	        this.setState({
	          mask: false
	        });
	      }, 100);
	    });
	  }

	  handleDelete() {
	    const selected = this.state.selected;

	    if (selected === null) {
	      return;
	    }

	    const script = app.editor.scripts.filter(n => n.uuid === selected)[0];
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${script.name}.${this.getExtension(script.type)}?`,
	      onOK: () => {
	        delete app.editor.scripts[script.uuid];
	        app.call('scriptChanged', this);
	      }
	    });
	  }

	  handleEditScript() {
	    const selected = this.state.selected;

	    if (selected === null) {
	      return;
	    }

	    var script = app.editor.scripts.filter(n => n.uuid === selected)[0];

	    if (script) {
	      app.call(`editScript`, this, script.uuid, script.name, script.type, script.source, this.save);
	    }
	  }

	  handleSelect(value) {
	    this.setState({
	      selected: value
	    });
	  }

	  handleExpand(value) {
	    let {
	      expanded
	    } = this.state;

	    if (expanded[value] === undefined || expanded[value] === true) {
	      expanded[value] = false;
	    } else {
	      expanded[value] = true;
	    }

	    this.setState({
	      expanded
	    });
	  }

	  handleDrop(current, newParent, newIndex) {
	    let scripts = this.state.scripts;

	    if (newParent) {
	      let parent = scripts.filter(n => n.uuid === newParent)[0];

	      if (parent.type !== 'folder') {
	        app.toast(_t('It is not allowed to drop on another script.'));
	        return;
	      }
	    }

	    let currentScript = scripts.filter(n => n.uuid === current)[0];
	    currentScript.pid = newParent; // 排序

	    if (!newParent) {
	      scripts = scripts.filter(n => !n.pid && n !== currentScript);
	    } else {
	      scripts = scripts.filter(n => n.pid === newParent && n !== currentScript);
	    }

	    let index = scripts.findIndex(n => n.uuid === newIndex);
	    scripts.splice(index, 0, currentScript);
	    scripts.forEach((n, i) => {
	      n.sort = i;
	    });
	    app.call(`scriptChanged`, this);
	  }

	  save(uuid, name, type, source) {
	    const index = app.editor.scripts.findIndex(n => n.uuid === uuid);

	    if (index > -1) {
	      app.editor.scripts[index] = {
	        id: null,
	        uuid,
	        name,
	        type,
	        source
	      };
	    } else {
	      app.editor.scripts.push({
	        id: null,
	        uuid,
	        name,
	        type,
	        source
	      });
	    }

	    app.call(`scriptChanged`, this);
	  }

	}

	/**
	 * 动画基本信息组件
	 * @author tengge / https://github.com/tengge1
	 */

	class BasicAnimationComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.animationType = {
	      Tween: _t('Tween Animation'),
	      Skeletal: _t('Skeletal Animation'),
	      Audio: _t('Play Audio'),
	      Filter: _t('Filter Animation'),
	      Particle: _t('Particle Animation')
	    };
	    this.state = {
	      show: false,
	      expanded: true,
	      name: '',
	      target: null,
	      type: null,
	      beginTime: 0,
	      endTime: 10
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleSetTarget = this.handleSetTarget.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      name,
	      target,
	      type,
	      beginTime,
	      endTime
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Basic Information'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(TextProperty, {
	      label: _t('Name'),
	      name: 'name',
	      value: name,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(DisplayProperty, {
	      label: _t('Target'),
	      name: 'target',
	      value: target ? target : `(${_t('None')})`,
	      btnText: _t('Set Target'),
	      btnShow: app.editor.selected !== null,
	      onClick: this.handleSetTarget,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Type'),
	      options: this.animationType,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('BeginTime'),
	      name: 'beginTime',
	      value: beginTime,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: _t('EndTime'),
	      name: 'endTime',
	      value: endTime,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`animationSelected.BasicAnimationComponent`, this.handleUpdate.bind(this));
	    app.on(`animationChanged.BasicAnimationComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate(animation) {
	    if (!animation) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.animation = animation;
	    let state = {
	      show: true,
	      name: this.animation.name,
	      type: this.animation.type,
	      beginTime: this.animation.beginTime,
	      endTime: this.animation.endTime
	    };

	    if (!this.animation.target) {
	      state.target = null;
	    } else {
	      let obj = app.editor.objectByUuid(this.animation.target);

	      if (obj === null) {
	        state.target = null;
	        console.warn(`BasicAnimationComponent: ${_t('Animation Object')} ${this.animation.target} ${_t('is not existed in the scene.')}`);
	      } else {
	        state.target = obj.name;
	      }
	    }

	    this.setState(state);
	  }

	  handleSetTarget() {
	    let selected = app.editor.selected;

	    if (selected === null) {
	      this.animation.target = null;
	    } else {
	      this.animation.target = selected.uuid;
	    }

	    app.call('animationChanged', this, this.animation);
	  }

	  handleChange(value, animName) {
	    if (value === null) {
	      this.setState({
	        [animName]: value
	      });
	      return;
	    }

	    const {
	      name,
	      type,
	      beginTime,
	      endTime
	    } = Object.assign({}, this.state, {
	      [animName]: value
	    });
	    this.animation.name = name;
	    this.animation.type = type;
	    this.animation.beginTime = beginTime;
	    this.animation.endTime = endTime;
	    app.call('animationChanged', this, this.animation);
	  }

	}

	/**
	 * 补间动画组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TweenAnimationComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.beginStatus = {
	      Current: _t('Current Status'),
	      Custom: _t('Custom Status')
	    };
	    this.ease = {
	      linear: 'Linear',
	      quadIn: 'Quad In',
	      quadOut: 'Quad Out',
	      quadInOut: 'Quad In Out',
	      cubicIn: 'Cubic In',
	      cubicOut: 'Cubic Out',
	      cubicInOut: 'Cubic InOut',
	      quartIn: 'Quart In',
	      quartOut: 'Quart Out',
	      quartInOut: 'Quart InOut',
	      quintIn: 'Quint In',
	      quintOut: 'Quint Out',
	      quintInOut: 'Quint In Out',
	      sineIn: 'Sine In',
	      sineOut: 'Sine Out',
	      sineInOut: 'Sine In Out',
	      backIn: 'Back In',
	      backOut: 'Back Out',
	      backInOut: 'Back In Out',
	      circIn: 'Circ In',
	      circOut: 'Circ Out',
	      circInOut: 'Circ In Out',
	      bounceIn: 'Bounce In',
	      bounceOut: 'Bounce Out',
	      bounceInOut: 'Bounce In Out',
	      elasticIn: 'Elastic In',
	      elasticOut: 'Elastic Out',
	      elasticInOut: 'Elastic In Out'
	    };
	    this.state = {
	      show: false,
	      expanded: true,
	      beginStatus: 'Custom',
	      showBeginState: false,
	      beginPositionX: 0,
	      beginPositionY: 0,
	      beginPositionZ: 0,
	      beginRotationX: 0,
	      beginRotationY: 0,
	      beginRotationZ: 0,
	      beginScaleLock: true,
	      beginScaleX: 1,
	      beginScaleY: 1,
	      beginScaleZ: 1,
	      ease: 'Linear',
	      endStatus: 'Custom',
	      showEndState: false,
	      endPositionX: 0,
	      endPositionY: 0,
	      endPositionZ: 0,
	      endRotationX: 0,
	      endRotationY: 0,
	      endRotationZ: 0,
	      endScaleLock: true,
	      endScaleX: 1,
	      endScaleY: 1,
	      endScaleZ: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      beginStatus,
	      showBeginState,
	      beginPositionX,
	      beginPositionY,
	      beginPositionZ,
	      beginRotationX,
	      beginRotationY,
	      beginRotationZ,
	      beginScaleLock,
	      beginScaleX,
	      beginScaleY,
	      beginScaleZ,
	      ease,
	      endStatus,
	      showEndState,
	      endPositionX,
	      endPositionY,
	      endPositionZ,
	      endRotationX,
	      endRotationY,
	      endRotationZ,
	      endScaleLock,
	      endScaleX,
	      endScaleY,
	      endScaleZ
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(PropertyGroup, {
	      title: _t('Tween Animation'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Begin Status'),
	      options: this.beginStatus,
	      name: 'beginStatus',
	      value: beginStatus,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Begin Position')} X`,
	      name: 'beginPositionX',
	      value: beginPositionX,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Begin Position')} Y`,
	      name: 'beginPositionY',
	      value: beginPositionY,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Begin Position')} Z`,
	      name: 'beginPositionZ',
	      value: beginPositionZ,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Begin Rotation')} X`,
	      name: 'beginRotationX',
	      value: beginRotationX,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Begin Rotation')} Y`,
	      name: 'beginRotationY',
	      value: beginRotationY,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Begin Rotation')} Z`,
	      name: 'beginRotationZ',
	      value: beginRotationZ,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('Begin Scale Lock'),
	      name: 'beginScaleLock',
	      value: beginScaleLock,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Begin Scale')} X`,
	      name: 'beginScaleX',
	      value: beginScaleX,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Begin Scale')} Y`,
	      name: 'beginScaleY',
	      value: beginScaleY,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('Begin Scale')} Z`,
	      name: 'beginScaleZ',
	      value: beginScaleZ,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('Ease Func'),
	      options: this.ease,
	      name: 'ease',
	      value: ease,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(SelectProperty, {
	      label: _t('End Status'),
	      options: this.beginStatus,
	      name: 'endStatus',
	      value: endStatus,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('End Position')} X`,
	      name: 'endPositionX',
	      value: endPositionX,
	      show: showEndState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('End Position')} Y`,
	      name: 'endPositionY',
	      value: endPositionY,
	      show: showEndState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('End Position')} Z`,
	      name: 'endPositionZ',
	      value: endPositionZ,
	      show: showEndState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('End Rotation')} X`,
	      name: 'endRotationX',
	      value: endRotationX,
	      show: showEndState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('End Rotation')} Y`,
	      name: 'endRotationY',
	      value: endRotationY,
	      show: showEndState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('End Rotation')} Z`,
	      name: 'endRotationZ',
	      value: endRotationZ,
	      show: showEndState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(CheckBoxProperty, {
	      label: _t('End Scale Lock'),
	      name: 'endScaleLock',
	      value: endScaleLock,
	      show: showEndState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('End Scale')} X`,
	      name: 'endScaleX',
	      value: endScaleX,
	      show: showEndState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('End Scale')} Y`,
	      name: 'endScaleY',
	      value: endScaleY,
	      show: showEndState,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement(NumberProperty, {
	      label: `${_t('End Scale')} Z`,
	      name: 'endScaleZ',
	      value: endScaleZ,
	      show: showEndState,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`animationSelected.TweenAnimationComponent`, this.handleUpdate.bind(this));
	    app.on(`animationChanged.TweenAnimationComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate(animation) {
	    if (!animation || animation.type !== 'Tween') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.animation = animation;
	    let data = this.animation.data;
	    let state = {
	      show: true,
	      beginStatus: data.beginStatus,
	      showBeginState: data.beginStatus === 'Custom',
	      beginPositionX: data.beginPositionX,
	      beginPositionY: data.beginPositionY,
	      beginPositionZ: data.beginPositionZ,
	      beginRotationX: data.beginRotationX * 180 / Math.PI,
	      beginRotationY: data.beginRotationY * 180 / Math.PI,
	      beginRotationZ: data.beginRotationZ * 180 / Math.PI,
	      beginScaleLock: data.beginScaleLock,
	      beginScaleX: data.beginScaleX,
	      beginScaleY: data.beginScaleY,
	      beginScaleZ: data.beginScaleZ,
	      ease: data.ease,
	      endStatus: data.endStatus,
	      showEndState: data.endStatus === 'Custom',
	      endPositionX: data.endPositionX,
	      endPositionY: data.endPositionY,
	      endPositionZ: data.endPositionZ,
	      endRotationX: data.endRotationX * 180 / Math.PI,
	      endRotationY: data.endRotationY * 180 / Math.PI,
	      endRotationZ: data.endRotationZ * 180 / Math.PI,
	      endScaleLock: data.endScaleLock,
	      endScaleX: data.endScaleX,
	      endScaleY: data.endScaleY,
	      endScaleZ: data.endScaleZ
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      beginStatus,
	      beginPositionX,
	      beginPositionY,
	      beginPositionZ,
	      beginRotationX,
	      beginRotationY,
	      beginRotationZ,
	      beginScaleLock,
	      beginScaleX,
	      beginScaleY,
	      beginScaleZ,
	      ease,
	      endStatus,
	      endPositionX,
	      endPositionY,
	      endPositionZ,
	      endRotationX,
	      endRotationY,
	      endRotationZ,
	      endScaleLock,
	      endScaleX,
	      endScaleY,
	      endScaleZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.animation.data = this.animation.data || {};
	    this.animation.data.beginStatus = beginStatus;
	    this.animation.data.beginPositionX = beginPositionX;
	    this.animation.data.beginPositionY = beginPositionY;
	    this.animation.data.beginPositionZ = beginPositionZ;
	    this.animation.data.beginRotationX = beginRotationX * Math.PI / 180;
	    this.animation.data.beginRotationY = beginRotationY * Math.PI / 180;
	    this.animation.data.beginRotationZ = beginRotationZ * Math.PI / 180;
	    this.animation.data.beginScaleLock = beginScaleLock;
	    this.animation.data.beginScaleX = beginScaleX;
	    this.animation.data.beginScaleY = beginScaleY;
	    this.animation.data.beginScaleZ = beginScaleZ;
	    this.animation.data.ease = ease;
	    this.animation.data.endStatus = endStatus;
	    this.animation.data.endPositionX = endPositionX;
	    this.animation.data.endPositionY = endPositionY;
	    this.animation.data.endPositionZ = endPositionZ;
	    this.animation.data.endRotationX = endRotationX * Math.PI / 180;
	    this.animation.data.endRotationY = endRotationY * Math.PI / 180;
	    this.animation.data.endRotationZ = endRotationZ * Math.PI / 180;
	    this.animation.data.endScaleLock = endScaleLock;
	    this.animation.data.endScaleX = endScaleX;
	    this.animation.data.endScaleY = endScaleY;
	    this.animation.data.endScaleZ = endScaleZ;
	    app.call('animationChanged', this, this.animation);
	  }

	}

	/**
	 * 动画属性面板
	 * @author tengge / https://github.com/tengge1
	 */

	class AnimationPropertyPanel extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    return /*#__PURE__*/React.createElement(PropertyGrid, null, /*#__PURE__*/React.createElement(BasicAnimationComponent, null), /*#__PURE__*/React.createElement(TweenAnimationComponent, null));
	  }

	}

	/**
	 * 侧边栏
	 * @author tengge / https://github.com/tengge1
	 */

	class EditorSideBar extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      topIndex: 0,
	      bottomIndex: 0
	    };
	    this.handleTopTabChange = this.handleTopTabChange.bind(this);
	    this.handleBottomTabChange = this.handleBottomTabChange.bind(this);
	    this.handleAnimationSelected = this.handleAnimationSelected.bind(this);
	  }

	  render() {
	    const {
	      topIndex,
	      bottomIndex
	    } = this.state;
	    return /*#__PURE__*/React.createElement(VBoxLayout, {
	      className: 'EditorSideBar'
	    }, /*#__PURE__*/React.createElement(TabLayout, {
	      className: 'top',
	      activeTabIndex: topIndex,
	      onActiveTabChange: this.handleTopTabChange
	    }, /*#__PURE__*/React.createElement(HierarchyPanel, {
	      title: _t('Hierachy')
	    }), /*#__PURE__*/React.createElement(HistoryPanel, {
	      title: _t('History')
	    })), /*#__PURE__*/React.createElement(TabLayout, {
	      className: 'bottom',
	      activeTabIndex: bottomIndex,
	      onActiveTabChange: this.handleBottomTabChange
	    }, /*#__PURE__*/React.createElement(PropertyPanel, {
	      title: _t('Property')
	    }), /*#__PURE__*/React.createElement(ScriptPanel, {
	      title: _t('Script')
	    }), /*#__PURE__*/React.createElement(AnimationPropertyPanel, {
	      title: _t('Animation')
	    })));
	  }

	  componentDidMount() {
	    app.on(`animationSelected.EditorSideBar`, this.handleAnimationSelected);
	  }

	  handleTopTabChange(index) {
	    this.setState({
	      topIndex: index
	    });
	  }

	  handleBottomTabChange(index) {
	    this.setState({
	      bottomIndex: index
	    });
	  }

	  handleAnimationSelected() {
	    this.setState({
	      bottomIndex: 2
	    });
	  }

	}

	/**
	 * 类别编辑窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class CategoryEditWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      name: props.name
	    };
	    this.handleOK = this.handleOK.bind(this, props.callback);
	    this.handleNameChange = this.handleNameChange.bind(this);
	    this.handleCancel = this.handleCancel.bind(this);
	  }

	  render() {
	    const {
	      typeName,
	      id
	    } = this.props;
	    const {
	      name
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'CategoryEditWindow',
	      title: id ? `${typeName} ${_t('Category Edit')}` : `${typeName} ${_t('Category Add')}`,
	      style: {
	        width: '380px',
	        height: '200px'
	      },
	      mask: false,
	      onClose: this.handleCancel
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Name')), /*#__PURE__*/React.createElement(Input, {
	      value: name,
	      onChange: this.handleNameChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleOK
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleCancel
	    }, _t('Cancel'))));
	  }

	  handleNameChange(value) {
	    this.setState({
	      name: value
	    });
	  }

	  handleOK(callback) {
	    const {
	      id,
	      type
	    } = this.props;
	    const {
	      name
	    } = this.state;
	    let body = `type=${type}&name=${name}`;

	    if (id) {
	      body += `&id=${id}`;
	    }

	    fetch(`${app.options.server}/api/Category/Save`, {
	      method: 'POST',
	      headers: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      body
	    }).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.handleCancel();
	        callback && callback();
	      });
	    });
	  }

	  handleCancel() {
	    app.removeElement(this);
	  }

	}

	CategoryEditWindow.propTypes = {
	  type: propTypes.string,
	  typeName: propTypes.string,
	  id: propTypes.string,
	  name: propTypes.string,
	  callback: propTypes.func
	};
	CategoryEditWindow.defaultProps = {
	  type: 'Scene',
	  typeName: 'Scene',
	  id: null,
	  name: '',
	  callback: null
	};

	/**
	 * 类别窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class CategoryWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      selected: null
	    };
	    this.updateUI = this.updateUI.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      typeName
	    } = this.props;
	    const {
	      data,
	      selected
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'CategoryWindow',
	      title: `${typeName} ${_t('Category Edit')}`,
	      style: {
	        width: '280px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(VBoxLayout, {
	      className: 'box'
	    }, /*#__PURE__*/React.createElement(Toolbar, {
	      className: 'toolbar'
	    }, /*#__PURE__*/React.createElement(Button, {
	      show: !enableAuthority || authorities.includes('SAVE_CATEGORY'),
	      onClick: this.handleAdd
	    }, _t('Create')), /*#__PURE__*/React.createElement(Button, {
	      show: !enableAuthority || authorities.includes('SAVE_CATEGORY'),
	      onClick: this.handleEdit
	    }, _t('Edit')), /*#__PURE__*/React.createElement(Button, {
	      show: !enableAuthority || authorities.includes('DELETE_CATEGORY'),
	      onClick: this.handleDelete
	    }, _t('Delete'))), /*#__PURE__*/React.createElement(DataGrid, {
	      className: 'list',
	      data: data,
	      selected: selected ? selected.ID : null,
	      onSelect: this.handleSelect
	    }, /*#__PURE__*/React.createElement(Column, {
	      type: 'number',
	      title: _t('#')
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Name',
	      title: _t('Name')
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  componentDidMount() {
	    this.updateUI();
	  }

	  updateUI() {
	    Ajax.getJson(`${app.options.server}/api/Category/List?Type=${this.props.type}`, json => {
	      this.setState({
	        data: json.Data.map(n => {
	          return {
	            id: n.ID,
	            ID: n.ID,
	            Name: n.Name
	          };
	        })
	      });
	    });
	  }

	  handleAdd() {
	    const {
	      type,
	      typeName
	    } = this.props;
	    let window = app.createElement(CategoryEditWindow, {
	      type,
	      typeName,
	      id: null,
	      name: '',
	      callback: this.updateUI
	    });
	    app.addElement(window);
	  }

	  handleEdit() {
	    const {
	      type,
	      typeName
	    } = this.props;
	    const {
	      selected
	    } = this.state;

	    if (!selected) {
	      app.toast(_t('Please select a record.'), 'warn');
	      return;
	    }

	    let window = app.createElement(CategoryEditWindow, {
	      type,
	      typeName,
	      id: selected.ID,
	      name: selected.Name,
	      callback: this.updateUI
	    });
	    app.addElement(window);
	  }

	  handleDelete() {
	    const {
	      selected
	    } = this.state;

	    if (!selected) {
	      app.toast(_t('Please select a record.'), 'warn');
	      return;
	    }

	    app.confirm({
	      title: _t('Query'),
	      content: _t('Delete this category?'),
	      onOK: () => {
	        fetch(`${app.options.server}/api/Category/Delete?ID=${selected.ID}`, {
	          method: 'POST',
	          headers: {
	            'Content-Type': 'application/x-www-form-urlencoded'
	          }
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code !== 200) {
	              app.toast(_t(obj.Msg), 'warn');
	              return;
	            }

	            this.updateUI();
	          });
	        });
	      }
	    });
	  }

	  handleSelect(obj) {
	    this.setState({
	      selected: obj
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	CategoryWindow.propTypes = {
	  type: propTypes.oneOf(['Scene', 'Mesh', 'Map', 'Texture', 'Material', 'Audio', 'Animation', 'Particle', 'Screenshot', 'Video']),
	  typeName: propTypes.string,
	  callback: propTypes.func
	};
	CategoryWindow.defaultProps = {
	  type: 'Scene',
	  typeName: 'Scene',
	  callback: null
	};

	/**
	 * 编辑场景窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class EditSceneWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      activeTabIndex: 0,
	      name: props.data.Name,
	      categories: null,
	      categoryID: props.data.CategoryID,
	      thumbnail: props.data.Thumbnail,
	      isPublic: props.data.IsPublic,
	      histories: [],
	      selectedHistory: null
	    };
	    this.handleActiveTabChange = this.handleActiveTabChange.bind(this);
	    this.updateUI = this.updateUI.bind(this);
	    this.handleNameChange = this.handleNameChange.bind(this);
	    this.handleCategoryChange = this.handleCategoryChange.bind(this);
	    this.handleThumbnailChange = this.handleThumbnailChange.bind(this);
	    this.handleIsPublicChange = this.handleIsPublicChange.bind(this);
	    this.handleEditCategoryList = this.handleEditCategoryList.bind(this);
	    this.handleSelectHistory = this.handleSelectHistory.bind(this);
	    this.loadHistoryRenderer = this.loadHistoryRenderer.bind(this);
	    this.handleLoadHistory = this.handleLoadHistory.bind(this);
	    this.handleSave = this.handleSave.bind(this, props.callback);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      typeName
	    } = this.props;
	    const {
	      activeTabIndex,
	      name,
	      categories,
	      categoryID,
	      thumbnail,
	      isPublic,
	      histories,
	      selectedHistory
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'EditSceneWindow',
	      title: `${_t('Edit')} ${typeName}`,
	      style: {
	        width: '400px',
	        height: '320px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(TabLayout, {
	      activeTabIndex: activeTabIndex,
	      onActiveTabChange: this.handleActiveTabChange
	    }, /*#__PURE__*/React.createElement(Form, {
	      title: _t('Basic Info')
	    }, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Name')), /*#__PURE__*/React.createElement(Input, {
	      name: 'name',
	      value: name,
	      onChange: this.handleNameChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Type')), /*#__PURE__*/React.createElement(Select, {
	      name: 'select',
	      options: categories,
	      value: categoryID,
	      onChange: this.handleCategoryChange
	    }), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleEditCategoryList
	    }, _t('Edit'))), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Thumbnail')), /*#__PURE__*/React.createElement(ImageUploader, {
	      server: app.options.server,
	      url: thumbnail,
	      noImageText: _t('No Image'),
	      onChange: this.handleThumbnailChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Is Public')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'isPublic',
	      checked: isPublic ? true : false,
	      onChange: this.handleIsPublicChange
	    }))), /*#__PURE__*/React.createElement(DataGrid, {
	      data: histories,
	      keyField: 'ID',
	      title: _t('Historic Version'),
	      selected: selectedHistory,
	      onSelect: this.handleSelectHistory
	    }, /*#__PURE__*/React.createElement(Column, {
	      type: 'number'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Version',
	      title: _t('Version'),
	      width: 80,
	      align: 'center'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'UpdateTime',
	      title: _t('Update Time'),
	      align: 'center'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'ID',
	      title: _t(''),
	      width: 80,
	      align: 'center',
	      renderer: this.loadHistoryRenderer
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  componentDidMount() {
	    this.updateUI();
	  }

	  handleActiveTabChange(activeTabIndex) {
	    if (activeTabIndex === 1) {
	      // 更新历史数据
	      const {
	        data
	      } = this.props;
	      fetch(`${app.options.server}/api/Scene/HistoryList?ID=${data.ID}`).then(response => {
	        response.json().then(json => {
	          this.setState({
	            histories: json.Data,
	            activeTabIndex
	          });
	        });
	      });
	    } else {
	      this.setState({
	        activeTabIndex
	      });
	    }
	  }

	  updateUI() {
	    Ajax.getJson(`${app.options.server}/api/Category/List?Type=${this.props.type}`, json => {
	      var options = {
	        '': _t('Not Set')
	      };
	      json.Data.forEach(n => {
	        options[n.ID] = n.Name;
	      });
	      this.setState({
	        categories: options
	      });
	    });
	  }

	  handleNameChange(value) {
	    this.setState({
	      name: value
	    });
	  }

	  handleCategoryChange(value) {
	    this.setState({
	      categoryID: value
	    });
	  }

	  handleThumbnailChange(file) {
	    Ajax.post(`${app.options.server}/api/Upload/Upload`, {
	      file
	    }, json => {
	      var obj = JSON.parse(json);

	      if (obj.Code === 200) {
	        this.setState({
	          thumbnail: obj.Data.url
	        });
	      } else {
	        app.toast(_t(obj.Msg), 'warn');
	      }
	    });
	  }

	  handleIsPublicChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleEditCategoryList() {
	    const window = app.createElement(CategoryWindow, {
	      type: this.props.type,
	      typeName: `${this.props.typeName}`
	    });
	    app.addElement(window);
	  }

	  handleSelectHistory(record) {
	    this.setState({
	      selectedHistory: record.ID
	    });
	  }

	  loadHistoryRenderer(id, row) {
	    if (row.IsNew) {
	      // 当前版本
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(LinkButton, {
	      name: row.ID,
	      onClick: this.handleLoadHistory
	    }, _t('Load'));
	  }

	  handleLoadHistory(name) {
	    const history = this.state.histories.filter(n => n.ID === name)[0];

	    if (!history) {
	      app.toast(_t('The scene is not existed!'));
	      return;
	    }

	    let url = `${app.options.server}/api/Scene/Load?ID=${history.SceneID}&Version=${history.Version}`;
	    app.call(`load`, this, url, history.SceneName, history.ID);
	  }

	  handleSave() {
	    const {
	      data,
	      saveUrl,
	      callback
	    } = this.props;
	    const {
	      name,
	      categoryID,
	      thumbnail,
	      isPublic
	    } = this.state;
	    Ajax.post(saveUrl, {
	      ID: data.ID,
	      Name: name,
	      Category: categoryID,
	      Image: thumbnail,
	      IsPublic: isPublic
	    }, json => {
	      var obj = JSON.parse(json);

	      if (obj.Code === 200) {
	        callback && callback(obj);
	        this.handleClose();
	      } else {
	        app.toast(_t(obj.Msg), 'warn');
	      }
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	EditSceneWindow.propTypes = {
	  type: propTypes.oneOf(['Scene']),
	  typeName: propTypes.string,
	  data: propTypes.object,
	  saveUrl: propTypes.string,
	  callback: propTypes.func
	};
	EditSceneWindow.defaultProps = {
	  type: 'Scene',
	  typeName: 'Scene',
	  data: null,
	  saveUrl: null,
	  callback: null
	};

	/**
	 * 场景面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ScenePanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'scenes',
	        cornerText: `v${n.Version}`,
	        showEditButton: !enableAuthority || app.server.isAdmin || n.Username === app.server.username,
	        showDeleteButton: !enableAuthority || app.server.isAdmin || n.Username === app.server.username
	      });
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('ScenePanel', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      showFilterButton: true,
	      onInput: this.handleSearch.bind(this)
	    }), /*#__PURE__*/React.createElement(ImageList, {
	      data: imageListData,
	      showEditButton: !enableAuthority || authorities.includes('EDIT_SCENE'),
	      showDeleteButton: !enableAuthority || authorities.includes('DELETE_SCENE'),
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate() {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	      app.on(`sceneSaved.ScenePanel`, this.update);
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?Type=Scene`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Scene/List`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    let url = `${app.options.server}/api/Scene/Load?ID=${data.id}`; // 下面代码演示使用，请勿删除

	    if (app.options.server === '.') {
	      url = `${app.options.server}/api/Scene/Scene_${data.id}`;
	    }

	    app.call(`load`, this, url, data.Name, data.ID);
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    const window = app.createElement(EditSceneWindow, {
	      type: 'Scene',
	      typeName: _t('Scene'),
	      data,
	      saveUrl: `${app.options.server}/api/Scene/Edit`,
	      callback: this.update
	    });
	    app.addElement(window);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Scene/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code !== 200) {
	              app.toast(_t(obj.Msg), 'warn');
	              return;
	            }

	            this.update();
	          });
	        });
	      }
	    });
	  }

	}

	ScenePanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	ScenePanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 编辑模型窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class EditModelWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      activeTabIndex: 0,
	      name: props.data.Name,
	      categories: null,
	      categoryID: props.data.CategoryID,
	      thumbnail: props.data.Thumbnail,
	      isPublic: props.data.IsPublic || false,
	      histories: [],
	      selectedHistory: null
	    };
	    this.handleActiveTabChange = this.handleActiveTabChange.bind(this);
	    this.updateUI = this.updateUI.bind(this);
	    this.handleNameChange = this.handleNameChange.bind(this);
	    this.handleCategoryChange = this.handleCategoryChange.bind(this);
	    this.handleThumbnailChange = this.handleThumbnailChange.bind(this);
	    this.handleIsPublicChange = this.handleIsPublicChange.bind(this);
	    this.handleEditCategoryList = this.handleEditCategoryList.bind(this);
	    this.handleSelectHistory = this.handleSelectHistory.bind(this);
	    this.loadHistoryRenderer = this.loadHistoryRenderer.bind(this);
	    this.handleLoadHistory = this.handleLoadHistory.bind(this);
	    this.handleDownload = this.handleDownload.bind(this);
	    this.handleSave = this.handleSave.bind(this, props.callback);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      activeTabIndex,
	      name,
	      categories,
	      categoryID,
	      thumbnail,
	      isPublic,
	      histories,
	      selectedHistory
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'EditModelWindow',
	      title: `${_t('Edit')} ${_t('Model')}`,
	      style: {
	        width: '400px',
	        height: '320px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(TabLayout, {
	      activeTabIndex: activeTabIndex,
	      onActiveTabChange: this.handleActiveTabChange
	    }, /*#__PURE__*/React.createElement(Form, {
	      title: _t('Basic Info')
	    }, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Name')), /*#__PURE__*/React.createElement(Input, {
	      name: 'name',
	      value: name,
	      onChange: this.handleNameChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Type')), /*#__PURE__*/React.createElement(Select, {
	      name: 'select',
	      options: categories,
	      value: categoryID,
	      onChange: this.handleCategoryChange
	    }), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleEditCategoryList
	    }, _t('Edit'))), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Thumbnail')), /*#__PURE__*/React.createElement(ImageUploader, {
	      server: app.options.server,
	      url: thumbnail,
	      noImageText: _t('No Image'),
	      onChange: this.handleThumbnailChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Is Public')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'isPublic',
	      checked: isPublic ? true : false,
	      disabled: true,
	      onChange: this.handleIsPublicChange
	    }))), /*#__PURE__*/React.createElement(DataGrid, {
	      data: histories,
	      keyField: 'ID',
	      title: _t('Historic Version'),
	      selected: selectedHistory,
	      onSelect: this.handleSelectHistory
	    }, /*#__PURE__*/React.createElement(Column, {
	      type: 'number'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'Version',
	      title: _t('Version'),
	      width: 80,
	      align: 'center'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'UpdateTime',
	      title: _t('Update Time'),
	      align: 'center'
	    }), /*#__PURE__*/React.createElement(Column, {
	      field: 'ID',
	      title: _t(''),
	      width: 80,
	      align: 'center',
	      renderer: this.loadHistoryRenderer
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      className: 'download',
	      onClick: this.handleDownload
	    }, _t('Download')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  componentDidMount() {
	    this.updateUI();
	  }

	  handleActiveTabChange(activeTabIndex) {
	    if (activeTabIndex === 1) {
	      // 更新历史数据
	      const {
	        data
	      } = this.props;
	      fetch(`${app.options.server}/api/Mesh/HistoryList?ID=${data.ID}`).then(response => {
	        response.json().then(json => {
	          this.setState({
	            histories: json.Data,
	            activeTabIndex
	          });
	        });
	      });
	    } else {
	      this.setState({
	        activeTabIndex
	      });
	    }
	  }

	  updateUI() {
	    Ajax.getJson(`${app.options.server}/api/Category/List?Type=Mesh`, json => {
	      var options = {
	        '': _t('Not Set')
	      };
	      json.Data.forEach(n => {
	        options[n.ID] = n.Name;
	      });
	      this.setState({
	        categories: options
	      });
	    });
	  }

	  handleNameChange(value) {
	    this.setState({
	      name: value
	    });
	  }

	  handleCategoryChange(value) {
	    this.setState({
	      categoryID: value
	    });
	  }

	  handleThumbnailChange(file) {
	    Ajax.post(`${app.options.server}/api/Upload/Upload`, {
	      file
	    }, json => {
	      var obj = JSON.parse(json);

	      if (obj.Code === 200) {
	        this.setState({
	          thumbnail: obj.Data.url
	        });
	      } else {
	        app.toast(_t(obj.Msg), 'warn');
	      }
	    });
	  }

	  handleIsPublicChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleEditCategoryList() {
	    const window = app.createElement(CategoryWindow, {
	      type: 'Mesh',
	      typeName: `${_t('Model')}`
	    });
	    app.addElement(window);
	  }

	  handleSelectHistory(record) {
	    this.setState({
	      selectedHistory: record.ID
	    });
	  }

	  loadHistoryRenderer(id, row) {
	    if (row.IsNew) {
	      // 当前版本
	      return null;
	    }

	    return /*#__PURE__*/React.createElement(LinkButton, {
	      name: row.ID,
	      onClick: this.handleLoadHistory
	    }, _t('Load'));
	  }

	  handleLoadHistory(name) {
	    const history = this.state.histories.filter(n => n.ID === name)[0];

	    if (!history) {
	      app.toast(_t('The mesh is not existed!'));
	      return;
	    }

	    let url = `${app.options.server}/api/Mesh/Load?ID=${history.MeshID}&Version=${history.Version}`;
	    app.call(`load`, this, url, history.MeshName, history.ID);
	  }

	  handleDownload() {
	    const {
	      data
	    } = this.props;
	    fetch(`${app.options.server}/api/Mesh/Download?ID=${data.ID}`, {
	      method: 'POST'
	    }).then(response => {
	      response.json().then(json => {
	        if (json.Code !== 200) {
	          app.toast(_t(json.Msg), 'warn');
	          return;
	        }

	        window.open(`${app.options.server}${json.Path}`);
	      });
	    });
	  }

	  handleSave() {
	    const {
	      data,
	      callback
	    } = this.props;
	    const {
	      name,
	      categoryID,
	      thumbnail,
	      isPublic
	    } = this.state;
	    Ajax.post(`${app.options.server}/api/Mesh/Edit`, {
	      ID: data.ID,
	      Name: name,
	      Category: categoryID,
	      Image: thumbnail,
	      IsPublic: isPublic
	    }, json => {
	      var obj = JSON.parse(json);

	      if (obj.Code === 200) {
	        callback && callback(obj);
	        this.handleClose();
	      } else {
	        app.toast(_t(obj.Msg), 'warn');
	      }
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	EditModelWindow.propTypes = {
	  data: propTypes.object,
	  callback: propTypes.func
	};
	EditModelWindow.defaultProps = {
	  data: null,
	  callback: null
	};

	/**
	 * 模型面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ModelPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'model',
	        cornerText: n.Type
	      });
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('ModelPanel', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      showAddButton: !enableAuthority || authorities.includes('ADD_MESH'),
	      showFilterButton: true,
	      onAdd: this.handleAdd,
	      onInput: this.handleSearch.bind(this)
	    }), /*#__PURE__*/React.createElement(ImageList, {
	      data: imageListData,
	      showEditButton: !enableAuthority || authorities.includes('EDIT_MESH'),
	      showDeleteButton: !enableAuthority || authorities.includes('DELETE_MESH'),
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate() {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?Type=Mesh`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Mesh/List`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(model) {
	    let loader = new ModelLoader(app);
	    let url = model.Url;

	    if (model.Url.indexOf(';') > -1) {
	      // 包含多个入口文件
	      url = url.split(';').map(n => app.options.server + n);
	    } else {
	      url = app.options.server + model.Url;
	    }

	    loader.load(url, model, {
	      camera: app.editor.camera,
	      renderer: app.editor.renderer,
	      audioListener: app.editor.audioListener,
	      clearChildren: true
	    }).then(obj => {
	      if (!obj) {
	        return;
	      }

	      obj.name = model.Name;
	      Object.assign(obj.userData, model, {
	        Server: true
	      });

	      if (app.storage.addMode === 'click') {
	        this.clickSceneToAdd(obj);
	      } else {
	        this.addToCenter(obj);
	      }
	    });
	  } // 添加到场景中心


	  addToCenter(obj) {
	    var cmd = new AddObjectCommand(obj);
	    cmd.execute();

	    if (obj.userData.scripts) {
	      obj.userData.scripts.forEach(n => {
	        app.editor.scripts.push(n);
	      });
	      app.call('scriptChanged', this);
	    }
	  } // 点击场景添加


	  clickSceneToAdd(obj) {
	    let added = false;
	    app.editor.gpuPickNum += 1;
	    app.on(`gpuPick.ModelPanel`, intersect => {
	      // 鼠标移动出现预览效果
	      if (!intersect.point) {
	        return;
	      }

	      if (!added) {
	        added = true;
	        app.editor.sceneHelpers.add(obj);
	      }

	      obj.position.copy(intersect.point);
	    });
	    app.on(`raycast.ModelPanel`, intersect => {
	      // 点击鼠标放置模型
	      app.on(`gpuPick.ModelPanel`, null);
	      app.on(`raycast.ModelPanel`, null);
	      obj.position.copy(intersect.point);
	      this.addToCenter(obj);
	      app.editor.gpuPickNum -= 1;
	    });
	  } // ------------------------------- 上传 ---------------------------------------


	  handleAdd() {
	    app.upload(`${app.options.server}/api/Mesh/Add`, obj => {
	      if (obj.Code === 200) {
	        this.update();
	      }

	      app.toast(_t(obj.Msg));
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditModelWindow, {
	      data,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Mesh/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code !== 200) {
	              app.toast(_t(obj.Msg), 'warn');
	              return;
	            }

	            this.update();
	          });
	        });
	      }
	    });
	  }

	}

	ModelPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	ModelPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 编辑窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class EditWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      name: props.data.Name,
	      categories: null,
	      categoryID: props.data.CategoryID,
	      thumbnail: props.data.Thumbnail,
	      isPublic: props.data.IsPublic
	    };
	    this.updateUI = this.updateUI.bind(this);
	    this.handleNameChange = this.handleNameChange.bind(this);
	    this.handleCategoryChange = this.handleCategoryChange.bind(this);
	    this.handleThumbnailChange = this.handleThumbnailChange.bind(this);
	    this.handleIsPublicChange = this.handleIsPublicChange.bind(this);
	    this.handleEditCategoryList = this.handleEditCategoryList.bind(this);
	    this.handleSave = this.handleSave.bind(this, props.callback);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      type,
	      typeName
	    } = this.props;
	    const {
	      name,
	      categories,
	      categoryID,
	      thumbnail,
	      isPublic
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'EditWindow',
	      title: `${_t('Edit')} ${typeName}`,
	      style: {
	        width: '320px',
	        height: '300px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement(Form, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Name')), /*#__PURE__*/React.createElement(Input, {
	      name: 'name',
	      value: name,
	      onChange: this.handleNameChange
	    })), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Type')), /*#__PURE__*/React.createElement(Select, {
	      name: 'select',
	      options: categories,
	      value: categoryID,
	      onChange: this.handleCategoryChange
	    }), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleEditCategoryList
	    }, _t('Edit'))), /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Thumbnail')), /*#__PURE__*/React.createElement(ImageUploader, {
	      server: app.options.server,
	      url: thumbnail,
	      noImageText: _t('No Image'),
	      onChange: this.handleThumbnailChange
	    })), type === 'Scene' && /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(Label, null, _t('Is Public')), /*#__PURE__*/React.createElement(CheckBox, {
	      name: 'isPublic',
	      checked: isPublic ? true : false,
	      onChange: this.handleIsPublicChange
	    })))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  componentDidMount() {
	    this.updateUI();
	  }

	  updateUI() {
	    Ajax.getJson(`${app.options.server}/api/Category/List?Type=${this.props.type}`, json => {
	      var options = {
	        '': _t('Not Set')
	      };
	      json.Data.forEach(n => {
	        options[n.ID] = n.Name;
	      });
	      this.setState({
	        categories: options
	      });
	    });
	  }

	  handleNameChange(value) {
	    this.setState({
	      name: value
	    });
	  }

	  handleCategoryChange(value) {
	    this.setState({
	      categoryID: value
	    });
	  }

	  handleThumbnailChange(file) {
	    Ajax.post(`${app.options.server}/api/Upload/Upload`, {
	      file
	    }, json => {
	      var obj = JSON.parse(json);

	      if (obj.Code === 200) {
	        this.setState({
	          thumbnail: obj.Data.url
	        });
	      } else {
	        app.toast(_t(obj.Msg), 'warn');
	      }
	    });
	  }

	  handleIsPublicChange(value, name) {
	    this.setState({
	      [name]: value
	    });
	  }

	  handleEditCategoryList() {
	    const window = app.createElement(CategoryWindow, {
	      type: this.props.type,
	      typeName: `${this.props.typeName}`
	    });
	    app.addElement(window);
	  }

	  handleSave() {
	    const {
	      data,
	      saveUrl,
	      callback
	    } = this.props;
	    const {
	      name,
	      categoryID,
	      thumbnail,
	      isPublic
	    } = this.state;
	    Ajax.post(saveUrl, {
	      ID: data.ID,
	      Name: name,
	      Category: categoryID,
	      Image: thumbnail,
	      IsPublic: isPublic
	    }, json => {
	      var obj = JSON.parse(json);

	      if (obj.Code === 200) {
	        callback && callback(obj);
	        this.handleClose();
	      } else {
	        app.toast(_t(obj.Msg), 'warn');
	      }
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	EditWindow.propTypes = {
	  type: propTypes.oneOf(['Scene', 'Mesh', 'Map', 'Texture', 'Material', 'Audio', 'Animation', 'Particle', 'Screenshot', 'Video']),
	  typeName: propTypes.string,
	  data: propTypes.object,
	  saveUrl: propTypes.string,
	  callback: propTypes.func
	};
	EditWindow.defaultProps = {
	  type: 'Scene',
	  typeName: 'Scene',
	  data: null,
	  saveUrl: null,
	  callback: null
	};

	/**
	 * 添加天空盒窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class AddSkyBoxWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      posX: null,
	      posXFile: null,
	      negX: null,
	      negXFile: null,
	      posY: null,
	      posYFile: null,
	      negY: null,
	      negYFile: null,
	      posZ: null,
	      posZFile: null,
	      negZ: null,
	      negZFile: null
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleSave = this.handleSave.bind(this, props.callback);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      posX,
	      negX,
	      posY,
	      negY,
	      posZ,
	      negZ
	    } = this.state;
	    return /*#__PURE__*/React.createElement(Window, {
	      className: 'AddSkyBoxWindow',
	      title: _t('Upload Sky Box'),
	      style: {
	        width: '640px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, /*#__PURE__*/React.createElement(Content, null, /*#__PURE__*/React.createElement("div", {
	      className: 'item'
	    }, /*#__PURE__*/React.createElement(ImageSelector, {
	      className: 'selector',
	      name: 'posX',
	      value: posX,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement("div", {
	      className: 'title'
	    }, "PosX")), /*#__PURE__*/React.createElement("div", {
	      className: 'item'
	    }, /*#__PURE__*/React.createElement(ImageSelector, {
	      className: 'selector',
	      name: 'negX',
	      value: negX,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement("div", {
	      className: 'title'
	    }, "NegX")), /*#__PURE__*/React.createElement("div", {
	      className: 'item'
	    }, /*#__PURE__*/React.createElement(ImageSelector, {
	      className: 'selector',
	      name: 'posY',
	      value: posY,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement("div", {
	      className: 'title'
	    }, "PosY")), /*#__PURE__*/React.createElement("div", {
	      className: 'item'
	    }, /*#__PURE__*/React.createElement(ImageSelector, {
	      className: 'selector',
	      name: 'negY',
	      value: negY,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement("div", {
	      className: 'title'
	    }, "NegY")), /*#__PURE__*/React.createElement("div", {
	      className: 'item'
	    }, /*#__PURE__*/React.createElement(ImageSelector, {
	      className: 'selector',
	      name: 'posZ',
	      value: posZ,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement("div", {
	      className: 'title'
	    }, "PosZ")), /*#__PURE__*/React.createElement("div", {
	      className: 'item'
	    }, /*#__PURE__*/React.createElement(ImageSelector, {
	      className: 'selector',
	      name: 'negZ',
	      value: negZ,
	      onChange: this.handleChange
	    }), /*#__PURE__*/React.createElement("div", {
	      className: 'title'
	    }, "NegZ"))), /*#__PURE__*/React.createElement(Buttons, null, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  handleChange(name, file) {
	    let reader = new FileReader();

	    reader.onload = e => {
	      reader.onload = null;
	      this.setState({
	        [name]: e.target.result,
	        [`${name}File`]: file
	      });
	    };

	    reader.readAsDataURL(file);
	  }

	  handleSave(callback) {
	    const {
	      posXFile,
	      negXFile,
	      posYFile,
	      negYFile,
	      posZFile,
	      negZFile
	    } = this.state;

	    if (!posXFile || !negXFile || !posYFile || !negYFile || !posZFile || !negZFile) {
	      app.toast(_t('Please upload all the textures before save.'), 'warn');
	      return;
	    }

	    Ajax.post(`${app.options.server}/api/Map/Add`, {
	      posX: posXFile,
	      negX: negXFile,
	      posY: posYFile,
	      negY: negYFile,
	      posZ: posZFile,
	      negZ: negZFile
	    }, result => {
	      let obj = JSON.parse(result);
	      this.handleClose();
	      callback && callback();
	      app.toast(_t(obj.Msg));
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	AddSkyBoxWindow.propTypes = {
	  callback: propTypes.func
	};
	AddSkyBoxWindow.defaultProps = {
	  callback: null
	};

	/**
	 * 贴图面板
	 * @author tengge / https://github.com/tengge1
	 */

	class MapPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleAddImage = this.handleAddImage.bind(this);
	    this.handleAddSkyBox = this.handleAddSkyBox.bind(this);
	    this.handleAddSkyBall = this.handleAddSkyBall.bind(this);
	    this.handleAddVideo = this.handleAddVideo.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'scenes'
	      });
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('MapPanel', className),
	      style: style
	    }, /*#__PURE__*/React.createElement("div", {
	      className: "toolbar"
	    }, /*#__PURE__*/React.createElement(IconMenuButton, {
	      className: 'add',
	      icon: 'add',
	      show: !enableAuthority || authorities.includes('ADD_MAP')
	    }, /*#__PURE__*/React.createElement(ContextMenu, null, /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Upload Image'),
	      onClick: this.handleAddImage
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Upload Sky Box'),
	      onClick: this.handleAddSkyBox
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Upload Sky Ball'),
	      onClick: this.handleAddSkyBall
	    }), /*#__PURE__*/React.createElement(MenuItem, {
	      title: _t('Upload Video'),
	      onClick: this.handleAddVideo
	    }))), /*#__PURE__*/React.createElement(SearchField, {
	      className: 'search',
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      showFilterButton: true,
	      onInput: this.handleSearch.bind(this)
	    })), /*#__PURE__*/React.createElement(ImageList, {
	      data: imageListData,
	      showEditButton: !enableAuthority || authorities.includes('EDIT_MAP'),
	      showDeleteButton: !enableAuthority || authorities.includes('DELETE_MAP'),
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate() {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?Type=Map`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Map/List`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    app.call(`selectMap`, this, data);
	  } // ------------------------------- 上传图片 ---------------------------------------


	  handleAddImage() {
	    app.upload(`${app.options.server}/api/Map/Add`, obj => {
	      if (obj.Code === 200) {
	        this.update();
	      }

	      app.toast(_t(obj.Msg));
	    });
	  } // ---------------------------- 上传天空盒 --------------------------------------


	  handleAddSkyBox() {
	    const win = app.createElement(AddSkyBoxWindow, {
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ---------------------------- 上传天空球 ---------------------------------------


	  handleAddSkyBall() {
	    app.upload(`${app.options.server}/api/Map/Add?type=skyBall`, obj => {
	      if (obj.Code === 200) {
	        this.update();
	      }

	      app.toast(_t(obj.Msg));
	    });
	  } // ------------------------------ 上传视频 --------------------------------------


	  handleAddVideo() {
	    app.upload(`${app.options.server}/api/Map/Add`, obj => {
	      if (obj.Code === 200) {
	        this.update();
	      }

	      app.toast(_t(obj.Msg));
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    const win = app.createElement(EditWindow, {
	      type: 'Map',
	      typeName: _t('Map'),
	      data,
	      saveUrl: `${app.options.server}/api/Map/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Map/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	MapPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	MapPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 材质面板
	 * @author tengge / https://github.com/tengge1
	 */

	class MaterialPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'model',
	        cornerText: n.Type
	      });
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('MaterialPanel', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      showFilterButton: true,
	      onInput: this.handleSearch.bind(this)
	    }), /*#__PURE__*/React.createElement(ImageList, {
	      data: imageListData,
	      showEditButton: !enableAuthority || authorities.includes('EDIT_MATERIAL'),
	      showDeleteButton: !enableAuthority || authorities.includes('DELETE_MATERIAL'),
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate() {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?Type=Material`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Material/List`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    Ajax.get(`${app.options.server}/api/Material/Get?ID=${data.ID}`, result => {
	      var obj = JSON.parse(result);

	      if (obj.Code === 200) {
	        var material = new MaterialsSerializer().fromJSON(obj.Data.Data, undefined, app.options.server);
	        app.call(`selectMaterial`, this, material);
	      }
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Material',
	      typeName: _t('Material'),
	      data,
	      saveUrl: `${app.options.server}/api/Material/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Material/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code !== 200) {
	              app.toast(_t(obj.Msg), 'warn');
	              return;
	            }

	            this.update();
	          });
	        });
	      }
	    });
	  }

	}

	MaterialPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	MaterialPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 音频面板
	 * @author tengge / https://github.com/tengge1
	 */

	class AudioPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'audio' // cornerText: n.Type,

	      });
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('AudioPanel', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      showAddButton: !enableAuthority || authorities.includes('ADD_AUDIO'),
	      showFilterButton: true,
	      onAdd: this.handleAdd,
	      onInput: this.handleSearch.bind(this)
	    }), /*#__PURE__*/React.createElement(ImageList, {
	      data: imageListData,
	      showEditButton: !enableAuthority || authorities.includes('EDIT_AUDIO'),
	      showDeleteButton: !enableAuthority || authorities.includes('DELETE_AUDIO'),
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate() {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?Type=Audio`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Audio/List`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    app.call(`selectAudio`, this, data);
	  } // ------------------------------- 上传 ---------------------------------------


	  handleAdd() {
	    app.upload(`${app.options.server}/api/Audio/Add`, obj => {
	      if (obj.Code === 200) {
	        this.update();
	      }

	      app.toast(_t(obj.Msg));
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Audio',
	      typeName: _t('Audio'),
	      data,
	      saveUrl: `${app.options.server}/api/Audio/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Audio/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code !== 200) {
	              app.toast(_t(obj.Msg), 'warn');
	              return;
	            }

	            this.update();
	          });
	        });
	      }
	    });
	  }

	}

	AudioPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	AudioPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 动画面板
	 * @author tengge / https://github.com/tengge1
	 */

	class AnimationPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'scenes' // cornerText: n.Type,

	      });
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('AnimationPanel', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      showAddButton: !enableAuthority || authorities.includes('ADD_ANIMATION'),
	      showFilterButton: true,
	      onAdd: this.handleAdd,
	      onInput: this.handleSearch.bind(this)
	    }), /*#__PURE__*/React.createElement(ImageList, {
	      data: imageListData,
	      showEditButton: !enableAuthority || authorities.includes('EDIT_ANIMATION'),
	      showDeleteButton: !enableAuthority || authorities.includes('DELETE_ANIMATION'),
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate() {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?Type=Animation`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Animation/List`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    app.call(`selectAnimation`, this, data);
	  } // ------------------------------- 上传 ---------------------------------------


	  handleAdd() {
	    app.upload(`${app.options.server}/api/Animation/Add`, obj => {
	      if (obj.Code === 200) {
	        this.update();
	      }

	      app.toast(_t(obj.Msg));
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Animation',
	      typeName: _t('Animation'),
	      data,
	      saveUrl: `${app.options.server}/api/Animation/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Animation/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code !== 200) {
	              app.toast(_t(obj.Msg), 'warn');
	              return;
	            }

	            this.update();
	          });
	        });
	      }
	    });
	  }

	}

	AnimationPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	AnimationPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 粒子面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ParticlePanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'model',
	        cornerText: n.Type
	      });
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('ParticlePanel', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      showFilterButton: true,
	      onInput: this.handleSearch.bind(this)
	    }), /*#__PURE__*/React.createElement(ImageList, {
	      data: imageListData,
	      showEditButton: !enableAuthority || authorities.includes('EDIT_PARTICLE'),
	      showDeleteButton: !enableAuthority || authorities.includes('DELETE_PARTICLE'),
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate() {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?Type=Particle`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Particle/List`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    Ajax.get(`${app.options.server}/api/Particle/Get?ID=${data.ID}`, result => {
	      var obj = JSON.parse(result);

	      if (obj.Code === 200) ;
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Particle',
	      typeName: _t('Particle'),
	      data,
	      saveUrl: `${app.options.server}/api/Particle/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Particle/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code !== 200) {
	              app.toast(_t(obj.Msg), 'warn');
	              return;
	            }

	            this.update();
	          });
	        });
	      }
	    });
	  }

	}

	ParticlePanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	ParticlePanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 预设体面板
	 * @author tengge / https://github.com/tengge1
	 */

	class PrefabPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'model',
	        cornerText: n.Type
	      });
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('PrefabPanel', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      showFilterButton: true,
	      onInput: this.handleSearch.bind(this)
	    }), /*#__PURE__*/React.createElement(ImageList, {
	      data: imageListData,
	      showEditButton: !enableAuthority || authorities.includes('EDIT_PREFAB'),
	      showDeleteButton: !enableAuthority || authorities.includes('DELETE_PREFAB'),
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate() {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?Type=Prefab`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Prefab/List`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    Ajax.get(`${app.options.server}/api/Prefab/Get?ID=${data.ID}`, result => {
	      var obj = JSON.parse(result);

	      if (obj.Code === 200) ;
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Prefab',
	      typeName: _t('Prefab'),
	      data,
	      saveUrl: `${app.options.server}/api/Prefab/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Prefab/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code !== 200) {
	              app.toast(_t(obj.Msg), 'warn');
	              return;
	            }

	            this.update();
	          });
	        });
	      }
	    });
	  }

	}

	PrefabPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	PrefabPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 截图面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ScreenshotPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'scenes'
	      });
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('ScreenshotPanel', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      showFilterButton: true,
	      onInput: this.handleSearch.bind(this)
	    }), /*#__PURE__*/React.createElement(ImageList, {
	      data: imageListData,
	      showEditButton: !enableAuthority || authorities.includes('EDIT_SCREENSHOT'),
	      showDeleteButton: !enableAuthority || authorities.includes('DELETE_SCREENSHOT'),
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate() {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?Type=Screenshot`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Screenshot/List`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    app.photo(data.Url);
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Screenshot',
	      typeName: _t('Screenshot'),
	      data,
	      saveUrl: `${app.options.server}/api/Screenshot/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Screenshot/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code !== 200) {
	              app.toast(_t(obj.Msg), 'warn');
	              return;
	            }

	            this.update();
	          });
	        });
	      }
	    });
	  }

	}

	ScreenshotPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	ScreenshotPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 视频面板
	 * @author tengge / https://github.com/tengge1
	 */

	class VideoPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    const {
	      enableAuthority,
	      authorities
	    } = app.server;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'scenes'
	      });
	    });
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('VideoPanel', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      showFilterButton: true,
	      onInput: this.handleSearch.bind(this)
	    }), /*#__PURE__*/React.createElement(ImageList, {
	      data: imageListData,
	      showEditButton: !enableAuthority || authorities.includes('EDIT_VIDEO'),
	      showDeleteButton: !enableAuthority || authorities.includes('DELETE_VIDEO'),
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate() {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?Type=Video`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Video/List`).then(response => {
	      response.json().then(obj => {
	        if (obj.Code !== 200) {
	          app.toast(_t(obj.Msg), 'warn');
	          return;
	        }

	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    app.video(data.Url);
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Video',
	      typeName: _t('Video'),
	      data,
	      saveUrl: `${app.options.server}/api/Video/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Video/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code !== 200) {
	              app.toast(_t(obj.Msg), 'warn');
	              return;
	            }

	            this.update();
	          });
	        });
	      }
	    });
	  }

	}

	VideoPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	VideoPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 日志面板
	 * @author tengge / https://github.com/tengge1
	 */

	class LogPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      logs: []
	    };
	    this.handleLog = this.handleLog.bind(this);
	    this.handleClear = this.handleClear.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      logs
	    } = this.state;
	    return /*#__PURE__*/React.createElement("div", {
	      className: bind('LogPanel', className),
	      style: style
	    }, /*#__PURE__*/React.createElement(Button, {
	      onClick: this.handleClear
	    }, _t('Clear')), /*#__PURE__*/React.createElement("div", {
	      className: 'logs'
	    }, logs.map((n, i) => {
	      return /*#__PURE__*/React.createElement("div", {
	        className: n.type,
	        key: i
	      }, n.time, " ", n.content);
	    })));
	  }

	  componentDidMount() {
	    app.on(`log.LogPanel`, this.handleLog);
	  }

	  handleLog(content, type) {
	    var date = new Date();
	    var hour = date.getHours();
	    var minute = date.getMinutes();
	    var second = date.getSeconds();
	    hour = hour < 10 ? '0' + hour : hour;
	    minute = minute < 10 ? '0' + minute : minute;
	    second = second < 10 ? '0' + second : second;
	    this.setState(state => {
	      let logs = state.logs;
	      logs.push({
	        time: `${hour}:${minute}:${second}`,
	        type,
	        content
	      });
	      return {
	        logs
	      };
	    });
	  }

	  handleClear() {
	    this.setState({
	      logs: []
	    });
	  }

	}

	LogPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	LogPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 资源面板
	 * @author tengge / https://github.com/tengge1
	 */

	class AssetsPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      activeIndex: 0,
	      sceneCount: 0,
	      meshCount: 0,
	      mapCount: 0,
	      materialCount: 0,
	      audioCount: 0,
	      animationCount: 0,
	      particleCount: 0,
	      prefabCount: 0,
	      characterCount: 0,
	      screenshotCount: 0,
	      videoCount: 0
	    };
	    this.handleActive = this.handleActive.bind(this);
	  }

	  render() {
	    const {
	      activeIndex,
	      sceneCount,
	      meshCount,
	      mapCount,
	      materialCount,
	      audioCount,
	      animationCount,
	      particleCount,
	      prefabCount,
	      screenshotCount,
	      videoCount
	    } = this.state;
	    const {
	      enableAuthority,
	      isLogin,
	      authorities
	    } = app.server;
	    let index = 0;
	    return /*#__PURE__*/React.createElement(AccordionLayout, {
	      className: 'AssetsPanel',
	      onActive: this.handleActive
	    }, /*#__PURE__*/React.createElement(Accordion, {
	      name: 'Scene',
	      title: `${_t('Scene')}(${sceneCount})`,
	      maximizable: true
	    }, /*#__PURE__*/React.createElement(ScenePanel, {
	      className: 'subPanel',
	      show: index++ === activeIndex
	    })), !enableAuthority || authorities.includes('LIST_MESH') ? /*#__PURE__*/React.createElement(Accordion, {
	      name: 'Model',
	      title: `${_t('Model')}(${meshCount})`,
	      maximizable: true
	    }, /*#__PURE__*/React.createElement(ModelPanel, {
	      className: 'subPanel',
	      show: index++ === activeIndex
	    })) : null, !enableAuthority || authorities.includes('LIST_MAP') ? /*#__PURE__*/React.createElement(Accordion, {
	      name: 'Map',
	      title: `${_t('Map')}(${mapCount})`,
	      maximizable: true
	    }, /*#__PURE__*/React.createElement(MapPanel, {
	      className: 'subPanel',
	      show: index++ === activeIndex
	    })) : null, !enableAuthority || authorities.includes('LIST_MATERIAL') ? /*#__PURE__*/React.createElement(Accordion, {
	      name: 'Material',
	      title: `${_t('Material')}(${materialCount})`,
	      maximizable: true
	    }, /*#__PURE__*/React.createElement(MaterialPanel, {
	      className: 'subPanel',
	      show: index++ === activeIndex
	    })) : null, !enableAuthority || authorities.includes('LIST_AUDIO') ? /*#__PURE__*/React.createElement(Accordion, {
	      name: 'Audio',
	      title: `${_t('Audio')}(${audioCount})`,
	      maximizable: true
	    }, /*#__PURE__*/React.createElement(AudioPanel, {
	      className: 'subPanel',
	      show: index++ === activeIndex
	    })) : null, !enableAuthority || authorities.includes('LIST_ANIMATION') ? /*#__PURE__*/React.createElement(Accordion, {
	      name: 'Animation',
	      title: `${_t('Animation')}(${animationCount})`,
	      maximizable: true
	    }, /*#__PURE__*/React.createElement(AnimationPanel, {
	      className: 'subPanel',
	      show: index++ === activeIndex
	    })) : null, !enableAuthority || authorities.includes('LIST_PARTICLE') ? /*#__PURE__*/React.createElement(Accordion, {
	      name: 'Particle',
	      title: `${_t('Particle')}(${particleCount})`,
	      maximizable: true
	    }, /*#__PURE__*/React.createElement(ParticlePanel, {
	      className: 'subPanel',
	      show: index++ === activeIndex
	    })) : null, !enableAuthority || authorities.includes('LIST_PREFAB') ? /*#__PURE__*/React.createElement(Accordion, {
	      name: 'Prefab',
	      title: `${_t('Prefab')}(${prefabCount})`,
	      maximizable: true
	    }, /*#__PURE__*/React.createElement(PrefabPanel, {
	      className: 'subPanel',
	      show: index++ === activeIndex
	    })) : null, !enableAuthority || authorities.includes('LIST_SCREENSHOT') ? /*#__PURE__*/React.createElement(Accordion, {
	      name: 'Screenshot',
	      title: `${_t('Screenshot')}(${screenshotCount})`,
	      maximizable: true
	    }, /*#__PURE__*/React.createElement(ScreenshotPanel, {
	      className: 'subPanel',
	      show: index++ === activeIndex
	    })) : null, !enableAuthority || authorities.includes('LIST_VIDEO') ? /*#__PURE__*/React.createElement(Accordion, {
	      name: 'Video',
	      title: `${_t('Video')}(${videoCount})`,
	      maximizable: true
	    }, /*#__PURE__*/React.createElement(VideoPanel, {
	      className: 'subPanel',
	      show: index++ === activeIndex
	    })) : null, !enableAuthority || isLogin ? /*#__PURE__*/React.createElement(Accordion, {
	      name: 'Log',
	      title: `${_t('Logs')}`,
	      maximizable: true
	    }, /*#__PURE__*/React.createElement(LogPanel, {
	      className: 'subPanel',
	      show: index++ === activeIndex
	    })) : null);
	  }

	  componentDidMount() {
	    this.update();
	  }

	  update() {
	    fetch(`${app.options.server}/api/Assets/List`).then(response => {
	      if (response.ok) {
	        response.json().then(obj => {
	          if (obj.Code !== 200) {
	            app.toast(_t(obj.Msg), 'warn');
	            return;
	          }

	          this.setState(obj);
	        });
	      }
	    });
	  }

	  handleActive(index) {
	    this.setState({
	      activeIndex: index
	    });
	  }

	}

	/**
	 * 历史记录
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param {*} editor 编辑器
	 */

	function History(editor) {
	  this.editor = editor;
	  this.undos = [];
	  this.redos = [];
	  this.lastCmdTime = new Date();
	  this.idCounter = 0;
	  Command.call(this, editor);
	}

	History.prototype = Object.create(Command.prototype);
	Object.assign(History.prototype, {
	  constructor: History,
	  execute: function (cmd, optionalName) {
	    var lastCmd = this.undos[this.undos.length - 1];
	    var timeDifference = new Date().getTime() - this.lastCmdTime.getTime();
	    var isUpdatableCmd = lastCmd && lastCmd.updatable && cmd.updatable && lastCmd.object === cmd.object && lastCmd.type === cmd.type && lastCmd.script === cmd.script && lastCmd.attributeName === cmd.attributeName;

	    if (isUpdatableCmd && timeDifference < 500) {
	      lastCmd.update(cmd);
	      cmd = lastCmd;
	    } else {
	      // the command is not updatable and is added as a new part of the history
	      this.undos.push(cmd);
	      cmd.id = ++this.idCounter;
	    }

	    cmd.name = optionalName !== undefined ? optionalName : cmd.name;
	    cmd.execute();
	    cmd.inMemory = true;
	    this.lastCmdTime = new Date(); // clearing all the redo-commands

	    this.redos = [];
	    app.call('historyChanged', this, cmd);
	  },
	  undo: function () {
	    var cmd = undefined;

	    if (this.undos.length > 0) {
	      cmd = this.undos.pop();

	      if (cmd.inMemory === false) {
	        cmd.fromJSON(cmd.json);
	      }
	    }

	    if (cmd !== undefined) {
	      cmd.undo();
	      this.redos.push(cmd);
	      app.call('historyChanged', this, cmd);
	    }

	    return cmd;
	  },
	  redo: function () {
	    var cmd = undefined;

	    if (this.redos.length > 0) {
	      cmd = this.redos.pop();

	      if (cmd.inMemory === false) {
	        cmd.fromJSON(cmd.json);
	      }
	    }

	    if (cmd !== undefined) {
	      cmd.execute();
	      this.undos.push(cmd);
	      app.call('historyChanged', this, cmd);
	    }

	    return cmd;
	  },
	  toJSON: function () {
	    var history = {};
	    history.undos = [];
	    history.redos = [];
	    var i; // Append Undos to History

	    for (i = 0; i < this.undos.length; i++) {
	      if (Object.prototype.hasOwnProperty.call(this.undos[i], "json")) {
	        history.undos.push(this.undos[i].json);
	      }
	    } // Append Redos to History


	    for (i = 0; i < this.redos.length; i++) {
	      if (Object.prototype.hasOwnProperty.call(this.redos[i], "json")) {
	        history.redos.push(this.redos[i].json);
	      }
	    }

	    return history;
	  },
	  fromJSON: function (json) {
	    if (json === undefined) return;
	    var i = 0,
	        cmdJSON,
	        cmd;

	    for (i = 0; i < json.undos.length; i++) {
	      cmdJSON = json.undos[i];
	      cmd = new window[cmdJSON.type](); // creates a new object of type "json.type"

	      cmd.json = cmdJSON;
	      cmd.id = cmdJSON.id;
	      cmd.name = cmdJSON.name;
	      this.undos.push(cmd);
	      this.idCounter = cmdJSON.id > this.idCounter ? cmdJSON.id : this.idCounter; // set last used idCounter
	    }

	    for (i = 0; i < json.redos.length; i++) {
	      cmdJSON = json.redos[i];
	      cmd = new window[cmdJSON.type](); // creates a new object of type "json.type"

	      cmd.json = cmdJSON;
	      cmd.id = cmdJSON.id;
	      cmd.name = cmdJSON.name;
	      this.redos.push(cmd);
	      this.idCounter = cmdJSON.id > this.idCounter ? cmdJSON.id : this.idCounter; // set last used idCounter
	    } // Select the last executed undo-command


	    app.call('historyChanged', this, this.undos[this.undos.length - 1]);
	  },
	  clear: function () {
	    this.undos = [];
	    this.redos = [];
	    this.idCounter = 0;
	    app.call('historyChanged', this);
	  },
	  goToState: function (id) {
	    var cmd = this.undos.length > 0 ? this.undos[this.undos.length - 1] : undefined; // next cmd to pop

	    if (cmd === undefined || id > cmd.id) {
	      cmd = this.redo();

	      while (cmd !== undefined && id > cmd.id) {
	        cmd = this.redo();
	      }
	    } else {
	      while (true) {
	        // eslint-disable-line
	        cmd = this.undos[this.undos.length - 1]; // next cmd to pop

	        if (cmd === undefined || id === cmd.id) {
	          break;
	        }

	        cmd = this.undo();
	      }
	    }

	    app.call('historyChanged', this, cmd);
	  },
	  enableSerialization: function (id) {
	    /**
	     * because there might be commands in this.undos and this.redos
	     * which have not been serialized with .toJSON() we go back
	     * to the oldest command and redo one command after the other
	     * while also calling .toJSON() on them.
	     */
	    this.goToState(-1);
	    var cmd = this.redo();

	    while (cmd !== undefined) {
	      if (!Object.prototype.hasOwnProperty.call(cmd, "json")) {
	        cmd.json = cmd.toJSON();
	      }

	      cmd = this.redo();
	    }

	    this.goToState(id);
	  }
	});

	var ID$a = -1;
	/**
	 * 帮助器基类
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseHelper() {
	  this.id = `${this.constructor.name}${ID$a--}`;
	}
	/**
	 * 帮助器开始运行
	 * @description 因为start是在`appStarted`事件中运行的，所以无法监听到`appStart`和`appStarted`事件
	 */


	BaseHelper.prototype.start = function () {};
	/**
	 * 帮助器结束运行
	 */


	BaseHelper.prototype.stop = function () {};

	/**
	 * 网格帮助器
	 * @author tengge / https://github.com/tengge1
	 */

	function GridHelper() {
	  BaseHelper.call(this);
	}

	GridHelper.prototype = Object.create(BaseHelper.prototype);
	GridHelper.prototype.constructor = GridHelper;

	GridHelper.prototype.start = function () {
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	  this.update();
	};

	GridHelper.prototype.stop = function () {
	  app.on(`appStarted.${this.id}`, null);

	  if (this.helper) {
	    var scene = app.editor.sceneHelpers;
	    scene.remove(this.helper);
	    delete this.helper;
	  }
	};

	GridHelper.prototype.update = function () {
	  var showGrid = app.storage.showGrid;

	  if (!this.helper) {
	    this.helper = new THREE.GridHelper(30, 30, 0x444444, 0x888888);
	    var array = this.helper.geometry.attributes.color.array;

	    for (let i = 0; i < array.length; i += 60) {
	      for (let j = 0; j < 12; j++) {
	        array[i + j] = 0.26;
	      }
	    }
	  }

	  var scene = app.editor.sceneHelpers;

	  if (showGrid && this.helper.parent !== scene) {
	    scene.add(this.helper);
	  } else if (!showGrid && this.helper.parent === scene) {
	    scene.remove(this.helper);
	  }
	};

	GridHelper.prototype.onStorageChanged = function (key) {
	  if (key === 'showGrid') {
	    this.update();
	  }
	};

	/**
	 * 相机帮助器
	 * @author tengge / https://github.com/tengge1
	 */

	function CameraHelper() {
	  BaseHelper.call(this);
	}

	CameraHelper.prototype = Object.create(BaseHelper.prototype);
	CameraHelper.prototype.constructor = CameraHelper;

	CameraHelper.prototype.start = function () {
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	  this.update();
	};

	CameraHelper.prototype.stop = function () {
	  app.on(`appStarted.${this.id}`, null);

	  if (this.helper) {
	    var scene = app.editor.sceneHelpers;
	    scene.remove(this.helper);
	    delete this.helper;
	  }
	};

	CameraHelper.prototype.update = function () {
	  var showCamera = app.storage.showCamera;

	  if (!this.helper) {
	    this.helper = new THREE.CameraHelper(app.editor.camera);
	  }

	  var scene = app.editor.sceneHelpers;

	  if (showCamera && this.helper.parent !== scene) {
	    scene.add(this.helper);
	  } else if (!showCamera && this.helper.parent === scene) {
	    scene.remove(this.helper);
	  }
	};

	CameraHelper.prototype.onStorageChanged = function (key) {
	  if (key === 'showCamera') {
	    this.update();
	  }
	};

	/**
	 * 具有一定体积的点光源帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {THREE.PointLight} light 点光源
	 * @param {Number} sphereSize 发射尺寸
	 * @param {Object} color 颜色
	 */
	function VolumePointLightHelper(light, sphereSize, color) {
	  THREE.PointLightHelper.call(this, light, sphereSize, color);
	  var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000,
	    visible: false
	  });
	  this.picker = new THREE.Mesh(geometry, material);
	  this.picker.name = 'picker';
	  this.add(this.picker);
	}

	VolumePointLightHelper.prototype = Object.create(THREE.PointLightHelper.prototype);
	VolumePointLightHelper.prototype.constructor = VolumePointLightHelper;

	VolumePointLightHelper.prototype.raycast = function (raycaster, intersects) {
	  var intersect = raycaster.intersectObject(this.picker)[0];

	  if (intersect) {
	    intersect.object = this.light;
	    intersects.push(intersect);
	  }
	};

	VolumePointLightHelper.prototype.dispose = function () {
	  this.remove(this.picker);
	  this.picker.geometry.dispose();
	  this.picker.material.dispose();
	  delete this.picker;
	  THREE.PointLightHelper.prototype.dispose.call(this);
	};

	/**
	 * 点光源帮助器
	 * @author tengge / https://github.com/tengge1
	 */

	function PointLightHelpers() {
	  BaseHelper.call(this);
	  this.helpers = [];
	}

	PointLightHelpers.prototype = Object.create(BaseHelper.prototype);
	PointLightHelpers.prototype.constructor = PointLightHelpers;

	PointLightHelpers.prototype.start = function () {
	  app.on(`objectAdded.${this.id}`, this.onObjectAdded.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	};

	PointLightHelpers.prototype.stop = function () {
	  app.on(`objectAdded.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	};

	PointLightHelpers.prototype.onObjectAdded = function (object) {
	  if (!object.isPointLight) {
	    return;
	  }

	  var helper = new VolumePointLightHelper(object, 1);
	  helper.visible = app.storage.showPointLight;
	  this.helpers.push(helper);
	  app.editor.sceneHelpers.add(helper);
	};

	PointLightHelpers.prototype.onObjectRemoved = function (object) {
	  if (!object.isPointLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  app.editor.sceneHelpers.remove(this.helpers[index]);
	  this.helpers[index].dispose();
	  this.helpers.splice(index, 1);
	};

	PointLightHelpers.prototype.onObjectChanged = function (object) {
	  if (!object.isPointLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  this.helpers[index].update();
	};

	PointLightHelpers.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showPointLight') {
	    return;
	  }

	  this.helpers.forEach(n => {
	    n.visible = value;
	  });
	};

	/**
	 * 具有一定体积的平行光帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {THREE.DirectionalLight} light 平行光
	 * @param {Number} size 尺寸
	 * @param {THREE.Color} color 颜色
	 */
	function VolumeDirectionalLightHelper(light, size, color) {
	  THREE.DirectionalLightHelper.call(this, light, size, color);
	  var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000,
	    visible: false
	  });
	  this.picker = new THREE.Mesh(geometry, material);
	  this.picker.name = 'picker';
	  this.add(this.picker);
	}

	VolumeDirectionalLightHelper.prototype = Object.create(THREE.DirectionalLightHelper.prototype);
	VolumeDirectionalLightHelper.prototype.constructor = VolumeDirectionalLightHelper;

	VolumeDirectionalLightHelper.prototype.raycast = function (raycaster, intersects) {
	  var intersect = raycaster.intersectObject(this.picker)[0];

	  if (intersect) {
	    intersect.object = this.light;
	    intersects.push(intersect);
	  }
	};

	VolumeDirectionalLightHelper.prototype.dispose = function () {
	  this.remove(this.picker);
	  this.picker.geometry.dispose();
	  this.picker.material.dispose();
	  delete this.picker;
	  THREE.DirectionalLightHelper.prototype.dispose.call(this);
	};

	/**
	 * 平行光帮助器
	 * @author tengge / https://github.com/tengge1
	 */

	function DirectionalLightHelpers() {
	  BaseHelper.call(this);
	  this.helpers = [];
	}

	DirectionalLightHelpers.prototype = Object.create(BaseHelper.prototype);
	DirectionalLightHelpers.prototype.constructor = DirectionalLightHelpers;

	DirectionalLightHelpers.prototype.start = function () {
	  app.on(`objectAdded.${this.id}`, this.onObjectAdded.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	};

	DirectionalLightHelpers.prototype.stop = function () {
	  app.on(`objectAdded.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	};

	DirectionalLightHelpers.prototype.onObjectAdded = function (object) {
	  if (!object.isDirectionalLight) {
	    return;
	  }

	  var helper = new VolumeDirectionalLightHelper(object, 1);
	  helper.visible = app.storage.showDirectionalLight;
	  this.helpers.push(helper);
	  app.editor.sceneHelpers.add(helper);
	};

	DirectionalLightHelpers.prototype.onObjectRemoved = function (object) {
	  if (!object.isDirectionalLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  app.editor.sceneHelpers.remove(this.helpers[index]);
	  this.helpers[index].dispose();
	  this.helpers.splice(index, 1);
	};

	DirectionalLightHelpers.prototype.onObjectChanged = function (object) {
	  if (!object.isDirectionalLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  this.helpers[index].update();
	};

	DirectionalLightHelpers.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showDirectionalLight') {
	    return;
	  }

	  this.helpers.forEach(n => {
	    n.visible = value;
	  });
	};

	/**
	 * 具有一定体积的半球光帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {THREE.HemisphereLight} light 半球光
	 * @param {Number} size 尺寸
	 * @param {Object} color 颜色
	 */
	function VolumeHemisphereLightHelper(light, size, color) {
	  THREE.HemisphereLightHelper.call(this, light, size, color);
	  var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000,
	    visible: false
	  });
	  this.picker = new THREE.Mesh(geometry, material);
	  this.picker.name = 'picker';
	  this.add(this.picker);
	}

	VolumeHemisphereLightHelper.prototype = Object.create(THREE.HemisphereLightHelper.prototype);
	VolumeHemisphereLightHelper.prototype.constructor = VolumeHemisphereLightHelper;

	VolumeHemisphereLightHelper.prototype.raycast = function (raycaster, intersects) {
	  var intersect = raycaster.intersectObject(this.picker)[0];

	  if (intersect) {
	    intersect.object = this.light;
	    intersects.push(intersect);
	  }
	};

	VolumeHemisphereLightHelper.prototype.dispose = function () {
	  this.remove(this.picker);
	  this.picker.geometry.dispose();
	  this.picker.material.dispose();
	  delete this.picker;
	  THREE.HemisphereLightHelper.prototype.dispose.call(this);
	};

	/**
	 * 半球光帮助器
	 * @author tengge / https://github.com/tengge1
	 */

	function HemisphereLightHelpers() {
	  BaseHelper.call(this);
	  this.helpers = [];
	}

	HemisphereLightHelpers.prototype = Object.create(BaseHelper.prototype);
	HemisphereLightHelpers.prototype.constructor = HemisphereLightHelpers;

	HemisphereLightHelpers.prototype.start = function () {
	  app.on(`objectAdded.${this.id}`, this.onObjectAdded.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	};

	HemisphereLightHelpers.prototype.stop = function () {
	  app.on(`objectAdded.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	};

	HemisphereLightHelpers.prototype.onObjectAdded = function (object) {
	  if (!object.isHemisphereLight) {
	    return;
	  }

	  var helper = new VolumeHemisphereLightHelper(object, 1);
	  helper.visible = app.storage.showHemisphereLight;
	  this.helpers.push(helper);
	  app.editor.sceneHelpers.add(helper);
	};

	HemisphereLightHelpers.prototype.onObjectRemoved = function (object) {
	  if (!object.isHemisphereLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  app.editor.sceneHelpers.remove(this.helpers[index]);
	  this.helpers[index].dispose();
	  this.helpers.splice(index, 1);
	};

	HemisphereLightHelpers.prototype.onObjectChanged = function (object) {
	  if (!object.isHemisphereLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  this.helpers[index].update();
	};

	HemisphereLightHelpers.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showHemisphereLight') {
	    return;
	  }

	  this.helpers.forEach(n => {
	    n.visible = value;
	  });
	};

	/**
	 * @author abelnation / http://github.com/abelnation
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 *  This helper must be added as a child of the light
	 */
	function RectAreaLightHelper$1(light, color) {
	  this.type = 'RectAreaLightHelper';
	  this.light = light;
	  this.color = color; // optional hardwired color for the helper

	  var positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
	  var geometry = new THREE.BufferGeometry();
	  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
	  geometry.computeBoundingSphere();
	  var material = new THREE.LineBasicMaterial({
	    fog: false
	  });
	  THREE.Line.call(this, geometry, material); //

	  var positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
	  var geometry2 = new THREE.BufferGeometry();
	  geometry2.setAttribute('position', new THREE.Float32BufferAttribute(positions2, 3));
	  geometry2.computeBoundingSphere();
	  this.add(new THREE.Mesh(geometry2, new THREE.MeshBasicMaterial({
	    side: THREE.BackSide,
	    fog: false
	  })));
	  this.update();
	}

	RectAreaLightHelper$1.prototype = Object.create(THREE.Line.prototype);
	RectAreaLightHelper$1.prototype.constructor = RectAreaLightHelper$1;

	RectAreaLightHelper$1.prototype.update = function () {
	  this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);

	  if (this.color !== undefined) {
	    this.material.color.set(this.color);
	    this.children[0].material.color.set(this.color);
	  } else {
	    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity); // prevent hue shift

	    var c = this.material.color;
	    var max = Math.max(c.r, c.g, c.b);
	    if (max > 1) c.multiplyScalar(1 / max);
	    this.children[0].material.color.copy(this.material.color);
	  }
	};

	RectAreaLightHelper$1.prototype.dispose = function () {
	  this.geometry.dispose();
	  this.material.dispose();
	  this.children[0].geometry.dispose();
	  this.children[0].material.dispose();
	};

	/**
	 * 具有一定体积的矩形光帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {THREE.RectAreaLight} light 矩形光
	 * @param {Object} color 颜色
	 */

	function VolumeRectAreaLightHelper(light, color) {
	  RectAreaLightHelper$1.call(this, light, color); // TODO: three.js bugs： 未设置矩形光帮助器矩阵

	  this.matrix = light.matrixWorld;
	  this.matrixAutoUpdate = false;
	  var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000,
	    visible: false
	  });
	  this.picker = new THREE.Mesh(geometry, material);
	  this.picker.name = 'picker';
	  this.add(this.picker);
	}

	VolumeRectAreaLightHelper.prototype = Object.create(RectAreaLightHelper$1.prototype);
	VolumeRectAreaLightHelper.prototype.constructor = VolumeRectAreaLightHelper;

	VolumeRectAreaLightHelper.prototype.raycast = function (raycaster, intersects) {
	  var intersect = raycaster.intersectObject(this.picker)[0];

	  if (intersect) {
	    intersect.object = this.light;
	    intersects.push(intersect);
	  }
	};

	VolumeRectAreaLightHelper.prototype.dispose = function () {
	  this.remove(this.picker);
	  this.picker.geometry.dispose();
	  this.picker.material.dispose();
	  delete this.picker;
	  THREE.RectAreaLightHelper.prototype.dispose.call(this);
	};

	/**
	 * 矩形光帮助器
	 * @author tengge / https://github.com/tengge1
	 */

	function RectAreaLightHelpers() {
	  BaseHelper.call(this);
	  this.helpers = [];
	}

	RectAreaLightHelpers.prototype = Object.create(BaseHelper.prototype);
	RectAreaLightHelpers.prototype.constructor = RectAreaLightHelpers;

	RectAreaLightHelpers.prototype.start = function () {
	  app.on(`objectAdded.${this.id}`, this.onObjectAdded.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	};

	RectAreaLightHelpers.prototype.stop = function () {
	  app.on(`objectAdded.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	};

	RectAreaLightHelpers.prototype.onObjectAdded = function (object) {
	  if (!object.isRectAreaLight) {
	    return;
	  }

	  var helper = new VolumeRectAreaLightHelper(object, 0xffffff);
	  helper.visible = app.storage.showRectAreaLight;
	  this.helpers.push(helper);
	  app.editor.sceneHelpers.add(helper);
	};

	RectAreaLightHelpers.prototype.onObjectRemoved = function (object) {
	  if (!object.isRectAreaLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  app.editor.sceneHelpers.remove(this.helpers[index]);
	  this.helpers[index].dispose();
	  this.helpers.splice(index, 1);
	};

	RectAreaLightHelpers.prototype.onObjectChanged = function (object) {
	  if (!object.isRectAreaLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  this.helpers[index].update();
	};

	RectAreaLightHelpers.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showRectAreaLight') {
	    return;
	  }

	  this.helpers.forEach(n => {
	    n.visible = value;
	  });
	};

	/**
	 * 具有一定体积的聚光灯帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {THREE.SpotLight} light 聚光灯
	 * @param {Object} color 颜色
	 */
	function VolumeSpotLightHelper(light, color) {
	  THREE.SpotLightHelper.call(this, light, color);
	  var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000,
	    visible: false
	  });
	  this.picker = new THREE.Mesh(geometry, material);
	  this.picker.name = 'picker';
	  this.add(this.picker);
	}

	VolumeSpotLightHelper.prototype = Object.create(THREE.SpotLightHelper.prototype);
	VolumeSpotLightHelper.prototype.constructor = VolumeSpotLightHelper;

	VolumeSpotLightHelper.prototype.raycast = function (raycaster, intersects) {
	  var intersect = raycaster.intersectObject(this.picker)[0];

	  if (intersect) {
	    intersect.object = this.light;
	    intersects.push(intersect);
	  }
	};

	VolumeSpotLightHelper.prototype.dispose = function () {
	  this.remove(this.picker);
	  this.picker.geometry.dispose();
	  this.picker.material.dispose();
	  delete this.picker;
	  THREE.SpotLightHelper.prototype.dispose.call(this);
	};

	/**
	 * 聚光灯帮助器
	 * @author tengge / https://github.com/tengge1
	 */

	function SpotLightHelpers() {
	  BaseHelper.call(this);
	  this.helpers = [];
	}

	SpotLightHelpers.prototype = Object.create(BaseHelper.prototype);
	SpotLightHelpers.prototype.constructor = SpotLightHelpers;

	SpotLightHelpers.prototype.start = function () {
	  app.on(`objectAdded.${this.id}`, this.onObjectAdded.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	};

	SpotLightHelpers.prototype.stop = function () {
	  app.on(`objectAdded.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	};

	SpotLightHelpers.prototype.onObjectAdded = function (object) {
	  if (!object.isSpotLight) {
	    return;
	  }

	  var helper = new VolumeSpotLightHelper(object, 0xffffff);
	  helper.visible = app.storage.showSpotLight;
	  this.helpers.push(helper);
	  app.editor.sceneHelpers.add(helper);
	};

	SpotLightHelpers.prototype.onObjectRemoved = function (object) {
	  if (!object.isSpotLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  app.editor.sceneHelpers.remove(this.helpers[index]);
	  this.helpers[index].dispose();
	  this.helpers.splice(index, 1);
	};

	SpotLightHelpers.prototype.onObjectChanged = function (object) {
	  if (!object.isSpotLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  this.helpers[index].update();
	};

	SpotLightHelpers.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showSpotLight') {
	    return;
	  }

	  this.helpers.forEach(n => {
	    n.visible = value;
	  });
	};

	var ArrowVertex = "precision highp float;\r\nprecision highp int;\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\n\r\nuniform mat4 modelViewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform mat3 normalMatrix;\r\n\r\nuniform float domWidth;\r\nuniform float domHeight;\r\nuniform float size;\r\nuniform float z;\r\n\r\nvarying vec3 vPosition;\r\nvarying vec3 vNormal;\r\n\r\nvoid main() {\r\n    mat4 translateMatrix = mat4(\r\n        1.0, 0.0, 0.0, 0.0,\r\n        0.0, 1.0, 0.0, 0.0,\r\n        0.0, 0.0, 1.0, 0.0,\r\n        1.0 - size / domWidth, 1.0 - size / domHeight, 0.0, 1.0\r\n    );\r\n\r\n    mat4 _modelViewMatrix = modelViewMatrix;\r\n    _modelViewMatrix[3][0] = 0.0;\r\n    _modelViewMatrix[3][1] = 0.0;\r\n    _modelViewMatrix[3][2] = -z;\r\n    \r\n    vec4 mvPosition = _modelViewMatrix * vec4(position, 1.0);\r\n\r\n    gl_Position = translateMatrix * projectionMatrix * mvPosition;\r\n    \r\n    vPosition = vec3(mvPosition);\r\n    vNormal = normalize(normalMatrix * normal);\r\n}";

	var ArrowFragment = "precision highp float;\r\nprecision highp int;\r\n\r\nuniform mat4 viewMatrix;\r\n\r\nuniform vec3 color;\r\nuniform vec3 ambientColor;\r\nuniform vec3 lightPosition;\r\nuniform vec3 diffuseColor;\r\nuniform float shininess;\r\n\r\nvarying vec3 vPosition;\r\nvarying vec3 vNormal;\r\n\r\nvoid main() {\r\n    vec3 ambient = ambientColor * color;\r\n    \r\n    vec3 normal = normalize(vNormal);\r\n    vec3 vLightPosition = vec3(0.0, 0.0, 1.0);\r\n    vec3 lightDirection = normalize(vLightPosition - vPosition);\r\n    float dotL = max(dot(lightDirection, normal), 0.0);\r\n    vec3 diffuse = diffuseColor * dotL * color;\r\n\r\n    vec3 eyeDirection = normalize(- vPosition);\r\n    vec3 reflectionDirection = reflect(-lightDirection, normal);\r\n    float specularLightWeight = pow(max(dot(reflectionDirection, eyeDirection), 0.0), shininess);\r\n    vec3 specular = color * specularLightWeight;\r\n\r\n    gl_FragColor = vec4(ambient + diffuse + specular, 1.0);\r\n}";

	/**
	 * 视角帮助器
	 * @author tengge / https://github.com/tengge1
	 */

	function ViewHelper() {
	  BaseHelper.call(this);
	}

	ViewHelper.prototype = Object.create(BaseHelper.prototype);
	ViewHelper.prototype.constructor = ViewHelper;

	ViewHelper.prototype.start = function () {
	  this.scene = new THREE.Scene();
	  let show = app.storage.showViewHelper;

	  if (show === undefined) {
	    show = true;
	    app.storage.showViewHelper = true;
	  }

	  this.show = show;
	  this.mesh = this.createMesh();
	  this.mesh.frustumCulled = false;
	  this.scene.add(this.mesh);
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	  app.on(`afterRender.${this.id}`, this.onAfterRender.bind(this)); // app.on(`mousedown.${this.id}`, this.onMouseDown.bind(this));

	  app.on(`resize.${this.id}`, this.onResize.bind(this));
	};

	ViewHelper.prototype.stop = function () {
	  this.scene.remove(this.mesh);
	  delete this.scene;
	  delete this.mesh;
	  app.on(`storageChanged.${this.id}`, null);
	  app.on(`afterRender.${this.id}`, null); // app.on(`mousedown.${this.id}`, null);

	  app.on(`resize.${this.id}`, null);
	};

	ViewHelper.prototype.createMesh = function () {
	  var geometry = new THREE.ConeBufferGeometry(0.25, 1.0, 16, 16);
	  geometry.computeBoundingBox();
	  geometry.translate(0, geometry.boundingBox.min.y, 0);
	  var geometryPX = geometry.clone();
	  geometryPX.rotateZ(Math.PI / 2);
	  var geometryNX = geometry.clone();
	  geometryNX.rotateZ(-Math.PI / 2);
	  var geometryPY = geometry.clone();
	  geometryPY.rotateX(Math.PI);
	  var geometryNY = geometry.clone();
	  var geometryPZ = geometry.clone();
	  geometryPZ.rotateX(-Math.PI / 2);
	  var geometryNZ = geometry.clone();
	  geometryNZ.rotateX(Math.PI / 2);
	  geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([geometryPX, geometryNX, geometryPY, geometryNY, geometryPZ, geometryNZ], true);
	  var domElement = app.editor.renderer.domElement;
	  var domWidth = domElement.clientWidth;
	  var domHeight = domElement.clientHeight;
	  this.z = 16; // 控件中心到相机距离，越远越小

	  var fov = app.editor.camera.fov;
	  var top = this.z * Math.tan(fov * Math.PI / 180 * 0.5); // 到相机垂直距离为z的地方屏幕高度一半

	  this.size = (domHeight / (2 * top) + 12) * 2; // 12为留白

	  var uniforms = {
	    domWidth: {
	      type: 'f',
	      value: domWidth
	    },
	    domHeight: {
	      type: 'f',
	      value: domHeight
	    },
	    size: {
	      type: 'f',
	      value: this.size
	    },
	    z: {
	      type: 'f',
	      value: this.z
	    },
	    color: {
	      type: 'v3',
	      value: new THREE.Vector3(1.0, 0.0, 0.0)
	    },
	    ambientColor: {
	      type: 'v3',
	      value: new THREE.Vector3(0.4, 0.4, 0.4)
	    },
	    lightPosition: {
	      type: 'v3',
	      value: new THREE.Vector3(10, 10, 10)
	    },
	    diffuseColor: {
	      type: 'v3',
	      value: new THREE.Vector3(1.0, 1.0, 1.0)
	    },
	    shininess: {
	      type: 'float',
	      value: 30
	    }
	  };
	  var material1 = new THREE.RawShaderMaterial({
	    uniforms: THREE.UniformsUtils.clone(uniforms),
	    vertexShader: ArrowVertex,
	    fragmentShader: ArrowFragment
	  });
	  var material2 = material1.clone();
	  material2.uniforms.color.value = new THREE.Vector3(0.5, 0.5, 0.5);
	  var material3 = material1.clone();
	  material3.uniforms.color.value = new THREE.Vector3(0.0, 1.0, 0.0);
	  var material4 = material1.clone();
	  material4.uniforms.color.value = new THREE.Vector3(0.5, 0.5, 0.5);
	  var material5 = material1.clone();
	  material5.uniforms.color.value = new THREE.Vector3(0.0, 0.0, 1.0);
	  var material6 = material1.clone();
	  material6.uniforms.color.value = new THREE.Vector3(0.5, 0.5, 0.5);
	  return new THREE.Mesh(geometry, [material1, material2, material3, material4, material5, material6]);
	};

	ViewHelper.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showViewHelper') {
	    return;
	  }

	  this.show = value;
	};

	ViewHelper.prototype.onAfterRender = function () {
	  if (!this.show) {
	    return;
	  }

	  if (!app.editor.showViewHelper) {
	    return;
	  }

	  let renderer = app.editor.renderer; // 最后绘制而且清空深度缓冲，保证视角控件不会被其他物体遮挡

	  renderer.clearDepth();
	  renderer.render(this.scene, app.editor.camera);
	};

	ViewHelper.prototype.onMouseDown = function (event) {
	  if (this.mouse === undefined) {
	    this.mouse = new THREE.Vector3();
	  }

	  if (this.raycaster === undefined) {
	    this.raycaster = new THREE.Raycaster();
	  }

	  var domElement = app.editor.renderer.domElement;
	  this.mouse.set(event.offsetX / domElement.clientWidth * 2 - 1, -event.offsetY / domElement.clientHeight * 2 + 1);
	  this.raycaster.setFromCamera(this.mouse, app.editor.camera); // 设置几何体矩阵，将其转换到左上角

	  if (this.matrix === undefined) {
	    this.matrix = new THREE.Matrix4();
	  }

	  this.matrix.copy(this.mesh.matrixWorld); // 旧：projectionMatrix * modelViewMatrix
	  // 新：translateMatrix * projectionMatrix * _modelViewMatrix
	  // matrixWorld = 

	  if (this.screenXY === undefined) {
	    this.screenXY = new THREE.Vector3();
	  }

	  this.screenXY.set((domElement.clientWidth - this.size / 2) / domElement.clientWidth * 2 - 1, -this.size / 2 / domElement.clientHeight * 2 + 1, -this.z);
	  this.screenXY.unproject(app.editor.camera); // var obj = this.raycaster.intersectObject(this.mesh)[0];
	  // this.mesh.matrixWorld.copy(this.matrix);
	  // if (obj) {
	  //     var materialIndex = obj.face.materialIndex;
	  // }
	};

	ViewHelper.prototype.onResize = function () {
	  var materials = this.mesh.material;
	  var width = app.editor.renderer.domElement.width;
	  var height = app.editor.renderer.domElement.height;
	  var fov = app.editor.camera.fov;
	  var top = this.z * Math.tan(fov * Math.PI / 180 * 0.5); // 到相机垂直距离为z的地方屏幕高度一半

	  this.size = (height / (2 * top) + 12) * 2; // 12为留白

	  materials.forEach(n => {
	    n.uniforms.domWidth.value = width;
	    n.uniforms.domHeight.value = height;
	    n.uniforms.size.value = this.size;
	  });
	};

	var MaskVertex = "// https://github.com/mrdoob/three.js/blob/dev/examples/js/postprocessing/OutlinePass.js\r\n\r\nvoid main() {\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}";

	var MaskFragment = "// https://github.com/mrdoob/three.js/blob/dev/examples/js/postprocessing/OutlinePass.js\r\n\r\nvoid main() {\r\n    gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);\r\n}";

	var EdgeVertex = "varying vec2 vUv;\r\n\r\n// https://github.com/mrdoob/three.js/blob/dev/examples/js/postprocessing/OutlinePass.js\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}";

	var EdgeFragment = "uniform sampler2D maskTexture;\r\nuniform vec2 texSize;\r\nuniform vec3 color;\r\nuniform float thickness;\r\n\r\nvarying vec2 vUv;\r\n\r\n// https://github.com/mrdoob/three.js/blob/dev/examples/js/postprocessing/OutlinePass.js\r\n\r\nvoid main() {\r\n    vec2 invSize = thickness / texSize;\r\n    vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\r\n\r\n    vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\r\n    vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\r\n    vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\r\n    vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\r\n    \r\n    float diff1 = (c1.r - c2.r)*0.5;\r\n    float diff2 = (c3.r - c4.r)*0.5;\r\n    \r\n    float d = length(vec2(diff1, diff2));\r\n    gl_FragColor = d > 0.0 ? vec4(color, 1.0) : vec4(0.0, 0.0, 0.0, 0.0);\r\n}";

	/**
	 * 选择帮助器
	 * @author tengge / https://github.com/tengge1
	 */

	function SelectHelper() {
	  BaseHelper.call(this);
	  this.hideObjects = [];
	}

	SelectHelper.prototype = Object.create(BaseHelper.prototype);
	SelectHelper.prototype.constructor = SelectHelper;

	SelectHelper.prototype.start = function () {
	  app.on(`objectSelected.${this.id}`, this.onObjectSelected.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`afterRender.${this.id}`, this.onAfterRender.bind(this));
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	};

	SelectHelper.prototype.stop = function () {
	  app.on(`objectSelected.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`afterRender.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	};

	SelectHelper.prototype.onObjectSelected = function (obj) {
	  if (!obj) {
	    this.unselect();
	    return;
	  } // 禁止选中场景和相机


	  if (obj === app.editor.scene || obj === app.editor.camera) {
	    return;
	  } // 不允许选中文字


	  if (obj.userData && (obj.userData.type === 'text' || obj.userData.type === 'pointMarker')) {
	    this.unselect();
	    return;
	  }

	  if (!this.size) {
	    this.size = new THREE.Vector2();
	  }

	  app.editor.renderer.getDrawingBufferSize(this.size);
	  let width = this.size.x * 2;
	  let height = this.size.y * 2;

	  if (this.scene === undefined) {
	    this.scene = new THREE.Scene();
	    this.scene.autoUpdate = false;
	  }

	  if (this.camera === undefined) {
	    this.camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 0, 1);
	    this.camera.position.z = 1;
	    this.camera.lookAt(new THREE.Vector3());
	  }

	  if (this.quad === undefined) {
	    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(width, height), null);
	    this.quad.frustumCulled = false;
	    this.scene.add(this.quad);
	  }

	  let params = {
	    minFilter: THREE.LinearFilter,
	    magFilter: THREE.LinearFilter,
	    format: THREE.RGBAFormat,
	    antialias: true
	  };

	  if (this.maskBuffer === undefined) {
	    this.maskBuffer = new THREE.WebGLRenderTarget(width, height, params);
	    this.maskBuffer.texture.generateMipmaps = false;
	  }

	  if (this.edgeBuffer === undefined) {
	    this.edgeBuffer = new THREE.WebGLRenderTarget(width, height, params);
	    this.edgeBuffer.texture.generateMipmaps = false;
	  }

	  if (this.maskMaterial === undefined) {
	    this.maskMaterial = new THREE.ShaderMaterial({
	      vertexShader: MaskVertex,
	      fragmentShader: MaskFragment,
	      depthTest: false
	    });
	  }

	  const selectedColor = app.storage.selectedColor;
	  const selectedThickness = app.storage.selectedThickness;

	  if (this.edgeMaterial === undefined) {
	    this.edgeMaterial = new THREE.ShaderMaterial({
	      vertexShader: EdgeVertex,
	      fragmentShader: EdgeFragment,
	      uniforms: {
	        maskTexture: {
	          value: this.maskBuffer.texture
	        },
	        texSize: {
	          value: new THREE.Vector2(width, height)
	        },
	        color: {
	          value: new THREE.Color(selectedColor)
	        },
	        thickness: {
	          type: 'f',
	          value: selectedThickness
	        },
	        transparent: true
	      },
	      depthTest: false
	    });
	  }

	  if (this.copyMaterial === undefined) {
	    this.copyMaterial = new THREE.ShaderMaterial({
	      vertexShader: THREE.FXAAShader.vertexShader,
	      fragmentShader: THREE.FXAAShader.fragmentShader,
	      uniforms: {
	        tDiffuse: {
	          value: this.edgeBuffer.texture
	        },
	        resolution: {
	          value: new THREE.Vector2(1 / width, 1 / height)
	        }
	      },
	      transparent: true,
	      depthTest: false
	    });
	  }

	  this.object = obj;
	};

	SelectHelper.prototype.onObjectRemoved = function (object) {
	  if (object === this.object) {
	    this.unselect();
	  }
	};

	SelectHelper.prototype.unselect = function () {
	  if (this.object) {
	    delete this.object;
	  }
	};

	SelectHelper.prototype.onAfterRender = function () {
	  if (!this.object || !this.object.parent) {
	    // TODO: this.object.parent为null时表示该物体被移除
	    return;
	  }

	  let renderScene = app.editor.scene;
	  let renderCamera = app.editor.view === 'perspective' ? app.editor.camera : app.editor.orthCamera;
	  let renderer = app.editor.renderer;
	  let scene = this.scene;
	  let camera = this.camera;
	  let selected = this.object; // 记录原始状态

	  let oldOverrideMaterial = renderScene.overrideMaterial;
	  let oldBackground = renderScene.background;
	  let oldAutoClear = renderer.autoClear;
	  let oldClearColor = renderer.getClearColor();
	  let oldClearAlpha = renderer.getClearAlpha();
	  let oldRenderTarget = renderer.getRenderTarget(); // 绘制蒙版

	  this.hideObjects.length = 0;
	  this.hideNonSelectedObjects(renderScene, selected, renderScene);
	  renderScene.overrideMaterial = this.maskMaterial;
	  renderScene.background = null;
	  renderer.autoClear = false;
	  renderer.setRenderTarget(this.maskBuffer);
	  renderer.setClearColor(0xffffff);
	  renderer.setClearAlpha(1);
	  renderer.clear();
	  renderer.render(renderScene, renderCamera);
	  this.showNonSelectedObjects(renderScene, selected);
	  this.hideObjects.length = 0; // 绘制边框

	  this.quad.material = this.edgeMaterial;
	  renderScene.overrideMaterial = null;
	  renderer.setRenderTarget(this.edgeBuffer);
	  renderer.clear();
	  renderer.render(scene, camera); // 与原场景叠加

	  this.quad.material = this.copyMaterial;
	  renderer.setRenderTarget(null);
	  renderer.render(scene, camera); // 还原原始状态

	  renderScene.overrideMaterial = oldOverrideMaterial;
	  renderScene.background = oldBackground;
	  renderer.autoClear = oldAutoClear;
	  renderer.setClearColor(oldClearColor);
	  renderer.setClearAlpha(oldClearAlpha);
	  renderer.setRenderTarget(oldRenderTarget);
	};

	SelectHelper.prototype.hideNonSelectedObjects = function (obj, selected, root) {
	  if (obj === selected) {
	    let current = obj.parent;

	    while (current && current !== root) {
	      let index = this.hideObjects.indexOf(current);
	      this.hideObjects.splice(index, 1);
	      current.visible = current.userData.oldVisible;
	      delete current.userData.oldVisible;
	      current = current.parent;
	    }

	    return;
	  }

	  if (obj !== root) {
	    obj.userData.oldVisible = obj.visible;
	    obj.visible = false;
	    this.hideObjects.push(obj);
	  }

	  for (let child of obj.children) {
	    if (child instanceof THREE.Light) {
	      continue;
	    }

	    this.hideNonSelectedObjects(child, selected, root);
	  }
	};

	SelectHelper.prototype.showNonSelectedObjects = function () {
	  this.hideObjects.forEach(n => {
	    n.visible = n.userData.oldVisible;
	    delete n.userData.oldVisible;
	  });
	};

	SelectHelper.prototype.onStorageChanged = function (name, value) {
	  if (!this.edgeMaterial) {
	    return;
	  }

	  if (name === 'selectedColor') {
	    this.edgeMaterial.uniforms.color.value.set(value);
	  } else if (name === 'selectedThickness') {
	    this.edgeMaterial.uniforms.thickness.value = value;
	  }
	};

	/**
	 * 鼠标移入帮助器
	 * @author tengge / https://github.com/tengge1
	 */

	function HoverHelper() {
	  BaseHelper.call(this);
	  this.hoverEnabled = app.storage.hoverEnabled;
	  this.hoveredColor = app.storage.hoveredColor;
	  this.onGpuPick = this.onGpuPick.bind(this);
	  this.onObjectRemoved = this.onObjectRemoved.bind(this);
	  this.onAfterRender = this.onAfterRender.bind(this);
	  this.onStorageChanged = this.onStorageChanged.bind(this);
	}

	HoverHelper.prototype = Object.create(BaseHelper.prototype);
	HoverHelper.prototype.constructor = HoverHelper;

	HoverHelper.prototype.start = function () {
	  this.time = 0;
	  this.offsetX = 0;
	  this.offsetY = 0;
	  this.mouse = new THREE.Vector2();
	  this.raycaster = new THREE.Raycaster();
	  this.object = null;
	  this.scene = new THREE.Scene();
	  this.scene.autoUpdate = false; // 避免场景自动更新物体的matrixWorld，否则会导致物体旋转后，高亮不准的bug。

	  this.scene.overrideMaterial = new THREE.MeshBasicMaterial({
	    color: this.hoveredColor,
	    transparent: true,
	    opacity: 0.5
	  });
	  app.on(`gpuPick.${this.id}`, this.onGpuPick);
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved);
	  app.on(`afterRender.${this.id}`, this.onAfterRender);
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged);
	};

	HoverHelper.prototype.stop = function () {
	  app.on(`gpuPick.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`afterRender.${this.id}`, null);
	};

	HoverHelper.prototype.onGpuPick = function (obj) {
	  let object = obj.object;

	  if (!object) {
	    this.object = null;
	    return;
	  } // 不允许对文字产生hover效果


	  if (object.userData && object.userData.type === 'text') {
	    return;
	  }

	  this.object = object;
	};

	HoverHelper.prototype.onObjectRemoved = function (object) {
	  if (object === this.object) {
	    this.object = null;
	  }
	};

	HoverHelper.prototype.onAfterRender = function () {
	  if (!this.hoverEnabled || !this.object || !this.object.parent) {
	    // TODO: this.object.parent为null时表示该物体被移除
	    return;
	  }

	  const renderer = app.editor.renderer;
	  const camera = app.editor.view === 'perspective' ? app.editor.camera : app.editor.orthCamera;
	  const parent = this.object.parent;
	  const index = parent.children.indexOf(this.object);
	  this.scene.add(this.object);
	  renderer.render(this.scene, camera);
	  this.scene.remove(this.object);
	  this.object.parent = parent;
	  parent.children.splice(index, 0, this.object);
	};

	HoverHelper.prototype.onStorageChanged = function (key, value) {
	  if (key === 'hoverEnabled') {
	    this.hoverEnabled = value;
	  } else if (key === 'hoveredColor') {
	    this.hoveredColor = value;

	    if (this.scene) {
	      this.scene.overrideMaterial.color.set(value);
	    }
	  }
	};

	/**
	 * 曲线帮助器基类
	 * @author tengge / https://github.com/tengge1
	 */

	function SplineHelper() {
	  BaseHelper.call(this);
	  this.box = [];
	}

	SplineHelper.prototype = Object.create(BaseHelper.prototype);
	SplineHelper.prototype.constructor = SplineHelper;

	SplineHelper.prototype.start = function () {
	  app.on(`objectSelected.${this.id}`, this.onObjectSelected.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	};

	SplineHelper.prototype.stop = function () {
	  app.on(`objectSelected.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	};

	SplineHelper.prototype.onObjectSelected = function (object) {
	  if (object === null) {
	    this.onCancelSelectLine();
	  } else if (object.userData && (object.userData.type === 'LineCurve' || object.userData.type === 'CatmullRomCurve' || object.userData.type === 'QuadraticBezierCurve' || object.userData.type === 'CubicBezierCurve')) {
	    this.onSelectLine(object);
	  }
	};

	SplineHelper.prototype.onObjectChanged = function (obj) {
	  if (this.box.length === 0) {
	    return;
	  }

	  var scene = app.editor.sceneHelpers;
	  var line = this.box[0].userData.object;

	  if (obj === line) {
	    // 修改了线
	    line.userData.points.forEach((n, i) => {
	      if (this.box[i]) {
	        this.box[i].position.copy(line.position).add(n);
	      } else {
	        var mesh = new THREE.Mesh(this.box[0].geometry, this.box[0].material);
	        mesh.position.copy(line.position).add(n);
	        Object.assign(mesh.userData, {
	          type: 'helper',
	          object: line
	        });
	        scene.add(mesh);
	        this.box.push(mesh);
	      }
	    });

	    if (this.box.length > line.userData.points.length) {
	      this.box.splice(line.userData.points.length, this.box.length - line.userData.points.length).forEach(n => {
	        delete n.object;
	        scene.remove(n);
	      });
	    }
	  } else if (obj.userData && obj.userData.type === 'helper') {
	    // 修改了帮助器
	    var object = obj.userData.object;
	    var index = this.box.indexOf(obj);

	    if (index > -1) {
	      object.userData.points[index].copy(object.position).multiplyScalar(-1).add(obj.position);
	      object.update();
	    }
	  }
	};

	SplineHelper.prototype.onSelectLine = function (object) {
	  var scene = app.editor.sceneHelpers;
	  this.onCancelSelectLine();
	  var geometry = new THREE.BoxBufferGeometry(0.4, 0.4, 0.4);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000
	  });
	  object.userData.points.forEach(n => {
	    var mesh = new THREE.Mesh(geometry, material);
	    mesh.position.copy(object.position).add(n);
	    Object.assign(mesh.userData, {
	      type: 'helper',
	      object: object
	    });
	    scene.add(mesh);
	    this.box.push(mesh);
	  });
	};

	SplineHelper.prototype.onCancelSelectLine = function () {
	  var scene = app.editor.sceneHelpers;
	  this.box.forEach(n => {
	    scene.remove(n);
	    delete n.userData.object;
	  });
	  this.box.length = 0;
	};

	// import GodRaysHelpers from './light/GodRaysHelpers';

	/**
	 * 所有帮助器
	 * @author tengge / https://github.com/tengge1
	 */

	function Helpers() {
	  BaseHelper.call(this);
	  this.helpers = [new GridHelper(), new CameraHelper(), new PointLightHelpers(), new DirectionalLightHelpers(), new HemisphereLightHelpers(), new RectAreaLightHelpers(), new SpotLightHelpers(), new SelectHelper(), new HoverHelper(), new ViewHelper(), new SplineHelper() // 测试
	  // new GodRaysHelpers() // 对性能影响太大，请勿使用
	  ];
	}

	Helpers.prototype = Object.create(BaseHelper.prototype);
	Helpers.prototype.constructor = Helpers;

	Helpers.prototype.start = function () {
	  this.helpers.forEach(n => {
	    n.start();
	  });
	};

	Helpers.prototype.stop = function () {
	  this.helpers.forEach(n => {
	    n.stop();
	  });
	};

	let ID$b = -1;
	/**
	 * 控制器基类
	 * @author tengge1 / https://github.com/tengge1
	 */

	class BaseControls {
	  /**
	   * 创建一个控制器
	   * @param {THREE.Camera} camera 相机
	   * @param {HTMLElement} domElement HTML文档
	   */
	  constructor(camera, domElement) {
	    this.id = `${this.constructor.name}${ID$b--}`;
	    this.camera = camera;
	    this.domElement = domElement;
	    this.enabled = true;
	    this.dispatch = dispatch('change', 'update', 'end'); // change(enabled, controlName, control)，控制器改变
	    // update()，相机位置改变
	    // end()，控制器内部退出当前模式，主要用于按Esc退出第一视角模式。

	    this.call = this.dispatch.call.bind(this.dispatch);
	    this.on = this.dispatch.on.bind(this.dispatch);
	  }
	  /**
	   * 启用控制器
	   */


	  enable() {
	    this.enabled = true;
	  }
	  /**
	   * 禁用控制器
	   */


	  disable() {
	    this.enabled = false;
	  }
	  /**
	   * 转到某个物体的视角
	   * @param {THREE.Object3D} target 目标
	   */


	  focus(target) {} // eslint-disable-line

	  /**
	   * 不断循环调用，以便实现动画效果
	   * @param {THREE.Clock} clock 时钟
	   * @param {Number} deltaTime 间隔时间
	   */


	  update(clock, deltaTime) {} // eslint-disable-line

	  /**
	   * 当前鼠标所在位置碰撞点世界坐标
	   * @param {THREE.Vector3} position 世界坐标
	   */


	  setPickPosition(position) {} // eslint-disable-line

	  /**
	   * 析构控制器
	   */


	  dispose() {
	    this.camera = null;
	    this.domElement = null;
	  }

	}

	/**
	 * 编辑器控制器
	 * @author tengge1 / https://github.com/tengge1
	 */

	class EditorControls extends BaseControls {
	  constructor(camera, domElement) {
	    super(camera, domElement);
	    this.controls = new THREE.EditorControls(camera, domElement);
	  }

	  enable() {
	    this.enabled = true;
	    this.controls.enabled = true;
	  }

	  disable() {
	    this.enabled = false;
	    this.controls.enabled = false;
	  }

	  focus(target) {
	    this.controls.focus(target);
	  }

	  dispose() {
	    this.controls.dispose();
	    this.camera = null;
	    this.domElement = null;
	  }

	}

	/**
	 * 自由控制器
	 * @author tengge1 / https://github.com/tengge1
	 */

	class FreeControls extends BaseControls {
	  constructor(camera, domElement) {
	    super(camera, domElement);
	    this.controls = new THREE.OrbitControls(camera, domElement);
	    this.controls.enableZoom = true;
	    this.controls.maxPolarAngle = 85 * Math.PI / 180; // 85°

	    this.controls.enableDamping = true;
	    this.controls.dampingFactor = 0.08;
	    this.controls.panSpeed = 1.6;
	  }

	  enable() {
	    this.enabled = true;
	    this.controls.enabled = true;
	  }

	  disable() {
	    this.enabled = false;
	    this.controls.enabled = false;
	  }

	  focus(target) {// eslint-disable-line
	  }

	  update() {
	    this.controls.update();
	  }

	  dispose() {
	    this.controls.dispose();
	    this.camera = null;
	    this.domElement = null;
	  }

	}

	const STATE = {
	  Forward: 1,
	  // 前进
	  Backward: 2,
	  // 后退
	  Left: 3,
	  // 向左移动
	  Right: 4 // 向右移动

	};
	const UP = new THREE.Vector3(0, 1, 0);
	const FORWARD = new THREE.Vector3(0, 0, -1);
	const RIGHT = new THREE.Vector3(1, 0, 0);
	/**
	 * 第一视角控制器
	 * @author tengge1 / https://github.com/tengge1
	 */

	class FirstPersonControls extends BaseControls {
	  constructor(camera, domElement) {
	    super(camera, domElement);
	    this.height = camera.position.y;
	    camera.lookAt(new THREE.Vector3(0, this.height, 0));
	    this.panSpeed = 0.1;
	    this.rotationSpeed = 0.1 * Math.PI / 180;
	    this.state = null; // 临时变量

	    this.up = new THREE.Vector3(); // 上方

	    this.forward = new THREE.Vector3(); // 前方

	    this.right = new THREE.Vector3(); // 右侧

	    this.onKeyDown = this.onKeyDown.bind(this);
	    this.onKeyUp = this.onKeyUp.bind(this);
	    this.onMouseMove = this.onMouseMove.bind(this);
	    this.onPointerlockChange = this.onPointerlockChange.bind(this);
	    this.isLocked = true;
	    this.domElement.requestPointerLock();
	    document.addEventListener('keydown', this.onKeyDown, false);
	    document.addEventListener('keyup', this.onKeyUp, false);
	    document.addEventListener('mousemove', this.onMouseMove, false);
	    document.addEventListener('pointerlockchange', this.onPointerlockChange, false);
	  }

	  onKeyDown(event) {
	    switch (event.keyCode) {
	      case 38: // up

	      case 87:
	        // w
	        this.state = STATE.Forward;
	        break;

	      case 40: // down

	      case 83:
	        // s
	        this.state = STATE.Backward;
	        break;

	      case 37: // left

	      case 65:
	        // a
	        this.state = STATE.Left;
	        break;

	      case 39: // right

	      case 68:
	        // d
	        this.state = STATE.Right;
	        break;
	    }
	  }

	  onKeyUp() {
	    this.state = null;
	  }

	  onMouseMove(event) {
	    if (!this.isLocked) {
	      return;
	    }

	    if (!this.quaternion1) {
	      this.quaternion1 = new THREE.Quaternion();
	    }

	    if (!this.quaternion2) {
	      this.quaternion2 = new THREE.Quaternion();
	    }

	    let camera = this.camera;
	    this.forward.copy(FORWARD).applyQuaternion(camera.quaternion).normalize();
	    this.right.copy(RIGHT).applyQuaternion(camera.quaternion).normalize();
	    const dx = -event.movementX * this.rotationSpeed;
	    const dy = -event.movementY * this.rotationSpeed;
	    this.quaternion1.setFromAxisAngle(UP, dx);
	    this.quaternion2.setFromAxisAngle(this.right, dy);
	    this.forward.applyQuaternion(this.quaternion1).applyQuaternion(this.quaternion2).add(camera.position);
	    camera.lookAt(this.forward);
	  }

	  onPointerlockChange() {
	    if (document.pointerLockElement === this.domElement) {
	      this.isLocked = true;
	    } else {
	      this.isLocked = false; // 按Esc可以强制退出第一视角模式。

	      this.call('end', this);
	    }
	  }

	  update() {
	    if (!this.state) {
	      return;
	    }

	    let camera = this.camera;
	    this.forward.copy(FORWARD).applyQuaternion(camera.quaternion).projectOnPlane(UP).normalize();
	    this.right.copy(RIGHT).applyQuaternion(camera.quaternion).projectOnPlane(UP).normalize();
	    this.forward.multiplyScalar(this.panSpeed);
	    this.right.multiplyScalar(this.panSpeed);

	    if (this.state === STATE.Forward) {
	      camera.position.add(this.forward);
	    } else if (this.state === STATE.Backward) {
	      camera.position.sub(this.forward);
	    } else if (this.state === STATE.Left) {
	      camera.position.sub(this.right);
	    } else if (this.state === STATE.Right) {
	      camera.position.add(this.right);
	    }
	  }

	  dispose() {
	    this.isLocked = false;
	    document.exitPointerLock();
	    document.removeEventListener('keydown', this.onKeyDown);
	    document.removeEventListener('keyup', this.onKeyUp);
	    document.removeEventListener('mousemove', this.onMouseMove);
	    document.removeEventListener('pointerlockchange', this.onPointerlockChange);
	    this.camera = null;
	    this.domElement = null;
	  }

	}

	const Controls = {
	  EditorControls,
	  FreeControls,
	  FirstPersonControls
	};
	/**
	 * 控制器管理器
	 * @author tengge1 / https://github.com/tengge1
	 */

	class ControlsManager extends BaseControls {
	  constructor(camera, domElement) {
	    super(camera, domElement);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleEnd = this.handleEnd.bind(this);
	    const mode = app.storage.controlMode;
	    this.changeMode(mode); // 记录上次控制器，以便按Esc退出第一视角，返回原来的模式。

	    this.lastControl = this.current; // 记录上次相机的平移、旋转和缩放

	    this.lastCamera = new THREE.Object3D();
	    app.on(`animate.${this.id}`, this.update.bind(this));
	    app.on(`gpuPick.${this.id}`, this.onGPUPick.bind(this));
	  }
	  /**
	   * 改变控制器模式
	   * @param {String} modeName 模式
	   */


	  changeMode(modeName) {
	    if (!Controls[modeName]) {
	      console.warn(`ControlsManager: ${modeName} is not defined.`);
	      return;
	    }

	    this.changeControl(new Controls[modeName](this.camera, this.domElement));
	  }

	  changeControl(control) {
	    if (this.current) {
	      let camera = app.editor.camera; // 第一视角模式不能作为原来的模式

	      if (!(this.current instanceof FirstPersonControls)) {
	        this.lastControl = this.current;
	        this.lastCamera.position.copy(camera.position);
	        this.lastCamera.rotation.copy(camera.rotation);
	        this.lastCamera.scale.copy(camera.scale);
	      }

	      this.current.disable();
	      this.current.on(`update.${this.id}`, null);
	      this.current.on(`end.${this.id}`, null);
	      this.call('change', this, false, this.current.constructor.name, this.current); // enabled, controlName, control
	    }

	    this.current = control;
	    this.current.enable();
	    this.current.on(`update.${this.id}`, this.handleUpdate);
	    this.current.on(`end.${this.id}`, this.handleEnd);
	    this.call('change', this, true, this.current.constructor.name, this.current);
	  }

	  enable() {
	    this.enabled = true;
	    this.current && this.current.enable();
	  }

	  disable() {
	    this.enabled = false;
	    this.current && this.current.disable();
	  }

	  focus(target) {
	    this.current && this.current.focus(target);
	  }

	  update(clock, deltaTime) {
	    this.current && this.current.update(clock, deltaTime);
	  }

	  setPickPosition(position) {
	    this.current && this.current.setPickPosition(position);
	  }

	  onGPUPick(obj) {
	    if (obj.point) {
	      this.setPickPosition(obj.point);
	    }
	  }

	  handleUpdate() {} // TODO: 太卡，待优化。
	  // app.call('cameraChanged', this, app.editor.camera);

	  /**
	   * 退出第一视角，返回原来的模式
	   */


	  handleEnd() {
	    this.changeControl(this.lastControl);
	    let camera = app.editor.camera;
	    camera.position.copy(this.lastCamera.position);
	    camera.rotation.copy(this.lastCamera.rotation);
	    camera.scale.copy(this.lastCamera.scale);
	  }

	  dispose() {
	    this.current && this.current.dispose();
	  }

	}

	/**
	 * 编辑器
	 * @author tengge / https://github.com/tengge1
	 */

	class Editor extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      showMask: false,
	      maskText: _t('Waiting...'),
	      elements: [],
	      assetsPanelShow: app.storage.assetsPanelShow,
	      sidebarShow: app.storage.sidebarShow,
	      toolbarShow: app.storage.toolbarShow,
	      timelinePanelShow: app.storage.timelinePanelShow,
	      statusBarShow: app.storage.statusBarShow
	    };
	    this.type = 'scene'; // 编辑器类型：scene, mesh, texture, material, terrain, ai

	    this.onToggle = this.onToggle.bind(this);
	  }

	  render() {
	    const {
	      showMask,
	      maskText,
	      elements,
	      assetsPanelShow,
	      sidebarShow,
	      toolbarShow,
	      timelinePanelShow,
	      statusBarShow
	    } = this.state;
	    const isLogin = !app.server.enableAuthority || app.server.isLogin;
	    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(BorderLayout, {
	      className: 'Editor'
	    }, /*#__PURE__*/React.createElement(EditorMenuBar, {
	      region: 'north'
	    }), /*#__PURE__*/React.createElement(EditorStatusBar, {
	      region: 'south',
	      show: statusBarShow
	    }), /*#__PURE__*/React.createElement(AssetsPanel, {
	      region: 'west',
	      split: true,
	      show: assetsPanelShow,
	      onToggle: this.onToggle
	    }), isLogin && /*#__PURE__*/React.createElement(EditorSideBar, {
	      region: 'east',
	      split: true,
	      show: sidebarShow,
	      onToggle: this.onToggle
	    }), /*#__PURE__*/React.createElement(BorderLayout, {
	      region: 'center'
	    }, isLogin && /*#__PURE__*/React.createElement(EditorToolbar, {
	      region: 'north',
	      show: toolbarShow
	    }), /*#__PURE__*/React.createElement(Viewport, {
	      region: 'center'
	    }), isLogin && /*#__PURE__*/React.createElement(TimelinePanel, {
	      region: 'south',
	      split: true,
	      show: timelinePanelShow,
	      onToggle: this.onToggle
	    }))), elements.map((n, i) => {
	      return /*#__PURE__*/React.createElement("div", {
	        key: i
	      }, n);
	    }), /*#__PURE__*/React.createElement(LoadMask, {
	      text: maskText,
	      show: showMask
	    }));
	  }

	  componentDidMount() {
	    app.editor = this; // 基础

	    this.history = new History(this); // 场景

	    this.scene = new THREE.Scene();
	    this.scene.name = _t('Scene');
	    this.scene.background = new THREE.Color(0xaaaaaa);
	    this.sceneHelpers = new THREE.Scene();
	    this.sceneID = null; // 当前场景ID

	    this.sceneName = null; // 当前场景名称

	    const width = app.viewport.clientWidth;
	    const height = app.viewport.clientHeight; // 相机

	    this.DEFAULT_CAMERA = new THREE.PerspectiveCamera(50, width / height, 0.1, 10000);
	    this.DEFAULT_CAMERA.name = _t('DefaultCamera');
	    this.DEFAULT_CAMERA.userData.isDefault = true;
	    this.DEFAULT_CAMERA.userData.control = 'OrbitControls'; // 场景控制类型

	    this.DEFAULT_CAMERA.userData.orbitOptions = {
	      enableDamping: true,
	      dampingFactor: 0.08,
	      panSpeed: 1.6
	    };
	    this.DEFAULT_CAMERA.position.set(20, 10, 20);
	    this.DEFAULT_CAMERA.lookAt(new THREE.Vector3()); // 说明：默认是透视相机，当选择正视图、侧视图、顶视图时，使用正交相机进行渲染、选中。
	    // 视图

	    this.view = 'perspective'; // perspective, front, side, top
	    // 透视相机

	    this.camera = this.DEFAULT_CAMERA.clone(); // 正交相机

	    this.orthCamera = new THREE.OrthographicCamera(-width / 4, width / 4, height / 4, -height / 4, 0.1, 10000); // 渲染器

	    this.renderer = new THREE.WebGLRenderer({
	      antialias: true,alpha:true 
	    }); // this.renderer.gammaInput = false;
	    // this.renderer.gammaOutput = false;

	    this.renderer.shadowMap.enabled = true;
	    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	    this.renderer.autoClear = false;
	    this.renderer.autoUpdateScene = false;
	    this.renderer.setPixelRatio(window.devicePixelRatio);
	    app.viewport.appendChild(this.renderer.domElement);
	    this.renderer.setSize(width, height); // 物体

	    this.objects = []; // 脚本 格式：[{ id: 'MongoDB _id', pid: null, name: 'Script Name', type: 'Script Type', source: 'Source Code', uuid: 'uuid', sort: 'sort' }, ...]
	    // 其中，uuid是创建脚本时自动生成，不可改变，关联时使用，id是mongo数据库ID字段；name：随便填写；
	    // type：javascript，vertexShader, fragmentShader, json, folder；source：源码；sort: 排序，小的在前面。
	    // pid是null或undefined是根节点，否则是子节点。
	    // type为group时表示一个文件夹，此时，不需要source属性。

	    this.scripts = []; // 动画格式：[{ id: 'MongoDB _id', uuid: 'uuid', layer: '动画层序号', layerName: '动画层名称', animations: '动画' }, ...]
	    // 其中，动画：[{ id: 'MongoDB _id', uuid: 'uuid', name: '动画名称', target: '动画对象uuid', type: '动画类型', beginTime: '开始时间(s)', endTime: '结束时间(s)', data: '动画参数' }, ...]
	    // 其中，uuid是创建脚本时自动生成，不可改变，关联时使用。
	    // 动画层序号：在时间面板显示位置，从0开始计算。
	    // 动画类型：Tween-补间动画，Skeletal-骨骼动画，Audio-音频播放，Shader-着色器动画，Filter-滤镜动画，Particle-粒子动画
	    // 动画参数：是一个字典，根据动画类型不同，参数也不同

	    this.animations = []; // 当前选中物体

	    this.selected = null; // 平移旋转缩放控件

	    this.transformControls = new THREE.TransformControls(this.camera, app.viewport);
	    this.sceneHelpers.add(this.transformControls); // 编辑器控件

	    this.controls = new ControlsManager(this.camera, app.viewport); // 帮助器场景灯光

	    let light = new THREE.DirectionalLight(0xffffff, 1.0);
	    light.position.z = 10;
	    this.sceneHelpers.add(light);
	    this.showViewHelper = true; // GPUPick使用数量。为0时，为了提升性能，不启用GPUPick。

	    this.gpuPickNum = app.storage.hoverEnabled ? 1 : 0; // 事件

	    app.on(`appStarted.Editor`, this.onAppStarted.bind(this));
	    app.on(`showMask.Editor`, this.onShowMask.bind(this));
	    app.on(`storageChanged.Editor`, this.onStorageChanged.bind(this)); // 帮助器

	    this.helpers = new Helpers(app);
	    app.call('appStart', this);
	    app.call('appStarted', this);
	    app.call('resize', this);
	    app.log(_t('Program started.'));
	  }

	  componentWillUnmount() {
	    app.call('appStop', this);
	    app.call('appStoped', this);
	    app.log(_t('Program stoped.'));
	    app.event.stop();
	  }

	  onAppStarted() {
	    this.helpers.start();
	    this.clear();
	    this._addAudioListener = this._addAudioListener.bind(this);
	    document.addEventListener('click', this._addAudioListener); // 如果检测到有自动保存的场景，提示是否载入

	    app.call(`queryLoadAutoSceneScene`, this);
	  }

	  onToggle() {
	    app.call('resize', this);
	  }

	  onStorageChanged(key, value) {
	    const keys = ['assetsPanelShow', 'sidebarShow', 'toolbarShow', 'timelinePanelShow', 'statusBarShow'];

	    if (keys.indexOf(key) === -1) {
	      return;
	    }

	    this.setState({
	      [key]: value
	    }, () => {
	      app.call(`resize`, this);
	    });
	  } // -------------------- 场景 --------------------------


	  setScene(scene) {
	    // 设置场景
	    // 移除原有物体
	    let objects = this.scene.children;

	    while (objects.length > 0) {
	      this.removeObject(objects[0]);
	    } // 添加新物体


	    let children = scene.children.slice();
	    scene.children.length = 0;
	    this.scene = scene;
	    children.forEach(n => {
	      this.addObject(n);
	    });
	    app.call('sceneGraphChanged', this);
	  }

	  clear(addObject = true) {
	    // 清空场景
	    const template = new EmptySceneTemplate();
	    template.clear(); // 添加默认元素

	    if (addObject) {
	      template.create();
	    }

	    app.call('editorCleared', this);
	    app.call('scriptChanged', this);
	    app.call('animationChanged', this);
	  } // 点击编辑器时才添加AudioListener，避免警告信息


	  _addAudioListener() {
	    document.removeEventListener('click', this._addAudioListener);
	    this.audioListener = new THREE.AudioListener();
	    this.audioListener.name = _t('AudioListener');

	    if (this.camera.children.findIndex(o => o instanceof THREE.AudioListener) === -1) {
	      this.camera.add(this.audioListener);
	    }
	  } // ---------------------- 物体 ---------------------------


	  objectByUuid(uuid) {
	    // 根据uuid获取物体
	    return this.scene.getObjectByProperty('uuid', uuid, true);
	  }

	  addObject(object) {
	    // 添加物体
	    this.scene.add(object);
	    app.call('objectAdded', this, object);
	    app.call('sceneGraphChanged', this);
	  }

	  moveObject(object, parent, before) {
	    // 移动物体
	    if (parent === undefined) {
	      parent = this.scene;
	    }

	    parent.add(object); // sort children array

	    if (before !== undefined) {
	      let index = parent.children.indexOf(before);
	      parent.children.splice(index, 0, object);
	      parent.children.pop();
	    }

	    app.call('sceneGraphChanged', this);
	  }

	  removeObject(object) {
	    // 移除物体
	    if (object.parent === null) {
	      // 避免删除相机或场景
	      return;
	    }

	    object.parent.remove(object);
	    app.call('objectRemoved', this, object);
	    app.call('sceneGraphChanged', this);
	  } // ------------------------- 帮助 ------------------------------


	  addPhysicsHelper(helper) {
	    let geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	    let material = new THREE.MeshBasicMaterial({
	      color: 0xff0000,
	      visible: false
	    });
	    let picker = new THREE.Mesh(geometry, material);
	    picker.name = 'picker';
	    picker.userData.object = helper.object;
	    helper.add(picker);
	    this.sceneHelpers.add(helper);
	    this.helpers[helper.object.id] = helper;
	    this.objects.push(picker);
	  }

	  removePhysicsHelper(helper) {
	    if (this.helpers[helper.object.id] !== undefined) {
	      helper.parent.remove(helper);
	      delete this.helpers[helper.object.id];
	      let objects = this.objects;
	      objects.splice(objects.indexOf(helper.getObjectByName('picker')), 1);
	    }
	  } // ------------------------ 选中事件 --------------------------------


	  select(object) {
	    // 选中物体
	    if (this.selected === object) {
	      return;
	    }

	    this.selected = object;

	    if (!object) {
	      this.transformControls.detach();
	    }

	    app.call('objectSelected', this, object);
	  }

	  selectById(id) {
	    // 根据id选中物体
	    if (id === this.camera.id) {
	      this.select(this.camera);
	      return;
	    }

	    this.select(this.scene.getObjectById(id, true));
	  }

	  selectByUuid(uuid) {
	    // 根据uuid选中物体
	    if (uuid === this.camera.uuid) {
	      this.select(this.camera);
	      return;
	    }

	    this.scene.traverse(child => {
	      if (child.uuid === uuid) {
	        this.select(child);
	      }
	    });
	  }

	  deselect() {
	    // 取消选中物体
	    this.select(null);
	  } // ---------------------- 焦点事件 --------------------------


	  focus(object) {
	    // 设置焦点
	    app.call('objectFocused', this, object);
	  }

	  focusById(id) {
	    // 根据id设置交点
	    let obj = this.scene.getObjectById(id, true);

	    if (obj) {
	      this.focus(obj);
	    }
	  }

	  focusByUUID(uuid) {
	    // 根据uuid设置焦点
	    if (uuid === this.camera.uuid) {
	      this.focus(this.camera);
	      return;
	    }

	    this.scene.traverse(child => {
	      if (child.uuid === uuid) {
	        this.focus(child);
	      }
	    });
	  } // ----------------------- 命令事件 --------------------------


	  execute(cmd, optionalName) {
	    // 执行事件
	    this.history.execute(cmd, optionalName);
	  }

	  undo() {
	    // 撤销事件
	    this.history.undo();
	  }

	  redo() {
	    // 重做事件
	    this.history.redo();
	  } // ---------------------- 用户界面 --------------------------------


	  createElement(type, props = {}, children = undefined) {
	    let ref = React.createRef();
	    props.ref = ref;
	    return React.createElement(type, props, children);
	  }

	  addElement(element, callback) {
	    let elements = this.state.elements;
	    elements.push(element);
	    this.setState({
	      elements
	    }, callback);
	  }

	  removeElement(element, callback) {
	    let elements = this.state.elements;
	    let index = elements.findIndex(n => n === element || n.ref && n.ref.current === element);

	    if (index > -1) {
	      elements.splice(index, 1);
	    }

	    this.setState({
	      elements
	    }, callback);
	  }

	  onShowMask(enabled, text) {
	    this.setState({
	      showMask: enabled,
	      maskText: text || _t('Waiting...')
	    });
	  }

	}

	/**
	 * 应用程序
	 * @author mrdoob / http://mrdoob.com/
	 * @author tengge / https://github.com/tengge1
	 * @param {HTMLElement} container 容器
	 * @param {Object} options 配置
	 */

	function Application(container, options) {
	  // 容器
	  this.container = container;
	  this.width = this.container.clientWidth;
	  this.height = this.container.clientHeight;
	  window.app = this; // 配置

	  this.options = new Options(options); // 存储

	  this.storage = new Storage();
	  this.debug = this.storage.get('debug') || false; // 服务端配置

	  this.server = new Server(this.options.server); // 包管理器

	  this.packageManager = new PackageManager();
	  this.require = this.packageManager.require.bind(this.packageManager); // 事件

	  this.event = new EventDispatcher(this);
	  this.call = this.event.call.bind(this.event);
	  this.on = this.event.on.bind(this.event); // 异步获取数据

	  const promise1 = new Promise(resolve => {
	    // 加载语言包
	    const loader = new LanguageLoader();
	    loader.load().then(() => {
	      resolve();
	    });
	  });
	  const promise2 = new Promise(resolve => {
	    // 加载物理引擎
	    // TODO: 由于ammo.js升级，导致很多类库不兼容，所以只能这么写。
	    Ammo().then(AmmoLib => {
	      window.Ammo = AmmoLib;
	      resolve();
	    });
	  });
	  const promise3 = new Promise(resolve => {
	    // 加载服务器配置
	    this.server.load().then(() => {
	      resolve();
	    });
	  }); // Loading Screen

	  const loader = React.createElement(Loader);
	  ReactDOM.render(loader, this.container);
	  Promise.all([promise1, promise2, promise3]).then(() => {
	    this.ui = React.createElement(Editor);
	    this.event.start();
	    ReactDOM.render(this.ui, this.container);
	  });
	} // ----------------------- UI函数 ---------------------------------

	/**
	 * 创建元素
	 * @param {React.Component} type ReactComponent类型
	 * @param {Object} props ReactComponent属性
	 * @param {Object} children 子节点
	 * @returns {*} React元素
	 */


	Application.prototype.createElement = function (type, props, children) {
	  return this.editor.createElement(type, props, children);
	};
	/**
	 * 添加元素
	 * @param {Object} element ReactElement元素
	 * @param {Function} callback 回调函数
	 * @returns {*} React元素
	 */


	Application.prototype.addElement = function (element, callback) {
	  return this.editor.addElement(element, callback);
	};
	/**
	 * 移除元素
	 * @param {Object} element ReactElement元素
	 * @param {Function} callback 回调函数
	 * @returns {*} React元素
	 */


	Application.prototype.removeElement = function (element, callback) {
	  return this.editor.removeElement(element, callback);
	};
	/**
	 * 弹窗一段时间消失的消息窗口
	 * @param {String} content 内容
	 * @param {String} type 类型（info, success, warn, error）
	 */


	Application.prototype.toast = function (content, type = 'info') {
	  let component = this.createElement(Message, {
	    type
	  }, content);
	  this.addElement(component);
	  setTimeout(() => {
	    this.removeElement(component);
	  }, 3000);
	};
	/**
	 * 提示窗口
	 * @param {Object} options 选项
	 * @param {String} options.title 标题
	 * @param {String} options.content 内容
	 * @param {String} options.className 样式类
	 * @param {Object} options.style 样式
	 * @param {Function} options.onOK 点击确定回调函数
	 * @param {Function} options.onClose 点击关闭回调函数
	 * @returns {*} React元素
	 */


	Application.prototype.alert = function (options = {}) {
	  let {
	    title,
	    content,
	    className,
	    style,
	    onOK,
	    onClose
	  } = options;
	  let component;

	  let close = () => {
	    component && this.removeElement(component);
	  };

	  if (onOK === undefined && onClose === undefined) {
	    onOK = onClose = close;
	  } else if (onClose === undefined) {
	    onClose = onOK;
	  }

	  component = this.createElement(Alert, {
	    title,
	    okText: _t('OK'),
	    className,
	    style,
	    onOK,
	    onClose
	  }, content);
	  this.addElement(component);
	  return {
	    component,
	    close
	  };
	};
	/**
	 * 询问窗口
	 * @param {Object} options 选项
	 * @param {String} options.title 标题
	 * @param {String} options.content 内容
	 * @param {String} options.className 样式类
	 * @param {Object} options.style 样式
	 * @param {Function} options.onOK 点击确定回调函数
	 * @param {Function} options.onCancel 点击取消回调函数
	 * @returns {*} React元素
	 */


	Application.prototype.confirm = function (options = {}) {
	  const {
	    title,
	    content,
	    okText,
	    cancelText,
	    className,
	    style,
	    onOK,
	    onCancel
	  } = options;
	  let component;

	  let close = () => {
	    component && this.removeElement(component);
	  };

	  let handleOK = () => {
	    if (onOK && onOK() !== false) {
	      close();
	    }
	  };

	  let handleCancel = () => {
	    if (onCancel && onCancel() !== false || !onCancel) {
	      close();
	    }
	  };

	  component = this.createElement(Confirm, {
	    title,
	    okText: okText || _t('OK'),
	    cancelText: cancelText || _t('Cancel'),
	    className,
	    style,
	    onOK: handleOK,
	    onCancel: handleCancel,
	    onClose: handleCancel
	  }, content);
	  this.addElement(component);
	  return {
	    component,
	    close
	  };
	};
	/**
	 * 输入窗口
	 * @param {Object} options 选项
	 * @param {String} options.title 标题
	 * @param {String} options.content 内容
	 * @param {String} options.className 样式类
	 * @param {Object} options.style 样式
	 * @param {String} options.value 默认值
	 * @param {Boolean} options.mask 是否显示遮罩层
	 * @param {Function} options.onOK 点击确定执行函数
	 * @param {Function} options.onClose 点击关闭执行函数
	 * @returns {*} React元素
	 */


	Application.prototype.prompt = function (options = {}) {
	  let {
	    title,
	    content,
	    className,
	    style,
	    value,
	    mask,
	    onOK,
	    onClose
	  } = options;
	  let component;

	  let close = () => {
	    component && this.removeElement(component);
	  };

	  let handleOK = value => {
	    if (onOK && onOK(value) !== false) {
	      close();
	    }
	  };

	  let handleClose = () => {
	    if (onClose === undefined) {
	      close();
	    } else if (onClose && onClose() !== false) {
	      close();
	    }
	  };

	  component = this.createElement(Prompt, {
	    title,
	    content,
	    className,
	    style,
	    value,
	    okText: _t('OK'),
	    mask,
	    onOK: handleOK,
	    onClose: handleClose
	  });
	  this.addElement(component);
	  return {
	    component,
	    close
	  };
	};
	/**
	 * 显示加载器
	 * @param {*} text 加载器文本
	 */


	Application.prototype.mask = function (text) {
	  this.call('showMask', this, true, text);
	};
	/**
	 * 隐藏加载器
	 */


	Application.prototype.unmask = function () {
	  this.call('showMask', this, false);
	};
	/**
	 * 查看图片
	 * @param {String} url 地址
	 */


	Application.prototype.photo = function (url) {
	  let component = null;

	  let close = () => {
	    if (component) {
	      this.removeElement(component);
	      component = null;
	    }
	  };

	  component = this.createElement(Photo, {
	    url,
	    onClick: close
	  });
	  this.addElement(component);
	};
	/**
	 * 查看视频
	 * @param {String} url 地址
	 */


	Application.prototype.video = function (url) {
	  let component = null;

	  let close = () => {
	    if (component) {
	      this.removeElement(component);
	      component = null;
	    }
	  };

	  component = this.createElement(Video, {
	    url,
	    onClick: close
	  });
	  this.addElement(component);
	}; // -------------------- 工具函数  -----------------------

	/**
	 * 上传文件
	 * @param {Object} url 上传Url
	 * @param {String} callback 回调函数
	 */


	Application.prototype.upload = function () {
	  let input;
	  return function (url, callback) {
	    if (!input) {
	      input = document.createElement('input');
	      input.type = 'file';
	      input.style.display = 'none';
	      input.addEventListener('change', event => {
	        Ajax.post(url, {
	          file: event.target.files[0]
	        }, json => {
	          let obj = JSON.parse(json);

	          if (obj.Code === 200) {
	            callback(obj);
	          } else {
	            app.toast(_t(obj.Msg), 'warn');
	          }
	        });
	      });
	      document.body.appendChild(input);
	    }

	    input.value = null;
	    input.click();
	  };
	}(); // ----------------------- 记录日志  --------------------------------


	Application.prototype.log = function (content) {
	  // 普通日志
	  this.call('log', this, content);
	};

	Application.prototype.warn = function (content) {
	  // 警告日志
	  this.call('log', this, content, 'warn');
	};

	Application.prototype.error = function (content) {
	  // 错误日志
	  this.call('log', this, content, 'error');
	};

	exports.AbsoluteLayout = AbsoluteLayout;
	exports.Accordion = Accordion;
	exports.AccordionLayout = AccordionLayout;
	exports.Alert = Alert;
	exports.Application = Application;
	exports.BorderLayout = BorderLayout;
	exports.Button = Button;
	exports.ButtonProperty = ButtonProperty;
	exports.Buttons = Buttons;
	exports.ButtonsProperty = ButtonsProperty;
	exports.Canvas = Canvas;
	exports.CheckBox = CheckBox;
	exports.CheckBoxProperty = CheckBoxProperty;
	exports.ColorProperty = ColorProperty;
	exports.Column = Column;
	exports.Confirm = Confirm;
	exports.Content = Content;
	exports.ContextMenu = ContextMenu;
	exports.DataGrid = DataGrid;
	exports.DisplayProperty = DisplayProperty;
	exports.Form = Form;
	exports.FormControl = FormControl;
	exports.HBoxLayout = HBoxLayout;
	exports.Icon = Icon;
	exports.IconButton = IconButton;
	exports.IconMenuButton = IconMenuButton;
	exports.Image = Image$1;
	exports.ImageButton = ImageButton;
	exports.ImageList = ImageList;
	exports.ImageSelector = ImageSelector;
	exports.ImageUploader = ImageUploader;
	exports.Input = Input;
	exports.IntegerProperty = IntegerProperty;
	exports.Item = Item;
	exports.Label = Label;
	exports.LanguageLoader = LanguageLoader;
	exports.LinkButton = LinkButton;
	exports.LoadMask = LoadMask;
	exports.Menu = Menu;
	exports.MenuBar = MenuBar;
	exports.MenuBarFiller = MenuBarFiller;
	exports.MenuItem = MenuItem;
	exports.MenuItemSeparator = MenuItemSeparator;
	exports.MenuTab = MenuTab;
	exports.Message = Message;
	exports.NumberProperty = NumberProperty;
	exports.Options = Options;
	exports.Panel = Panel;
	exports.Photo = Photo;
	exports.Player = Player;
	exports.Prompt = Prompt;
	exports.PropTypes = propTypes;
	exports.PropertyGrid = PropertyGrid;
	exports.PropertyGroup = PropertyGroup;
	exports.Radio = Radio;
	exports.Row = Row;
	exports.Rows = Rows;
	exports.SVG = SVG;
	exports.SearchField = SearchField;
	exports.Select = Select;
	exports.SelectProperty = SelectProperty;
	exports.TabLayout = TabLayout;
	exports.Table = Table;
	exports.TableBody = TableBody;
	exports.TableCell = TableCell;
	exports.TableHead = TableHead;
	exports.TableRow = TableRow;
	exports.TextArea = TextArea;
	exports.TextProperty = TextProperty;
	exports.TextureProperty = TextureProperty;
	exports.Timeline = Timeline;
	exports.Toast = Toast;
	exports.Toggle = Toggle;
	exports.Toolbar = Toolbar;
	exports.ToolbarFiller = ToolbarFiller;
	exports.ToolbarSeparator = ToolbarSeparator;
	exports.Tree = Tree;
	exports.VBoxLayout = VBoxLayout;
	exports.Video = Video;
	exports.Window = Window;
	exports.classNames = bind;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
